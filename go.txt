(() => {
  var yc = Object.defineProperty,
    vc = Object.defineProperties;
  var Ec = Object.getOwnPropertyDescriptors;
  var ll = Object.getOwnPropertySymbols;
  var Sc = Object.prototype.hasOwnProperty,
    Tc = Object.prototype.propertyIsEnumerable;
  var Rs = Math.pow,
    hl = (Qs, As, Ut) =>
      As in Qs
        ? yc(Qs, As, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Ut,
          })
        : (Qs[As] = Ut),
    cl = (Qs, As) => {
      for (var Ut in As || (As = {})) Sc.call(As, Ut) && hl(Qs, Ut, As[Ut]);
      if (ll) for (var Ut of ll(As)) Tc.call(As, Ut) && hl(Qs, Ut, As[Ut]);
      return Qs;
    },
    dl = (Qs, As) => vc(Qs, Ec(As));
  var xc = (Qs, As) => () => (
    As || Qs((As = { exports: {} }).exports, As), As.exports
  );
  var Kt = (Qs, As, Ut) =>
    new Promise((ta, xe) => {
      var V = (x) => {
          try {
            A(Ut.next(x));
          } catch (y) {
            xe(y);
          }
        },
        a = (x) => {
          try {
            A(Ut.throw(x));
          } catch (y) {
            xe(y);
          }
        },
        A = (x) => (x.done ? ta(x.value) : Promise.resolve(x.value).then(V, a));
      A((Ut = Ut.apply(Qs, As)).next());
    });
  var Ac = xc((fl) => {
    (() => {
      var Qs = {
          7526: (xe, V) => {
            "use strict";
            (V.byteLength = f), (V.toByteArray = l), (V.fromByteArray = i);
            for (
              var a = [],
                A = [],
                x = typeof Uint8Array != "undefined" ? Uint8Array : Array,
                y =
                  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                c = 0,
                d = y.length;
              c < d;
              ++c
            )
              (a[c] = y[c]), (A[y.charCodeAt(c)] = c);
            (A[45] = 62), (A[95] = 63);
            function h(e) {
              var t = e.length;
              if (t % 4 > 0)
                throw new Error(
                  "Invalid string. Length must be a multiple of 4"
                );
              var r = e.indexOf("=");
              r === -1 && (r = t);
              var u = r === t ? 0 : 4 - (r % 4);
              return [r, u];
            }
            function f(e) {
              var t = h(e),
                r = t[0],
                u = t[1];
              return ((r + u) * 3) / 4 - u;
            }
            function s(e, t, r) {
              return ((t + r) * 3) / 4 - r;
            }
            function l(e) {
              var t,
                r = h(e),
                u = r[0],
                v = r[1],
                _ = new x(s(e, u, v)),
                m = 0,
                g = v > 0 ? u - 4 : u,
                T;
              for (T = 0; T < g; T += 4)
                (t =
                  (A[e.charCodeAt(T)] << 18) |
                  (A[e.charCodeAt(T + 1)] << 12) |
                  (A[e.charCodeAt(T + 2)] << 6) |
                  A[e.charCodeAt(T + 3)]),
                  (_[m++] = (t >> 16) & 255),
                  (_[m++] = (t >> 8) & 255),
                  (_[m++] = t & 255);
              return (
                v === 2 &&
                  ((t =
                    (A[e.charCodeAt(T)] << 2) | (A[e.charCodeAt(T + 1)] >> 4)),
                  (_[m++] = t & 255)),
                v === 1 &&
                  ((t =
                    (A[e.charCodeAt(T)] << 10) |
                    (A[e.charCodeAt(T + 1)] << 4) |
                    (A[e.charCodeAt(T + 2)] >> 2)),
                  (_[m++] = (t >> 8) & 255),
                  (_[m++] = t & 255)),
                _
              );
            }
            function n(e) {
              return (
                a[(e >> 18) & 63] +
                a[(e >> 12) & 63] +
                a[(e >> 6) & 63] +
                a[e & 63]
              );
            }
            function o(e, t, r) {
              for (var u, v = [], _ = t; _ < r; _ += 3)
                (u =
                  ((e[_] << 16) & 16711680) +
                  ((e[_ + 1] << 8) & 65280) +
                  (e[_ + 2] & 255)),
                  v.push(n(u));
              return v.join("");
            }
            function i(e) {
              for (
                var t,
                  r = e.length,
                  u = r % 3,
                  v = [],
                  _ = 16383,
                  m = 0,
                  g = r - u;
                m < g;
                m += _
              )
                v.push(o(e, m, m + _ > g ? g : m + _));
              return (
                u === 1
                  ? ((t = e[r - 1]),
                    v.push(a[t >> 2] + a[(t << 4) & 63] + "=="))
                  : u === 2 &&
                    ((t = (e[r - 2] << 8) + e[r - 1]),
                    v.push(
                      a[t >> 10] + a[(t >> 4) & 63] + a[(t << 2) & 63] + "="
                    )),
                v.join("")
              );
            }
          },
          6035: (xe) => {
            var V = 4096,
              a = 2 * V + 32,
              A = 2 * V - 1,
              x = new Uint32Array([
                0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191,
                16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151,
                4194303, 8388607, 16777215,
              ]);
            function y(c) {
              (this.buf_ = new Uint8Array(a)), (this.input_ = c), this.reset();
            }
            (y.READ_SIZE = V),
              (y.IBUF_MASK = A),
              (y.prototype.reset = function () {
                (this.buf_ptr_ = 0),
                  (this.val_ = 0),
                  (this.pos_ = 0),
                  (this.bit_pos_ = 0),
                  (this.bit_end_pos_ = 0),
                  (this.eos_ = 0),
                  this.readMoreInput();
                for (var c = 0; c < 4; c++)
                  (this.val_ |= this.buf_[this.pos_] << (8 * c)), ++this.pos_;
                return this.bit_end_pos_ > 0;
              }),
              (y.prototype.readMoreInput = function () {
                if (!(this.bit_end_pos_ > 256))
                  if (this.eos_) {
                    if (this.bit_pos_ > this.bit_end_pos_)
                      throw new Error(
                        "Unexpected end of input " +
                          this.bit_pos_ +
                          " " +
                          this.bit_end_pos_
                      );
                  } else {
                    var c = this.buf_ptr_,
                      d = this.input_.read(this.buf_, c, V);
                    if (d < 0) throw new Error("Unexpected end of input");
                    if (d < V) {
                      this.eos_ = 1;
                      for (var h = 0; h < 32; h++) this.buf_[c + d + h] = 0;
                    }
                    if (c === 0) {
                      for (var h = 0; h < 32; h++)
                        this.buf_[(V << 1) + h] = this.buf_[h];
                      this.buf_ptr_ = V;
                    } else this.buf_ptr_ = 0;
                    this.bit_end_pos_ += d << 3;
                  }
              }),
              (y.prototype.fillBitWindow = function () {
                for (; this.bit_pos_ >= 8; )
                  (this.val_ >>>= 8),
                    (this.val_ |= this.buf_[this.pos_ & A] << 24),
                    ++this.pos_,
                    (this.bit_pos_ = (this.bit_pos_ - 8) >>> 0),
                    (this.bit_end_pos_ = (this.bit_end_pos_ - 8) >>> 0);
              }),
              (y.prototype.readBits = function (c) {
                32 - this.bit_pos_ < c && this.fillBitWindow();
                var d = (this.val_ >>> this.bit_pos_) & x[c];
                return (this.bit_pos_ += c), d;
              }),
              (xe.exports = y);
          },
          2805: (xe, V) => {
            var a = 0,
              A = 1,
              x = 2,
              y = 3;
            (V.lookup = new Uint8Array([
              0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24,
              28, 12, 12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44, 44,
              44, 32, 32, 24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52,
              48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52,
              52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60,
              56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60,
              60, 60, 24, 12, 28, 12, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
              1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
              1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
              1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
              3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
              3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
              3, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1,
              1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
              4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
              4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
              4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
              6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
              8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
              16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
              16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
              16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
              40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
              40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
              40, 40, 40, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
              48, 48, 56, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
              16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
              32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
              48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0,
              1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
              20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
              36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5,
              6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
              23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
              39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
              55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
              10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
              26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
              42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
              58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3,
              3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
              9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13,
              13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
              17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21,
              21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25,
              25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29,
              29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33,
              33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37,
              37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41,
              41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45,
              45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49,
              49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53,
              53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57,
              57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61,
              61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
            ])),
              (V.lookupOffsets = new Uint16Array([
                1024, 1536, 1280, 1536, 0, 256, 768, 512,
              ]));
          },
          9206: (xe, V, a) => {
            var A,
              x = a(4927).z,
              y = a(4927).y,
              c = a(6035),
              d = a(8712),
              h = a(8171).z,
              f = a(8171).u,
              s = a(2805),
              l = a(7708),
              n = a(8270),
              o = 8,
              i = 16,
              e = 256,
              t = 704,
              r = 26,
              u = 6,
              v = 2,
              _ = 8,
              m = 255,
              g = 1080,
              T = 18,
              E = new Uint8Array([
                1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,
              ]),
              M = 16,
              R = new Uint8Array([
                3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
              ]),
              P = new Int8Array([
                0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3,
              ]),
              F = new Uint16Array([
                256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758,
                790, 822, 854, 886, 920, 952, 984, 1016, 1048, 1080,
              ]);
            function b(O) {
              var Y;
              return O.readBits(1) === 0
                ? 16
                : ((Y = O.readBits(3)),
                  Y > 0 ? 17 + Y : ((Y = O.readBits(3)), Y > 0 ? 8 + Y : 17));
            }
            function D(O) {
              if (O.readBits(1)) {
                var Y = O.readBits(3);
                return Y === 0 ? 1 : O.readBits(Y) + (1 << Y);
              }
              return 0;
            }
            function G() {
              (this.meta_block_length = 0),
                (this.input_end = 0),
                (this.is_uncompressed = 0),
                (this.is_metadata = !1);
            }
            function X(O) {
              var Y = new G(),
                ne,
                de,
                re;
              if (((Y.input_end = O.readBits(1)), Y.input_end && O.readBits(1)))
                return Y;
              if (((ne = O.readBits(2) + 4), ne === 7)) {
                if (((Y.is_metadata = !0), O.readBits(1) !== 0))
                  throw new Error("Invalid reserved bit");
                if (((de = O.readBits(2)), de === 0)) return Y;
                for (re = 0; re < de; re++) {
                  var I = O.readBits(8);
                  if (re + 1 === de && de > 1 && I === 0)
                    throw new Error("Invalid size byte");
                  Y.meta_block_length |= I << (re * 8);
                }
              } else
                for (re = 0; re < ne; ++re) {
                  var w = O.readBits(4);
                  if (re + 1 === ne && ne > 4 && w === 0)
                    throw new Error("Invalid size nibble");
                  Y.meta_block_length |= w << (re * 4);
                }
              return (
                ++Y.meta_block_length,
                !Y.input_end &&
                  !Y.is_metadata &&
                  (Y.is_uncompressed = O.readBits(1)),
                Y
              );
            }
            function ie(O, Y, ne) {
              var de = Y,
                re;
              return (
                ne.fillBitWindow(),
                (Y += (ne.val_ >>> ne.bit_pos_) & m),
                (re = O[Y].bits - _),
                re > 0 &&
                  ((ne.bit_pos_ += _),
                  (Y += O[Y].value),
                  (Y += (ne.val_ >>> ne.bit_pos_) & ((1 << re) - 1))),
                (ne.bit_pos_ += O[Y].bits),
                O[Y].value
              );
            }
            function Q(O, Y, ne, de) {
              for (
                var re = 0, I = o, w = 0, N = 0, W = 32768, he = [], ue = 0;
                ue < 32;
                ue++
              )
                he.push(new h(0, 0));
              for (f(he, 0, 5, O, T); re < Y && W > 0; ) {
                var ye = 0,
                  Oe;
                if (
                  (de.readMoreInput(),
                  de.fillBitWindow(),
                  (ye += (de.val_ >>> de.bit_pos_) & 31),
                  (de.bit_pos_ += he[ye].bits),
                  (Oe = he[ye].value & 255),
                  Oe < i)
                )
                  (w = 0),
                    (ne[re++] = Oe),
                    Oe !== 0 && ((I = Oe), (W -= 32768 >> Oe));
                else {
                  var Ae = Oe - 14,
                    ke,
                    Ue,
                    Ge = 0;
                  if (
                    (Oe === i && (Ge = I),
                    N !== Ge && ((w = 0), (N = Ge)),
                    (ke = w),
                    w > 0 && ((w -= 2), (w <<= Ae)),
                    (w += de.readBits(Ae) + 3),
                    (Ue = w - ke),
                    re + Ue > Y)
                  )
                    throw new Error(
                      "[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols"
                    );
                  for (var ht = 0; ht < Ue; ht++) ne[re + ht] = N;
                  (re += Ue), N !== 0 && (W -= Ue << (15 - N));
                }
              }
              if (W !== 0)
                throw new Error("[ReadHuffmanCodeLengths] space = " + W);
              for (; re < Y; re++) ne[re] = 0;
            }
            function te(O, Y, ne, de) {
              var re = 0,
                I,
                w = new Uint8Array(O);
              if ((de.readMoreInput(), (I = de.readBits(2)), I === 1)) {
                for (
                  var N,
                    W = O - 1,
                    he = 0,
                    ue = new Int32Array(4),
                    ye = de.readBits(2) + 1;
                  W;

                )
                  (W >>= 1), ++he;
                for (N = 0; N < ye; ++N)
                  (ue[N] = de.readBits(he) % O), (w[ue[N]] = 2);
                switch (((w[ue[0]] = 1), ye)) {
                  case 1:
                    break;
                  case 3:
                    if (ue[0] === ue[1] || ue[0] === ue[2] || ue[1] === ue[2])
                      throw new Error("[ReadHuffmanCode] invalid symbols");
                    break;
                  case 2:
                    if (ue[0] === ue[1])
                      throw new Error("[ReadHuffmanCode] invalid symbols");
                    w[ue[1]] = 1;
                    break;
                  case 4:
                    if (
                      ue[0] === ue[1] ||
                      ue[0] === ue[2] ||
                      ue[0] === ue[3] ||
                      ue[1] === ue[2] ||
                      ue[1] === ue[3] ||
                      ue[2] === ue[3]
                    )
                      throw new Error("[ReadHuffmanCode] invalid symbols");
                    de.readBits(1)
                      ? ((w[ue[2]] = 3), (w[ue[3]] = 3))
                      : (w[ue[0]] = 2);
                    break;
                }
              } else {
                var N,
                  Oe = new Uint8Array(T),
                  Ae = 32,
                  ke = 0,
                  Ue = [
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(3, 2),
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(4, 1),
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(3, 2),
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(4, 5),
                  ];
                for (N = I; N < T && Ae > 0; ++N) {
                  var Ge = E[N],
                    ht = 0,
                    me;
                  de.fillBitWindow(),
                    (ht += (de.val_ >>> de.bit_pos_) & 15),
                    (de.bit_pos_ += Ue[ht].bits),
                    (me = Ue[ht].value),
                    (Oe[Ge] = me),
                    me !== 0 && ((Ae -= 32 >> me), ++ke);
                }
                if (!(ke === 1 || Ae === 0))
                  throw new Error(
                    "[ReadHuffmanCode] invalid num_codes or space"
                  );
                Q(Oe, O, w, de);
              }
              if (((re = f(Y, ne, _, w, O)), re === 0))
                throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
              return re;
            }
            function ae(O, Y, ne) {
              var de, re;
              return (
                (de = ie(O, Y, ne)),
                (re = l.kBlockLengthPrefixCode[de].nbits),
                l.kBlockLengthPrefixCode[de].offset + ne.readBits(re)
              );
            }
            function Z(O, Y, ne) {
              var de;
              return (
                O < M
                  ? ((ne += R[O]), (ne &= 3), (de = Y[ne] + P[O]))
                  : (de = O - M + 1),
                de
              );
            }
            function J(O, Y) {
              for (var ne = O[Y], de = Y; de; --de) O[de] = O[de - 1];
              O[0] = ne;
            }
            function ve(O, Y) {
              var ne = new Uint8Array(256),
                de;
              for (de = 0; de < 256; ++de) ne[de] = de;
              for (de = 0; de < Y; ++de) {
                var re = O[de];
                (O[de] = ne[re]), re && J(ne, re);
              }
            }
            function _e(O, Y) {
              (this.alphabet_size = O),
                (this.num_htrees = Y),
                (this.codes = new Array(Y + Y * F[(O + 31) >>> 5])),
                (this.htrees = new Uint32Array(Y));
            }
            _e.prototype.decode = function (O) {
              var Y,
                ne,
                de = 0;
              for (Y = 0; Y < this.num_htrees; ++Y)
                (this.htrees[Y] = de),
                  (ne = te(this.alphabet_size, this.codes, de, O)),
                  (de += ne);
            };
            function L(O, Y) {
              var ne = { num_htrees: null, context_map: null },
                de,
                re = 0,
                I,
                w;
              Y.readMoreInput();
              var N = (ne.num_htrees = D(Y) + 1),
                W = (ne.context_map = new Uint8Array(O));
              if (N <= 1) return ne;
              for (
                de = Y.readBits(1),
                  de && (re = Y.readBits(4) + 1),
                  I = [],
                  w = 0;
                w < g;
                w++
              )
                I[w] = new h(0, 0);
              for (te(N + re, I, 0, Y), w = 0; w < O; ) {
                var he;
                if ((Y.readMoreInput(), (he = ie(I, 0, Y)), he === 0))
                  (W[w] = 0), ++w;
                else if (he <= re)
                  for (var ue = 1 + (1 << he) + Y.readBits(he); --ue; ) {
                    if (w >= O)
                      throw new Error(
                        "[DecodeContextMap] i >= context_map_size"
                      );
                    (W[w] = 0), ++w;
                  }
                else (W[w] = he - re), ++w;
              }
              return Y.readBits(1) && ve(W, O), ne;
            }
            function ge(O, Y, ne, de, re, I, w) {
              var N = ne * 2,
                W = ne,
                he = ie(Y, ne * g, w),
                ue;
              he === 0
                ? (ue = re[N + (I[W] & 1)])
                : he === 1
                ? (ue = re[N + ((I[W] - 1) & 1)] + 1)
                : (ue = he - 2),
                ue >= O && (ue -= O),
                (de[ne] = ue),
                (re[N + (I[W] & 1)] = ue),
                ++I[W];
            }
            function k(O, Y, ne, de, re, I) {
              var w = re + 1,
                N = ne & re,
                W = I.pos_ & c.IBUF_MASK,
                he;
              if (Y < 8 || I.bit_pos_ + (Y << 3) < I.bit_end_pos_) {
                for (; Y-- > 0; )
                  I.readMoreInput(),
                    (de[N++] = I.readBits(8)),
                    N === w && (O.write(de, w), (N = 0));
                return;
              }
              if (I.bit_end_pos_ < 32)
                throw new Error(
                  "[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32"
                );
              for (; I.bit_pos_ < 32; )
                (de[N] = I.val_ >>> I.bit_pos_), (I.bit_pos_ += 8), ++N, --Y;
              if (
                ((he = (I.bit_end_pos_ - I.bit_pos_) >> 3),
                W + he > c.IBUF_MASK)
              ) {
                for (var ue = c.IBUF_MASK + 1 - W, ye = 0; ye < ue; ye++)
                  de[N + ye] = I.buf_[W + ye];
                (he -= ue), (N += ue), (Y -= ue), (W = 0);
              }
              for (var ye = 0; ye < he; ye++) de[N + ye] = I.buf_[W + ye];
              if (((N += he), (Y -= he), N >= w)) {
                O.write(de, w), (N -= w);
                for (var ye = 0; ye < N; ye++) de[ye] = de[w + ye];
              }
              for (; N + Y >= w; ) {
                if (((he = w - N), I.input_.read(de, N, he) < he))
                  throw new Error(
                    "[CopyUncompressedBlockToOutput] not enough bytes"
                  );
                O.write(de, w), (Y -= he), (N = 0);
              }
              if (I.input_.read(de, N, Y) < Y)
                throw new Error(
                  "[CopyUncompressedBlockToOutput] not enough bytes"
                );
              I.reset();
            }
            function j(O) {
              var Y = (O.bit_pos_ + 7) & -8,
                ne = O.readBits(Y - O.bit_pos_);
              return ne == 0;
            }
            function B(O) {
              var Y = new x(O),
                ne = new c(Y);
              b(ne);
              var de = X(ne);
              return de.meta_block_length;
            }
            A = B;
            function $(O, Y) {
              var ne = new x(O);
              Y == null && (Y = B(O));
              var de = new Uint8Array(Y),
                re = new y(de);
              return (
                le(ne, re),
                re.pos < re.buffer.length &&
                  (re.buffer = re.buffer.subarray(0, re.pos)),
                re.buffer
              );
            }
            V.i_ = $;
            function le(O, Y) {
              var ne,
                de = 0,
                re = 0,
                I = 0,
                w,
                N = 0,
                W,
                he,
                ue,
                ye,
                Oe = [16, 15, 11, 4],
                Ae = 0,
                ke = 0,
                Ue = 0,
                Ge = [new _e(0, 0), new _e(0, 0), new _e(0, 0)],
                ht,
                me,
                z,
                K = 128 + c.READ_SIZE;
              (z = new c(O)),
                (I = b(z)),
                (w = (1 << I) - 16),
                (W = 1 << I),
                (he = W - 1),
                (ue = new Uint8Array(W + K + d.maxDictionaryWordLength)),
                (ye = W),
                (ht = []),
                (me = []);
              for (var Te = 0; Te < 3 * g; Te++)
                (ht[Te] = new h(0, 0)), (me[Te] = new h(0, 0));
              for (; !re; ) {
                var H = 0,
                  q,
                  se = [1 << 28, 1 << 28, 1 << 28],
                  Ce = [0],
                  we = [1, 1, 1],
                  Me = [0, 1, 0, 1, 0, 1],
                  Ie = [0],
                  Le,
                  tt,
                  vt,
                  it,
                  At = null,
                  Rt = null,
                  Ft,
                  ut = null,
                  Pt,
                  bt = 0,
                  Zt = null,
                  Xt = 0,
                  yt = 0,
                  Pe = null,
                  $e = 0,
                  Je = 0,
                  rt = 0,
                  ct,
                  Ve;
                for (ne = 0; ne < 3; ++ne)
                  (Ge[ne].codes = null), (Ge[ne].htrees = null);
                z.readMoreInput();
                var wt = X(z);
                if (((H = wt.meta_block_length), de + H > Y.buffer.length)) {
                  var at = new Uint8Array(de + H);
                  at.set(Y.buffer), (Y.buffer = at);
                }
                if (
                  ((re = wt.input_end),
                  (q = wt.is_uncompressed),
                  wt.is_metadata)
                ) {
                  for (j(z); H > 0; --H) z.readMoreInput(), z.readBits(8);
                  continue;
                }
                if (H !== 0) {
                  if (q) {
                    (z.bit_pos_ = (z.bit_pos_ + 7) & -8),
                      k(Y, H, de, ue, he, z),
                      (de += H);
                    continue;
                  }
                  for (ne = 0; ne < 3; ++ne)
                    (we[ne] = D(z) + 1),
                      we[ne] >= 2 &&
                        (te(we[ne] + 2, ht, ne * g, z),
                        te(r, me, ne * g, z),
                        (se[ne] = ae(me, ne * g, z)),
                        (Ie[ne] = 1));
                  for (
                    z.readMoreInput(),
                      Le = z.readBits(2),
                      tt = M + (z.readBits(4) << Le),
                      vt = (1 << Le) - 1,
                      it = tt + (48 << Le),
                      Rt = new Uint8Array(we[0]),
                      ne = 0;
                    ne < we[0];
                    ++ne
                  )
                    z.readMoreInput(), (Rt[ne] = z.readBits(2) << 1);
                  var ce = L(we[0] << u, z);
                  (Ft = ce.num_htrees), (At = ce.context_map);
                  var pe = L(we[2] << v, z);
                  for (
                    Pt = pe.num_htrees,
                      ut = pe.context_map,
                      Ge[0] = new _e(e, Ft),
                      Ge[1] = new _e(t, we[1]),
                      Ge[2] = new _e(it, Pt),
                      ne = 0;
                    ne < 3;
                    ++ne
                  )
                    Ge[ne].decode(z);
                  for (
                    Zt = 0,
                      Pe = 0,
                      ct = Rt[Ce[0]],
                      Je = s.lookupOffsets[ct],
                      rt = s.lookupOffsets[ct + 1],
                      Ve = Ge[1].htrees[0];
                    H > 0;

                  ) {
                    var De, fe, Ze, Ne, Ye, Ke, nt, ot, ze, et, _t;
                    for (
                      z.readMoreInput(),
                        se[1] === 0 &&
                          (ge(we[1], ht, 1, Ce, Me, Ie, z),
                          (se[1] = ae(me, g, z)),
                          (Ve = Ge[1].htrees[Ce[1]])),
                        --se[1],
                        De = ie(Ge[1].codes, Ve, z),
                        fe = De >> 6,
                        fe >= 2 ? ((fe -= 2), (nt = -1)) : (nt = 0),
                        Ze = l.kInsertRangeLut[fe] + ((De >> 3) & 7),
                        Ne = l.kCopyRangeLut[fe] + (De & 7),
                        Ye =
                          l.kInsertLengthPrefixCode[Ze].offset +
                          z.readBits(l.kInsertLengthPrefixCode[Ze].nbits),
                        Ke =
                          l.kCopyLengthPrefixCode[Ne].offset +
                          z.readBits(l.kCopyLengthPrefixCode[Ne].nbits),
                        ke = ue[(de - 1) & he],
                        Ue = ue[(de - 2) & he],
                        et = 0;
                      et < Ye;
                      ++et
                    )
                      z.readMoreInput(),
                        se[0] === 0 &&
                          (ge(we[0], ht, 0, Ce, Me, Ie, z),
                          (se[0] = ae(me, 0, z)),
                          (bt = Ce[0] << u),
                          (Zt = bt),
                          (ct = Rt[Ce[0]]),
                          (Je = s.lookupOffsets[ct]),
                          (rt = s.lookupOffsets[ct + 1])),
                        (ze = s.lookup[Je + ke] | s.lookup[rt + Ue]),
                        (Xt = At[Zt + ze]),
                        --se[0],
                        (Ue = ke),
                        (ke = ie(Ge[0].codes, Ge[0].htrees[Xt], z)),
                        (ue[de & he] = ke),
                        (de & he) === he && Y.write(ue, W),
                        ++de;
                    if (((H -= Ye), H <= 0)) break;
                    if (nt < 0) {
                      var ze;
                      if (
                        (z.readMoreInput(),
                        se[2] === 0 &&
                          (ge(we[2], ht, 2, Ce, Me, Ie, z),
                          (se[2] = ae(me, 2 * g, z)),
                          (yt = Ce[2] << v),
                          (Pe = yt)),
                        --se[2],
                        (ze = (Ke > 4 ? 3 : Ke - 2) & 255),
                        ($e = ut[Pe + ze]),
                        (nt = ie(Ge[2].codes, Ge[2].htrees[$e], z)),
                        nt >= tt)
                      ) {
                        var Qe, lt, xt;
                        (nt -= tt),
                          (lt = nt & vt),
                          (nt >>= Le),
                          (Qe = (nt >> 1) + 1),
                          (xt = ((2 + (nt & 1)) << Qe) - 4),
                          (nt = tt + ((xt + z.readBits(Qe)) << Le) + lt);
                      }
                    }
                    if (((ot = Z(nt, Oe, Ae)), ot < 0))
                      throw new Error("[BrotliDecompress] invalid distance");
                    if (
                      (de < w && N !== w ? (N = de) : (N = w),
                      (_t = de & he),
                      ot > N)
                    )
                      if (
                        Ke >= d.minDictionaryWordLength &&
                        Ke <= d.maxDictionaryWordLength
                      ) {
                        var xt = d.offsetsByLength[Ke],
                          Tt = ot - N - 1,
                          ft = d.sizeBitsByLength[Ke],
                          gt = (1 << ft) - 1,
                          Fe = Tt & gt,
                          Qt = Tt >> ft;
                        if (((xt += Fe * Ke), Qt < n.kNumTransforms)) {
                          var zt = n.transformDictionaryWord(
                            ue,
                            _t,
                            xt,
                            Ke,
                            Qt
                          );
                          if (((_t += zt), (de += zt), (H -= zt), _t >= ye)) {
                            Y.write(ue, W);
                            for (var Lt = 0; Lt < _t - ye; Lt++)
                              ue[Lt] = ue[ye + Lt];
                          }
                        } else
                          throw new Error(
                            "Invalid backward reference. pos: " +
                              de +
                              " distance: " +
                              ot +
                              " len: " +
                              Ke +
                              " bytes left: " +
                              H
                          );
                      } else
                        throw new Error(
                          "Invalid backward reference. pos: " +
                            de +
                            " distance: " +
                            ot +
                            " len: " +
                            Ke +
                            " bytes left: " +
                            H
                        );
                    else {
                      if ((nt > 0 && ((Oe[Ae & 3] = ot), ++Ae), Ke > H))
                        throw new Error(
                          "Invalid backward reference. pos: " +
                            de +
                            " distance: " +
                            ot +
                            " len: " +
                            Ke +
                            " bytes left: " +
                            H
                        );
                      for (et = 0; et < Ke; ++et)
                        (ue[de & he] = ue[(de - ot) & he]),
                          (de & he) === he && Y.write(ue, W),
                          ++de,
                          --H;
                    }
                    (ke = ue[(de - 1) & he]), (Ue = ue[(de - 2) & he]);
                  }
                  de &= 1073741823;
                }
              }
              Y.write(ue, de & he);
            }
            (A = le), d.init();
          },
          9017: (xe, V, a) => {
            var A = a(7526);
            V.init = function () {
              var x = a(9206).i_,
                y = A.toByteArray(a(7611));
              return x(y);
            };
          },
          7611: (xe) => {
            xe.exports =
              "W5/fcQLn5gKf2XUbAiQ1XULX+TZz6ADToDsgqk6qVfeC0e4m6OO2wcQ1J76ZBVRV1fRkEsdu//62zQsFEZWSTCnMhcsQKlS2qOhuVYYMGCkV0fXWEoMFbESXrKEZ9wdUEsyw9g4bJlEt1Y6oVMxMRTEVbCIwZzJzboK5j8m4YH02qgXYhv1V+PM435sLVxyHJihaJREEhZGqL03txGFQLm76caGO/ovxKvzCby/3vMTtX/459f0igi7WutnKiMQ6wODSoRh/8Lx1V3Q99MvKtwB6bHdERYRY0hStJoMjNeTsNX7bn+Y7e4EQ3bf8xBc7L0BsyfFPK43dGSXpL6clYC/I328h54/VYrQ5i0648FgbGtl837svJ35L3Mot/+nPlNpWgKx1gGXQYqX6n+bbZ7wuyCHKcUok12Xjqub7NXZGzqBx0SD+uziNf87t7ve42jxSKQoW3nyxVrWIGlFShhCKxjpZZ5MeGna0+lBkk+kaN8F9qFBAFgEogyMBdcX/T1W/WnMOi/7ycWUQloEBKGeC48MkiwqJkJO+12eQiOFHMmck6q/IjWW3RZlany23TBm+cNr/84/oi5GGmGBZWrZ6j+zykVozz5fT/QH/Da6WTbZYYPynVNO7kxzuNN2kxKKWche5WveitPKAecB8YcAHz/+zXLjcLzkdDSktNIDwZE9J9X+tto43oJy65wApM3mDzYtCwX9lM+N5VR3kXYo0Z3t0TtXfgBFg7gU8oN0Dgl7fZlUbhNll+0uuohRVKjrEd8egrSndy5/Tgd2gqjA4CAVuC7ESUmL3DZoGnfhQV8uwnpi8EGvAVVsowNRxPudck7+oqAUDkwZopWqFnW1riss0t1z6iCISVKreYGNvQcXv+1L9+jbP8cd/dPUiqBso2q+7ZyFBvENCkkVr44iyPbtOoOoCecWsiuqMSML5lv+vN5MzUr+Dnh73G7Q1YnRYJVYXHRJaNAOByiaK6CusgFdBPE40r0rvqXV7tksKO2DrHYXBTv8P5ysqxEx8VDXUDDqkPH6NNOV/a2WH8zlkXRELSa8P+heNyJBBP7PgsG1EtWtNef6/i+lcayzQwQCsduidpbKfhWUDgAEmyhGu/zVTacI6RS0zTABrOYueemnVa19u9fT23N/Ta6RvTpof5DWygqreCqrDAgM4LID1+1T/taU6yTFVLqXOv+/MuQOFnaF8vLMKD7tKWDoBdALgxF33zQccCcdHx8fKIVdW69O7qHtXpeGr9jbbpFA+qRMWr5hp0s67FPc7HAiLV0g0/peZlW7hJPYEhZyhpSwahnf93/tZgfqZWXFdmdXBzqxGHLrQKxoAY6fRoBhgCRPmmGueYZ5JexTVDKUIXzkG/fqp/0U3hAgQdJ9zumutK6nqWbaqvm1pgu03IYR+G+8s0jDBBz8cApZFSBeuWasyqo2OMDKAZCozS+GWSvL/HsE9rHxooe17U3s/lTE+VZAk4j3dp6uIGaC0JMiqR5CUsabPyM0dOYDR7Ea7ip4USZlya38YfPtvrX/tBlhHilj55nZ1nfN24AOAi9BVtz/Mbn8AEDJCqJgsVUa6nQnSxv2Fs7l/NlCzpfYEjmPrNyib/+t0ei2eEMjvNhLkHCZlci4WhBe7ePZTmzYqlY9+1pxtS4GB+5lM1BHT9tS270EWUDYFq1I0yY/fNiAk4bk9yBgmef/f2k6AlYQZHsNFnW8wBQxCd68iWv7/35bXfz3JZmfGligWAKRjIs3IpzxQ27vAglHSiOzCYzJ9L9A1CdiyFvyR66ucA4jKifu5ehwER26yV7HjKqn5Mfozo7Coxxt8LWWPT47BeMxX8p0Pjb7hZn+6bw7z3Lw+7653j5sI8CLu5kThpMlj1m4c2ch3jGcP1FsT13vuK3qjecKTZk2kHcOZY40UX+qdaxstZqsqQqgXz+QGF99ZJLqr3VYu4aecl1Ab5GmqS8k/GV5b95zxQ5d4EfXUJ6kTS/CXF/aiqKDOT1T7Jz5z0PwDUcwr9clLN1OJGCiKfqvah+h3XzrBOiLOW8wvn8gW6qE8vPxi+Efv+UH55T7PQFVMh6cZ1pZQlzJpKZ7P7uWvwPGJ6DTlR6wbyj3Iv2HyefnRo/dv7dNx+qaa0N38iBsR++Uil7Wd4afwDNsrzDAK4fXZwvEY/jdKuIKXlfrQd2C39dW7ntnRbIp9OtGy9pPBn/V2ASoi/2UJZfS+xuGLH8bnLuPlzdTNS6zdyk8Dt/h6sfOW5myxh1f+zf3zZ3MX/mO9cQPp5pOx967ZA6/pqHvclNfnUFF+rq+Vd7alKr6KWPcIDhpn6v2K6NlUu6LrKo8b/pYpU/Gazfvtwhn7tEOUuXht5rUJdSf6sLjYf0VTYDgwJ81yaqKTUYej/tbHckSRb/HZicwGJqh1mAHB/IuNs9dc9yuvF3D5Xocm3elWFdq5oEy70dYFit79yaLiNjPj5UUcVmZUVhQEhW5V2Z6Cm4HVH/R8qlamRYwBileuh07CbEce3TXa2JmXWBf+ozt319psboobeZhVnwhMZzOeQJzhpTDbP71Tv8HuZxxUI/+ma3XW6DFDDs4+qmpERwHGBd2edxwUKlODRdUWZ/g0GOezrbzOZauFMai4QU6GVHV6aPNBiBndHSsV4IzpvUiiYyg6OyyrL4Dj5q/Lw3N5kAwftEVl9rNd7Jk5PDij2hTH6wIXnsyXkKePxbmHYgC8A6an5Fob/KH5GtC0l4eFso+VpxedtJHdHpNm+Bvy4C79yVOkrZsLrQ3OHCeB0Ra+kBIRldUGlDCEmq2RwXnfyh6Dz+alk6eftI2n6sastRrGwbwszBeDRS/Fa/KwRJkCzTsLr/JCs5hOPE/MPLYdZ1F1fv7D+VmysX6NpOC8aU9F4Qs6HvDyUy9PvFGDKZ/P5101TYHFl8pjj6wm/qyS75etZhhfg0UEL4OYmHk6m6dO192AzoIyPSV9QedDA4Ml23rRbqxMPMxf7FJnDc5FTElVS/PyqgePzmwVZ26NWhRDQ+oaT7ly7ell4s3DypS1s0g+tOr7XHrrkZj9+x/mJBttrLx98lFIaRZzHz4aC7r52/JQ4VjHahY2/YVXZn/QC2ztQb/sY3uRlyc5vQS8nLPGT/n27495i8HPA152z7Fh5aFpyn1GPJKHuPL8Iw94DuW3KjkURAWZXn4EQy89xiKEHN1mk/tkM4gYDBxwNoYvRfE6LFqsxWJtPrDGbsnLMap3Ka3MUoytW0cvieozOmdERmhcqzG+3HmZv2yZeiIeQTKGdRT4HHNxekm1tY+/n06rGmFleqLscSERzctTKM6G9P0Pc1RmVvrascIxaO1CQCiYPE15bD7c3xSeW7gXxYjgxcrUlcbIvO0r+Yplhx0kTt3qafDOmFyMjgGxXu73rddMHpV1wMubyAGcf/v5dLr5P72Ta9lBF+fzMJrMycwv+9vnU3ANIl1cH9tfW7af8u0/HG0vV47jNFXzFTtaha1xvze/s8KMtCYucXc1nzfd/MQydUXn/b72RBt5wO/3jRcMH9BdhC/yctKBIveRYPrNpDWqBsO8VMmP+WvRaOcA4zRMR1PvSoO92rS7pYEv+fZfEfTMzEdM+6X5tLlyxExhqLRkms5EuLovLfx66de5fL2/yX02H52FPVwahrPqmN/E0oVXnsCKhbi/yRxX83nRbUKWhzYceXOntfuXn51NszJ6MO73pQf5Pl4in3ec4JU8hF7ppV34+mm9r1LY0ee/i1O1wpd8+zfLztE0cqBxggiBi5Bu95v9l3r9r/U5hweLn+TbfxowrWDqdJauKd8+q/dH8sbPkc9ttuyO94f7/XK/nHX46MPFLEb5qQlNPvhJ50/59t9ft3LXu7uVaWaO2bDrDCnRSzZyWvFKxO1+vT8MwwunR3bX0CkfPjqb4K9O19tn5X50PvmYpEwHtiW9WtzuV/s76B1zvLLNkViNd8ySxIl/3orfqP90TyTGaf7/rx8jQzeHJXdmh/N6YDvbvmTBwCdxfEQ1NcL6wNMdSIXNq7b1EUzRy1/Axsyk5p22GMG1b+GxFgbHErZh92wuvco0AuOLXct9hvw2nw/LqIcDRRmJmmZzcgUa7JpM/WV/S9IUfbF56TL2orzqwebdRD8nIYNJ41D/hz37Fo11p2Y21wzPcn713qVGhqtevStYfGH4n69OEJtPvbbLYWvscDqc3Hgnu166+tAyLnxrX0Y5zoYjV++1sI7t5kMr02KT/+uwtkc+rZLOf/qn/s3nYCf13Dg8/sB2diJgjGqjQ+TLhxbzyue2Ob7X6/9lUwW7a+lbznHzOYy8LKW1C/uRPbQY3KW/0gO9LXunHLvPL97afba9bFtc9hmz7GAttjVYlCvQAiOwAk/gC5+hkLEs6tr3AZKxLJtOEwk2dLxTYWsIB/j/ToWtIWzo906FrSG8iaqqqqqqiIiIiAgzMzMzNz+AyK+01/zi8n8S+Y1MjoRaQ80WU/G8MBlO+53VPXANrWm4wzGUVZUjjBJZVdhpcfkjsmcWaO+UEldXi1e+zq+HOsCpknYshuh8pOLISJun7TN0EIGW2xTnlOImeecnoGW4raxe2G1T3HEvfYUYMhG+gAFOAwh5nK8mZhwJMmN7r224QVsNFvZ87Z0qatvknklyPDK3Hy45PgVKXji52Wen4d4PlFVVYGnNap+fSpFbK90rYnhUc6n91Q3AY9E0tJOFrcfZtm/491XbcG/jsViUPPX76qmeuiz+qY1Hk7/1VPM405zWVuoheLUimpWYdVzCmUdKHebMdzgrYrb8mL2eeLSnRWHdonfZa8RsOU9F37w+591l5FLYHiOqWeHtE/lWrBHcRKp3uhtr8yXm8LU/5ms+NM6ZKsqu90cFZ4o58+k4rdrtB97NADFbwmEG7lXqvirhOTOqU14xuUF2myIjURcPHrPOQ4lmM3PeMg7bUuk0nnZi67bXsU6H8lhqIo8TaOrEafCO1ARK9PjC0QOoq2BxmMdgYB9G/lIb9++fqNJ2s7BHGFyBNmZAR8J3KCo012ikaSP8BCrf6VI0X5xdnbhHIO+B5rbOyB54zXkzfObyJ4ecwxfqBJMLFc7m59rNcw7hoHnFZ0b00zee+gTqvjm61Pb4xn0kcDX4jvHM0rBXZypG3DCKnD/Waa/ZtHmtFPgO5eETx+k7RrVg3aSwm2YoNXnCs3XPQDhNn+Fia6IlOOuIG6VJH7TP6ava26ehKHQa2T4N0tcZ9dPCGo3ZdnNltsHQbeYt5vPnJezV/cAeNypdml1vCHI8M81nSRP5Qi2+mI8v/sxiZru9187nRtp3f/42NemcONa+4eVC3PCZzc88aZh851CqSsshe70uPxeN/dmYwlwb3trwMrN1Gq8jbnApcVDx/yDPeYs5/7r62tsQ6lLg+DiFXTEhzR9dHqv0iT4tgj825W+H3XiRUNUZT2kR9Ri0+lp+UM3iQtS8uOE23Ly4KYtvqH13jghUntJRAewuzNLDXp8RxdcaA3cMY6TO2IeSFRXezeWIjCqyhsUdMYuCgYTZSKpBype1zRfq8FshvfBPc6BAQWl7/QxIDp3VGo1J3vn42OEs3qznws+YLRXbymyB19a9XBx6n/owcyxlEYyFWCi+kG9F+EyD/4yn80+agaZ9P7ay2Dny99aK2o91FkfEOY8hBwyfi5uwx2y5SaHmG+oq/zl1FX/8irOf8Y3vAcX/6uLP6A6nvMO24edSGPjQc827Rw2atX+z2bKq0CmW9mOtYnr5/AfDa1ZfPaXnKtlWborup7QYx+Or2uWb+N3N//2+yDcXMqIJdf55xl7/vsj4WoPPlxLxtVrkJ4w/tTe3mLdATOOYwxcq52w5Wxz5MbPdVs5O8/lhfE7dPj0bIiPQ3QV0iqm4m3YX8hRfc6jQ3fWepevMqUDJd86Z4vwM40CWHnn+WphsGHfieF02D3tmZvpWD+kBpNCFcLnZhcmmrhpGzzbdA+sQ1ar18OJD87IOKOFoRNznaHPNHUfUNhvY1iU+uhvEvpKHaUn3qK3exVVyX4joipp3um7FmYJWmA+WbIDshRpbVRx5/nqstCgy87FGbfVB8yDGCqS+2qCsnRwnSAN6zgzxfdB2nBT/vZ4/6uxb6oH8b4VBRxiIB93wLa47hG3w2SL/2Z27yOXJFwZpSJaBYyvajA7vRRYNKqljXKpt/CFD/tSMr18DKKbwB0xggBePatl1nki0yvqW5zchlyZmJ0OTxJ3D+fsYJs/mxYN5+Le5oagtcl+YsVvy8kSjI2YGvGjvmpkRS9W2dtXqWnVuxUhURm1lKtou/hdEq19VBp9OjGvHEQSmrpuf2R24mXGheil8KeiANY8fW1VERUfBImb64j12caBZmRViZHbeVMjCrPDg9A90IXrtnsYCuZtRQ0PyrKDjBNOsPfKsg1pA02gHlVr0OXiFhtp6nJqXVzcbfM0KnzC3ggOENPE9VBdmHKN6LYaijb4wXxJn5A0FSDF5j+h1ooZx885Jt3ZKzO5n7Z5WfNEOtyyPqQEnn7WLv5Fis3PdgMshjF1FRydbNyeBbyKI1oN1TRVrVK7kgsb/zjX4NDPIRMctVeaxVB38Vh1x5KbeJbU138AM5KzmZu3uny0ErygxiJF7GVXUrPzFxrlx1uFdAaZFDN9cvIb74qD9tzBMo7L7WIEYK+sla1DVMHpF0F7b3+Y6S+zjvLeDMCpapmJo1weBWuxKF3rOocih1gun4BoJh1kWnV/Jmiq6uOhK3VfKxEHEkafjLgK3oujaPzY6SXg8phhL4TNR1xvJd1Wa0aYFfPUMLrNBDCh4AuGRTbtKMc6Z1Udj8evY/ZpCuMAUefdo69DZUngoqE1P9A3PJfOf7WixCEj+Y6t7fYeHbbxUAoFV3M89cCKfma3fc1+jKRe7MFWEbQqEfyzO2x/wrO2VYH7iYdQ9BkPyI8/3kXBpLaCpU7eC0Yv/am/tEDu7HZpqg0EvHo0nf/R/gRzUWy33/HXMJQeu1GylKmOkXzlCfGFruAcPPhaGqZOtu19zsJ1SO2Jz4Ztth5cBX6mRQwWmDwryG9FUMlZzNckMdK+IoMJv1rOWnBamS2w2KHiaPMPLC15hCZm4KTpoZyj4E2TqC/P6r7/EhnDMhKicZZ1ZwxuC7DPzDGs53q8gXaI9kFTK+2LTq7bhwsTbrMV8Rsfua5lMS0FwbTitUVnVa1yTb5IX51mmYnUcP9wPr8Ji1tiYJeJV9GZTrQhF7vvdU2OTU42ogJ9FDwhmycI2LIg++03C6scYhUyUuMV5tkw6kGUoL+mjNC38+wMdWNljn6tGPpRES7veqrSn5TRuv+dh6JVL/iDHU1db4c9WK3++OrH3PqziF916UMUKn8G67nN60GfWiHrXYhUG3yVWmyYak59NHj8t1smG4UDiWz2rPHNrKnN4Zo1LBbr2/eF9YZ0n0blx2nG4X+EKFxvS3W28JESD+FWk61VCD3z/URGHiJl++7TdBwkCj6tGOH3qDb0QqcOF9Kzpj0HUb/KyFW3Yhj2VMKJqGZleFBH7vqvf7WqLC3XMuHV8q8a4sTFuxUtkD/6JIBvKaVjv96ndgruKZ1k/BHzqf2K9fLk7HGXANyLDd1vxkK/i055pnzl+zw6zLnwXlVYVtfmacJgEpRP1hbGgrYPVN6v2lG+idQNGmwcKXu/8xEj/P6qe/sB2WmwNp6pp8jaISMkwdleFXYK55NHWLTTbutSUqjBfDGWo/Yg918qQ+8BRZSAHZbfuNZz2O0sov1Ue4CWlVg3rFhM3Kljj9ksGd/NUhk4nH+a5UN2+1i8+NM3vRNp7uQ6sqexSCukEVlVZriHNqFi5rLm9TMWa4qm3idJqppQACol2l4VSuvWLfta4JcXy3bROPNbXOgdOhG47LC0CwW/dMlSx4Jf17aEU3yA1x9p+Yc0jupXgcMuYNku64iYOkGToVDuJvlbEKlJqsmiHbvNrIVZEH+yFdF8DbleZ6iNiWwMqvtMp/mSpwx5KxRrT9p3MAPTHGtMbfvdFhyj9vhaKcn3At8Lc16Ai+vBcSp1ztXi7rCJZx/ql7TXcclq6Q76UeKWDy9boS0WHIjUuWhPG8LBmW5y2rhuTpM5vsLt+HOLh1Yf0DqXa9tsfC+kaKt2htA0ai/L2i7RKoNjEwztkmRU0GfgW1TxUvPFhg0V7DdfWJk5gfrccpYv+MA9M0dkGTLECeYwUixRzjRFdmjG7zdZIl3XKB9YliNKI31lfa7i2JG5C8Ss+rHe0D7Z696/V3DEAOWHnQ9yNahMUl5kENWS6pHKKp2D1BaSrrHdE1w2qNxIztpXgUIrF0bm15YML4b6V1k+GpNysTahKMVrrS85lTVo9OGJ96I47eAy5rYWpRf/mIzeoYU1DKaQCTUVwrhHeyNoDqHel+lLxr9WKzhSYw7vrR6+V5q0pfi2k3L1zqkubY6rrd9ZLvSuWNf0uqnkY+FpTvFzSW9Fp0b9l8JA7THV9eCi/PY/SCZIUYx3BU2alj7Cm3VV6eYpios4b6WuNOJdYXUK3zTqj5CVG2FqYM4Z7CuIU0qO05XR0d71FHM0YhZmJmTRfLlXEumN82BGtzdX0S19t1e+bUieK8zRmqpa4Qc5TSjifmaQsY2ETLjhI36gMR1+7qpjdXXHiceUekfBaucHShAOiFXmv3sNmGQyU5iVgnoocuonQXEPTFwslHtS8R+A47StI9wj0iSrtbi5rMysczFiImsQ+bdFClnFjjpXXwMy6O7qfjOr8Fb0a7ODItisjnn3EQO16+ypd1cwyaAW5Yzxz5QknfMO7643fXW/I9y3U2xH27Oapqr56Z/tEzglj6IbT6HEHjopiXqeRbe5mQQvxtcbDOVverN0ZgMdzqRYRjaXtMRd56Q4cZSmdPvZJdSrhJ1D9zNXPqAEqPIavPdfubt5oke2kmv0dztIszSv2VYuoyf1UuopbsYb+uX9h6WpwjpgtZ6fNNawNJ4q8O3CFoSbioAaOSZMx2GYaPYB+rEb6qjQiNRFQ76TvwNFVKD+BhH9VhcKGsXzmMI7BptU/CNWolM7YzROvpFAntsiWJp6eR2d3GarcYShVYSUqhmYOWj5E96NK2WvmYNTeY7Zs4RUEdv9h9QT4EseKt6LzLrqEOs3hxAY1MaNWpSa6zZx8F3YOVeCYMS88W+CYHDuWe4yoc6YK+djDuEOrBR5lvh0r+Q9uM88lrjx9x9AtgpQVNE8r+3O6Gvw59D+kBF/UMXyhliYUtPjmvXGY6Dk3x+kEOW+GtdMVC4EZTqoS/jmR0P0LS75DOc/w2vnri97M4SdbZ8qeU7gg8DVbERkU5geaMQO3mYrSYyAngeUQqrN0C0/vsFmcgWNXNeidsTAj7/4MncJR0caaBUpbLK1yBCBNRjEv6KvuVSdpPnEMJdsRRtqJ+U8tN1gXA4ePHc6ZT0eviI73UOJF0fEZ8YaneAQqQdGphNvwM4nIqPnXxV0xA0fnCT+oAhJuyw/q8jO0y8CjSteZExwBpIN6SvNp6A5G/abi6egeND/1GTguhuNjaUbbnSbGd4L8937Ezm34Eyi6n1maeOBxh3PI0jzJDf5mh/BsLD7F2GOKvlA/5gtvxI3/eV4sLfKW5Wy+oio+es/u6T8UU+nsofy57Icb/JlZHPFtCgd/x+bwt3ZT+xXTtTtTrGAb4QehC6X9G+8YT+ozcLxDsdCjsuOqwPFnrdLYaFc92Ui0m4fr39lYmlCaqTit7G6O/3kWDkgtXjNH4BiEm/+jegQnihOtfffn33WxsFjhfMd48HT+f6o6X65j7XR8WLSHMFkxbvOYsrRsF1bowDuSQ18Mkxk4qz2zoGPL5fu9h2Hqmt1asl3Q3Yu3szOc+spiCmX4AETBM3pLoTYSp3sVxahyhL8eC4mPN9k2x3o0xkiixIzM3CZFzf5oR4mecQ5+ax2wCah3/crmnHoqR0+KMaOPxRif1oEFRFOO/kTPPmtww+NfMXxEK6gn6iU32U6fFruIz8Q4WgljtnaCVTBgWx7diUdshC9ZEa5yKpRBBeW12r/iNc/+EgNqmhswNB8SBoihHXeDF7rrWDLcmt3V8GYYN7pXRy4DZjj4DJuUBL5iC3DQAaoo4vkftqVTYRGLS3mHZ7gdmdTTqbgNN/PTdTCOTgXolc88MhXAEUMdX0iy1JMuk5wLsgeu0QUYlz2S4skTWwJz6pOm/8ihrmgGfFgri+ZWUK2gAPHgbWa8jaocdSuM4FJYoKicYX/ZSENkg9Q1ZzJfwScfVnR2DegOGwCvmogaWJCLQepv9WNlU6QgsmOwICquU28Mlk3d9W5E81lU/5Ez0LcX6lwKMWDNluNKfBDUy/phJgBcMnfkh9iRxrdOzgs08JdPB85Lwo+GUSb4t3nC+0byqMZtO2fQJ4U2zGIr49t/28qmmGv2RanDD7a3FEcdtutkW8twwwlUSpb8QalodddbBfNHKDQ828BdE7OBgFdiKYohLawFYqpybQoxATZrheLhdI7+0Zlu9Q1myRcd15r9UIm8K2LGJxqTegntqNVMKnf1a8zQiyUR1rxoqjiFxeHxqFcYUTHfDu7rhbWng6qOxOsI+5A1p9mRyEPdVkTlE24vY54W7bWc6jMgZvNXdfC9/9q7408KDsbdL7Utz7QFSDetz2picArzrdpL8OaCHC9V26RroemtDZ5yNM/KGkWMyTmfnInEvwtSD23UcFcjhaE3VKzkoaEMKGBft4XbIO6forTY1lmGQwVmKicBCiArDzE+1oIxE08fWeviIOD5TznqH+OoHadvoOP20drMPe5Irg3XBQziW2XDuHYzjqQQ4wySssjXUs5H+t3FWYMHppUnBHMx/nYIT5d7OmjDbgD9F6na3m4l7KdkeSO3kTEPXafiWinogag7b52taiZhL1TSvBFmEZafFq2H8khQaZXuitCewT5FBgVtPK0j4xUHPfUz3Q28eac1Z139DAP23dgki94EC8vbDPTQC97HPPSWjUNG5tWKMsaxAEMKC0665Xvo1Ntd07wCLNf8Q56mrEPVpCxlIMVlQlWRxM3oAfpgIc+8KC3rEXUog5g06vt7zgXY8grH7hhwVSaeuvC06YYRAwpbyk/Unzj9hLEZNs2oxPQB9yc+GnL6zTgq7rI++KDJwX2SP8Sd6YzTuw5lV/kU6eQxRD12omfQAW6caTR4LikYkBB1CMOrvgRr/VY75+NSB40Cni6bADAtaK+vyxVWpf9NeKJxN2KYQ8Q2xPB3K1s7fuhvWbr2XpgW044VD6DRs0qXoqKf1NFsaGvKJc47leUV3pppP/5VTKFhaGuol4Esfjf5zyCyUHmHthChcYh4hYLQF+AFWsuq4t0wJyWgdwQVOZiV0efRHPoK5+E1vjz9wTJmVkITC9oEstAsyZSgE/dbicwKr89YUxKZI+owD205Tm5lnnmDRuP/JnzxX3gMtlrcX0UesZdxyQqYQuEW4R51vmQ5xOZteUd8SJruMlTUzhtVw/Nq7eUBcqN2/HVotgfngif60yKEtoUx3WYOZlVJuJOh8u59fzSDPFYtQgqDUAGyGhQOAvKroXMcOYY0qjnStJR/G3aP+Jt1sLVlGV8POwr/6OGsqetnyF3TmTqZjENfnXh51oxe9qVUw2M78EzAJ+IM8lZ1MBPQ9ZWSVc4J3mWSrLKrMHReA5qdGoz0ODRsaA+vwxXA2cAM4qlfzBJA6581m4hzxItQw5dxrrBL3Y6kCbUcFxo1S8jyV44q//+7ASNNudZ6xeaNOSIUffqMn4A9lIjFctYn2gpEPAb3f7p3iIBN8H14FUGQ9ct2hPsL+cEsTgUrR47uJVN4n4wt/wgfwwHuOnLd4yobkofy8JvxSQTA7rMpDIc608SlZFJfZYcmbT0tAHpPE8MrtQ42siTUNWxqvWZOmvu9f0JPoQmg+6l7sZWwyfi6PXkxJnwBraUG0MYG4zYHQz3igy/XsFkx5tNQxw43qvI9dU3f0DdhOUlHKjmi1VAr2Kiy0HZwD8VeEbhh0OiDdMYspolQsYdSwjCcjeowIXNZVUPmL2wwIkYhmXKhGozdCJ4lRKbsf4NBh/XnQoS92NJEWOVOFs2YhN8c5QZFeK0pRdAG40hqvLbmoSA8xQmzOOEc7wLcme9JOsjPCEgpCwUs9E2DohMHRhUeyGIN6TFvrbny8nDuilsDpzrH5mS76APoIEJmItS67sQJ+nfwddzmjPxcBEBBCw0kWDwd0EZCkNeOD7NNQhtBm7KHL9mRxj6U1yWU2puzlIDtpYxdH4ZPeXBJkTGAJfUr/oTCz/iypY6uXaR2V1doPxJYlrw2ghH0D5gbrhFcIxzYwi4a/4hqVdf2DdxBp6vGYDjavxMAAoy+1+3aiO6S3W/QAKNVXagDtvsNtx7Ks+HKgo6U21B+QSZgIogV5Bt+BnXisdVfy9VyXV+2P5fMuvdpAjM1o/K9Z+XnE4EOCrue+kcdYHqAQ0/Y/OmNlQ6OI33jH/uD1RalPaHpJAm2av0/xtpqdXVKNDrc9F2izo23Wu7firgbURFDNX9eGGeYBhiypyXZft2j3hTvzE6PMWKsod//rEILDkzBXfi7xh0eFkfb3/1zzPK/PI5Nk3FbZyTl4mq5BfBoVoqiPHO4Q4QKZAlrQ3MdNfi3oxIjvsM3kAFv3fdufurqYR3PSwX/mpGy/GFI/B2MNPiNdOppWVbs/gjF3YH+QA9jMhlAbhvasAHstB0IJew09iAkmXHl1/TEj+jvHOpOGrPRQXbPADM+Ig2/OEcUcpgPTItMtW4DdqgfYVI/+4hAFWYjUGpOP/UwNuB7+BbKOcALbjobdgzeBQfjgNSp2GOpxzGLj70Vvq5cw2AoYENwKLUtJUX8sGRox4dVa/TN4xKwaKcl9XawQR/uNus700Hf17pyNnezrUgaY9e4MADhEDBpsJT6y1gDJs1q6wlwGhuUzGR7C8kgpjPyHWwsvrf3yn1zJEIRa5eSxoLAZOCR9xbuztxFRJW9ZmMYfCFJ0evm9F2fVnuje92Rc4Pl6A8bluN8MZyyJGZ0+sNSb//DvAFxC2BqlEsFwccWeAl6CyBcQV1bx4mQMBP1Jxqk1EUADNLeieS2dUFbQ/c/kvwItbZ7tx0st16viqd53WsRmPTKv2AD8CUnhtPWg5aUegNpsYgasaw2+EVooeNKmrW3MFtj76bYHJm5K9gpAXZXsE5U8DM8XmVOSJ1F1WnLy6nQup+jx52bAb+rCq6y9WXl2B2oZDhfDkW7H3oYfT/4xx5VncBuxMXP2lNfhUVQjSSzSRbuZFE4vFawlzveXxaYKVs8LpvAb8IRYF3ZHiRnm0ADeNPWocwxSzNseG7NrSEVZoHdKWqaGEBz1N8Pt7kFbqh3LYmAbm9i1IChIpLpM5AS6mr6OAPHMwwznVy61YpBYX8xZDN/a+lt7n+x5j4bNOVteZ8lj3hpAHSx1VR8vZHec4AHO9XFCdjZ9eRkSV65ljMmZVzaej2qFn/qt1lvWzNZEfHxK3qOJrHL6crr0CRzMox5f2e8ALBB4UGFZKA3tN6F6IXd32GTJXGQ7DTi9j/dNcLF9jCbDcWGKxoKTYblIwbLDReL00LRcDPMcQuXLMh5YzgtfjkFK1DP1iDzzYYVZz5M/kWYRlRpig1htVRjVCknm+h1M5LiEDXOyHREhvzCGpFZjHS0RsK27o2avgdilrJkalWqPW3D9gmwV37HKmfM3F8YZj2ar+vHFvf3B8CRoH4kDHIK9mrAg+owiEwNjjd9V+FsQKYR8czJrUkf7Qoi2YaW6EVDZp5zYlqiYtuXOTHk4fAcZ7qBbdLDiJq0WNV1l2+Hntk1mMWvxrYmc8kIx8G3rW36J6Ra4lLrTOCgiOihmow+YnzUT19jbV2B3RWqSHyxkhmgsBqMYWvOcUom1jDQ436+fcbu3xf2bbeqU/ca+C4DOKE+e3qvmeMqW3AxejfzBRFVcwVYPq4L0APSWWoJu+5UYX4qg5U6YTioqQGPG9XrnuZ/BkxuYpe6Li87+18EskyQW/uA+uk2rpHpr6hut2TlVbKgWkFpx+AZffweiw2+VittkEyf/ifinS/0ItRL2Jq3tQOcxPaWO2xrG68GdFoUpZgFXaP2wYVtRc6xYCfI1CaBqyWpg4bx8OHBQwsV4XWMibZZ0LYjWEy2IxQ1mZrf1/UNbYCJplWu3nZ4WpodIGVA05d+RWSS+ET9tH3RfGGmNI1cIY7evZZq7o+a0bjjygpmR3mVfalkT/SZGT27Q8QGalwGlDOS9VHCyFAIL0a1Q7JiW3saz9gqY8lqKynFrPCzxkU4SIfLc9VfCI5edgRhDXs0edO992nhTKHriREP1NJC6SROMgQ0xO5kNNZOhMOIT99AUElbxqeZF8A3xrfDJsWtDnUenAHdYWSwAbYjFqQZ+D5gi3hNK8CSxU9i6f6ClL9IGlj1OPMQAsr84YG6ijsJpCaGWj75c3yOZKBB9mNpQNPUKkK0D6wgLH8MGoyRxTX6Y05Q4AnYNXMZwXM4eij/9WpsM/9CoRnFQXGR6MEaY+FXvXEO3RO0JaStk6OXuHVATHJE+1W+TU3bSZ2ksMtqjO0zfSJCdBv7y2d8DMx6TfVme3q0ZpTKMMu4YL/t7ciTNtdDkwPogh3Cnjx7qk08SHwf+dksZ7M2vCOlfsF0hQ6J4ehPCaHTNrM/zBSOqD83dBEBCW/F/LEmeh0nOHd7oVl3/Qo/9GUDkkbj7yz+9cvvu+dDAtx8NzCDTP4iKdZvk9MWiizvtILLepysflSvTLFBZ37RLwiriqyRxYv/zrgFd/9XVHh/OmzBvDX4mitMR/lUavs2Vx6cR94lzAkplm3IRNy4TFfu47tuYs9EQPIPVta4P64tV+sZ7n3ued3cgEx2YK+QL5+xms6osk8qQbTyuKVGdaX9FQqk6qfDnT5ykxk0VK7KZ62b6DNDUfQlqGHxSMKv1P0XN5BqMeKG1P4Wp5QfZDUCEldppoX0U6ss2jIko2XpURKCIhfaOqLPfShdtS37ZrT+jFRSH2xYVV1rmT/MBtRQhxiO4MQ3iAGlaZi+9PWBEIXOVnu9jN1f921lWLZky9bqbM3J2MAAI9jmuAx3gyoEUa6P2ivs0EeNv/OR+AX6q5SW6l5HaoFuS6jr6yg9limu+P0KYKzfMXWcQSfTXzpOzKEKpwI3YGXZpSSy2LTlMgfmFA3CF6R5c9xWEtRuCg2ZPUQ2Nb6dRFTNd4TfGHrnEWSKHPuRyiJSDAZ+KX0VxmSHjGPbQTLVpqixia2uyhQ394gBMt7C3ZAmxn/DJS+l1fBsAo2Eir/C0jG9csd4+/tp12pPc/BVJGaK9mfvr7M/CeztrmCO5qY06Edi4xAGtiEhnWAbzLy2VEyazE1J5nPmgU4RpW4Sa0TnOT6w5lgt3/tMpROigHHmexBGAMY0mdcDbDxWIz41NgdD6oxgHsJRgr5RnT6wZAkTOcStU4NMOQNemSO7gxGahdEsC+NRVGxMUhQmmM0llWRbbmFGHzEqLM4Iw0H7577Kyo+Zf+2cUFIOw93gEY171vQaM0HLwpjpdRR6Jz7V0ckE7XzYJ0TmY9znLdzkva0vNrAGGT5SUZ5uaHDkcGvI0ySpwkasEgZPMseYcu85w8HPdSNi+4T6A83iAwDbxgeFcB1ZM2iGXzFcEOUlYVrEckaOyodfvaYSQ7GuB4ISE0nYJc15X/1ciDTPbPCgYJK55VkEor4LvzL9S2WDy4xj+6FOqVyTAC2ZNowheeeSI5hA/02l8UYkv4nk9iaVn+kCVEUstgk5Hyq+gJm6R9vG3rhuM904he/hFmNQaUIATB1y3vw+OmxP4X5Yi6A5I5jJufHCjF9+AGNwnEllZjUco6XhsO5T5+R3yxz5yLVOnAn0zuS+6zdj0nTJbEZCbXJdtpfYZfCeCOqJHoE2vPPFS6eRLjIJlG69X93nfR0mxSFXzp1Zc0lt/VafDaImhUMtbnqWVb9M4nGNQLN68BHP7AR8Il9dkcxzmBv8PCZlw9guY0lurbBsmNYlwJZsA/B15/HfkbjbwPddaVecls/elmDHNW2r4crAx43feNkfRwsaNq/yyJ0d/p5hZ6AZajz7DBfUok0ZU62gCzz7x8eVfJTKA8IWn45vINLSM1q+HF9CV9qF3zP6Ml21kPPL3CXzkuYUlnSqT+Ij4tI/od5KwIs+tDajDs64owN7tOAd6eucGz+KfO26iNcBFpbWA5732bBNWO4kHNpr9D955L61bvHCF/mwSrz6eQaDjfDEANqGMkFc+NGxpKZzCD2sj/JrHd+zlPQ8Iz7Q+2JVIiVCuCKoK/hlAEHzvk/Piq3mRL1rT/fEh9hoT5GJmeYswg1otiKydizJ/fS2SeKHVu6Z3JEHjiW8NaTQgP5xdBli8nC57XiN9hrquBu99hn9zqwo92+PM2JXtpeVZS0PdqR5mDyDreMMtEws+CpwaRyyzoYtfcvt9PJIW0fJVNNi/FFyRsea7peLvJrL+5b4GOXJ8tAr+ATk9f8KmiIsRhqRy0vFzwRV3Z5dZ3QqIU8JQ/uQpkJbjMUMFj2F9sCFeaBjI4+fL/oN3+LQgjI4zuAfQ+3IPIPFQBccf0clJpsfpnBxD84atwtupkGqKvrH7cGNl/QcWcSi6wcVDML6ljOgYbo+2BOAWNNjlUBPiyitUAwbnhFvLbnqw42kR3Yp2kv2dMeDdcGOX5kT4S6M44KHEB/SpCfl7xgsUvs+JNY9G3O2X/6FEt9FyAn57lrbiu+tl83sCymSvq9eZbe9mchL7MTf/Ta78e80zSf0hYY5eUU7+ff14jv7Xy8qjzfzzzvaJnrIdvFb5BLWKcWGy5/w7+vV2cvIfwHqdTB+RuJK5oj9mbt0Hy94AmjMjjwYNZlNS6uiyxNnwNyt3gdreLb64p/3+08nXkb92LTkkRgFOwk1oGEVllcOj5lv1hfAZywDows0944U8vUFw+A/nuVq/UCygsrmWIBnHyU01d0XJPwriEOvx/ISK6Pk4y2w0gmojZs7lU8TtakBAdne4v/aNxmMpK4VcGMp7si0yqsiolXRuOi1Z1P7SqD3Zmp0CWcyK4Ubmp2SXiXuI5nGLCieFHKHNRIlcY3Pys2dwMTYCaqlyWSITwr2oGXvyU3h1Pf8eQ3w1bnD7ilocVjYDkcXR3Oo1BXgMLTUjNw2xMVwjtp99NhSVc5aIWrDQT5DHPKtCtheBP4zHcw4dz2eRdTMamhlHhtfgqJJHI7NGDUw1XL8vsSeSHyKqDtqoAmrQqsYwvwi7HW3ojWyhIa5oz5xJTaq14NAzFLjVLR12rRNUQ6xohDnrWFb5bG9yf8aCD8d5phoackcNJp+Dw3Due3RM+5Rid7EuIgsnwgpX0rUWh/nqPtByMhMZZ69NpgvRTKZ62ViZ+Q7Dp5r4K0d7EfJuiy06KuIYauRh5Ecrhdt2QpTS1k1AscEHvapNbU3HL1F2TFyR33Wxb5MvH5iZsrn3SDcsxlnnshO8PLwmdGN+paWnQuORtZGX37uhFT64SeuPsx8UOokY6ON85WdQ1dki5zErsJGazcBOddWJEKqNPiJpsMD1GrVLrVY+AOdPWQneTyyP1hRX/lMM4ZogGGOhYuAdr7F/DOiAoc++cn5vlf0zkMUJ40Z1rlgv9BelPqVOpxKeOpzKdF8maK+1Vv23MO9k/8+qpLoxrIGH2EDQlnGmH8CD31G8QqlyQIcpmR5bwmSVw9/Ns6IHgulCRehvZ/+VrM60Cu/r3AontFfrljew74skYe2uyn7JKQtFQBQRJ9ryGic/zQOsbS4scUBctA8cPToQ3x6ZBQu6DPu5m1bnCtP8TllLYA0UTQNVqza5nfew3Mopy1GPUwG5jsl0OVXniPmAcmLqO5HG8Hv3nSLecE9oOjPDXcsTxoCBxYyzBdj4wmnyEV4kvFDunipS8SSkvdaMnTBN9brHUR8xdmmEAp/Pdqk9uextp1t+JrtXwpN/MG2w/qhRMpSNxQ1uhg/kKO30eQ/FyHUDkWHT8V6gGRU4DhDMxZu7xXij9Ui6jlpWmQCqJg3FkOTq3WKneCRYZxBXMNAVLQgHXSCGSqNdjebY94oyIpVjMYehAiFx/tqzBXFHZaL5PeeD74rW5OysFoUXY8sebUZleFTUa/+zBKVTFDopTReXNuZq47QjkWnxjirCommO4L/GrFtVV21EpMyw8wyThL5Y59d88xtlx1g1ttSICDwnof6lt/6zliPzgVUL8jWBjC0o2D6Kg+jNuThkAlaDJsq/AG2aKA//A76avw2KNqtv223P+Wq3StRDDNKFFgtsFukYt1GFDWooFVXitaNhb3RCyJi4cMeNjROiPEDb4k+G3+hD8tsg+5hhmSc/8t2JTSwYoCzAI75doq8QTHe+E/Tw0RQSUDlU+6uBeNN3h6jJGX/mH8oj0i3caCNsjvTnoh73BtyZpsflHLq6AfwJNCDX4S98h4+pCOhGKDhV3rtkKHMa3EG4J9y8zFWI4UsfNzC/Rl5midNn7gwoN9j23HGCQQ+OAZpTTPMdiVow740gIyuEtd0qVxMyNXhHcnuXRKdw5wDUSL358ktjMXmAkvIB73BLa1vfF9BAUZInPYJiwxqFWQQBVk7gQH4ojfUQ/KEjn+A/WR6EEe4CtbpoLe1mzHkajgTIoE0SLDHVauKhrq12zrAXBGbPPWKCt4DGedq3JyGRbmPFW32bE7T20+73BatV/qQhhBWfWBFHfhYWXjALts38FemnoT+9bn1jDBMcUMmYgSc0e7GQjv2MUBwLU8ionCpgV+Qrhg7iUIfUY6JFxR0Y+ZTCPM+rVuq0GNLyJXX6nrUTt8HzFBRY1E/FIm2EeVA9NcXrj7S6YYIChVQCWr/m2fYUjC4j0XLkzZ8GCSLfmkW3PB/xq+nlXsKVBOj7vTvqKCOMq7Ztqr3cQ+N8gBnPaAps+oGwWOkbuxnRYj/x/WjiDclVrs22xMK4qArE1Ztk1456kiJriw6abkNeRHogaPRBgbgF9Z8i/tbzWELN4CvbqtrqV9TtGSnmPS2F9kqOIBaazHYaJ9bi3AoDBvlZasMluxt0BDXfhp02Jn411aVt6S4TUB8ZgFDkI6TP6gwPY85w+oUQSsjIeXVminrwIdK2ZAawb8Se6XOJbOaliQxHSrnAeONDLuCnFejIbp4YDtBcQCwMsYiRZfHefuEJqJcwKTTJ8sx5hjHmJI1sPFHOr6W9AhZ2NAod38mnLQk1gOz2LCAohoQbgMbUK9RMEA3LkiF7Sr9tLZp6lkciIGhE2V546w3Mam53VtVkGbB9w0Yk2XiRnCmbpxmHr2k4eSC0RuNbjNsUfDIfc8DZvRvgUDe1IlKdZTzcT4ZGEb53dp8VtsoZlyXzLHOdAbsp1LPTVaHvLA0GYDFMbAW/WUBfUAdHwqLFAV+3uHvYWrCfhUOR2i89qvCBoOb48usAGdcF2M4aKn79k/43WzBZ+xR1L0uZfia70XP9soQReeuhZiUnXFDG1T8/OXNmssTSnYO+3kVLAgeiY719uDwL9FQycgLPessNihMZbAKG7qwPZyG11G1+ZA3jAX2yddpYfmaKBlmfcK/V0mwIRUDC0nJSOPUl2KB8h13F4dlVZiRhdGY5farwN+f9hEb1cRi41ZcGDn6Xe9MMSTOY81ULJyXIHSWFIQHstVYLiJEiUjktlHiGjntN5/btB8Fu+vp28zl2fZXN+dJDyN6EXhS+0yzqpl/LSJNEUVxmu7BsNdjAY0jVsAhkNuuY0E1G48ej25mSt+00yPbQ4SRCVkIwb6ISvYtmJRPz9Zt5dk76blf+lJwAPH5KDF+vHAmACLoCdG2Adii6dOHnNJnTmZtoOGO8Q1jy1veMw6gbLFToQmfJa7nT7Al89mRbRkZZQxJTKgK5Kc9INzmTJFp0tpAPzNmyL/F08bX3nhCumM/cR/2RPn9emZ3VljokttZD1zVWXlUIqEU7SLk5I0lFRU0AcENXBYazNaVzsVHA/sD3o9hm42wbHIRb/BBQTKzAi8s3+bMtpOOZgLdQzCYPfX3UUxKd1WYVkGH7lh/RBBgMZZwXzU9+GYxdBqlGs0LP+DZ5g2BWNh6FAcR944B+K/JTWI3t9YyVyRhlP4CCoUk/mmF7+r2pilVBjxXBHFaBfBtr9hbVn2zDuI0kEOG3kBx8CGdPOjX1ph1POOZJUO1JEGG0jzUy2tK4X0CgVNYhmkqqQysRNtKuPdCJqK3WW57kaV17vXgiyPrl4KEEWgiGF1euI4QkSFHFf0TDroQiLNKJiLbdhH0YBhriRNCHPxSqJmNNoketaioohqMglh6wLtEGWSM1EZbQg72h0UJAIPVFCAJOThpQGGdKfFovcwEeiBuZHN2Ob4uVM7+gwZLz1D9E7ta4RmMZ24OBBAg7Eh6dLXGofZ4U2TFOCQMKjwhVckjrydRS+YaqCw1kYt6UexuzbNEDyYLTZnrY1PzsHZJT4U+awO2xlqTSYu6n/U29O2wPXgGOEKDMSq+zTUtyc8+6iLp0ivav4FKx+xxVy4FxhIF/pucVDqpsVe2jFOfdZhTzLz2QjtzvsTCvDPU7bzDH2eXVKUV9TZ+qFtaSSxnYgYdXKwVreIgvWhT9eGDB2OvnWyPLfIIIfNnfIxU8nW7MbcH05nhlsYtaW9EZRsxWcKdEqInq1DiZPKCz7iGmAU9/ccnnQud2pNgIGFYOTAWjhIrd63aPDgfj8/sdlD4l+UTlcxTI9jbaMqqN0gQxSHs60IAcW3cH4p3V1aSciTKB29L1tz2eUQhRiTgTvmqc+sGtBNh4ky0mQJGsdycBREP+fAaSs1EREDVo5gvgi5+aCN7NECw30owbCc1mSpjiahyNVwJd1jiGgzSwfTpzf2c5XJvG/g1n0fH88KHNnf+u7ZiRMlXueSIsloJBUtW9ezvsx9grfsX/FNxnbxU1Lvg0hLxixypHKGFAaPu0xCD8oDTeFSyfRT6s8109GMUZL8m2xXp8X2dpPCWWdX84iga4BrTlOfqox4shqEgh/Ht4qRst52cA1xOIUuOxgfUivp6v5f8IVyaryEdpVk72ERAwdT4aoY1usBgmP+0m06Q216H/nubtNYxHaOIYjcach3A8Ez/zc0KcShhel0HCYjFsA0FjYqyJ5ZUH1aZw3+zWC0hLpM6GDfcAdn9fq2orPmZbW6XXrf+Krc9RtvII5jeD3dFoT1KwZJwxfUMvc5KLfn8rROW23Jw89sJ2a5dpB3qWDUBWF2iX8OCuKprHosJ2mflBR+Wqs86VvgI/XMnsqb97+VlKdPVysczPj8Jhzf+WCvGBHijAqYlavbF60soMWlHbvKT+ScvhprgeTln51xX0sF+Eadc/l2s2a5BgkVbHYyz0E85p0LstqH+gEGiR84nBRRFIn8hLSZrGwqjZ3E29cuGi+5Z5bp7EM8MWFa9ssS/vy4VrDfECSv7DSU84DaP0sXI3Ap4lWznQ65nQoTKRWU30gd7Nn8ZowUvGIx4aqyXGwmA/PB4qN8msJUODezUHEl0VP9uo+cZ8vPFodSIB4C7lQYjEFj8yu49C2KIV3qxMFYTevG8KqAr0TPlkbzHHnTpDpvpzziAiNFh8xiT7C/TiyH0EguUw4vxAgpnE27WIypV+uFN2zW7xniF/n75trs9IJ5amB1zXXZ1LFkJ6GbS/dFokzl4cc2mamVwhL4XU0Av5gDWAl+aEWhAP7t2VIwU+EpvfOPDcLASX7H7lZpXA2XQfbSlD4qU18NffNPoAKMNSccBfO9YVVgmlW4RydBqfHAV7+hrZ84WJGho6bNT0YMhxxLdOx/dwGj0oyak9aAkNJ8lRJzUuA8sR+fPyiyTgUHio5+Pp+YaKlHrhR41jY5NESPS3x+zTMe0S2HnLOKCOQPpdxKyviBvdHrCDRqO+l96HhhNBLXWv4yEMuEUYo8kXnYJM8oIgVM4XJ+xXOev4YbWeqsvgq0lmw4/PiYr9sYLt+W5EAuYSFnJEan8CwJwbtASBfLBBpJZiRPor/aCJBZsM+MhvS7ZepyHvU8m5WSmaZnxuLts8ojl6KkS8oSAHkq5GWlCB/NgJ5W3rO2Cj1MK7ahxsCrbTT3a0V/QQH+sErxV4XUWDHx0kkFy25bPmBMBQ6BU3HoHhhYcJB9JhP6NXUWKxnE0raXHB6U9KHpWdQCQI72qevp5fMzcm+AvC85rsynVQhruDA9fp9COe7N56cg1UKGSas89vrN+WlGLYTwi5W+0xYdKEGtGCeNJwXKDU0XqU5uQYnWsMwTENLGtbQMvoGjIFIEMzCRal4rnBAg7D/CSn8MsCvS+FDJJAzoiioJEhZJgAp9n2+1Yznr7H+6eT4YkJ9Mpj60ImcW4i4iHDLn9RydB8dx3QYm3rsX6n4VRrZDsYK6DCGwkwd5n3/INFEpk16fYpP6JtMQpqEMzcOfQGAHXBTEGzuLJ03GYQL9bmV2/7ExDlRf+Uvf1sM2frRtCWmal12pMgtonvSCtR4n1CLUZRdTHDHP1Otwqd+rcdlavnKjUB/OYXQHUJzpNyFoKpQK+2OgrEKpGyIgIBgn2y9QHnTJihZOpEvOKIoHAMGAXHmj21Lym39Mbiow4IF+77xNuewziNVBxr6KD5e+9HzZSBIlUa/AmsDFJFXeyrQakR3FwowTGcADJHcEfhGkXYNGSYo4dh4bxwLM+28xjiqkdn0/3R4UEkvcBrBfn/SzBc1XhKM2VPlJgKSorjDac96V2UnQYXl1/yZPT4DVelgO+soMjexXwYO58VLl5xInQUZI8jc3H2CPnCNb9X05nOxIy4MlecasTqGK6s2az4RjpF2cQP2G28R+7wDPsZDZC/kWtjdoHC7SpdPmqQrUAhMwKVuxCmYTiD9q/O7GHtZvPSN0CAUQN/rymXZNniYLlJDE70bsk6Xxsh4kDOdxe7A2wo7P9F5YvqqRDI6brf79yPCSp4I0jVoO4YnLYtX5nzspR5WB4AKOYtR1ujXbOQpPyYDvfRE3FN5zw0i7reehdi7yV0YDRKRllGCGRk5Yz+Uv1fYl2ZwrnGsqsjgAVo0xEUba8ohjaNMJNwTwZA/wBDWFSCpg1eUH8MYL2zdioxRTqgGQrDZxQyNzyBJPXZF0+oxITJAbj7oNC5JwgDMUJaM5GqlGCWc//KCIrI+aclEe4IA0uzv7cuj6GCdaJONpi13O544vbtIHBF+A+JeDFUQNy61Gki3rtyQ4aUywn6ru314/dkGiP8Iwjo0J/2Txs49ZkwEl4mx+iYUUO55I6pJzU4P+7RRs+DXZkyKUYZqVWrPF4I94m4Wx1tXeE74o9GuX977yvJ/jkdak8+AmoHVjI15V+WwBdARFV2IPirJgVMdsg1Pez2VNHqa7EHWdTkl3XTcyjG9BiueWFvQfXI8aWSkuuRmqi/HUuzqyvLJfNfs0txMqldYYflWB1BS31WkuPJGGwXUCpjiQSktkuBMWwHjSkQxeehqw1Kgz0Trzm7QbtgxiEPDVmWCNCAeCfROTphd1ZNOhzLy6XfJyG6Xgd5MCAZw4xie0Sj5AnY1/akDgNS9YFl3Y06vd6FAsg2gVQJtzG7LVq1OH2frbXNHWH/NY89NNZ4QUSJqL2yEcGADbT38X0bGdukqYlSoliKOcsSTuqhcaemUeYLLoI8+MZor2RxXTRThF1LrHfqf/5LcLAjdl4EERgUysYS2geE+yFdasU91UgUDsc2cSQ1ZoT9+uLOwdgAmifwQqF028INc2IQEDfTmUw3eZxvz7Ud1z3xc1PQfeCvfKsB9jOhRj7rFyb9XcDWLcYj0bByosychMezMLVkFiYcdBBQtvI6K0KRuOZQH2kBsYHJaXTkup8F0eIhO1/GcIwWKpr2mouB7g5TUDJNvORXPXa/mU8bh27TAZYBe2sKx4NSv5OjnHIWD2RuysCzBlUfeNXhDd2jxnHoUlheJ3jBApzURy0fwm2FwwsSU0caQGl0Kv8hopRQE211NnvtLRsmCNrhhpEDoNiZEzD2QdJWKbRRWnaFedXHAELSN0t0bfsCsMf0ktfBoXBoNA+nZN9+pSlmuzspFevmsqqcMllzzvkyXrzoA+Ryo1ePXpdGOoJvhyru+EBRsmOp7MXZ0vNUMUqHLUoKglg1p73sWeZmPc+KAw0pE2zIsFFE5H4192KwDvDxdxEYoDBDNZjbg2bmADTeUKK57IPD4fTYF4c6EnXx/teYMORBDtIhPJneiZny7Nv/zG+YmekIKCoxr6kauE2bZtBLufetNG0BtBY7f+/ImUypMBvdWu/Q7vTMRzw5aQGZWuc1V0HEsItFYMIBnoKGZ0xcarba/TYZq50kCaflFysYjA4EDKHqGdpYWdKYmm+a7TADmW35yfnOYpZYrkpVEtiqF0EujI00aeplNs2k+qyFZNeE3CDPL9P6b4PQ/kataHkVpLSEVGK7EX6rAa7IVNrvZtFvOA6okKvBgMtFDAGZOx88MeBcJ8AR3AgUUeIznAN6tjCUipGDZONm1FjWJp4A3QIzSaIOmZ7DvF/ysYYbM/fFDOV0jntAjRdapxJxL0eThpEhKOjCDDq2ks+3GrwxqIFKLe1WdOzII8XIOPGnwy6LKXVfpSDOTEfaRsGujhpS4hBIsMOqHbl16PJxc4EkaVu9wpEYlF/84NSv5Zum4drMfp9yXbzzAOJqqS4YkI4cBrFrC7bMPiCfgI3nNZAqkk3QOZqR+yyqx+nDQKBBBZ7QKrfGMCL+XpqFaBJU0wpkBdAhbR4hJsmT5aynlvkouoxm/NjD5oe6BzVIO9uktM+/5dEC5P7vZvarmuO/lKXz4sBabVPIATuKTrwbJP8XUkdM6uEctHKXICUJGjaZIWRbZp8czquQYfY6ynBUCfIU+gG6wqSIBmYIm9pZpXdaL121V7q0VjDjmQnXvMe7ysoEZnZL15B0SpxS1jjd83uNIOKZwu5MPzg2NhOx3xMOPYwEn2CUzbSrwAs5OAtrz3GAaUkJOU74XwjaYUmGJdZBS1NJVkGYrToINLKDjxcuIlyfVsKQSG/G4DyiO2SlQvJ0d0Ot1uOG5IFSAkq+PRVMgVMDvOIJMdqjeCFKUGRWBW9wigYvcbU7CQL/7meF2KZAaWl+4y9uhowAX7elogAvItAAxo2+SFxGRsHGEW9BnhlTuWigYxRcnVUBRQHV41LV+Fr5CJYV7sHfeywswx4XMtUx6EkBhR+q8AXXUA8uPJ73Pb49i9KG9fOljvXeyFj9ixgbo6CcbAJ7WHWqKHy/h+YjBwp6VcN7M89FGzQ04qbrQtgrOFybg3gQRTYG5xn73ArkfQWjCJROwy3J38Dx/D7jOa6BBNsitEw1wGq780EEioOeD+ZGp2J66ADiVGMayiHYucMk8nTK2zzT9CnEraAk95kQjy4k0GRElLL5YAKLQErJ5rp1eay9O4Fb6yJGm9U4FaMwPGxtKD6odIIHKoWnhKo1U8KIpFC+MVn59ZXmc7ZTBZfsg6FQ8W10YfTr4u0nYrpHZbZ1jXiLmooF0cOm0+mPnJBXQtepc7n0BqOipNCqI6yyloTeRShNKH04FIo0gcMk0H/xThyN4pPAWjDDkEp3lNNPRNVfpMI44CWRlRgViP64eK0JSRp0WUvCWYumlW/c58Vcz/yMwVcW5oYb9+26TEhwvbxiNg48hl1VI1UXTU//Eta+BMKnGUivctfL5wINDD0giQL1ipt6U7C9cd4+lgqY2lMUZ02Uv6Prs+ZEZer7ZfWBXVghlfOOrClwsoOFKzWEfz6RZu1eCs+K8fLvkts5+BX0gyrFYve0C3qHrn5U/Oh6D/CihmWIrY7HUZRhJaxde+tldu6adYJ+LeXupQw0XExC36RETdNFxcq9glMu4cNQSX9cqR/GQYp+IxUkIcNGWVU7ZtGa6P3XAyodRt0XeS3Tp01AnCh0ZbUh4VrSZeV9RWfSoWyxnY3hzcZ30G/InDq4wxRrEejreBxnhIQbkxenxkaxl+k7eLUQkUR6vKJ2iDFNGX3WmVA1yaOH+mvhBd+sE6vacQzFobwY5BqEAFmejwW5ne7HtVNolOUgJc8CsUxmc/LBi8N5mu9VsIA5HyErnS6zeCz7VLI9+n/hbT6hTokMXTVyXJRKSG2hd2labXTbtmK4fNH3IZBPreSA4FMeVouVN3zG5x9CiGpLw/3pceo4qGqp+rVp+z+7yQ98oEf+nyH4F3+J9IheDBa94Wi63zJbLBCIZm7P0asHGpIJt3PzE3m0S4YIWyXBCVXGikj8MudDPB/6Nm2v4IxJ5gU0ii0guy5SUHqGUYzTP0jIJU5E82RHUXtX4lDdrihBLdP1YaG1AGUC12rQKuIaGvCpMjZC9bWSCYnjDlvpWbkdXMTNeBHLKiuoozMGIvkczmP0aRJSJ8PYnLCVNhKHXBNckH79e8Z8Kc2wUej4sQZoH8qDRGkg86maW/ZQWGNnLcXmq3FlXM6ssR/3P6E/bHMvm6HLrv1yRixit25JsH3/IOr2UV4BWJhxXW5BJ6Xdr07n9kF3ZNAk6/Xpc5MSFmYJ2R7bdL8Kk7q1OU9Elg/tCxJ8giT27wSTySF0GOxg4PbYJdi/Nyia9Nn89CGDulfJemm1aiEr/eleGSN+5MRrVJ4K6lgyTTIW3i9cQ0dAi6FHt0YMbH3wDSAtGLSAccezzxHitt1QdhW36CQgPcA8vIIBh3/JNjf/Obmc2yzpk8edSlS4lVdwgW5vzbYEyFoF4GCBBby1keVNueHAH+evi+H7oOVfS3XuPQSNTXOONAbzJeSb5stwdQHl1ZjrGoE49I8+A9j3t+ahhQj74FCSWpZrj7wRSFJJnnwi1T9HL5qrCFW/JZq6P62XkMWTb+u4lGpKfmmwiJWx178GOG7KbrZGqyWwmuyKWPkNswkZ1q8uptUlviIi+AXh2bOOTOLsrtNkfqbQJeh24reebkINLkjut5r4d9GR/r8CBa9SU0UQhsnZp5cP+RqWCixRm7i4YRFbtZ4EAkhtNa6jHb6gPYQv7MKqkPLRmX3dFsK8XsRLVZ6IEVrCbmNDc8o5mqsogjAQfoC9Bc7R6gfw03m+lQpv6kTfhxscDIX6s0w+fBxtkhjXAXr10UouWCx3C/p/FYwJRS/AXRKkjOb5CLmK4XRe0+xeDDwVkJPZau52bzLEDHCqV0f44pPgKOkYKgTZJ33fmk3Tu8SdxJ02SHM8Fem5SMsWqRyi2F1ynfRJszcFKykdWlNqgDA/L9lKYBmc7Zu/q9ii1FPF47VJkqhirUob53zoiJtVVRVwMR34gV9iqcBaHbRu9kkvqk3yMpfRFG49pKKjIiq7h/VpRwPGTHoY4cg05X5028iHsLvUW/uz+kjPyIEhhcKUwCkJAwbR9pIEGOn8z6svAO8i89sJ3dL5qDWFYbS+HGPRMxYwJItFQN86YESeJQhn2urGiLRffQeLptDl8dAgb+Tp47UQPxWOw17OeChLN1WnzlkPL1T5O+O3Menpn4C3IY5LEepHpnPeZHbvuWfeVtPlkH4LZjPbBrkJT3NoRJzBt86CO0Xq59oQ+8dsm0ymRcmQyn8w71mhmcuEI5byuF+C88VPYly2sEzjlzAQ3vdn/1+Hzguw6qFNNbqenhZGbdiG6RwZaTG7jTA2X9RdXjDN9yj1uQpyO4Lx8KRAcZcbZMafp4wPOd5MdXoFY52V1A8M9hi3sso93+uprE0qYNMjkE22CvK4HuUxqN7oIz5pWuETq1lQAjqlSlqdD2Rnr/ggp/TVkQYjn9lMfYelk2sH5HPdopYo7MHwlV1or9Bxf+QCyLzm92vzG2wjiIjC/ZHEJzeroJl6bdFPTpZho5MV2U86fLQqxNlGIMqCGy+9WYhJ8ob1r0+Whxde9L2PdysETv97O+xVw+VNN1TZSQN5I6l9m5Ip6pLIqLm4a1B1ffH6gHyqT9p82NOjntRWGIofO3bJz5GhkvSWbsXueTAMaJDou99kGLqDlhwBZNEQ4mKPuDvVwSK4WmLluHyhA97pZiVe8g+JxmnJF8IkV/tCs4Jq/HgOoAEGR9tCDsDbDmi3OviUQpG5D8XmKcSAUaFLRXb2lmJTNYdhtYyfjBYZQmN5qT5CNuaD3BVnlkCk7bsMW3AtXkNMMTuW4HjUERSJnVQ0vsBGa1wo3Qh7115XGeTF3NTz8w0440AgU7c3bSXO/KMINaIWXd0oLpoq/0/QJxCQSJ9XnYy1W7TYLBJpHsVWD1ahsA7FjNvRd6mxCiHsm8g6Z0pnzqIpF1dHUtP2ITU5Z1hZHbu+L3BEEStBbL9XYvGfEakv1bmf+bOZGnoiuHEdlBnaChxYKNzB23b8sw8YyT7Ajxfk49eJIAvdbVkdFCe2J0gMefhQ0bIZxhx3fzMIysQNiN8PgOUKxOMur10LduigREDRMZyP4oGWrP1GFY4t6groASsZ421os48wAdnrbovNhLt7ScNULkwZ5AIZJTrbaKYTLjA1oJ3sIuN/aYocm/9uoQHEIlacF1s/TM1fLcPTL38O9fOsjMEIwoPKfvt7opuI9G2Hf/PR4aCLDQ7wNmIdEuXJ/QNL72k5q4NejAldPfe3UVVqzkys8YZ/jYOGOp6c+YzRCrCuq0M11y7TiN6qk7YXRMn/gukxrEimbMQjr3jwRM6dKVZ4RUfWQr8noPXLJq6yh5R3EH1IVOHESst/LItbG2D2vRsZRkAObzvQAAD3mb3/G4NzopI0FAiHfbpq0X72adg6SRj+8OHMShtFxxLZlf/nLgRLbClwl5WmaYSs+yEjkq48tY7Z2bE0N91mJwt+ua0NlRJIDh0HikF4UvSVorFj2YVu9YeS5tfvlVjPSoNu/Zu6dEUfBOT555hahBdN3Sa5Xuj2Rvau1lQNIaC944y0RWj9UiNDskAK1WoL+EfXcC6IbBXFRyVfX/WKXxPAwUyIAGW8ggZ08hcijKTt1YKnUO6QPvcrmDVAb0FCLIXn5id4fD/Jx4tw/gbXs7WF9b2RgXtPhLBG9vF5FEkdHAKrQHZAJC/HWvk7nvzzDzIXZlfFTJoC3JpGgLPBY7SQTjGlUvG577yNutZ1hTfs9/1nkSXK9zzKLRZ3VODeKUovJe0WCq1zVMYxCJMenmNzPIU2S8TA4E7wWmbNkxq9rI2dd6v0VpcAPVMxnDsvWTWFayyqvKZO7Z08a62i/oH2/jxf8rpmfO64in3FLiL1GX8IGtVE9M23yGsIqJbxDTy+LtaMWDaPqkymb5VrQdzOvqldeU0SUi6IirG8UZ3jcpRbwHa1C0Dww9G/SFX3gPvTJQE+kyz+g1BeMILKKO+olcHzctOWgzxYHnOD7dpCRtuZEXACjgqesZMasoPgnuDC4nUviAAxDc5pngjoAITIkvhKwg5d608pdrZcA+qn5TMT6Uo/QzBaOxBCLTJX3Mgk85rMfsnWx86oLxf7p2PX5ONqieTa/qM3tPw4ZXvlAp83NSD8F7+ZgctK1TpoYwtiU2h02HCGioH5tkVCqNVTMH5p00sRy2JU1qyDBP2CII/Dg4WDsIl+zgeX7589srx6YORRQMBfKbodbB743Tl4WLKOEnwWUVBsm94SOlCracU72MSyj068wdpYjyz1FwC2bjQnxnB6Mp/pZ+yyZXtguEaYB+kqhjQ6UUmwSFazOb+rhYjLaoiM+aN9/8KKn0zaCTFpN9eKwWy7/u4EHzO46TdFSNjMfn2iPSJwDPCFHc0I1+vjdAZw5ZjqR/uzi9Zn20oAa5JnLEk/EA3VRWE7J/XrupfFJPtCUuqHPpnlL7ISJtRpSVcB8qsZCm2QEkWoROtCKKxUh3yEcMbWYJwk6DlEBG0bZP6eg06FL3v6RPb7odGuwm7FN8fG4woqtB8e7M5klPpo97GoObNwt+ludTAmxyC5hmcFx+dIvEZKI6igFKHqLH01iY1o7903VzG9QGetyVx5RNmBYUU+zIuSva/yIcECUi4pRmE3VkF2avqulQEUY4yZ/wmNboBzPmAPey3+dSYtBZUjeWWT0pPwCz4Vozxp9xeClIU60qvEFMQCaPvPaA70WlOP9f/ey39macvpGCVa+zfa8gO44wbxpJUlC8GN/pRMTQtzY8Z8/hiNrU+Zq64ZfFGIkdj7m7abcK1EBtws1X4J/hnqvasPvvDSDYWN+QcQVGMqXalkDtTad5rYY0TIR1Eqox3czwPMjKPvF5sFv17Thujr1IZ1Ytl4VX1J0vjXKmLY4lmXipRAro0qVGEcXxEVMMEl54jQMd4J7RjgomU0j1ptjyxY+cLiSyXPfiEcIS2lWDK3ISAy6UZ3Hb5vnPncA94411jcy75ay6B6DSTzK6UTCZR9uDANtPBrvIDgjsfarMiwoax2OlLxaSoYn4iRgkpEGqEkwox5tyI8aKkLlfZ12lO11TxsqRMY89j5JaO55XfPJPDL1LGSnC88Re9Ai+Nu5bZjtwRrvFITUFHPR4ZmxGslQMecgbZO7nHk32qHxYkdvWpup07ojcMCaVrpFAyFZJJbNvBpZfdf39Hdo2kPtT7v0/f8R/B5Nz4f1t9/3zNM/7n6SUHfcWk5dfQFJvcJMgPolGCpOFb/WC0FGWU2asuQyT+rm88ZKZ78Cei/CAh939CH0JYbpZIPtxc2ufXqjS3pHH9lnWK4iJ7OjR/EESpCo2R3MYKyE7rHfhTvWho4cL1QdN4jFTyR6syMwFm124TVDDRXMNveI1Dp/ntwdz8k8kxw7iFSx6+Yx6O+1LzMVrN0BBzziZi9kneZSzgollBnVwBh6oSOPHXrglrOj+QmR/AESrhDpKrWT+8/AiMDxS/5wwRNuGQPLlJ9ovomhJWn8sMLVItQ8N/7IXvtD8kdOoHaw+vBSbFImQsv/OCAIui99E+YSIOMlMvBXkAt+NAZK8wB9Jf8CPtB+TOUOR+z71d/AFXpPBT6+A5FLjxMjLIEoJzrQfquvxEIi+WoUzGR1IzQFNvbYOnxb2PyQ0kGdyXKzW2axQL8lNAXPk6NEjqrRD1oZtKLlFoofrXw0dCNWASHzy+7PSzOUJ3XtaPZsxLDjr+o41fKuKWNmjiZtfkOzItvlV2MDGSheGF0ma04qE3TUEfqJMrXFm7DpK+27DSvCUVf7rbNoljPhha5W7KBqVq0ShUSTbRmuqPtQreVWH4JET5yMhuqMoSd4r/N8sDmeQiQQvi1tcZv7Moc7dT5X5AtCD6kNEGZOzVcNYlpX4AbTsLgSYYliiPyVoniuYYySxsBy5cgb3pD+EK0Gpb0wJg031dPgaL8JZt6sIvzNPEHfVPOjXmaXj4bd4voXzpZ5GApMhILgMbCEWZ2zwgdeQgjNHLbPIt+KqxRwWPLTN6HwZ0Ouijj4UF+Sg0Au8XuIKW0WxlexdrFrDcZJ8Shauat3X0XmHygqgL1nAu2hrJFb4wZXkcS+i36KMyU1yFvYv23bQUJi/3yQpqr/naUOoiEWOxckyq/gq43dFou1DVDaYMZK9tho7+IXXokBCs5GRfOcBK7g3A+jXQ39K4YA8PBRW4m5+yR0ZAxWJncjRVbITvIAPHYRt1EJ3YLiUbqIvoKHtzHKtUy1ddRUQ0AUO41vonZDUOW+mrszw+SW/6Q/IUgNpcXFjkM7F4CSSQ2ExZg85otsMs7kqsQD4OxYeBNDcSpifjMoLb7GEbGWTwasVObmB/bfPcUlq0wYhXCYEDWRW02TP5bBrYsKTGWjnWDDJ1F7zWai0zW/2XsCuvBQjPFcTYaQX3tSXRSm8hsAoDdjArK/OFp6vcWYOE7lizP0Yc+8p16i7/NiXIiiQTp7c7Xus925VEtlKAjUdFhyaiLT7VxDagprMFwix4wZ05u0qj7cDWFd0W9OYHIu3JbJKMXRJ1aYNovugg+QqRN7fNHSi26VSgBpn+JfMuPo3aeqPWik/wI5Rz3BWarPQX4i5+dM0npwVOsX+KsOhC7vDg+OJsz4Q5zlnIeflUWL6QYMbf9WDfLmosLF4Qev3mJiOuHjoor/dMeBpA9iKDkMjYBNbRo414HCxjsHrB4EXNbHzNMDHCLuNBG6Sf+J4MZ/ElVsDSLxjIiGsTPhw8BPjxbfQtskj+dyNMKOOcUYIRBEIqbazz3lmjlRQhplxq673VklMMY6597vu+d89ec/zq7Mi4gQvh87ehYbpOuZEXj5g/Q7S7BFDAAB9DzG35SC853xtWVcnZQoH54jeOqYLR9NDuwxsVthTV7V99n/B7HSbAytbEyVTz/5NhJ8gGIjG0E5j3griULUd5Rg7tQR+90hJgNQKQH2btbSfPcaTOfIexc1db1BxUOhM1vWCpLaYuKr3FdNTt/T3PWCpEUWDKEtzYrjpzlL/wri3MITKsFvtF8QVV/NhVo97aKIBgdliNc10dWdXVDpVtsNn+2UIolrgqdWA4EY8so0YvB4a+aLzMXiMAuOHQrXY0tr+CL10JbvZzgjJJuB1cRkdT7DUqTvnswVUp5kkUSFVtIIFYK05+tQxT6992HHNWVhWxUsD1PkceIrlXuUVRogwmfdhyrf6zzaL8+c0L7GXMZOteAhAVQVwdJh+7nrX7x4LaIIfz2F2v7Dg/uDfz2Fa+4gFm2zHAor8UqimJG3VTJtZEoFXhnDYXvxMJFc6ku2bhbCxzij2z5UNuK0jmp1mnvkVNUfR+SEmj1Lr94Lym75PO7Fs0MIr3GdsWXRXSfgLTVY0FLqba97u1In8NAcY7IC6TjWLigwKEIm43NxTdaVTv9mcKkzuzBkKd8x/xt1p/9BbP7Wyb4bpo1K1gnOpbLvKz58pWl3B55RJ/Z5mRDLPtNQg14jdOEs9+h/V5UVpwrAI8kGbX8KPVPDIMfIqKDjJD9UyDOPhjZ3vFAyecwyq4akUE9mDOtJEK1hpDyi6Ae87sWAClXGTiwPwN7PXWwjxaR79ArHRIPeYKTunVW24sPr/3HPz2IwH8oKH4OlWEmt4BLM6W5g4kMcYbLwj2usodD1088stZA7VOsUSpEVl4w7NMb1EUHMRxAxLF0CIV+0L3iZb+ekB1vSDSFjAZ3hfLJf7gFaXrOKn+mhR+rWw/eTXIcAgl4HvFuBg1LOmOAwJH3eoVEjjwheKA4icbrQCmvAtpQ0mXG0agYp5mj4Rb6mdQ+RV4QBPbxMqh9C7o8nP0Wko2ocnCHeRGhN1XVyT2b9ACsL+6ylUy+yC3QEnaKRIJK91YtaoSrcWZMMwxuM0E9J68Z+YyjA0g8p1PfHAAIROy6Sa04VXOuT6A351FOWhKfTGsFJ3RTJGWYPoLk5FVK4OaYR9hkJvezwF9vQN1126r6isMGXWTqFW+3HL3I/jurlIdDWIVvYY+s6yq7lrFSPAGRdnU7PVwY/SvWbZGpXzy3BQ2LmAJlrONUsZs4oGkly0V267xbD5KMY8woNNsmWG1VVgLCra8aQBBcI4DP2BlNwxhiCtHlaz6OWFoCW0vMR3ErrG7JyMjTSCnvRcsEHgmPnwA6iNpJ2DrFb4gLlhKJyZGaWkA97H6FFdwEcLT6DRQQL++fOkVC4cYGW1TG/3iK5dShRSuiBulmihqgjR45Vi03o2RbQbP3sxt90VxQ6vzdlGfkXmmKmjOi080JSHkLntjvsBJnv7gKscOaTOkEaRQqAnCA4HWtB4XnMtOhpRmH2FH8tTXrIjAGNWEmudQLCkcVlGTQ965Kh0H6ixXbgImQP6b42B49sO5C8pc7iRlgyvSYvcnH9FgQ3azLbQG2cUW96SDojTQStxkOJyOuDGTHAnnWkz29aEwN9FT8EJ4yhXOg+jLTrCPKeEoJ9a7lDXOjEr8AgX4BmnMQ668oW0zYPyQiVMPxKRHtpfnEEyaKhdzNVThlxxDQNdrHeZiUFb6NoY2KwvSb7BnRcpJy+/g/zAYx3fYSN5QEaVD2Y1VsNWxB0BSO12MRsRY8JLfAezRMz5lURuLUnG1ToKk6Q30FughqWN6gBNcFxP/nY/iv+iaUQOa+2Nuym46wtI/DvSfzSp1jEi4SdYBE7YhTiVV5cX9gwboVDMVgZp5YBQlHOQvaDNfcCoCJuYhf5kz5kwiIKPjzgpcRJHPbOhJajeoeRL53cuMahhV8Z7IRr6M4hW0JzT7mzaMUzQpm866zwM7Cs07fJYXuWvjAMkbe5O6V4bu71sOG6JQ4oL8zIeXHheFVavzxmlIyBkgc9IZlEDplMPr8xlcyss4pVUdwK1e7CK2kTsSdq7g5SHRAl3pYUB9Ko4fsh4qleOyJv1z3KFSTSvwEcRO/Ew8ozEDYZSqpfoVW9uhJfYrNAXR0Z3VmeoAD+rVWtwP/13sE/3ICX3HhDG3CMc476dEEC0K3umSAD4j+ZQLVdFOsWL2C1TH5+4KiSWH+lMibo+B55hR3Gq40G1n25sGcN0mEcoU2wN9FCVyQLBhYOu9aHVLWjEKx2JIUZi5ySoHUAI9b8hGzaLMxCZDMLhv8MkcpTqEwz9KFDpCpqQhVmsGQN8m24wyB82FAKNmjgfKRsXRmsSESovAwXjBIoMKSG51p6Um8b3i7GISs7kjTq/PZoioCfJzfKdJTN0Q45kQEQuh9H88M3yEs3DbtRTKALraM0YC8laiMiOOe6ADmTcCiREeAWZelBaEXRaSuj2lx0xHaRYqF65O0Lo5OCFU18A8cMDE4MLYm9w2QSr9NgQAIcRxZsNpA7UJR0e71JL+VU+ISWFk5I97lra8uGg7GlQYhGd4Gc6rxsLFRiIeGO4abP4S4ekQ1fiqDCy87GZHd52fn5aaDGuvOmIofrzpVwMvtbreZ/855OaXTRcNiNE0wzGZSxbjg26v8ko8L537v/XCCWP2MFaArJpvnkep0pA+O86MWjRAZPQRfznZiSIaTppy6m3p6HrNSsY7fDtz7Cl4V/DJAjQDoyiL2uwf1UHVd2AIrzBUSlJaTj4k6NL97a/GqhWKU9RUmjnYKpm2r+JYUcrkCuZKvcYvrg8pDoUKQywY9GDWg03DUFSirlUXBS5SWn/KAntnf0IdHGL/7mwXqDG+LZYjbEdQmqUqq4y54TNmWUP7IgcAw5816YBzwiNIJiE9M4lPCzeI/FGBeYy3p6IAmH4AjXXmvQ4Iy0Y82NTobcAggT2Cdqz6Mx4TdGoq9fn2etrWKUNFyatAHydQTVUQ2S5OWVUlugcNvoUrlA8cJJz9MqOa/W3iVno4zDHfE7zhoY5f5lRTVZDhrQbR8LS4eRLz8iPMyBL6o4PiLlp89FjdokQLaSBmKHUwWp0na5fE3v9zny2YcDXG/jfI9sctulHRbdkI5a4GOPJx4oAJQzVZ/yYAado8KNZUdEFs9ZPiBsausotXMNebEgr0dyopuqfScFJ3ODNPHgclACPdccwv0YJGQdsN2lhoV4HVGBxcEUeUX/alr4nqpcc1CCR3vR7g40zteQg/JvWmFlUE4mAiTpHlYGrB7w+U2KdSwQz2QJKBe/5eiixWipmfP15AFWrK8Sh1GBBYLgzki1wTMhGQmagXqJ2+FuqJ8f0XzXCVJFHQdMAw8xco11HhM347alrAu+wmX3pDFABOvkC+WPX0Uhg1Z5MVHKNROxaR84YV3s12UcM+70cJ460SzEaKLyh472vOMD3XnaK7zxZcXlWqenEvcjmgGNR2OKbI1s8U+iwiW+HotHalp3e1MGDy6BMVIvajnAzkFHbeVsgjmJUkrP9OAwnEHYXVBqYx3q7LvXjoVR0mY8h+ZaOnh053pdsGkmbqhyryN01eVHySr+CkDYkSMeZ1xjPNVM+gVLTDKu2VGsMUJqWO4TwPDP0VOg2/8ITbAUaMGb4LjL7L+Pi11lEVMXTYIlAZ/QHmTENjyx3kDkBdfcvvQt6tKk6jYFM4EG5UXDTaF5+1ZjRz6W7MdJPC+wTkbDUim4p5QQH3b9kGk2Bkilyeur8Bc20wm5uJSBO95GfYDI1EZipoRaH7uVveneqz43tlTZGRQ4a7CNmMHgXyOQQOL6WQkgMUTQDT8vh21aSdz7ERiZT1jK9F+v6wgFvuEmGngSvIUR2CJkc5tx1QygfZnAruONobB1idCLB1FCfO7N1ZdRocT8/Wye+EnDiO9pzqIpnLDl4bkaRKW+ekBVwHn46Shw1X0tclt/0ROijuUB4kIInrVJU4buWf4YITJtjOJ6iKdr1u+flgQeFH70GxKjhdgt/MrwfB4K/sXczQ+9zYcrD4dhY6qZhZ010rrxggWA8JaZyg2pYij8ieYEg1aZJkZK9O1Re7sB0iouf60rK0Gd+AYlp7soqCBCDGwfKeUQhCBn0E0o0GS6PdmjLi0TtCYZeqazqwN+yNINIA8Lk3iPDnWUiIPLGNcHmZDxfeK0iAdxm/T7LnN+gemRL61hHIc0NCAZaiYJR+OHnLWSe8sLrK905B5eEJHNlWq4RmEXIaFTmo49f8w61+NwfEUyuJAwVqZCLFcyHBKAcIVj3sNzfEOXzVKIndxHw+AR93owhbCxUZf6Gs8cz6/1VdrFEPrv330+9s6BtMVPJ3zl/Uf9rUi0Z/opexfdL3ykF76e999GPfVv8fJv/Y/+/5hEMon1tqNFyVRevV9y9/uIvsG3dbB8GRRrgaEXfhx+2xeOFt+cEn3RZanNxdEe2+B6MHpNbrRE53PlDifPvFcp4kO78ILR0T4xyW/WGPyBsqGdoA7zJJCu1TKbGfhnqgnRbxbB2B3UZoeQ2bz2sTVnUwokTcTU21RxN1PYPS3Sar7T0eRIsyCNowr9amwoMU/od9s2APtiKNL6ENOlyKADstAEWKA+sdKDhrJ6BOhRJmZ+QJbAaZ3/5Fq0/lumCgEzGEbu3yi0Y4I4EgVAjqxh4HbuQn0GrRhOWyAfsglQJAVL1y/6yezS2k8RE2MstJLh92NOB3GCYgFXznF4d25qiP4ZCyI4RYGesut6FXK6GwPpKK8WHEkhYui0AyEmr5Ml3uBFtPFdnioI8RiCooa7Z1G1WuyIi3nSNglutc+xY8BkeW3JJXPK6jd2VIMpaSxpVtFq+R+ySK9J6WG5Qvt+C+QH1hyYUOVK7857nFmyDBYgZ/o+AnibzNVqyYCJQvyDXDTK+iXdkA71bY7TL3bvuLxLBQ8kbTvTEY9aqkQ3+MiLWbEgjLzOH+lXgco1ERgzd80rDCymlpaRQbOYnKG/ODoFl46lzT0cjM5FYVvv0qLUbD5lyJtMUaC1pFlTkNONx6lliaX9o0i/1vws5bNKn5OuENQEKmLlcP4o2ZmJjD4zzd3Fk32uQ4uRWkPSUqb4LBe3EXHdORNB2BWsws5daRnMfNVX7isPSb1hMQdAJi1/qmDMfRUlCU74pmnzjbXfL8PVG8NsW6IQM2Ne23iCPIpryJjYbVnm5hCvKpMa7HLViNiNc+xTfDIaKm3jctViD8A1M9YPJNk003VVr4Zo2MuGW8vil8SLaGpPXqG7I4DLdtl8a4Rbx1Lt4w5Huqaa1XzZBtj208EJVGcmKYEuaeN27zT9EE6a09JerXdEbpaNgNqYJdhP1NdqiPKsbDRUi86XvvNC7rME5mrSQtrzAZVndtSjCMqd8BmaeGR4l4YFULGRBeXIV9Y4yxLFdyoUNpiy2IhePSWzBofYPP0eIa2q5JP4j9G8at/AqoSsLAUuRXtvgsqX/zYwsE+of6oSDbUOo4RMJw+DOUTJq+hnqwKim9Yy/napyZNTc2rCq6V9jHtJbxGPDwlzWj/Sk3zF/BHOlT/fSjSq7FqlPI1q6J+ru8Aku008SFINXZfOfnZNOvGPMtEmn2gLPt+H4QLA+/SYe4j398auzhKIp2Pok3mPC5q1IN1HgR+mnEfc4NeeHYwd2/kpszR3cBn7ni9NbIqhtSWFW8xbUJuUPVOeeXu3j0IGZmFNiwaNZ6rH4/zQ2ODz6tFxRLsUYZu1bfd1uIvfQDt4YD/efKYv8VF8bHGDgK22w2Wqwpi43vNCOXFJZCGMqWiPbL8mil6tsmOTXAWCyMCw73e2rADZj2IK6rqksM3EXF2cbLb4vjB14wa/yXK5vwU+05MzERJ5nXsXsW21o7M+gO0js2OyKciP5uF2iXyb2DiptwQeHeqygkrNsqVCSlldxBMpwHi1vfc8RKpP/4L3Lmpq6DZcvhDDfxTCE3splacTcOtXdK2g303dIWBVe2wD/Gvja1cClFQ67gw0t1ZUttsUgQ1Veky8oOpS6ksYEc4bqseCbZy766SvL3FodmnahlWJRgVCNjPxhL/fk2wyvlKhITH/VQCipOI0dNcRa5B1M5HmOBjTLeZQJy237e2mobwmDyJNHePhdDmiknvLKaDbShL+Is1XTCJuLQd2wmdJL7+mKvs294whXQD+vtd88KKk0DXP8B1Xu9J+xo69VOuFgexgTrcvI6SyltuLix9OPuE6/iRJYoBMEXxU4shQMf4Fjqwf1PtnJ/wWSZd29rhZjRmTGgiGTAUQqRz+nCdjeMfYhsBD5Lv60KILWEvNEHfmsDs2L0A252351eUoYxAysVaCJVLdH9QFWAmqJDCODUcdoo12+gd6bW2boY0pBVHWL6LQDK5bYWh1V8vFvi0cRpfwv7cJiMX3AZNJuTddHehTIdU0YQ/sQ1dLoF2xQPcCuHKiuCWOY30DHe1OwcClLAhqAKyqlnIbH/8u9ScJpcS4kgp6HKDUdiOgRaRGSiUCRBjzI5gSksMZKqy7Sd51aeg0tgJ+x0TH9YH2Mgsap9N7ENZdEB0bey2DMTrBA1hn56SErNHf3tKtqyL9b6yXEP97/rc+jgD2N1LNUH6RM9AzP3kSipr06RkKOolR7HO768jjWiH1X92jA7dkg7gcNcjqsZCgfqWw0tPXdLg20cF6vnQypg7gLtkazrHAodyYfENPQZsdfnjMZiNu4nJO97D1/sQE+3vNFzrSDOKw+keLECYf7RJwVHeP/j79833oZ0egonYB2FlFE5qj02B/LVOMJQlsB8uNg3Leg4qtZwntsOSNidR0abbZmAK4sCzvt8Yiuz2yrNCJoH5O8XvX/vLeR/BBYTWj0sOPYM/jyxRd5+/JziKAABaPcw/34UA3aj/gLZxZgRCWN6m4m3demanNgsx0P237/Q+Ew5VYnJPkyCY0cIVHoFn2Ay/e7U4P19APbPFXEHX94N6KhEMPG7iwB3+I+O1jd5n6VSgHegxgaSawO6iQCYFgDsPSMsNOcUj4q3sF6KzGaH/0u5PQoAj/8zq6Uc9MoNrGqhYeb2jQo0WlGlXjxtanZLS24/OIN5Gx/2g684BPDQpwlqnkFcxpmP/osnOXrFuu4PqifouQH0eF5qCkvITQbJw/Zvy5mAHWC9oU+cTiYhJmSfKsCyt1cGVxisKu+NymEQIAyaCgud/V09qT3nk/9s/SWsYtha7yNpzBIMM40rCSGaJ9u6lEkl00vXBiEt7p9P5IBCiavynEOv7FgLqPdeqxRiCwuFVMolSIUBcoyfUC2e2FJSAUgYdVGFf0b0Kn2EZlK97yyxrT2MVgvtRikfdaAW8RwEEfN+B7/eK8bBdp7URpbqn1xcrC6d2UjdsKbzCjBFqkKkoZt7Mrhg6YagE7spkqj0jOrWM+UGQ0MUlG2evP1uE1p2xSv4dMK0dna6ENcNUF+xkaJ7B764NdxLCpuvhblltVRAf7vK5qPttJ/9RYFUUSGcLdibnz6mf7WkPO3MkUUhR2mAOuGv8IWw5XG1ZvoVMnjSAZe6T7WYA99GENxoHkMiKxHlCuK5Gd0INrISImHQrQmv6F4mqU/TTQ8nHMDzCRivKySQ8dqkpQgnUMnwIkaAuc6/FGq1hw3b2Sba398BhUwUZSAIO8XZvnuLdY2n6hOXws+gq9BHUKcKFA6kz6FDnpxLPICa3qGhnc97bo1FT/XJk48LrkHJ2CAtBv0RtN97N21plfpXHvZ8gMJb7Zc4cfI6MbPwsW7AilCSXMFIEUEmir8XLEklA0ztYbGpTTGqttp5hpFTTIqUyaAIqvMT9A/x+Ji5ejA4Bhxb/cl1pUdOD6epd3yilIdO6j297xInoiBPuEDW2/UfslDyhGkQs7Wy253bVnlT+SWg89zYIK/9KXFl5fe+jow2rd5FXv8zDPrmfMXiUPt9QBO/iK4QGbX5j/7Rx1c1vzsY8ONbP3lVIaPrhL4+1QrECTN3nyKavGG0gBBtHvTKhGoBHgMXHStFowN+HKrPriYu+OZ05Frn8okQrPaaxoKP1ULCS/cmKFN3gcH7HQlVjraCeQmtjg1pSQxeuqXiSKgLpxc/1OiZsU4+n4lz4hpahGyWBURLi4642n1gn9qz9bIsaCeEPJ0uJmenMWp2tJmIwLQ6VSgDYErOeBCfSj9P4G/vI7oIF+l/n5fp956QgxGvur77ynawAu3G9MdFbJbu49NZnWnnFcQHjxRuhUYvg1U/e84N4JTecciDAKb/KYIFXzloyuE1eYXf54MmhjTq7B/yBToDzzpx3tJCTo3HCmVPYfmtBRe3mPYEE/6RlTIxbf4fSOcaKFGk4gbaUWe44hVk9SZzhW80yfW5QWBHxmtUzvMhfVQli4gZTktIOZd9mjJ5hsbmzttaHQB29Am3dZkmx3g/qvYocyhZ2PXAWsNQiIaf+Q8W/MWPIK7/TjvCx5q2XRp4lVWydMc2wIQkhadDB0xsnw/kSEyGjLKjI4coVIwtubTF3E7MJ6LS6UOsJKj82XVAVPJJcepfewbzE91ivXZvOvYfsmMevwtPpfMzGmC7WJlyW2j0jh7AF1JLmwEJSKYwIvu6DHc3YnyLH9ZdIBnQ+nOVDRiP+REpqv++typYHIvoJyICGA40d8bR7HR2k7do6UQTHF4oriYeIQbxKe4Th6+/l1BjUtS9hqORh3MbgvYrStXTfSwaBOmAVQZzpYNqsAmQyjY56MUqty3c/xH6GuhNvNaG9vGbG6cPtBM8UA3e8r51D0AR9kozKuGGSMgLz3nAHxDNnc7GTwpLj7/6HeWp1iksDeTjwCLpxejuMtpMnGJgsiku1sOACwQ9ukzESiDRN77YNESxR5LphOlcASXA5uIts1LnBIcn1J7BLWs49DMALSnuz95gdOrTZr0u1SeYHinno/pE58xYoXbVO/S+FEMMs5qyWkMnp8Q3ClyTlZP52Y9nq7b8fITPuVXUk9ohG5EFHw4gAEcjFxfKb3xuAsEjx2z1wxNbSZMcgS9GKyW3R6KwJONgtA64LTyxWm8Bvudp0M1FdJPEGopM4Fvg7G/hsptkhCfHFegv4ENwxPeXmYhxwZy7js+BeM27t9ODBMynVCLJ7RWcBMteZJtvjOYHb5lOnCLYWNEMKC59BA7covu1cANa2PXL05iGdufOzkgFqqHBOrgQVUmLEc+Mkz4Rq8O6WkNr7atNkH4M8d+SD1t/tSzt3oFql+neVs+AwEI5JaBJaxARtY2Z4mKoUqxds4UpZ0sv3zIbNoo0J4fihldQTX3XNcuNcZmcrB5LTWMdzeRuAtBk3cZHYQF6gTi3PNuDJ0nmR+4LPLoHvxQIxRgJ9iNNXqf2SYJhcvCtJiVWo85TsyFOuq7EyBPJrAdhEgE0cTq16FQXhYPJFqSfiVn0IQnPOy0LbU4BeG94QjdYNB0CiQ3QaxQqD2ebSMiNjaVaw8WaM4Z5WnzcVDsr4eGweSLa2DE3BWViaxhZFIcSTjgxNCAfelg+hznVOYoe5VqTYs1g7WtfTm3e4/WduC6p+qqAM8H4ZyrJCGpewThTDPe6H7CzX/zQ8Tm+r65HeZn+MsmxUciEWPlAVaK/VBaQBWfoG/aRL/jSZIQfep/89GjasWmbaWzeEZ2R1FOjvyJT37O9B8046SRSKVEnXWlBqbkb5XCS3qFeuE9xb9+frEknxWB5h1D/hruz2iVDEAS7+qkEz5Ot5agHJc7WCdY94Ws61sURcX5nG8UELGBAHZ3i+3VulAyT0nKNNz4K2LBHBWJcTBX1wzf+//u/j/9+//v87+9/l9Lbh/L/uyNYiTsWV2LwsjaA6MxTuzFMqmxW8Jw/+IppdX8t/Clgi1rI1SN0UC/r6tX/4lUc2VV1OQReSeCsjUpKZchw4XUcjHfw6ryCV3R8s6VXm67vp4n+lcPV9gJwmbKQEsmrJi9c2vkwrm8HFbVYNTaRGq8D91t9n5+U+aD/hNtN3HjC/nC/vUoGFSCkXP+NlRcmLUqLbiUBl4LYf1U/CCvwtd3ryCH8gUmGITAxiH1O5rnGTz7y1LuFjmnFGQ1UWuM7HwfXtWl2fPFKklYwNUpF2IL/TmaRETjQiM5SJacI+3Gv5MBU8lP5Io6gWkawpyzNEVGqOdx4YlO1dCvjbWFZWbCmeiFKPSlMKtKcMFLs/KQxtgAHi7NZNCQ32bBAW2mbHflVZ8wXKi1JKVHkW20bnYnl3dKWJeWJOiX3oKPBD6Zbi0ZvSIuWktUHB8qDR8DMMh1ZfkBL9FS9x5r0hBGLJ8pUCJv3NYH+Ae8p40mZWd5m5fhobFjQeQvqTT4VKWIYfRL0tfaXKiVl75hHReuTJEcqVlug+eOIIc4bdIydtn2K0iNZPsYWQvQio2qbO3OqAlPHDDOB7DfjGEfVF51FqqNacd6QmgFKJpMfLp5DHTv4wXlONKVXF9zTJpDV4m1sYZqJPhotcsliZM8yksKkCkzpiXt+EcRQvSQqmBS9WdWkxMTJXPSw94jqI3varCjQxTazjlMH8jTS8ilaW8014/vwA/LNa+YiFoyyx3s/KswP3O8QW1jtq45yTM/DX9a8M4voTVaO2ebvw1EooDw/yg6Y1faY+WwrdVs5Yt0hQ5EwRfYXSFxray1YvSM+kYmlpLG2/9mm1MfmbKHXr44Ih8nVKb1M537ZANUkCtdsPZ80JVKVKabVHCadaLXg+IV8i5GSwpZti0h6diTaKs9sdpUKEpd7jDUpYmHtiX33SKiO3tuydkaxA7pEc9XIQEOfWJlszj5YpL5bKeQyT7aZSBOamvSHl8xsWvgo26IP/bqk+0EJUz+gkkcvlUlyPp2kdKFtt7y5aCdks9ZJJcFp5ZWeaWKgtnXMN3ORwGLBE0PtkEIek5FY2aVssUZHtsWIvnljMVJtuVIjpZup/5VL1yPOHWWHkOMc6YySWMckczD5jUj2mlLVquFaMU8leGVaqeXis+aRRL8zm4WuBk6cyWfGMxgtr8useQEx7k/PvRoZyd9nde1GUCV84gMX8Ogu/BWezYPSR27llzQnA97oo0pYyxobYUJfsj+ysTm9zJ+S4pk0TGo9VTG0KjqYhTmALfoDZVKla2b5yhv241PxFaLJs3i05K0AAIdcGxCJZmT3ZdT7CliR7q+kur7WdQjygYtOWRL9B8E4s4LI8KpAj7bE0dg7DLOaX+MGeAi0hMMSSWZEz+RudXbZCsGYS0QqiXjH9XQbd8sCB+nIVTq7/T/FDS+zWY9q7Z2fdq1tdLb6v3hKKVDAw5gjj6o9r1wHFROdHc18MJp4SJ2Ucvu+iQ9EgkekW8VCM+psM6y+/2SBy8tNN4a3L1MzP+OLsyvESo5gS7IQOnIqMmviJBVc6zbVG1n8eXiA3j46kmvvtJlewwNDrxk4SbJOtP/TV/lIVK9ueShNbbMHfwnLTLLhbZuO79ec5XvfgRwLFK+w1r5ZWW15rVFZrE+wKqNRv5KqsLNfpGgnoUU6Y71NxEmN7MyqwqAQqoIULOw/LbuUB2+uE75gJt+kq1qY4LoxV+qR/zalupea3D5+WMeaRIn0sAI6DDWDh158fqUb4YhAxhREbUN0qyyJYkBU4V2KARXDT65gW3gRsiv7xSPYEKLwzgriWcWgPr0sbZnv7m1XHNFW6xPdGNZUdxFiUYlmXNjDVWuu7LCkX/nVkrXaJhiYktBISC2xgBXQnNEP+cptWl1eG62a7CPXrnrkTQ5BQASbEqUZWMDiZUisKyHDeLFOaJILUo5f6iDt4ZO8MlqaKLto0AmTHVVbkGuyPa1R/ywZsWRoRDoRdNMMHwYTsklMVnlAd2S0282bgMI8fiJpDh69OSL6K3qbo20KfpNMurnYGQSr/stFqZ7hYsxKlLnKAKhsmB8AIpEQ4bd/NrTLTXefsE6ChRmKWjXKVgpGoPs8GAicgKVw4K0qgDgy1A6hFq1WRat3fHF+FkU+b6H4NWpOU3KXTxrIb2qSHAb+qhm8hiSROi/9ofapjxhyKxxntPpge6KL5Z4+WBMYkAcE6+0Hd3Yh2zBsK2MV3iW0Y6cvOCroXlRb2MMJtdWx+3dkFzGh2Pe3DZ9QpSqpaR/rE1ImOrHqYYyccpiLC22amJIjRWVAherTfpQLmo6/K2pna85GrDuQPlH1Tsar8isAJbXLafSwOof4gg9RkAGm/oYpBQQiPUoyDk2BCQ1k+KILq48ErFo4WSRhHLq/y7mgw3+L85PpP6xWr6cgp9sOjYjKagOrxF148uhuaWtjet953fh1IQiEzgC+d2IgBCcUZqgTAICm2bR8oCjDLBsmg+ThyhfD+zBalsKBY1Ce54Y/t9cwfbLu9SFwEgphfopNA3yNxgyDafUM3mYTovZNgPGdd4ZFFOj1vtfFW3u7N+iHEN1HkeesDMXKPyoCDCGVMo4GCCD6PBhQ3dRZIHy0Y/3MaE5zU9mTCrwwnZojtE+qNpMSkJSpmGe0EzLyFelMJqhfFQ7a50uXxZ8pCc2wxtAKWgHoeamR2O7R+bq7IbPYItO0esdRgoTaY38hZLJ5y02oIVwoPokGIzxAMDuanQ1vn2WDQ00Rh6o5QOaCRu99fwDbQcN0XAuqkFpxT/cfz3slGRVokrNU0iqiMAJFEbKScZdmSkTUznC0U+MfwFOGdLgsewRyPKwBZYSmy6U325iUhBQNxbAC3FLKDV9VSOuQpOOukJ/GAmu/tyEbX9DgEp6dv1zoU0IqzpG6gssSjIYRVPGgU1QAQYRgIT8gEV0EXr1sqeh2I6rXjtmoCYyEDCe/PkFEi/Q48FuT29p557iN+LCwk5CK/CZ2WdAdfQZh2Z9QGrzPLSNRj5igUWzl9Vi0rCqH8G1Kp4QMLkuwMCAypdviDXyOIk0AHTM8HBYKh3b0/F+DxoNj4ZdoZfCpQVdnZarqoMaHWnMLNVcyevytGsrXQEoIbubqWYNo7NRHzdc0zvT21fWVirj7g36iy6pxogfvgHp1xH1Turbz8QyyHnXeBJicpYUctbzApwzZ1HT+FPEXMAgUZetgeGMwt4G+DHiDT2Lu+PT21fjJCAfV16a/Wu1PqOkUHSTKYhWW6PhhHUlNtWzFnA7MbY+r64vkwdpfNB2JfWgWXAvkzd42K4lN9x7Wrg4kIKgXCb4mcW595MCPJ/cTfPAMQMFWwnqwde4w8HZYJFpQwcSMhjVz4B8p6ncSCN1X4klxoIH4BN2J6taBMj6lHkAOs8JJAmXq5xsQtrPIPIIp/HG6i21xMGcFgqDXSRF0xQg14d2uy6HgKE13LSvQe52oShF5Jx1R6avyL4thhXQZHfC94oZzuPUBKFYf1VvDaxIrtV6dNGSx7DO0i1p6CzBkuAmEqyWceQY7F9+U0ObYDzoa1iKao/cOD/v6Q9gHrrr1uCeOk8fST9MG23Ul0KmM3r+Wn6Hi6WAcL7gEeaykicvgjzkjSwFsAXIR81Zx4QJ6oosVyJkCcT+4xAldCcihqvTf94HHUPXYp3REIaR4dhpQF6+FK1H0i9i7Pvh8owu3lO4PT1iuqu+DkL2Bj9+kdfGAg2TXw03iNHyobxofLE2ibjsYDPgeEQlRMR7afXbSGQcnPjI2D+sdtmuQ771dbASUsDndU7t58jrrNGRzISvwioAlHs5FA+cBE5Ccznkd8NMV6BR6ksnKLPZnMUawRDU1MZ/ib3xCdkTblHKu4blNiylH5n213yM0zubEie0o4JhzcfAy3H5qh2l17uLooBNLaO+gzonTH2uF8PQu9EyH+pjGsACTMy4cHzsPdymUSXYJOMP3yTkXqvO/lpvt0cX5ekDEu9PUfBeZODkFuAjXCaGdi6ew4qxJ8PmFfwmPpkgQjQlWqomFY6UkjmcnAtJG75EVR+NpzGpP1Ef5qUUbfowrC3zcSLX3BxgWEgEx/v9cP8H8u1Mvt9/rMDYf6sjwU1xSOPBgzFEeJLMRVFtKo5QHsUYT8ZRLCah27599EuqoC9PYjYO6aoAMHB8X1OHwEAYouHfHB3nyb2B+SnZxM/vw/bCtORjLMSy5aZoEpvgdGvlJfNPFUu/p7Z4VVK1hiI0/UTuB3ZPq4ohEbm7Mntgc1evEtknaosgZSwnDC2BdMmibpeg48X8Ixl+/8+xXdbshQXUPPvx8jT3fkELivHSmqbhblfNFShWAyQnJ3WBU6SMYSIpTDmHjdLVAdlADdz9gCplZw6mTiHqDwIsxbm9ErGusiVpg2w8Q3khKV/R9Oj8PFeF43hmW/nSd99nZzhyjCX3QOZkkB6BsH4H866WGyv9E0hVAzPYah2tkRfQZMmP2rinfOeQalge0ovhduBjJs9a1GBwReerceify49ctOh5/65ATYuMsAkVltmvTLBk4oHpdl6i+p8DoNj4Fb2vhdFYer2JSEilEwPd5n5zNoGBXEjreg/wh2NFnNRaIUHSOXa4eJRwygZoX6vnWnqVdCRT1ARxeFrNBJ+tsdooMwqnYhE7zIxnD8pZH+P0Nu1wWxCPTADfNWmqx626IBJJq6NeapcGeOmbtXvl0TeWG0Y7OGGV4+EHTtNBIT5Wd0Bujl7inXgZgfXTM5efD3qDTJ54O9v3Bkv+tdIRlq1kXcVD0BEMirmFxglNPt5pedb1AnxuCYMChUykwsTIWqT23XDpvTiKEru1cTcEMeniB+HQDehxPXNmkotFdwUPnilB/u4Nx5Xc6l8J9jH1EgKZUUt8t8cyoZleDBEt8oibDmJRAoMKJ5Oe9CSWS5ZMEJvacsGVdXDWjp/Ype5x0p9PXB2PAwt2LRD3d+ftNgpuyvxlP8pB84oB1i73vAVpwyrmXW72hfW6Dzn9Jkj4++0VQ4d0KSx1AsDA4OtXXDo63/w+GD+zC7w5SJaxsmnlYRQ4dgdjA7tTl2KNLnpJ+mvkoDxtt1a4oPaX3EVqj96o9sRKBQqU7ZOiupeAIyLMD+Y3YwHx30XWHB5CQiw7q3mj1EDlP2eBsZbz79ayUMbyHQ7s8gu4Lgip1LiGJj7NQj905/+rgUYKAA5qdrlHKIknWmqfuR+PB8RdBkDg/NgnlT89G72h2NvySnj7UyBwD+mi/IWs1xWbxuVwUIVXun5cMqBtFbrccI+DILjsVQg6eeq0itiRfedn89CvyFtpkxaauEvSANuZmB1p8FGPbU94J9medwsZ9HkUYjmI7OH5HuxendLbxTaYrPuIfE2ffXFKhoNBUp33HsFAXmCV/Vxpq5AYgFoRr5Ay93ZLRlgaIPjhZjXZZChT+aE5iWAXMX0oSFQEtwjiuhQQItTQX5IYrKfKB+queTNplR1Hoflo5/I6aPPmACwQCE2jTOYo5Dz1cs7Sod0KTG/3kEDGk3kUaUCON19xSJCab3kNpWZhSWkO8l+SpW70Wn3g0ciOIJO5JXma6dbos6jyisuxXwUUhj2+1uGhcvuliKtWwsUTw4gi1c/diEEpZHoKoxTBeMDmhPhKTx7TXWRakV8imJR355DcIHkR9IREHxohP4TbyR5LtFU24umRPRmEYHbpe1LghyxPx7YgUHjNbbQFRQhh4KeU1EabXx8FS3JAxp2rwRDoeWkJgWRUSKw6gGP5U2PuO9V4ZuiKXGGzFQuRuf+tkSSsbBtRJKhCi3ENuLlXhPbjTKD4djXVnfXFds6Zb+1XiUrRfyayGxJq1+SYBEfbKlgjiSmk0orgTqzSS+DZ5rTqsJbttiNtp+KMqGE2AHGFw6jQqM5vD6vMptmXV9OAjq49Uf/Lx9Opam+Hn5O9p8qoBBAQixzQZ4eNVkO9sPzJAMyR1y4/RCQQ1s0pV5KAU5sKLw3tkcFbI/JqrjCsK4Mw+W8aod4lioYuawUiCyVWBE/qPaFi5bnkgpfu/ae47174rI1fqQoTbW0HrU6FAejq7ByM0V4zkZTg02/YJK2N7hUQRCeZ4BIgSEqgD8XsjzG6LIsSbuHoIdz/LhFzbNn1clci1NHWJ0/6/O8HJMdIpEZbqi1RrrFfoo/rI/7ufm2MPG5lUI0IYJ4MAiHRTSOFJ2oTverFHYXThkYFIoyFx6rMYFgaOKM4xNWdlOnIcKb/suptptgTOTdVIf4YgdaAjJnIAm4qNNHNQqqAzvi53GkyRCEoseUBrHohZsjUbkR8gfKtc/+Oa72lwxJ8Mq6HDfDATbfbJhzeIuFQJSiw1uZprHlzUf90WgqG76zO0eCB1WdPv1IT6sNxxh91GEL2YpgC97ikFHyoaH92ndwduqZ6IYjkg20DX33MWdoZk7QkcKUCgisIYslOaaLyvIIqRKWQj16jE1DlQWJJaPopWTJjXfixEjRJJo8g4++wuQjbq+WVYjsqCuNIQW3YjnxKe2M5ZKEqq+cX7ZVgnkbsU3RWIyXA1rxv4kGersYJjD//auldXGmcEbcfTeF16Y1708FB1HIfmWv6dSFi6oD4E+RIjCsEZ+kY7dKnwReJJw3xCjKvi3kGN42rvyhUlIz0Bp+fNSV5xwFiuBzG296e5s/oHoFtUyUplmPulIPl+e1CQIQVtjlzLzzzbV+D/OVQtYzo5ixtMi5BmHuG4N/uKfJk5UIREp7+12oZlKtPBomXSzAY0KgtbPzzZoHQxujnREUgBU+O/jKKhgxVhRPtbqyHiUaRwRpHv7pgRPyUrnE7fYkVblGmfTY28tFCvlILC04Tz3ivkNWVazA+OsYrxvRM/hiNn8Fc4bQBeUZABGx5S/xFf9Lbbmk298X7iFg2yeimvsQqqJ+hYbt6uq+Zf9jC+Jcwiccd61NKQtFvGWrgJiHB5lwi6fR8KzYS7EaEHf/ka9EC7H8D+WEa3TEACHBkNSj/cXxFeq4RllC+fUFm2xtstYLL2nos1DfzsC9vqDDdRVcPA3Ho95aEQHvExVThXPqym65llkKlfRXbPTRiDepdylHjmV9YTWAEjlD9DdQnCem7Aj/ml58On366392214B5zrmQz/9ySG2mFqEwjq5sFl5tYJPw5hNz8lyZPUTsr5E0F2C9VMPnZckWP7+mbwp/BiN7f4kf7vtGnZF2JGvjK/sDX1RtcFY5oPQnE4lIAYV49U3C9SP0LCY/9i/WIFK9ORjzM9kG/KGrAuwFmgdEpdLaiqQNpCTGZVuAO65afkY1h33hrqyLjZy92JK3/twdj9pafFcwfXONmPQWldPlMe7jlP24Js0v9m8bIJ9TgS2IuRvE9ZVRaCwSJYOtAfL5H/YS4FfzKWKbek+GFulheyKtDNlBtrdmr+KU+ibHTdalzFUmMfxw3f36x+3cQbJLItSilW9cuvZEMjKw987jykZRlsH/UI+HlKfo2tLwemBEeBFtmxF2xmItA/dAIfQ+rXnm88dqvXa+GapOYVt/2waFimXFx3TC2MUiOi5/Ml+3rj/YU6Ihx2hXgiDXFsUeQkRAD6wF3SCPi2flk7XwKAA4zboqynuELD312EJ88lmDEVOMa1W/K/a8tGylZRMrMoILyoMQzzbDJHNZrhH77L9qSC42HVmKiZ5S0016UTp83gOhCwz9XItK9fgXfK3F5d7nZCBUekoLxrutQaPHa16Rjsa0gTrzyjqTnmcIcrxg6X6dkKiucudc0DD5W4pJPf0vuDW8r5/uw24YfMuxFRpD2ovT2mFX79xH6Jf+MVdv2TYqR6/955QgVPe3JCD/WjAYcLA9tpXgFiEjge2J5ljeI/iUzg91KQuHkII4mmHZxC3XQORLAC6G7uFn5LOmlnXkjFdoO976moNTxElS8HdxWoPAkjjocDR136m2l+f5t6xaaNgdodOvTu0rievnhNAB79WNrVs6EsPgkgfahF9gSFzzAd+rJSraw5Mllit7vUP5YxA843lUpu6/5jAR0RvH4rRXkSg3nE+O5GFyfe+L0s5r3k05FyghSFnKo4TTgs07qj4nTLqOYj6qaW9knJTDkF5OFMYbmCP+8H16Ty482OjvERV6OFyw043L9w3hoJi408sR+SGo1WviXUu8d7qS+ehKjpKwxeCthsm2LBFSFeetx0x4AaKPxtp3CxdWqCsLrB1s/j5TAhc1jNZsXWl6tjo/WDoewxzg8T8NnhZ1niUwL/nhfygLanCnRwaFGDyLw+sfZhyZ1UtYTp8TYB6dE7R3VsKKH95CUxJ8u8N+9u2/9HUNKHW3x3w5GQrfOPafk2w5qZq8MaHT0ebeY3wIsp3rN9lrpIsW9c1ws3VNV+JwNz0Lo9+V7zZr6GD56We6gWVIvtmam5GPPkVAbr74r6SwhuL+TRXtW/0pgyX16VNl4/EAD50TnUPuwrW6OcUO2VlWXS0inq872kk7GUlW6o/ozFKq+Sip6LcTtSDfDrPTcCHhx75H8BeRon+KG2wRwzfDgWhALmiWOMO6h3pm1UCZEPEjScyk7tdLx6WrdA2N1QTPENvNnhCQjW6kl057/qv7IwRryHrZBCwVSbLLnFRiHdTwk8mlYixFt1slEcPD7FVht13HyqVeyD55HOXrh2ElAxJyinGeoFzwKA91zfrdLvDxJSjzmImfvTisreI25EDcVfGsmxLVbfU8PGe/7NmWWKjXcdTJ11jAlVIY/Bv/mcxg/Q10vCHwKG1GW/XbJq5nxDhyLqiorn7Wd7VEVL8UgVzpHMjQ+Z8DUgSukiVwWAKkeTlVVeZ7t1DGnCgJVIdBPZAEK5f8CDyDNo7tK4/5DBjdD5MPV86TaEhGsLVFPQSI68KlBYy84FievdU9gWh6XZrugvtCZmi9vfd6db6V7FmoEcRHnG36VZH8N4aZaldq9zZawt1uBFgxYYx+Gs/qW1jwANeFy+LCoymyM6zgG7j8bGzUyLhvrbJkTYAEdICEb4kMKusKT9V3eIwMLsjdUdgijMc+7iKrr+TxrVWG0U+W95SGrxnxGrE4eaJFfgvAjUM4SAy8UaRwE9j6ZQH5qYAWGtXByvDiLSDfOD0yFA3UCMKSyQ30fyy1mIRg4ZcgZHLNHWl+c9SeijOvbOJxoQy7lTN2r3Y8p6ovxvUY74aOYbuVezryqXA6U+fcp6wSV9X5/OZKP18tB56Ua0gMyxJI7XyNT7IrqN8GsB9rL/kP5KMrjXxgqKLDa+V5OCH6a5hmOWemMUsea9vQl9t5Oce76PrTyTv50ExOqngE3PHPfSL//AItPdB7kGnyTRhVUUFNdJJ2z7RtktZwgmQzhBG/G7QsjZmJfCE7k75EmdIKH7xlnmDrNM/XbTT6FzldcH/rcRGxlPrv4qDScqE7JSmQABJWqRT/TUcJSwoQM+1jvDigvrjjH8oeK2in1S+/yO1j8xAws/T5u0VnIvAPqaE1atNuN0cuRliLcH2j0nTL4JpcR7w9Qya0JoaHgsOiALLCCzRkl1UUESz+ze/gIXHGtDwgYrK6pCFKJ1webSDog4zTlPkgXZqxlQDiYMjhDpwTtBW2WxthWbov9dt2X9XFLFmcF+eEc1UaQ74gqZiZsdj63pH1qcv3Vy8JYciogIVKsJ8Yy3J9w/GhjWVSQAmrS0BPOWK+RKV+0lWqXgYMnIFwpcZVD7zPSp547i9HlflB8gVnSTGmmq1ClO081OW/UH11pEQMfkEdDFzjLC1Cdo/BdL3s7cXb8J++Hzz1rhOUVZFIPehRiZ8VYu6+7Er7j5PSZu9g/GBdmNzJmyCD9wiswj9BZw+T3iBrg81re36ihMLjoVLoWc+62a1U/7qVX5CpvTVF7rocSAKwv4cBVqZm7lLDS/qoXs4fMs/VQi6BtVbNA3uSzKpQfjH1o3x4LrvkOn40zhm6hjduDglzJUwA0POabgdXIndp9fzhOo23Pe+Rk9GSLX0d71Poqry8NQDTzNlsa+JTNG9+UrEf+ngxCjGEsDCc0bz+udVRyHQI1jmEO3S+IOQycEq7XwB6z3wfMfa73m8PVRp+iOgtZfeSBl01xn03vMaQJkyj7vnhGCklsCWVRUl4y+5oNUzQ63B2dbjDF3vikd/3RUMifPYnX5Glfuk2FsV/7RqjI9yKTbE8wJY+74p7qXO8+dIYgjtLD/N8TJtRh04N9tXJA4H59IkMmLElgvr0Q5OCeVfdAt+5hkh4pQgfRMHpL74XatLQpPiOyHRs/OdmHtBf8nOZcxVKzdGclIN16lE7kJ+pVMjspOI+5+TqLRO6m0ZpNXJoZRv9MPDRcAfJUtNZHyig/s2wwReakFgPPJwCQmu1I30/tcBbji+Na53i1W1N+BqoY7Zxo+U/M9XyJ4Ok2SSkBtoOrwuhAY3a03Eu6l8wFdIG1cN+e8hopTkiKF093KuH/BcB39rMiGDLn6XVhGKEaaT/vqb/lufuAdpGExevF1+J9itkFhCfymWr9vGb3BTK4j598zRH7+e+MU9maruZqb0pkGxRDRE1CD4Z8LV4vhgPidk5w2Bq816g3nHw1//j3JStz7NR9HIWELO8TMn3QrP/zZp//+Dv9p429/ogv+GATR+n/UdF+ns9xNkXZQJXY4t9jMkJNUFygAtzndXwjss+yWH9HAnLQQfhAskdZS2l01HLWv7L7us5uTH409pqitvfSOQg/c+Zt7k879P3K9+WV68n7+3cZfuRd/dDPP/03rn+d+/nBvWfgDlt8+LzjqJ/vx3CnNOwiXhho778C96iD+1TBvRZYeP+EH81LE0vVwOOrmCLB3iKzI1x+vJEsrPH4uF0UB4TJ4X3uDfOCo3PYpYe0MF4bouh0DQ/l43fxUF7Y+dpWuvTSffB0yO2UQUETI/LwCZE3BvnevJ7c9zUlY3H58xzke6DNFDQG8n0WtDN4LAYN4nogKav1ezOfK/z+t6tsCTp+dhx4ymjWuCJk1dEUifDP+HyS4iP/Vg9B2jTo9L4NbiBuDS4nuuHW6H+JDQn2JtqRKGkEQPEYE7uzazXIkcxIAqUq1esasZBETlEZY7y7Jo+RoV/IsjY9eIMkUvr42Hc0xqtsavZvhz1OLwSxMOTuqzlhb0WbdOwBH9EYiyBjatz40bUxTHbiWxqJ0uma19qhPruvcWJlbiSSH48OLDDpaHPszvyct41ZfTu10+vjox6kOqK6v0K/gEPphEvMl/vwSv+A4Hhm36JSP9IXTyCZDm4kKsqD5ay8b1Sad/vaiyO5N/sDfEV6Z4q95E+yfjxpqBoBETW2C7xl4pIO2bDODDFurUPwE7EWC2Uplq+AHmBHvir2PSgkR12/Ry65O0aZtQPeXi9mTlF/Wj5GQ+vFkYyhXsLTjrBSP9hwk4GPqDP5rBn5/l8b0mLRAvRSzXHc293bs3s8EsdE3m2exxidWVB4joHR+S+dz5/W+v00K3TqN14CDBth8eWcsTbiwXPsygHdGid0PEdy6HHm2v/IUuV5RVapYmzGsX90mpnIdNGcOOq64Dbc5GUbYpD9M7S+6cLY//QmjxFLP5cuTFRm3vA5rkFZroFnO3bjHF35uU3s8mvL7Tp9nyTc4mymTJ5sLIp7umSnGkO23faehtz3mmTS7fbVx5rP7x3HXIjRNeq/A3xCs9JNB08c9S9BF2O3bOur0ItslFxXgRPdaapBIi4dRpKGxVz7ir69t/bc9qTxjvtOyGOfiLGDhR4fYywHv1WdOplxIV87TpLBy3Wc0QP0P9s4G7FBNOdITS/tep3o3h1TEa5XDDii7fWtqRzUEReP2fbxz7bHWWJdbIOxOUJZtItNZpTFRfj6vm9sYjRxQVO+WTdiOhdPeTJ+8YirPvoeL88l5iLYOHd3b/Imkq+1ZN1El3UikhftuteEYxf1Wujof8Pr4ICTu5ezZyZ4tHQMxlzUHLYO2VMOoNMGL/20S5i2o2obfk+8qqdR7xzbRDbgU0lnuIgz4LelQ5XS7xbLuSQtNS95v3ZUOdaUx/Qd8qxCt6xf2E62yb/HukLO6RyorV8KgYl5YNc75y+KvefrxY+lc/64y9kvWP0a0bDz/rojq+RWjO06WeruWqNFU7r3HPIcLWRql8ICZsz2Ls/qOm/CLn6++X+Qf7mGspYCrZod/lpl6Rw4xN/yuq8gqV4B6aHk1hVE1SfILxWu5gvXqbfARYQpspcxKp1F/c8XOPzkZvmoSw+vEqBLdrq1fr3wAPv5NnM9i8F+jdAuxkP5Z71c6uhK3enlnGymr7UsWZKC12qgUiG8XXGQ9mxnqz4GSIlybF9eXmbqj2sHX+a1jf0gRoONHRdRSrIq03Ty89eQ1GbV/Bk+du4+V15zls+vvERvZ4E7ZbnxWTVjDjb4o/k8jlw44pTIrUGxxuJvBeO+heuhOjpFsO6lVJ/aXnJDa/bM0Ql1cLbXE/Pbv3EZ3vj3iVrB5irjupZTzlnv677NrI9UNYNqbPgp/HZXS+lJmk87wec+7YOxTDo2aw2l3NfDr34VNlvqWJBknuK7oSlZ6/T10zuOoPZOeoIk81N+sL843WJ2Q4Z0fZ3scsqC/JV2fuhWi1jGURSKZV637lf53Xnnx16/vKEXY89aVJ0fv91jGdfG+G4+sniwHes4hS+udOr4RfhFhG/F5gUG35QaU+McuLmclb5ZWmR+sG5V6nf+PxYzlrnFGxpZaK8eqqVo0NfmAWoGfXDiT/FnUbWvzGDOTr8aktOZWg4BYvz5YH12ZbfCcGtNk+dDAZNGWvHov+PIOnY9Prjg8h/wLRrT69suaMVZ5bNuK00lSVpnqSX1NON/81FoP92rYndionwgOiA8WMf4vc8l15KqEEG4yAm2+WAN5Brfu1sq9suWYqgoajgOYt/JCk1gC8wPkK+XKCtRX6TAtgvrnuBgNRmn6I8lVDipOVB9kX6Oxkp4ZKyd1M6Gj8/v2U7k+YQBL95Kb9PQENucJb0JlW3b5tObN7m/Z1j1ev388d7o15zgXsI9CikAGAViR6lkJv7nb4Ak40M2G8TJ447kN+pvfHiOFjSUSP6PM+QfbAywKJCBaxSVxpizHseZUyUBhq59vFwrkyGoRiHbo0apweEZeSLuNiQ+HAekOnarFg00dZNXaPeoHPTRR0FmEyqYExOVaaaO8c0uFUh7U4e/UxdBmthlBDgg257Q33j1hA7HTxSeTTSuVnPZbgW1nodwmG16aKBDKxEetv7D9OjO0JhrbJTnoe+kcGoDJazFSO8/fUN9Jy/g4XK5PUkw2dgPDGpJqBfhe7GA+cjzfE/EGsMM+FV9nj9IAhrSfT/J3QE5TEIYyk5UjsI6ZZcCPr6A8FZUF4g9nnpVmjX90MLSQysIPD0nFzqwCcSJmIb5mYv2Cmk+C1MDFkZQyCBq4c/Yai9LJ6xYkGS/x2s5/frIW2vmG2Wrv0APpCdgCA9snFvfpe8uc0OwdRs4G9973PGEBnQB5qKrCQ6m6X/H7NInZ7y/1674/ZXOVp7OeuCRk8JFS516VHrnH1HkIUIlTIljjHaQtEtkJtosYul77cVwjk3gW1Ajaa6zWeyHGLlpk3VHE2VFzT2yI/EvlGUSz2H9zYE1s4nsKMtMqNyKNtL/59CpFJki5Fou6VXGm8vWATEPwrUVOLvoA8jLuwOzVBCgHB2Cr5V6OwEWtJEKokJkfc87h+sNHTvMb0KVTp5284QTPupoWvQVUwUeogZR3kBMESYo0mfukewRVPKh5+rzLQb7HKjFFIgWhj1w3yN/qCNoPI8XFiUgBNT1hCHBsAz8L7Oyt8wQWUFj92ONn/APyJFg8hzueqoJdNj57ROrFbffuS/XxrSXLTRgj5uxZjpgQYceeMc2wJrahReSKpm3QjHfqExTLAB2ipVumE8pqcZv8LYXQiPHHsgb5BMW8zM5pvQit+mQx8XGaVDcfVbLyMTlY8xcfmm/RSAT/H09UQol5gIz7rESDmnrQ4bURIB4iRXMDQwxgex1GgtDxKp2HayIkR+E/aDmCttNm2C6lytWdfOVzD6X2SpDWjQDlMRvAp1symWv4my1bPCD+E1EmGnMGWhNwmycJnDV2WrQNxO45ukEb08AAffizYKVULp15I4vbNK5DzWwCSUADfmKhfGSUqii1L2UsE8rB7mLuHuUJZOx4+WiizHBJ/hwboaBzhpNOVvgFTf5cJsHef7L1HCI9dOUUbb+YxUJWn6dYOLz+THi91kzY5dtO5c+grX7v0jEbsuoOGnoIreDIg/sFMyG+TyCLIcAWd1IZ1UNFxE8Uie13ucm40U2fcxC0u3WLvLOxwu+F7MWUsHsdtFQZ7W+nlfCASiAKyh8rnP3EyDByvtJb6Kax6/HkLzT9SyEyTMVM1zPtM0MJY14DmsWh4MgD15Ea9Hd00AdkTZ0EiG5NAGuIBzQJJ0JR0na+OB7lQA6UKxMfihIQ7GCCnVz694QvykWXTxpS2soDu+smru1UdIxSvAszBFD1c8c6ZOobA8bJiJIvuycgIXBQIXWwhyTgZDQxJTRXgEwRNAawGSXO0a1DKjdihLVNp/taE/xYhsgwe+VpKEEB4LlraQyE84gEihxCnbfoyOuJIEXy2FIYw+JjRusybKlU2g/vhTSGTydvCvXhYBdtAXtS2v7LkHtmXh/8fly1do8FI/D0f8UbzVb5h+KRhMGSAmR2mhi0YG/uj7wgxcfzCrMvdjitUIpXDX8ae2JcF/36qUWIMwN6JsjaRGNj+jEteGDcFyTUb8X/NHSucKMJp7pduxtD6KuxVlyxxwaeiC1FbGBESO84lbyrAugYxdl+2N8/6AgWpo/IeoAOcsG35IA/b3AuSyoa55L7llBLlaWlEWvuCFd8f8NfcTUgzJv6CbB+6ohWwodlk9nGWFpBAOaz5uEW5xBvmjnHFeDsb0mXwayj3mdYq5gxxNf3H3/tnCgHwjSrpSgVxLmiTtuszdRUFIsn6LiMPjL808vL1uQhDbM7aA43mISXReqjSskynIRcHCJ9qeFopJfx9tqyUoGbSwJex/0aDE3plBPGtNBYgWbdLom3+Q/bjdizR2/AS/c/dH/d3G7pyl1qDXgtOFtEqidwLqxPYtrNEveasWq3vPUUtqTeu8gpov4bdOQRI2kneFvRNMrShyVeEupK1PoLDPMSfWMIJcs267mGB8X9CehQCF0gIyhpP10mbyM7lwW1e6TGvHBV1sg/UyTghHPGRqMyaebC6pbB1WKNCQtlai1GGvmq9zUKaUzLaXsXEBYtHxmFbEZ2kJhR164LhWW2Tlp1dhsGE7ZgIWRBOx3Zcu2DxgH+G83WTPceKG0TgQKKiiNNOlWgvqNEbnrk6fVD+AqRam2OguZb0YWSTX88N+i/ELSxbaUUpPx4vJUzYg/WonSeA8xUK6u7DPHgpqWpEe6D4cXg5uK9FIYVba47V/nb+wyOtk+zG8RrS4EA0ouwa04iByRLSvoJA2FzaobbZtXnq8GdbfqEp5I2dpfpj59TCVif6+E75p665faiX8gS213RqBxTZqfHP46nF6NSenOneuT+vgbLUbdTH2/t0REFXZJOEB6DHvx6N6g9956CYrY/AYcm9gELJXYkrSi+0F0geKDZgOCIYkLU/+GOW5aGj8mvLFgtFH5+XC8hvAE3CvHRfl4ofM/Qwk4x2A+R+nyc9gNu/9Tem7XW4XRnyRymf52z09cTOdr+PG6+P/Vb4QiXlwauc5WB1z3o+IJjlbxI8MyWtSzT+k4sKVbhF3xa+vDts3NxXa87iiu+xRH9cAprnOL2h6vV54iQRXuOAj1s8nLFK8gZ70ThIQcWdF19/2xaJmT0efrkNDkWbpAQPdo92Z8+Hn/aLjbOzB9AI/k12fPs9HhUNDJ1u6ax2VxD3R6PywN7BrLJ26z6s3QoMp76qzzwetrDABKSGkfW5PwS1GvYNUbK6uRqxfyVGNyFB0E+OugMM8kKwmJmupuRWO8XkXXXQECyRVw9UyIrtCtcc4oNqXqr7AURBmKn6Khz3eBN96LwIJrAGP9mr/59uTOSx631suyT+QujDd4beUFpZ0kJEEnjlP+X/Kr2kCKhnENTg4BsMTOmMqlj2WMFLRUlVG0fzdCBgUta9odrJfpVdFomTi6ak0tFjXTcdqqvWBAzjY6hVrH9sbt3Z9gn+AVDpTcQImefbB4edirjzrsNievve4ZT4EUZWV3TxEsIW+9MT/RJoKfZZYSRGfC1CwPG/9rdMOM8qR/LUYvw5f/emUSoD7YSFuOoqchdUg2UePd1eCtFSKgxLSZ764oy4lvRCIH6bowPxZWwxNFctksLeil47pfevcBipkkBIc4ngZG+kxGZ71a72KQ7VaZ6MZOZkQJZXM6kb/Ac0/XkJx8dvyfJcWbI3zONEaEPIW8GbkYjsZcwy+eMoKrYjDmvEEixHzkCSCRPRzhOfJZuLdcbx19EL23MA8rnjTZZ787FGMnkqnpuzB5/90w1gtUSRaWcb0eta8198VEeZMUSfIhyuc4/nywFQ9uqn7jdqXh+5wwv+RK9XouNPbYdoEelNGo34KyySwigsrfCe0v/PlWPvQvQg8R0KgHO18mTVThhQrlbEQ0Kp/JxPdjHyR7E1QPw/ut0r+HDDG7BwZFm9IqEUZRpv2WpzlMkOemeLcAt5CsrzskLGaVOAxyySzZV/D2EY7ydNZMf8e8VhHcKGHAWNszf1EOq8fNstijMY4JXyATwTdncFFqcNDfDo+mWFvxJJpc4sEZtjXyBdoFcxbUmniCoKq5jydUHNjYJxMqN1KzYV62MugcELVhS3Bnd+TLLOh7dws/zSXWzxEb4Nj4aFun5x4kDWLK5TUF/yCXB/cZYvI9kPgVsG2jShtXkxfgT+xzjJofXqPEnIXIQ1lnIdmVzBOM90EXvJUW6a0nZ/7XjJGl8ToO3H/fdxnxmTNKBZxnkpXLVgLXCZywGT3YyS75w/PAH5I/jMuRspej8xZObU9kREbRA+kqjmKRFaKGWAmFQspC+QLbKPf0RaK3OXvBSWqo46p70ws/eZpu6jCtZUgQy6r4tHMPUdAgWGGUYNbuv/1a6K+MVFsd3T183+T8capSo6m0+Sh57fEeG/95dykGJBQMj09DSW2bY0mUonDy9a8trLnnL5B5LW3Nl8rJZNysO8Zb+80zXxqUGFpud3Qzwb7bf+8mq6x0TAnJU9pDQR9YQmZhlna2xuxJt0aCO/f1SU8gblOrbIyMsxTlVUW69VJPzYU2HlRXcqE2lLLxnObZuz2tT9CivfTAUYfmzJlt/lOPgsR6VN64/xQd4Jlk/RV7UKVv2Gx/AWsmTAuCWKhdwC+4HmKEKYZh2Xis4KsUR1BeObs1c13wqFRnocdmuheaTV30gvVXZcouzHKK5zwrN52jXJEuX6dGx3BCpV/++4f3hyaW/cQJLFKqasjsMuO3B3WlMq2gyYfdK1e7L2pO/tRye2mwzwZPfdUMrl5wdLqdd2Kv/wVtnpyWYhd49L6rsOV+8HXPrWH2Kup89l2tz6bf80iYSd+V4LROSOHeamvexR524q4r43rTmtFzQvArpvWfLYFZrbFspBsXNUqqenjxNNsFXatZvlIhk7teUPfK+YL32F8McTnjv0BZNppb+vshoCrtLXjIWq3EJXpVXIlG6ZNL0dh6qEm2WMwDjD3LfOfkGh1/czYc/0qhiD2ozNnH4882MVVt3JbVFkbwowNCO3KL5IoYW5wlVeGCViOuv1svZx7FbzxKzA4zGqBlRRaRWCobXaVq4yYCWbZf8eiJwt3OY+MFiSJengcFP2t0JMfzOiJ7cECvpx7neg1Rc5x+7myPJOXt2FohVRyXtD+/rDoTOyGYInJelZMjolecVHUhUNqvdZWg2J2t0jPmiLFeRD/8fOT4o+NGILb+TufCo9ceBBm3JLVn+MO2675n7qiEX/6W+188cYg3Zn5NSTjgOKfWFSAANa6raCxSoVU851oJLY11WIoYK0du0ec5E4tCnAPoKh71riTsjVIp3gKvBbEYQiNYrmH22oLQWA2AdwMnID6PX9b58dR2QKo4qag1D1Z+L/FwEKTR7osOZPWECPJIHQqPUsM5i/CH5YupVPfFA5pHUBcsesh8eO5YhyWnaVRPZn/BmdXVumZWPxMP5e28zm2uqHgFoT9CymHYNNrzrrjlXZM06HnzDxYNlI5b/QosxLmmrqDFqmogQdqk0WLkUceoAvQxHgkIyvWU69BPFr24VB6+lx75Rna6dGtrmOxDnvBojvi1/4dHjVeg8owofPe1cOnxU1ioh016s/Vudv9mhV9f35At+Sh28h1bpp8xhr09+vf47Elx3Ms6hyp6QvB3t0vnLbOhwo660cp7K0vvepabK7YJfxEWWfrC2YzJfYOjygPwfwd/1amTqa0hZ5ueebhWYVMubRTwIjj+0Oq0ohU3zfRfuL8gt59XsHdwKtxTQQ4Y2qz6gisxnm2UdlmpEkgOsZz7iEk6QOt8BuPwr+NR01LTqXmJo1C76o1N274twJvl+I069TiLpenK/miRxhyY8jvYV6W1WuSwhH9q7kuwnJMtm7IWcqs7HsnyHSqWXLSpYtZGaR1V3t0gauninFPZGtWskF65rtti48UV9uV9KM8kfDYs0pgB00S+TlzTXV6P8mxq15b9En8sz3jWSszcifZa/NuufPNnNTb031pptt0+sRSH/7UG8pzbsgtt3OG3ut7B9JzDMt2mTZuyRNIV8D54TuTrpNcHtgmMlYJeiY9XS83NYJicjRjtJSf9BZLsQv629QdDsKQhTK5CnXhpk7vMNkHzPhm0ExW/VCGApHfPyBagtZQTQmPHx7g5IXXsrQDPzIVhv2LB6Ih138iSDww1JNHrDvzUxvp73MsQBVhW8EbrReaVUcLB1R3PUXyaYG4HpJUcLVxMgDxcPkVRQpL7VTAGabDzbKcvg12t5P8TSGQkrj/gOrpnbiDHwluA73xbXts/L7u468cRWSWRtgTwlQnA47EKg0OiZDgFxAKQQUcsbGomITgeXUAAyKe03eA7Mp4gnyKQmm0LXJtEk6ddksMJCuxDmmHzmVhO+XaN2A54MIh3niw5CF7PwiXFZrnA8wOdeHLvvhdoqIDG9PDI7UnWWHq526T8y6ixJPhkuVKZnoUruOpUgOOp3iIKBjk+yi1vHo5cItHXb1PIKzGaZlRS0g5d3MV2pD8FQdGYLZ73aae/eEIUePMc4NFz8pIUfLCrrF4jVWH5gQneN3S8vANBmUXrEcKGn6hIUN95y1vpsvLwbGpzV9L0ZKTan6TDXM05236uLJcIEMKVAxKNT0K8WljuwNny3BNQRfzovA85beI9zr1AGNYnYCVkR1aGngWURUrgqR+gRrQhxW81l3CHevjvGEPzPMTxdsIfB9dfGRbZU0cg/1mcubtECX4tvaedmNAvTxCJtc2QaoUalGfENCGK7IS/O8CRpdOVca8EWCRwv2sSWE8CJPW5PCugjCXPd3h6U60cPD+bdhtXZuYB6stcoveE7Sm5MM2yvfUHXFSW7KzLmi7/EeEWL0wqcOH9MOSKjhCHHmw+JGLcYE/7SBZQCRggox0ZZTAxrlzNNXYXL5fNIjkdT4YMqVUz6p8YDt049v4OXGdg3qTrtLBUXOZf7ahPlZAY/O+7Sp0bvGSHdyQ8B1LOsplqMb9Se8VAE7gIdSZvxbRSrfl+Lk5Qaqi5QJceqjitdErcHXg/3MryljPSIAMaaloFm1cVwBJ8DNmkDqoGROSHFetrgjQ5CahuKkdH5pRPigMrgTtlFI8ufJPJSUlGgTjbBSvpRc0zypiUn6U5KZqcRoyrtzhmJ7/caeZkmVRwJQeLOG8LY6vP5ChpKhc8Js0El+n6FXqbx9ItdtLtYP92kKfaTLtCi8StLZdENJa9Ex1nOoz1kQ7qxoiZFKRyLf4O4CHRT0T/0W9F8epNKVoeyxUXhy3sQMMsJjQJEyMOjmOhMFgOmmlscV4eFi1CldU92yjwleirEKPW3bPAuEhRZV7JsKV3Lr5cETAiFuX5Nw5UlF7d2HZ96Bh0sgFIL5KGaKSoVYVlvdKpZJVP5+NZ7xDEkQhmDgsDKciazJCXJ6ZN2B3FY2f6VZyGl/t4aunGIAk/BHaS+i+SpdRfnB/OktOvyjinWNfM9Ksr6WwtCa1hCmeRI6icpFM4o8quCLsikU0tMoZI/9EqXRMpKGaWzofl4nQuVQm17d5fU5qXCQeCDqVaL9XJ9qJ08n3G3EFZS28SHEb3cdRBdtO0YcTzil3QknNKEe/smQ1fTb0XbpyNB5xAeuIlf+5KWlEY0DqJbsnzJlQxJPOVyHiKMx5Xu9FcEv1Fbg6Fhm4t+Jyy5JC1W3YO8dYLsO0PXPbxodBgttTbH3rt9Cp1lJIk2r3O1Zqu94eRbnIz2f50lWolYzuKsj4PMok4abHLO8NAC884hiXx5Fy5pWKO0bWL7uEGXaJCtznhP67SlQ4xjWIfgq6EpZ28QMtuZK7JC0RGbl9nA4XtFLug/NLMoH1pGt9IonAJqcEDLyH6TDROcbsmGPaGIxMo41IUAnQVPMPGByp4mOmh9ZQMkBAcksUK55LsZj7E5z5XuZoyWCKu6nHmDq22xI/9Z8YdxJy4kWpD16jLVrpwGLWfyOD0Wd+cBzFBxVaGv7S5k9qwh/5t/LQEXsRqI3Q9Rm3QIoaZW9GlsDaKOUyykyWuhNOprSEi0s1G4rgoiX1V743EELti+pJu5og6X0g6oTynUqlhH9k6ezyRi05NGZHz0nvp3HOJr7ebrAUFrDjbkFBObEvdQWkkUbL0pEvMU46X58vF9j9F3j6kpyetNUBItrEubW9ZvMPM4qNqLlsSBJqOH3XbNwv/cXDXNxN8iFLzUhteisYY+RlHYOuP29/Cb+L+xv+35Rv7xudnZ6ohK4cMPfCG8KI7dNmjNk/H4e84pOxn/sZHK9psfvj8ncA8qJz7O8xqbxESDivGJOZzF7o5PJLQ7g34qAWoyuA+x3btU98LT6ZyGyceIXjrqob2CAVql4VOTQPUQYvHV/g4zAuCZGvYQBtf0wmd5lilrvuEn1BXLny01B4h4SMDlYsnNpm9d7m9h578ufpef9Z4WplqWQvqo52fyUA7J24eZD5av6SyGIV9kpmHNqyvdfzcpEMw97BvknV2fq+MFHun9BT3Lsf8pbzvisWiIQvYkng+8Vxk1V+dli1u56kY50LRjaPdotvT5BwqtwyF+emo/z9J3yVUVGfKrxQtJMOAQWoQii/4dp9wgybSa5mkucmRLtEQZ/pz0tL/NVcgWAd95nEQ3Tg6tNbuyn3Iepz65L3huMUUBntllWuu4DbtOFSMSbpILV4fy6wlM0SOvi6CpLh81c1LreIvKd61uEWBcDw1lUBUW1I0Z+m/PaRlX+PQ/oxg0Ye6KUiIiTF4ADNk59Ydpt5/rkxmq9tV5Kcp/eQLUVVmBzQNVuytQCP6Ezd0G8eLxWyHpmZWJ3bAzkWTtg4lZlw42SQezEmiUPaJUuR/qklVA/87S4ArFCpALdY3QRdUw3G3XbWUp6aq9z0zUizcPa7351p9JXOZyfdZBFnqt90VzQndXB/mwf8LC9STj5kenVpNuqOQQP3mIRJj7eV21FxG8VAxKrEn3c+XfmZ800EPb9/5lIlijscUbB6da0RQaMook0zug1G0tKi/JBC4rw7/D3m4ARzAkzMcVrDcT2SyFtUdWAsFlsPDFqV3N+EjyXaoEePwroaZCiLqEzb8MW+PNE9TmTC01EzWli51PzZvUqkmyuROU+V6ik+Le/9qT6nwzUzf9tP68tYei0YaDGx6kAd7jn1cKqOCuYbiELH9zYqcc4MnRJjkeGiqaGwLImhyeKs+xKJMBlOJ05ow9gGCKZ1VpnMKoSCTbMS+X+23y042zOb5MtcY/6oBeAo1Vy89OTyhpavFP78jXCcFH0t7Gx24hMEOm2gsEfGabVpQgvFqbQKMsknFRRmuPHcZu0Su/WMFphZvB2r/EGbG72rpGGho3h+Msz0uGzJ7hNK2uqQiE1qmn0zgacKYYZBCqsxV+sjbpoVdSilW/b94n2xNb648VmNIoizqEWhBnsen+d0kbCPmRItfWqSBeOd9Wne3c6bcd6uvXOJ6WdiSsuXq0ndhqrQ4QoWUjCjYtZ0EAhnSOP1m44xkf0O7jXghrzSJWxP4a/t72jU29Vu2rvu4n7HfHkkmQOMGSS+NPeLGO5I73mC2B7+lMiBQQZRM9/9liLIfowupUFAbPBbR+lxDM6M8Ptgh1paJq5Rvs7yEuLQv/7d1oU2woFSb3FMPWQOKMuCuJ7pDDjpIclus5TeEoMBy2YdVB4fxmesaCeMNsEgTHKS5WDSGyNUOoEpcC2OFWtIRf0w27ck34/DjxRTVIcc9+kqZE6iMSiVDsiKdP/Xz5XfEhm/sBhO50p1rvJDlkyyxuJ9SPgs7YeUJBjXdeAkE+P9OQJm6SZnn1svcduI78dYmbkE2mtziPrcjVisXG78spLvbZaSFx/Rks9zP4LKn0Cdz/3JsetkT06A8f/yCgMO6Mb1Hme0JJ7b2wZz1qleqTuKBGokhPVUZ0dVu+tnQYNEY1fmkZSz6+EGZ5EzL7657mreZGR3jUfaEk458PDniBzsSmBKhDRzfXameryJv9/D5m6HIqZ0R+ouCE54Dzp4IJuuD1e4Dc5i+PpSORJfG23uVgqixAMDvchMR0nZdH5brclYwRoJRWv/rlxGRI5ffD5NPGmIDt7vDE1434pYdVZIFh89Bs94HGGJbTwrN8T6lh1HZFTOB4lWzWj6EVqxSMvC0/ljWBQ3F2kc/mO2b6tWonT2JEqEwFts8rz2h+oWNds9ceR2cb7zZvJTDppHaEhK5avWqsseWa2Dt5BBhabdWSktS80oMQrL4TvAM9b5HMmyDnO+OkkbMXfUJG7eXqTIG6lqSOEbqVR+qYdP7uWb57WEJqzyh411GAVsDinPs7KvUeXItlcMdOUWzXBH6zscymV1LLVCtc8IePojzXHF9m5b5zGwBRdzcyUJkiu938ApmAayRdJrX1PmVguWUvt2ThQ62czItTyWJMW2An/hdDfMK7SiFQlGIdAbltHz3ycoh7j9V7GxNWBpbtcSdqm4XxRwTawc3cbZ+xfSv9qQfEkDKfZTwCkqWGI/ur250ItXlMlh6vUNWEYIg9A3GzbgmbqvTN8js2YMo87CU5y6nZ4dbJLDQJj9fc7yM7tZzJDZFtqOcU8+mZjYlq4VmifI23iHb1ZoT9E+kT2dolnP1AfiOkt7PQCSykBiXy5mv637IegWSKj9IKrYZf4Lu9+I7ub+mkRdlvYzehh/jaJ9n7HUH5b2IbgeNdkY7wx1yVzxS7pbvky6+nmVUtRllEFfweUQ0/nG017WoUYSxs+j2B4FV/F62EtHlMWZXYrjGHpthnNb1x66LKZ0Qe92INWHdfR/vqp02wMS8r1G4dJqHok8KmQ7947G13a4YXbsGgHcBvRuVu1eAi4/A5+ZixmdSXM73LupB/LH7O9yxLTVXJTyBbI1S49TIROrfVCOb/czZ9pM4JsZx8kUz8dQGv7gUWKxXvTH7QM/3J2OuXXgciUhqY+cgtaOliQQVOYthBLV3xpESZT3rmfEYNZxmpBbb24CRao86prn+i9TNOh8VxRJGXJfXHATJHs1T5txgc/opYrY8XjlGQQbRcoxIBcnVsMjmU1ymmIUL4dviJXndMAJ0Yet+c7O52/p98ytlmAsGBaTAmMhimAnvp1TWNGM9BpuitGj+t810CU2UhorrjPKGtThVC8WaXw04WFnT5fTjqmPyrQ0tN3CkLsctVy2xr0ZWgiWVZ1OrlFjjxJYsOiZv2cAoOvE+7sY0I/TwWcZqMoyIKNOftwP7w++Rfg67ljfovKYa50if3fzE/8aPYVey/Nq35+nH2sLPh/fP5TsylSKGOZ4k69d2PnH43+kq++sRXHQqGArWdwhx+hpwQC6JgT2uxehYU4Zbw7oNb6/HLikPyJROGK2ouyr+vzseESp9G50T4AyFrSqOQ0rroCYP4sMDFBrHn342EyZTMlSyk47rHSq89Y9/nI3zG5lX16Z5lxphguLOcZUndL8wNcrkyjH82jqg8Bo8OYkynrxZvbFno5lUS3OPr8Ko3mX9NoRPdYOKKjD07bvgFgpZ/RF+YzkWvJ/Hs/tUbfeGzGWLxNAjfDzHHMVSDwB5SabQLsIZHiBp43FjGkaienYoDd18hu2BGwOK7U3o70K/WY/kuuKdmdrykIBUdG2mvE91L1JtTbh20mOLbk1vCAamu7utlXeGU2ooVikbU/actcgmsC1FKk2qmj3GWeIWbj4tGIxE7BLcBWUvvcnd/lYxsMV4F917fWeFB/XbINN3qGvIyTpCalz1lVewdIGqeAS/gB8Mi+sA+BqDiX3VGD2eUunTRbSY+AuDy4E3Qx3hAhwnSXX+B0zuj3eQ1miS8Vux2z/l6/BkWtjKGU72aJkOCWhGcSf3+kFkkB15vGOsQrSdFr6qTj0gBYiOlnBO41170gOWHSUoBVRU2JjwppYdhIFDfu7tIRHccSNM5KZOFDPz0TGMAjzzEpeLwTWp+kn201kU6NjbiMQJx83+LX1e1tZ10kuChJZ/XBUQ1dwaBHjTDJDqOympEk8X2M3VtVw21JksChA8w1tTefO3RJ1FMbqZ01bHHkudDB/OhLfe7P5GOHaI28ZXKTMuqo0hLWQ4HabBsGG7NbP1RiXtETz074er6w/OerJWEqjmkq2y51q1BVI+JUudnVa3ogBpzdhFE7fC7kybrAt2Z6RqDjATAUEYeYK45WMupBKQRtQlU+uNsjnzj6ZmGrezA+ASrWxQ6LMkHRXqXwNq7ftv28dUx/ZSJciDXP2SWJsWaN0FjPX9Yko6LobZ7aYW/IdUktI9apTLyHS8DyWPyuoZyxN1TK/vtfxk3HwWh6JczZC8Ftn0bIJay2g+n5wd7lm9rEsKO+svqVmi+c1j88hSCxbzrg4+HEP0Nt1/B6YW1XVm09T1CpAKjc9n18hjqsaFGdfyva1ZG0Xu3ip6N6JGpyTSqY5h4BOlpLPaOnyw45PdXTN+DtAKg7DLrLFTnWusoSBHk3s0d7YouJHq85/R09Tfc37ENXZF48eAYLnq9GLioNcwDZrC6FW6godB8JnqYUPvn0pWLfQz0lM0Yy8Mybgn84Ds3Q9bDP10bLyOV+qzxa4Rd9Dhu7cju8mMaONXK3UqmBQ9qIg7etIwEqM/kECk/Dzja4Bs1xR+Q/tCbc8IKrSGsTdJJ0vge7IG20W687uVmK6icWQ6cD3lwFzgNMGtFvO5qyJeKflGLAAcQZOrkxVwy3cWvqlGpvjmf9Qe6Ap20MPbV92DPV0OhFM4kz8Yr0ffC2zLWSQ1kqY6QdQrttR3kh1YLtQd1kCEv5hVoPIRWl5ERcUTttBIrWp6Xs5Ehh5OUUwI5aEBvuiDmUoENmnVw1FohCrbRp1A1E+XSlWVOTi7ADW+5Ohb9z1vK4qx5R5lPdGCPBJZ00mC+Ssp8VUbgpGAvXWMuWQQRbCqI6Rr2jtxZxtfP7W/8onz+yz0Gs76LaT5HX9ecyiZCB/ZR/gFtMxPsDwohoeCRtiuLxE1GM1vUEUgBv86+eehL58/P56QFGQ/MqOe/vC76L63jzmeax4exd/OKTUvkXg+fOJUHych9xt/9goJMrapSgvXrj8+8vk/N80f22Sewj6cyGqt1B6mztoeklVHHraouhvHJaG/OuBz6DHKMpFmQULU1bRWlyYE0RPXYYkUycIemN7TLtgNCJX6BqdyxDKkegO7nJK5xQ7OVYDZTMf9bVHidtk6DQX9Et+V9M7esgbsYBdEeUpsB0Xvw2kd9+rI7V+m47u+O/tq7mw7262HU1WlS9uFzsV6JxIHNmUCy0QS9e077JGRFbG65z3/dOKB/Zk+yDdKpUmdXjn/aS3N5nv4fK7bMHHmPlHd4E2+iTbV5rpzScRnxk6KARuDTJ8Q1LpK2mP8gj1EbuJ9RIyY+EWK4hCiIDBAS1Tm2IEXAFfgKPgdL9O6mAa06wjCcUAL6EsxPQWO9VNegBPm/0GgkZbDxCynxujX/92vmGcjZRMAY45puak2sFLCLSwXpEsyy5fnF0jGJBhm+fNSHKKUUfy+276A7/feLOFxxUuHRNJI2Osenxyvf8DAGObT60pfTTlhEg9u/KKkhJqm5U1/+BEcSkpFDA5XeCqxwXmPac1jcuZ3JWQ+p0NdWzb/5v1ZvF8GtMTFFEdQjpLO0bwPb0BHNWnip3liDXI2fXf05jjvfJ0NpjLCUgfTh9CMFYVFKEd4Z/OG/2C+N435mnK+9t1gvCiVcaaH7rK4+PjCvpVNiz+t2QyqH1O8x3JKZVl6Q+Lp/XK8wMjVMslOq9FdSw5FtUs/CptXH9PW+wbWHgrV17R5jTVOtGtKFu3nb80T+E0tv9QkzW3J2dbaw/8ddAKZ0pxIaEqLjlPrji3VgJ3GvdFvlqD8075woxh4fVt0JZE0KVFsAvqhe0dqN9b35jtSpnYMXkU+vZq+IAHad3IHc2s/LYrnD1anfG46IFiMIr9oNbZDWvwthqYNqOigaKd/XlLU4XHfk/PXIjPsLy/9/kAtQ+/wKH+hI/IROWj5FPvTZAT9f7j4ZXQyG4M0TujMAFXYkKvEHv1xhySekgXGGqNxWeWKlf8dDAlLuB1cb/qOD+rk7cmwt+1yKpk9cudqBanTi6zTbXRtV8qylNtjyOVKy1HTz0GW9rjt6sSjAZcT5R+KdtyYb0zyqG9pSLuCw5WBwAn7fjBjKLLoxLXMI+52L9cLwIR2B6OllJZLHJ8vDxmWdtF+QJnmt1rsHPIWY20lftk8fYePkAIg6Hgn532QoIpegMxiWgAOfe5/U44APR8Ac0NeZrVh3gEhs12W+tVSiWiUQekf/YBECUy5fdYbA08dd7VzPAP9aiVcIB9k6tY7WdJ1wNV+bHeydNtmC6G5ICtFC1ZwmJU/j8hf0I8TRVKSiz5oYIa93EpUI78X8GYIAZabx47/n8LDAAJ0nNtP1rpROprqKMBRecShca6qXuTSI3jZBLOB3Vp381B5rCGhjSvh/NSVkYp2qIdP/Bg=";
          },
          8712: (xe, V, a) => {
            var A = a(9017);
            (V.init = function () {
              V.dictionary = A.init();
            }),
              (V.offsetsByLength = new Uint32Array([
                0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488,
                74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536,
                115968, 118528, 119872, 121280, 122016,
              ])),
              (V.sizeBitsByLength = new Uint8Array([
                0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7,
                8, 7, 7, 6, 6, 5, 5,
              ])),
              (V.minDictionaryWordLength = 4),
              (V.maxDictionaryWordLength = 24);
          },
          8171: (xe, V) => {
            function a(d, h) {
              (this.bits = d), (this.value = h);
            }
            V.z = a;
            var A = 15;
            function x(d, h) {
              for (var f = 1 << (h - 1); d & f; ) f >>= 1;
              return (d & (f - 1)) + f;
            }
            function y(d, h, f, s, l) {
              do (s -= f), (d[h + s] = new a(l.bits, l.value));
              while (s > 0);
            }
            function c(d, h, f) {
              for (var s = 1 << (h - f); h < A && ((s -= d[h]), !(s <= 0)); )
                ++h, (s <<= 1);
              return h - f;
            }
            V.u = function (d, h, f, s, l) {
              var n = h,
                o,
                i,
                e,
                t,
                r,
                u,
                v,
                _,
                m,
                g,
                T,
                E = new Int32Array(A + 1),
                M = new Int32Array(A + 1);
              for (T = new Int32Array(l), e = 0; e < l; e++) E[s[e]]++;
              for (M[1] = 0, i = 1; i < A; i++) M[i + 1] = M[i] + E[i];
              for (e = 0; e < l; e++) s[e] !== 0 && (T[M[s[e]]++] = e);
              if (((_ = f), (m = 1 << _), (g = m), M[A] === 1)) {
                for (t = 0; t < g; ++t) d[h + t] = new a(0, T[0] & 65535);
                return g;
              }
              for (t = 0, e = 0, i = 1, r = 2; i <= f; ++i, r <<= 1)
                for (; E[i] > 0; --E[i])
                  (o = new a(i & 255, T[e++] & 65535)),
                    y(d, h + t, r, m, o),
                    (t = x(t, i));
              for (v = g - 1, u = -1, i = f + 1, r = 2; i <= A; ++i, r <<= 1)
                for (; E[i] > 0; --E[i])
                  (t & v) !== u &&
                    ((h += m),
                    (_ = c(E, i, f)),
                    (m = 1 << _),
                    (g += m),
                    (u = t & v),
                    (d[n + u] = new a((_ + f) & 255, (h - n - u) & 65535))),
                    (o = new a((i - f) & 255, T[e++] & 65535)),
                    y(d, h + (t >> f), r, m, o),
                    (t = x(t, i));
              return g;
            };
          },
          7708: (xe, V) => {
            function a(A, x) {
              (this.offset = A), (this.nbits = x);
            }
            (V.kBlockLengthPrefixCode = [
              new a(1, 2),
              new a(5, 2),
              new a(9, 2),
              new a(13, 2),
              new a(17, 3),
              new a(25, 3),
              new a(33, 3),
              new a(41, 3),
              new a(49, 4),
              new a(65, 4),
              new a(81, 4),
              new a(97, 4),
              new a(113, 5),
              new a(145, 5),
              new a(177, 5),
              new a(209, 5),
              new a(241, 6),
              new a(305, 6),
              new a(369, 7),
              new a(497, 8),
              new a(753, 9),
              new a(1265, 10),
              new a(2289, 11),
              new a(4337, 12),
              new a(8433, 13),
              new a(16625, 24),
            ]),
              (V.kInsertLengthPrefixCode = [
                new a(0, 0),
                new a(1, 0),
                new a(2, 0),
                new a(3, 0),
                new a(4, 0),
                new a(5, 0),
                new a(6, 1),
                new a(8, 1),
                new a(10, 2),
                new a(14, 2),
                new a(18, 3),
                new a(26, 3),
                new a(34, 4),
                new a(50, 4),
                new a(66, 5),
                new a(98, 5),
                new a(130, 6),
                new a(194, 7),
                new a(322, 8),
                new a(578, 9),
                new a(1090, 10),
                new a(2114, 12),
                new a(6210, 14),
                new a(22594, 24),
              ]),
              (V.kCopyLengthPrefixCode = [
                new a(2, 0),
                new a(3, 0),
                new a(4, 0),
                new a(5, 0),
                new a(6, 0),
                new a(7, 0),
                new a(8, 0),
                new a(9, 0),
                new a(10, 1),
                new a(12, 1),
                new a(14, 2),
                new a(18, 2),
                new a(22, 3),
                new a(30, 3),
                new a(38, 4),
                new a(54, 4),
                new a(70, 5),
                new a(102, 5),
                new a(134, 6),
                new a(198, 7),
                new a(326, 8),
                new a(582, 9),
                new a(1094, 10),
                new a(2118, 24),
              ]),
              (V.kInsertRangeLut = [0, 0, 8, 8, 0, 16, 8, 16, 16]),
              (V.kCopyRangeLut = [0, 8, 0, 8, 16, 0, 16, 8, 16]);
          },
          4927: (xe, V) => {
            function a(x) {
              (this.buffer = x), (this.pos = 0);
            }
            (a.prototype.read = function (x, y, c) {
              this.pos + c > this.buffer.length &&
                (c = this.buffer.length - this.pos);
              for (var d = 0; d < c; d++) x[y + d] = this.buffer[this.pos + d];
              return (this.pos += c), c;
            }),
              (V.z = a);
            function A(x) {
              (this.buffer = x), (this.pos = 0);
            }
            (A.prototype.write = function (x, y) {
              if (this.pos + y > this.buffer.length)
                throw new Error("Output buffer is not large enough");
              return (
                this.buffer.set(x.subarray(0, y), this.pos), (this.pos += y), y
              );
            }),
              (V.y = A);
          },
          8270: (xe, V, a) => {
            var A = a(8712),
              x = 0,
              y = 1,
              c = 2,
              d = 3,
              h = 4,
              f = 5,
              s = 6,
              l = 7,
              n = 8,
              o = 9,
              i = 10,
              e = 11,
              t = 12,
              r = 13,
              u = 14,
              v = 15,
              _ = 16,
              m = 17,
              g = 18,
              T = 19,
              E = 20;
            function M(F, b, D) {
              (this.prefix = new Uint8Array(F.length)),
                (this.transform = b),
                (this.suffix = new Uint8Array(D.length));
              for (var G = 0; G < F.length; G++)
                this.prefix[G] = F.charCodeAt(G);
              for (var G = 0; G < D.length; G++)
                this.suffix[G] = D.charCodeAt(G);
            }
            var R = [
              new M("", x, ""),
              new M("", x, " "),
              new M(" ", x, " "),
              new M("", t, ""),
              new M("", i, " "),
              new M("", x, " the "),
              new M(" ", x, ""),
              new M("s ", x, " "),
              new M("", x, " of "),
              new M("", i, ""),
              new M("", x, " and "),
              new M("", r, ""),
              new M("", y, ""),
              new M(", ", x, " "),
              new M("", x, ", "),
              new M(" ", i, " "),
              new M("", x, " in "),
              new M("", x, " to "),
              new M("e ", x, " "),
              new M("", x, '"'),
              new M("", x, "."),
              new M("", x, '">'),
              new M(
                "",
                x,
                `
`
              ),
              new M("", d, ""),
              new M("", x, "]"),
              new M("", x, " for "),
              new M("", u, ""),
              new M("", c, ""),
              new M("", x, " a "),
              new M("", x, " that "),
              new M(" ", i, ""),
              new M("", x, ". "),
              new M(".", x, ""),
              new M(" ", x, ", "),
              new M("", v, ""),
              new M("", x, " with "),
              new M("", x, "'"),
              new M("", x, " from "),
              new M("", x, " by "),
              new M("", _, ""),
              new M("", m, ""),
              new M(" the ", x, ""),
              new M("", h, ""),
              new M("", x, ". The "),
              new M("", e, ""),
              new M("", x, " on "),
              new M("", x, " as "),
              new M("", x, " is "),
              new M("", l, ""),
              new M("", y, "ing "),
              new M(
                "",
                x,
                `
	`
              ),
              new M("", x, ":"),
              new M(" ", x, ". "),
              new M("", x, "ed "),
              new M("", E, ""),
              new M("", g, ""),
              new M("", s, ""),
              new M("", x, "("),
              new M("", i, ", "),
              new M("", n, ""),
              new M("", x, " at "),
              new M("", x, "ly "),
              new M(" the ", x, " of "),
              new M("", f, ""),
              new M("", o, ""),
              new M(" ", i, ", "),
              new M("", i, '"'),
              new M(".", x, "("),
              new M("", e, " "),
              new M("", i, '">'),
              new M("", x, '="'),
              new M(" ", x, "."),
              new M(".com/", x, ""),
              new M(" the ", x, " of the "),
              new M("", i, "'"),
              new M("", x, ". This "),
              new M("", x, ","),
              new M(".", x, " "),
              new M("", i, "("),
              new M("", i, "."),
              new M("", x, " not "),
              new M(" ", x, '="'),
              new M("", x, "er "),
              new M(" ", e, " "),
              new M("", x, "al "),
              new M(" ", e, ""),
              new M("", x, "='"),
              new M("", e, '"'),
              new M("", i, ". "),
              new M(" ", x, "("),
              new M("", x, "ful "),
              new M(" ", i, ". "),
              new M("", x, "ive "),
              new M("", x, "less "),
              new M("", e, "'"),
              new M("", x, "est "),
              new M(" ", i, "."),
              new M("", e, '">'),
              new M(" ", x, "='"),
              new M("", i, ","),
              new M("", x, "ize "),
              new M("", e, "."),
              new M("\xC2\xA0", x, ""),
              new M(" ", x, ","),
              new M("", i, '="'),
              new M("", e, '="'),
              new M("", x, "ous "),
              new M("", e, ", "),
              new M("", i, "='"),
              new M(" ", i, ","),
              new M(" ", e, '="'),
              new M(" ", e, ", "),
              new M("", e, ","),
              new M("", e, "("),
              new M("", e, ". "),
              new M(" ", e, "."),
              new M("", e, "='"),
              new M(" ", e, ". "),
              new M(" ", i, '="'),
              new M(" ", e, "='"),
              new M(" ", i, "='"),
            ];
            (V.kTransforms = R), (V.kNumTransforms = R.length);
            function P(F, b) {
              return F[b] < 192
                ? (F[b] >= 97 && F[b] <= 122 && (F[b] ^= 32), 1)
                : F[b] < 224
                ? ((F[b + 1] ^= 32), 2)
                : ((F[b + 2] ^= 5), 3);
            }
            V.transformDictionaryWord = function (F, b, D, G, X) {
              var ie = R[X].prefix,
                Q = R[X].suffix,
                te = R[X].transform,
                ae = te < t ? 0 : te - (t - 1),
                Z = 0,
                J = b,
                ve;
              ae > G && (ae = G);
              for (var _e = 0; _e < ie.length; ) F[b++] = ie[_e++];
              for (D += ae, G -= ae, te <= o && (G -= te), Z = 0; Z < G; Z++)
                F[b++] = A.dictionary[D + Z];
              if (((ve = b - G), te === i)) P(F, ve);
              else if (te === e)
                for (; G > 0; ) {
                  var L = P(F, ve);
                  (ve += L), (G -= L);
                }
              for (var ge = 0; ge < Q.length; ) F[b++] = Q[ge++];
              return b - J;
            };
          },
          8287: (xe, V, a) => {
            "use strict";
            var A;
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */ const x = a(7526),
              y = a(251),
              c =
                typeof Symbol == "function" && typeof Symbol.for == "function"
                  ? Symbol.for("nodejs.util.inspect.custom")
                  : null;
            (V.hp = s), (A = m), (V.IS = 50);
            const d = 2147483647;
            (A = d),
              (s.TYPED_ARRAY_SUPPORT = h()),
              !s.TYPED_ARRAY_SUPPORT &&
                typeof console != "undefined" &&
                typeof console.error == "function" &&
                console.error(
                  "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
                );
            function h() {
              try {
                const me = new Uint8Array(1),
                  z = {
                    foo: function () {
                      return 42;
                    },
                  };
                return (
                  Object.setPrototypeOf(z, Uint8Array.prototype),
                  Object.setPrototypeOf(me, z),
                  me.foo() === 42
                );
              } catch (me) {
                return !1;
              }
            }
            Object.defineProperty(s.prototype, "parent", {
              enumerable: !0,
              get: function () {
                if (s.isBuffer(this)) return this.buffer;
              },
            }),
              Object.defineProperty(s.prototype, "offset", {
                enumerable: !0,
                get: function () {
                  if (s.isBuffer(this)) return this.byteOffset;
                },
              });
            function f(me) {
              if (me > d)
                throw new RangeError(
                  'The value "' + me + '" is invalid for option "size"'
                );
              const z = new Uint8Array(me);
              return Object.setPrototypeOf(z, s.prototype), z;
            }
            function s(me, z, K) {
              if (typeof me == "number") {
                if (typeof z == "string")
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                return i(me);
              }
              return l(me, z, K);
            }
            s.poolSize = 8192;
            function l(me, z, K) {
              if (typeof me == "string") return e(me, z);
              if (ArrayBuffer.isView(me)) return r(me);
              if (me == null)
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                    typeof me
                );
              if (
                Ae(me, ArrayBuffer) ||
                (me && Ae(me.buffer, ArrayBuffer)) ||
                (typeof SharedArrayBuffer != "undefined" &&
                  (Ae(me, SharedArrayBuffer) ||
                    (me && Ae(me.buffer, SharedArrayBuffer))))
              )
                return u(me, z, K);
              if (typeof me == "number")
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              const Te = me.valueOf && me.valueOf();
              if (Te != null && Te !== me) return s.from(Te, z, K);
              const H = v(me);
              if (H) return H;
              if (
                typeof Symbol != "undefined" &&
                Symbol.toPrimitive != null &&
                typeof me[Symbol.toPrimitive] == "function"
              )
                return s.from(me[Symbol.toPrimitive]("string"), z, K);
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                  typeof me
              );
            }
            (s.from = function (me, z, K) {
              return l(me, z, K);
            }),
              Object.setPrototypeOf(s.prototype, Uint8Array.prototype),
              Object.setPrototypeOf(s, Uint8Array);
            function n(me) {
              if (typeof me != "number")
                throw new TypeError('"size" argument must be of type number');
              if (me < 0)
                throw new RangeError(
                  'The value "' + me + '" is invalid for option "size"'
                );
            }
            function o(me, z, K) {
              return (
                n(me),
                me <= 0
                  ? f(me)
                  : z !== void 0
                  ? typeof K == "string"
                    ? f(me).fill(z, K)
                    : f(me).fill(z)
                  : f(me)
              );
            }
            s.alloc = function (me, z, K) {
              return o(me, z, K);
            };
            function i(me) {
              return n(me), f(me < 0 ? 0 : _(me) | 0);
            }
            (s.allocUnsafe = function (me) {
              return i(me);
            }),
              (s.allocUnsafeSlow = function (me) {
                return i(me);
              });
            function e(me, z) {
              if (
                ((typeof z != "string" || z === "") && (z = "utf8"),
                !s.isEncoding(z))
              )
                throw new TypeError("Unknown encoding: " + z);
              const K = g(me, z) | 0;
              let Te = f(K);
              const H = Te.write(me, z);
              return H !== K && (Te = Te.slice(0, H)), Te;
            }
            function t(me) {
              const z = me.length < 0 ? 0 : _(me.length) | 0,
                K = f(z);
              for (let Te = 0; Te < z; Te += 1) K[Te] = me[Te] & 255;
              return K;
            }
            function r(me) {
              if (Ae(me, Uint8Array)) {
                const z = new Uint8Array(me);
                return u(z.buffer, z.byteOffset, z.byteLength);
              }
              return t(me);
            }
            function u(me, z, K) {
              if (z < 0 || me.byteLength < z)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (me.byteLength < z + (K || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              let Te;
              return (
                z === void 0 && K === void 0
                  ? (Te = new Uint8Array(me))
                  : K === void 0
                  ? (Te = new Uint8Array(me, z))
                  : (Te = new Uint8Array(me, z, K)),
                Object.setPrototypeOf(Te, s.prototype),
                Te
              );
            }
            function v(me) {
              if (s.isBuffer(me)) {
                const z = _(me.length) | 0,
                  K = f(z);
                return K.length === 0 || me.copy(K, 0, 0, z), K;
              }
              if (me.length !== void 0)
                return typeof me.length != "number" || ke(me.length)
                  ? f(0)
                  : t(me);
              if (me.type === "Buffer" && Array.isArray(me.data))
                return t(me.data);
            }
            function _(me) {
              if (me >= d)
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum size: 0x" +
                    d.toString(16) +
                    " bytes"
                );
              return me | 0;
            }
            function m(me) {
              return +me != me && (me = 0), s.alloc(+me);
            }
            (s.isBuffer = function (z) {
              return z != null && z._isBuffer === !0 && z !== s.prototype;
            }),
              (s.compare = function (z, K) {
                if (
                  (Ae(z, Uint8Array) && (z = s.from(z, z.offset, z.byteLength)),
                  Ae(K, Uint8Array) && (K = s.from(K, K.offset, K.byteLength)),
                  !s.isBuffer(z) || !s.isBuffer(K))
                )
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  );
                if (z === K) return 0;
                let Te = z.length,
                  H = K.length;
                for (let q = 0, se = Math.min(Te, H); q < se; ++q)
                  if (z[q] !== K[q]) {
                    (Te = z[q]), (H = K[q]);
                    break;
                  }
                return Te < H ? -1 : H < Te ? 1 : 0;
              }),
              (s.isEncoding = function (z) {
                switch (String(z).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return !0;
                  default:
                    return !1;
                }
              }),
              (s.concat = function (z, K) {
                if (!Array.isArray(z))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                if (z.length === 0) return s.alloc(0);
                let Te;
                if (K === void 0)
                  for (K = 0, Te = 0; Te < z.length; ++Te) K += z[Te].length;
                const H = s.allocUnsafe(K);
                let q = 0;
                for (Te = 0; Te < z.length; ++Te) {
                  let se = z[Te];
                  if (Ae(se, Uint8Array))
                    q + se.length > H.length
                      ? (s.isBuffer(se) || (se = s.from(se)), se.copy(H, q))
                      : Uint8Array.prototype.set.call(H, se, q);
                  else if (s.isBuffer(se)) se.copy(H, q);
                  else
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers'
                    );
                  q += se.length;
                }
                return H;
              });
            function g(me, z) {
              if (s.isBuffer(me)) return me.length;
              if (ArrayBuffer.isView(me) || Ae(me, ArrayBuffer))
                return me.byteLength;
              if (typeof me != "string")
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                    typeof me
                );
              const K = me.length,
                Te = arguments.length > 2 && arguments[2] === !0;
              if (!Te && K === 0) return 0;
              let H = !1;
              for (;;)
                switch (z) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return K;
                  case "utf8":
                  case "utf-8":
                    return W(me).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return K * 2;
                  case "hex":
                    return K >>> 1;
                  case "base64":
                    return ye(me).length;
                  default:
                    if (H) return Te ? -1 : W(me).length;
                    (z = ("" + z).toLowerCase()), (H = !0);
                }
            }
            s.byteLength = g;
            function T(me, z, K) {
              let Te = !1;
              if (
                ((z === void 0 || z < 0) && (z = 0),
                z > this.length ||
                  ((K === void 0 || K > this.length) && (K = this.length),
                  K <= 0) ||
                  ((K >>>= 0), (z >>>= 0), K <= z))
              )
                return "";
              for (me || (me = "utf8"); ; )
                switch (me) {
                  case "hex":
                    return J(this, z, K);
                  case "utf8":
                  case "utf-8":
                    return ie(this, z, K);
                  case "ascii":
                    return ae(this, z, K);
                  case "latin1":
                  case "binary":
                    return Z(this, z, K);
                  case "base64":
                    return X(this, z, K);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ve(this, z, K);
                  default:
                    if (Te) throw new TypeError("Unknown encoding: " + me);
                    (me = (me + "").toLowerCase()), (Te = !0);
                }
            }
            s.prototype._isBuffer = !0;
            function E(me, z, K) {
              const Te = me[z];
              (me[z] = me[K]), (me[K] = Te);
            }
            (s.prototype.swap16 = function () {
              const z = this.length;
              if (z % 2 !== 0)
                throw new RangeError(
                  "Buffer size must be a multiple of 16-bits"
                );
              for (let K = 0; K < z; K += 2) E(this, K, K + 1);
              return this;
            }),
              (s.prototype.swap32 = function () {
                const z = this.length;
                if (z % 4 !== 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 32-bits"
                  );
                for (let K = 0; K < z; K += 4)
                  E(this, K, K + 3), E(this, K + 1, K + 2);
                return this;
              }),
              (s.prototype.swap64 = function () {
                const z = this.length;
                if (z % 8 !== 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 64-bits"
                  );
                for (let K = 0; K < z; K += 8)
                  E(this, K, K + 7),
                    E(this, K + 1, K + 6),
                    E(this, K + 2, K + 5),
                    E(this, K + 3, K + 4);
                return this;
              }),
              (s.prototype.toString = function () {
                const z = this.length;
                return z === 0
                  ? ""
                  : arguments.length === 0
                  ? ie(this, 0, z)
                  : T.apply(this, arguments);
              }),
              (s.prototype.toLocaleString = s.prototype.toString),
              (s.prototype.equals = function (z) {
                if (!s.isBuffer(z))
                  throw new TypeError("Argument must be a Buffer");
                return this === z ? !0 : s.compare(this, z) === 0;
              }),
              (s.prototype.inspect = function () {
                let z = "";
                const K = V.IS;
                return (
                  (z = this.toString("hex", 0, K)
                    .replace(/(.{2})/g, "$1 ")
                    .trim()),
                  this.length > K && (z += " ... "),
                  "<Buffer " + z + ">"
                );
              }),
              c && (s.prototype[c] = s.prototype.inspect),
              (s.prototype.compare = function (z, K, Te, H, q) {
                if (
                  (Ae(z, Uint8Array) && (z = s.from(z, z.offset, z.byteLength)),
                  !s.isBuffer(z))
                )
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                      typeof z
                  );
                if (
                  (K === void 0 && (K = 0),
                  Te === void 0 && (Te = z ? z.length : 0),
                  H === void 0 && (H = 0),
                  q === void 0 && (q = this.length),
                  K < 0 || Te > z.length || H < 0 || q > this.length)
                )
                  throw new RangeError("out of range index");
                if (H >= q && K >= Te) return 0;
                if (H >= q) return -1;
                if (K >= Te) return 1;
                if (
                  ((K >>>= 0), (Te >>>= 0), (H >>>= 0), (q >>>= 0), this === z)
                )
                  return 0;
                let se = q - H,
                  Ce = Te - K;
                const we = Math.min(se, Ce),
                  Me = this.slice(H, q),
                  Ie = z.slice(K, Te);
                for (let Le = 0; Le < we; ++Le)
                  if (Me[Le] !== Ie[Le]) {
                    (se = Me[Le]), (Ce = Ie[Le]);
                    break;
                  }
                return se < Ce ? -1 : Ce < se ? 1 : 0;
              });
            function M(me, z, K, Te, H) {
              if (me.length === 0) return -1;
              if (
                (typeof K == "string"
                  ? ((Te = K), (K = 0))
                  : K > 2147483647
                  ? (K = 2147483647)
                  : K < -2147483648 && (K = -2147483648),
                (K = +K),
                ke(K) && (K = H ? 0 : me.length - 1),
                K < 0 && (K = me.length + K),
                K >= me.length)
              ) {
                if (H) return -1;
                K = me.length - 1;
              } else if (K < 0)
                if (H) K = 0;
                else return -1;
              if ((typeof z == "string" && (z = s.from(z, Te)), s.isBuffer(z)))
                return z.length === 0 ? -1 : R(me, z, K, Te, H);
              if (typeof z == "number")
                return (
                  (z = z & 255),
                  typeof Uint8Array.prototype.indexOf == "function"
                    ? H
                      ? Uint8Array.prototype.indexOf.call(me, z, K)
                      : Uint8Array.prototype.lastIndexOf.call(me, z, K)
                    : R(me, [z], K, Te, H)
                );
              throw new TypeError("val must be string, number or Buffer");
            }
            function R(me, z, K, Te, H) {
              let q = 1,
                se = me.length,
                Ce = z.length;
              if (
                Te !== void 0 &&
                ((Te = String(Te).toLowerCase()),
                Te === "ucs2" ||
                  Te === "ucs-2" ||
                  Te === "utf16le" ||
                  Te === "utf-16le")
              ) {
                if (me.length < 2 || z.length < 2) return -1;
                (q = 2), (se /= 2), (Ce /= 2), (K /= 2);
              }
              function we(Ie, Le) {
                return q === 1 ? Ie[Le] : Ie.readUInt16BE(Le * q);
              }
              let Me;
              if (H) {
                let Ie = -1;
                for (Me = K; Me < se; Me++)
                  if (we(me, Me) === we(z, Ie === -1 ? 0 : Me - Ie)) {
                    if ((Ie === -1 && (Ie = Me), Me - Ie + 1 === Ce))
                      return Ie * q;
                  } else Ie !== -1 && (Me -= Me - Ie), (Ie = -1);
              } else
                for (K + Ce > se && (K = se - Ce), Me = K; Me >= 0; Me--) {
                  let Ie = !0;
                  for (let Le = 0; Le < Ce; Le++)
                    if (we(me, Me + Le) !== we(z, Le)) {
                      Ie = !1;
                      break;
                    }
                  if (Ie) return Me;
                }
              return -1;
            }
            (s.prototype.includes = function (z, K, Te) {
              return this.indexOf(z, K, Te) !== -1;
            }),
              (s.prototype.indexOf = function (z, K, Te) {
                return M(this, z, K, Te, !0);
              }),
              (s.prototype.lastIndexOf = function (z, K, Te) {
                return M(this, z, K, Te, !1);
              });
            function P(me, z, K, Te) {
              K = Number(K) || 0;
              const H = me.length - K;
              Te ? ((Te = Number(Te)), Te > H && (Te = H)) : (Te = H);
              const q = z.length;
              Te > q / 2 && (Te = q / 2);
              let se;
              for (se = 0; se < Te; ++se) {
                const Ce = parseInt(z.substr(se * 2, 2), 16);
                if (ke(Ce)) return se;
                me[K + se] = Ce;
              }
              return se;
            }
            function F(me, z, K, Te) {
              return Oe(W(z, me.length - K), me, K, Te);
            }
            function b(me, z, K, Te) {
              return Oe(he(z), me, K, Te);
            }
            function D(me, z, K, Te) {
              return Oe(ye(z), me, K, Te);
            }
            function G(me, z, K, Te) {
              return Oe(ue(z, me.length - K), me, K, Te);
            }
            (s.prototype.write = function (z, K, Te, H) {
              if (K === void 0) (H = "utf8"), (Te = this.length), (K = 0);
              else if (Te === void 0 && typeof K == "string")
                (H = K), (Te = this.length), (K = 0);
              else if (isFinite(K))
                (K = K >>> 0),
                  isFinite(Te)
                    ? ((Te = Te >>> 0), H === void 0 && (H = "utf8"))
                    : ((H = Te), (Te = void 0));
              else
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              const q = this.length - K;
              if (
                ((Te === void 0 || Te > q) && (Te = q),
                (z.length > 0 && (Te < 0 || K < 0)) || K > this.length)
              )
                throw new RangeError("Attempt to write outside buffer bounds");
              H || (H = "utf8");
              let se = !1;
              for (;;)
                switch (H) {
                  case "hex":
                    return P(this, z, K, Te);
                  case "utf8":
                  case "utf-8":
                    return F(this, z, K, Te);
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return b(this, z, K, Te);
                  case "base64":
                    return D(this, z, K, Te);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return G(this, z, K, Te);
                  default:
                    if (se) throw new TypeError("Unknown encoding: " + H);
                    (H = ("" + H).toLowerCase()), (se = !0);
                }
            }),
              (s.prototype.toJSON = function () {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0),
                };
              });
            function X(me, z, K) {
              return z === 0 && K === me.length
                ? x.fromByteArray(me)
                : x.fromByteArray(me.slice(z, K));
            }
            function ie(me, z, K) {
              K = Math.min(me.length, K);
              const Te = [];
              let H = z;
              for (; H < K; ) {
                const q = me[H];
                let se = null,
                  Ce = q > 239 ? 4 : q > 223 ? 3 : q > 191 ? 2 : 1;
                if (H + Ce <= K) {
                  let we, Me, Ie, Le;
                  switch (Ce) {
                    case 1:
                      q < 128 && (se = q);
                      break;
                    case 2:
                      (we = me[H + 1]),
                        (we & 192) === 128 &&
                          ((Le = ((q & 31) << 6) | (we & 63)),
                          Le > 127 && (se = Le));
                      break;
                    case 3:
                      (we = me[H + 1]),
                        (Me = me[H + 2]),
                        (we & 192) === 128 &&
                          (Me & 192) === 128 &&
                          ((Le =
                            ((q & 15) << 12) | ((we & 63) << 6) | (Me & 63)),
                          Le > 2047 && (Le < 55296 || Le > 57343) && (se = Le));
                      break;
                    case 4:
                      (we = me[H + 1]),
                        (Me = me[H + 2]),
                        (Ie = me[H + 3]),
                        (we & 192) === 128 &&
                          (Me & 192) === 128 &&
                          (Ie & 192) === 128 &&
                          ((Le =
                            ((q & 15) << 18) |
                            ((we & 63) << 12) |
                            ((Me & 63) << 6) |
                            (Ie & 63)),
                          Le > 65535 && Le < 1114112 && (se = Le));
                  }
                }
                se === null
                  ? ((se = 65533), (Ce = 1))
                  : se > 65535 &&
                    ((se -= 65536),
                    Te.push(((se >>> 10) & 1023) | 55296),
                    (se = 56320 | (se & 1023))),
                  Te.push(se),
                  (H += Ce);
              }
              return te(Te);
            }
            const Q = 4096;
            function te(me) {
              const z = me.length;
              if (z <= Q) return String.fromCharCode.apply(String, me);
              let K = "",
                Te = 0;
              for (; Te < z; )
                K += String.fromCharCode.apply(String, me.slice(Te, (Te += Q)));
              return K;
            }
            function ae(me, z, K) {
              let Te = "";
              K = Math.min(me.length, K);
              for (let H = z; H < K; ++H)
                Te += String.fromCharCode(me[H] & 127);
              return Te;
            }
            function Z(me, z, K) {
              let Te = "";
              K = Math.min(me.length, K);
              for (let H = z; H < K; ++H) Te += String.fromCharCode(me[H]);
              return Te;
            }
            function J(me, z, K) {
              const Te = me.length;
              (!z || z < 0) && (z = 0), (!K || K < 0 || K > Te) && (K = Te);
              let H = "";
              for (let q = z; q < K; ++q) H += Ue[me[q]];
              return H;
            }
            function ve(me, z, K) {
              const Te = me.slice(z, K);
              let H = "";
              for (let q = 0; q < Te.length - 1; q += 2)
                H += String.fromCharCode(Te[q] + Te[q + 1] * 256);
              return H;
            }
            s.prototype.slice = function (z, K) {
              const Te = this.length;
              (z = ~~z),
                (K = K === void 0 ? Te : ~~K),
                z < 0 ? ((z += Te), z < 0 && (z = 0)) : z > Te && (z = Te),
                K < 0 ? ((K += Te), K < 0 && (K = 0)) : K > Te && (K = Te),
                K < z && (K = z);
              const H = this.subarray(z, K);
              return Object.setPrototypeOf(H, s.prototype), H;
            };
            function _e(me, z, K) {
              if (me % 1 !== 0 || me < 0)
                throw new RangeError("offset is not uint");
              if (me + z > K)
                throw new RangeError("Trying to access beyond buffer length");
            }
            (s.prototype.readUintLE = s.prototype.readUIntLE =
              function (z, K, Te) {
                (z = z >>> 0), (K = K >>> 0), Te || _e(z, K, this.length);
                let H = this[z],
                  q = 1,
                  se = 0;
                for (; ++se < K && (q *= 256); ) H += this[z + se] * q;
                return H;
              }),
              (s.prototype.readUintBE = s.prototype.readUIntBE =
                function (z, K, Te) {
                  (z = z >>> 0), (K = K >>> 0), Te || _e(z, K, this.length);
                  let H = this[z + --K],
                    q = 1;
                  for (; K > 0 && (q *= 256); ) H += this[z + --K] * q;
                  return H;
                }),
              (s.prototype.readUint8 = s.prototype.readUInt8 =
                function (z, K) {
                  return (z = z >>> 0), K || _e(z, 1, this.length), this[z];
                }),
              (s.prototype.readUint16LE = s.prototype.readUInt16LE =
                function (z, K) {
                  return (
                    (z = z >>> 0),
                    K || _e(z, 2, this.length),
                    this[z] | (this[z + 1] << 8)
                  );
                }),
              (s.prototype.readUint16BE = s.prototype.readUInt16BE =
                function (z, K) {
                  return (
                    (z = z >>> 0),
                    K || _e(z, 2, this.length),
                    (this[z] << 8) | this[z + 1]
                  );
                }),
              (s.prototype.readUint32LE = s.prototype.readUInt32LE =
                function (z, K) {
                  return (
                    (z = z >>> 0),
                    K || _e(z, 4, this.length),
                    (this[z] | (this[z + 1] << 8) | (this[z + 2] << 16)) +
                      this[z + 3] * 16777216
                  );
                }),
              (s.prototype.readUint32BE = s.prototype.readUInt32BE =
                function (z, K) {
                  return (
                    (z = z >>> 0),
                    K || _e(z, 4, this.length),
                    this[z] * 16777216 +
                      ((this[z + 1] << 16) | (this[z + 2] << 8) | this[z + 3])
                  );
                }),
              (s.prototype.readBigUInt64LE = Ge(function (z) {
                (z = z >>> 0), re(z, "offset");
                const K = this[z],
                  Te = this[z + 7];
                (K === void 0 || Te === void 0) && I(z, this.length - 8);
                const H =
                    K +
                    this[++z] * Rs(2, 8) +
                    this[++z] * Rs(2, 16) +
                    this[++z] * Rs(2, 24),
                  q =
                    this[++z] +
                    this[++z] * Rs(2, 8) +
                    this[++z] * Rs(2, 16) +
                    Te * Rs(2, 24);
                return BigInt(H) + (BigInt(q) << BigInt(32));
              })),
              (s.prototype.readBigUInt64BE = Ge(function (z) {
                (z = z >>> 0), re(z, "offset");
                const K = this[z],
                  Te = this[z + 7];
                (K === void 0 || Te === void 0) && I(z, this.length - 8);
                const H =
                    K * Rs(2, 24) +
                    this[++z] * Rs(2, 16) +
                    this[++z] * Rs(2, 8) +
                    this[++z],
                  q =
                    this[++z] * Rs(2, 24) +
                    this[++z] * Rs(2, 16) +
                    this[++z] * Rs(2, 8) +
                    Te;
                return (BigInt(H) << BigInt(32)) + BigInt(q);
              })),
              (s.prototype.readIntLE = function (z, K, Te) {
                (z = z >>> 0), (K = K >>> 0), Te || _e(z, K, this.length);
                let H = this[z],
                  q = 1,
                  se = 0;
                for (; ++se < K && (q *= 256); ) H += this[z + se] * q;
                return (q *= 128), H >= q && (H -= Math.pow(2, 8 * K)), H;
              }),
              (s.prototype.readIntBE = function (z, K, Te) {
                (z = z >>> 0), (K = K >>> 0), Te || _e(z, K, this.length);
                let H = K,
                  q = 1,
                  se = this[z + --H];
                for (; H > 0 && (q *= 256); ) se += this[z + --H] * q;
                return (q *= 128), se >= q && (se -= Math.pow(2, 8 * K)), se;
              }),
              (s.prototype.readInt8 = function (z, K) {
                return (
                  (z = z >>> 0),
                  K || _e(z, 1, this.length),
                  this[z] & 128 ? (255 - this[z] + 1) * -1 : this[z]
                );
              }),
              (s.prototype.readInt16LE = function (z, K) {
                (z = z >>> 0), K || _e(z, 2, this.length);
                const Te = this[z] | (this[z + 1] << 8);
                return Te & 32768 ? Te | 4294901760 : Te;
              }),
              (s.prototype.readInt16BE = function (z, K) {
                (z = z >>> 0), K || _e(z, 2, this.length);
                const Te = this[z + 1] | (this[z] << 8);
                return Te & 32768 ? Te | 4294901760 : Te;
              }),
              (s.prototype.readInt32LE = function (z, K) {
                return (
                  (z = z >>> 0),
                  K || _e(z, 4, this.length),
                  this[z] |
                    (this[z + 1] << 8) |
                    (this[z + 2] << 16) |
                    (this[z + 3] << 24)
                );
              }),
              (s.prototype.readInt32BE = function (z, K) {
                return (
                  (z = z >>> 0),
                  K || _e(z, 4, this.length),
                  (this[z] << 24) |
                    (this[z + 1] << 16) |
                    (this[z + 2] << 8) |
                    this[z + 3]
                );
              }),
              (s.prototype.readBigInt64LE = Ge(function (z) {
                (z = z >>> 0), re(z, "offset");
                const K = this[z],
                  Te = this[z + 7];
                (K === void 0 || Te === void 0) && I(z, this.length - 8);
                const H =
                  this[z + 4] +
                  this[z + 5] * Rs(2, 8) +
                  this[z + 6] * Rs(2, 16) +
                  (Te << 24);
                return (
                  (BigInt(H) << BigInt(32)) +
                  BigInt(
                    K +
                      this[++z] * 256 +
                      this[++z] * 65536 +
                      this[++z] * 16777216
                  )
                );
              })),
              (s.prototype.readBigInt64BE = Ge(function (z) {
                (z = z >>> 0), re(z, "offset");
                const K = this[z],
                  Te = this[z + 7];
                (K === void 0 || Te === void 0) && I(z, this.length - 8);
                const H =
                  (K << 24) +
                  this[++z] * Rs(2, 16) +
                  this[++z] * Rs(2, 8) +
                  this[++z];
                return (
                  (BigInt(H) << BigInt(32)) +
                  BigInt(
                    this[++z] * 16777216 +
                      this[++z] * 65536 +
                      this[++z] * 256 +
                      Te
                  )
                );
              })),
              (s.prototype.readFloatLE = function (z, K) {
                return (
                  (z = z >>> 0),
                  K || _e(z, 4, this.length),
                  y.read(this, z, !0, 23, 4)
                );
              }),
              (s.prototype.readFloatBE = function (z, K) {
                return (
                  (z = z >>> 0),
                  K || _e(z, 4, this.length),
                  y.read(this, z, !1, 23, 4)
                );
              }),
              (s.prototype.readDoubleLE = function (z, K) {
                return (
                  (z = z >>> 0),
                  K || _e(z, 8, this.length),
                  y.read(this, z, !0, 52, 8)
                );
              }),
              (s.prototype.readDoubleBE = function (z, K) {
                return (
                  (z = z >>> 0),
                  K || _e(z, 8, this.length),
                  y.read(this, z, !1, 52, 8)
                );
              });
            function L(me, z, K, Te, H, q) {
              if (!s.isBuffer(me))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (z > H || z < q)
                throw new RangeError('"value" argument is out of bounds');
              if (K + Te > me.length)
                throw new RangeError("Index out of range");
            }
            (s.prototype.writeUintLE = s.prototype.writeUIntLE =
              function (z, K, Te, H) {
                if (((z = +z), (K = K >>> 0), (Te = Te >>> 0), !H)) {
                  const Ce = Math.pow(2, 8 * Te) - 1;
                  L(this, z, K, Te, Ce, 0);
                }
                let q = 1,
                  se = 0;
                for (this[K] = z & 255; ++se < Te && (q *= 256); )
                  this[K + se] = (z / q) & 255;
                return K + Te;
              }),
              (s.prototype.writeUintBE = s.prototype.writeUIntBE =
                function (z, K, Te, H) {
                  if (((z = +z), (K = K >>> 0), (Te = Te >>> 0), !H)) {
                    const Ce = Math.pow(2, 8 * Te) - 1;
                    L(this, z, K, Te, Ce, 0);
                  }
                  let q = Te - 1,
                    se = 1;
                  for (this[K + q] = z & 255; --q >= 0 && (se *= 256); )
                    this[K + q] = (z / se) & 255;
                  return K + Te;
                }),
              (s.prototype.writeUint8 = s.prototype.writeUInt8 =
                function (z, K, Te) {
                  return (
                    (z = +z),
                    (K = K >>> 0),
                    Te || L(this, z, K, 1, 255, 0),
                    (this[K] = z & 255),
                    K + 1
                  );
                }),
              (s.prototype.writeUint16LE = s.prototype.writeUInt16LE =
                function (z, K, Te) {
                  return (
                    (z = +z),
                    (K = K >>> 0),
                    Te || L(this, z, K, 2, 65535, 0),
                    (this[K] = z & 255),
                    (this[K + 1] = z >>> 8),
                    K + 2
                  );
                }),
              (s.prototype.writeUint16BE = s.prototype.writeUInt16BE =
                function (z, K, Te) {
                  return (
                    (z = +z),
                    (K = K >>> 0),
                    Te || L(this, z, K, 2, 65535, 0),
                    (this[K] = z >>> 8),
                    (this[K + 1] = z & 255),
                    K + 2
                  );
                }),
              (s.prototype.writeUint32LE = s.prototype.writeUInt32LE =
                function (z, K, Te) {
                  return (
                    (z = +z),
                    (K = K >>> 0),
                    Te || L(this, z, K, 4, 4294967295, 0),
                    (this[K + 3] = z >>> 24),
                    (this[K + 2] = z >>> 16),
                    (this[K + 1] = z >>> 8),
                    (this[K] = z & 255),
                    K + 4
                  );
                }),
              (s.prototype.writeUint32BE = s.prototype.writeUInt32BE =
                function (z, K, Te) {
                  return (
                    (z = +z),
                    (K = K >>> 0),
                    Te || L(this, z, K, 4, 4294967295, 0),
                    (this[K] = z >>> 24),
                    (this[K + 1] = z >>> 16),
                    (this[K + 2] = z >>> 8),
                    (this[K + 3] = z & 255),
                    K + 4
                  );
                });
            function ge(me, z, K, Te, H) {
              de(z, Te, H, me, K, 7);
              let q = Number(z & BigInt(4294967295));
              (me[K++] = q),
                (q = q >> 8),
                (me[K++] = q),
                (q = q >> 8),
                (me[K++] = q),
                (q = q >> 8),
                (me[K++] = q);
              let se = Number((z >> BigInt(32)) & BigInt(4294967295));
              return (
                (me[K++] = se),
                (se = se >> 8),
                (me[K++] = se),
                (se = se >> 8),
                (me[K++] = se),
                (se = se >> 8),
                (me[K++] = se),
                K
              );
            }
            function k(me, z, K, Te, H) {
              de(z, Te, H, me, K, 7);
              let q = Number(z & BigInt(4294967295));
              (me[K + 7] = q),
                (q = q >> 8),
                (me[K + 6] = q),
                (q = q >> 8),
                (me[K + 5] = q),
                (q = q >> 8),
                (me[K + 4] = q);
              let se = Number((z >> BigInt(32)) & BigInt(4294967295));
              return (
                (me[K + 3] = se),
                (se = se >> 8),
                (me[K + 2] = se),
                (se = se >> 8),
                (me[K + 1] = se),
                (se = se >> 8),
                (me[K] = se),
                K + 8
              );
            }
            (s.prototype.writeBigUInt64LE = Ge(function (z, K = 0) {
              return ge(this, z, K, BigInt(0), BigInt("0xffffffffffffffff"));
            })),
              (s.prototype.writeBigUInt64BE = Ge(function (z, K = 0) {
                return k(this, z, K, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (s.prototype.writeIntLE = function (z, K, Te, H) {
                if (((z = +z), (K = K >>> 0), !H)) {
                  const we = Math.pow(2, 8 * Te - 1);
                  L(this, z, K, Te, we - 1, -we);
                }
                let q = 0,
                  se = 1,
                  Ce = 0;
                for (this[K] = z & 255; ++q < Te && (se *= 256); )
                  z < 0 && Ce === 0 && this[K + q - 1] !== 0 && (Ce = 1),
                    (this[K + q] = (((z / se) >> 0) - Ce) & 255);
                return K + Te;
              }),
              (s.prototype.writeIntBE = function (z, K, Te, H) {
                if (((z = +z), (K = K >>> 0), !H)) {
                  const we = Math.pow(2, 8 * Te - 1);
                  L(this, z, K, Te, we - 1, -we);
                }
                let q = Te - 1,
                  se = 1,
                  Ce = 0;
                for (this[K + q] = z & 255; --q >= 0 && (se *= 256); )
                  z < 0 && Ce === 0 && this[K + q + 1] !== 0 && (Ce = 1),
                    (this[K + q] = (((z / se) >> 0) - Ce) & 255);
                return K + Te;
              }),
              (s.prototype.writeInt8 = function (z, K, Te) {
                return (
                  (z = +z),
                  (K = K >>> 0),
                  Te || L(this, z, K, 1, 127, -128),
                  z < 0 && (z = 255 + z + 1),
                  (this[K] = z & 255),
                  K + 1
                );
              }),
              (s.prototype.writeInt16LE = function (z, K, Te) {
                return (
                  (z = +z),
                  (K = K >>> 0),
                  Te || L(this, z, K, 2, 32767, -32768),
                  (this[K] = z & 255),
                  (this[K + 1] = z >>> 8),
                  K + 2
                );
              }),
              (s.prototype.writeInt16BE = function (z, K, Te) {
                return (
                  (z = +z),
                  (K = K >>> 0),
                  Te || L(this, z, K, 2, 32767, -32768),
                  (this[K] = z >>> 8),
                  (this[K + 1] = z & 255),
                  K + 2
                );
              }),
              (s.prototype.writeInt32LE = function (z, K, Te) {
                return (
                  (z = +z),
                  (K = K >>> 0),
                  Te || L(this, z, K, 4, 2147483647, -2147483648),
                  (this[K] = z & 255),
                  (this[K + 1] = z >>> 8),
                  (this[K + 2] = z >>> 16),
                  (this[K + 3] = z >>> 24),
                  K + 4
                );
              }),
              (s.prototype.writeInt32BE = function (z, K, Te) {
                return (
                  (z = +z),
                  (K = K >>> 0),
                  Te || L(this, z, K, 4, 2147483647, -2147483648),
                  z < 0 && (z = 4294967295 + z + 1),
                  (this[K] = z >>> 24),
                  (this[K + 1] = z >>> 16),
                  (this[K + 2] = z >>> 8),
                  (this[K + 3] = z & 255),
                  K + 4
                );
              }),
              (s.prototype.writeBigInt64LE = Ge(function (z, K = 0) {
                return ge(
                  this,
                  z,
                  K,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (s.prototype.writeBigInt64BE = Ge(function (z, K = 0) {
                return k(
                  this,
                  z,
                  K,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              }));
            function j(me, z, K, Te, H, q) {
              if (K + Te > me.length)
                throw new RangeError("Index out of range");
              if (K < 0) throw new RangeError("Index out of range");
            }
            function B(me, z, K, Te, H) {
              return (
                (z = +z),
                (K = K >>> 0),
                H ||
                  j(me, z, K, 4, 34028234663852886e22, -34028234663852886e22),
                y.write(me, z, K, Te, 23, 4),
                K + 4
              );
            }
            (s.prototype.writeFloatLE = function (z, K, Te) {
              return B(this, z, K, !0, Te);
            }),
              (s.prototype.writeFloatBE = function (z, K, Te) {
                return B(this, z, K, !1, Te);
              });
            function $(me, z, K, Te, H) {
              return (
                (z = +z),
                (K = K >>> 0),
                H ||
                  j(me, z, K, 8, 17976931348623157e292, -17976931348623157e292),
                y.write(me, z, K, Te, 52, 8),
                K + 8
              );
            }
            (s.prototype.writeDoubleLE = function (z, K, Te) {
              return $(this, z, K, !0, Te);
            }),
              (s.prototype.writeDoubleBE = function (z, K, Te) {
                return $(this, z, K, !1, Te);
              }),
              (s.prototype.copy = function (z, K, Te, H) {
                if (!s.isBuffer(z))
                  throw new TypeError("argument should be a Buffer");
                if (
                  (Te || (Te = 0),
                  !H && H !== 0 && (H = this.length),
                  K >= z.length && (K = z.length),
                  K || (K = 0),
                  H > 0 && H < Te && (H = Te),
                  H === Te || z.length === 0 || this.length === 0)
                )
                  return 0;
                if (K < 0) throw new RangeError("targetStart out of bounds");
                if (Te < 0 || Te >= this.length)
                  throw new RangeError("Index out of range");
                if (H < 0) throw new RangeError("sourceEnd out of bounds");
                H > this.length && (H = this.length),
                  z.length - K < H - Te && (H = z.length - K + Te);
                const q = H - Te;
                return (
                  this === z &&
                  typeof Uint8Array.prototype.copyWithin == "function"
                    ? this.copyWithin(K, Te, H)
                    : Uint8Array.prototype.set.call(z, this.subarray(Te, H), K),
                  q
                );
              }),
              (s.prototype.fill = function (z, K, Te, H) {
                if (typeof z == "string") {
                  if (
                    (typeof K == "string"
                      ? ((H = K), (K = 0), (Te = this.length))
                      : typeof Te == "string" && ((H = Te), (Te = this.length)),
                    H !== void 0 && typeof H != "string")
                  )
                    throw new TypeError("encoding must be a string");
                  if (typeof H == "string" && !s.isEncoding(H))
                    throw new TypeError("Unknown encoding: " + H);
                  if (z.length === 1) {
                    const se = z.charCodeAt(0);
                    ((H === "utf8" && se < 128) || H === "latin1") && (z = se);
                  }
                } else
                  typeof z == "number"
                    ? (z = z & 255)
                    : typeof z == "boolean" && (z = Number(z));
                if (K < 0 || this.length < K || this.length < Te)
                  throw new RangeError("Out of range index");
                if (Te <= K) return this;
                (K = K >>> 0),
                  (Te = Te === void 0 ? this.length : Te >>> 0),
                  z || (z = 0);
                let q;
                if (typeof z == "number") for (q = K; q < Te; ++q) this[q] = z;
                else {
                  const se = s.isBuffer(z) ? z : s.from(z, H),
                    Ce = se.length;
                  if (Ce === 0)
                    throw new TypeError(
                      'The value "' + z + '" is invalid for argument "value"'
                    );
                  for (q = 0; q < Te - K; ++q) this[q + K] = se[q % Ce];
                }
                return this;
              });
            const le = {};
            function O(me, z, K) {
              le[me] = class extends K {
                constructor() {
                  super(),
                    Object.defineProperty(this, "message", {
                      value: z.apply(this, arguments),
                      writable: !0,
                      configurable: !0,
                    }),
                    (this.name = `${this.name} [${me}]`),
                    this.stack,
                    delete this.name;
                }
                get code() {
                  return me;
                }
                set code(H) {
                  Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: H,
                    writable: !0,
                  });
                }
                toString() {
                  return `${this.name} [${me}]: ${this.message}`;
                }
              };
            }
            O(
              "ERR_BUFFER_OUT_OF_BOUNDS",
              function (me) {
                return me
                  ? `${me} is outside of buffer bounds`
                  : "Attempt to access memory outside buffer bounds";
              },
              RangeError
            ),
              O(
                "ERR_INVALID_ARG_TYPE",
                function (me, z) {
                  return `The "${me}" argument must be of type number. Received type ${typeof z}`;
                },
                TypeError
              ),
              O(
                "ERR_OUT_OF_RANGE",
                function (me, z, K) {
                  let Te = `The value of "${me}" is out of range.`,
                    H = K;
                  return (
                    Number.isInteger(K) && Math.abs(K) > 4294967296
                      ? (H = Y(String(K)))
                      : typeof K == "bigint" &&
                        ((H = String(K)),
                        (K > Rs(BigInt(2), BigInt(32)) ||
                          K < -Rs(BigInt(2), BigInt(32))) &&
                          (H = Y(H)),
                        (H += "n")),
                    (Te += ` It must be ${z}. Received ${H}`),
                    Te
                  );
                },
                RangeError
              );
            function Y(me) {
              let z = "",
                K = me.length;
              const Te = me[0] === "-" ? 1 : 0;
              for (; K >= Te + 4; K -= 3) z = `_${me.slice(K - 3, K)}${z}`;
              return `${me.slice(0, K)}${z}`;
            }
            function ne(me, z, K) {
              re(z, "offset"),
                (me[z] === void 0 || me[z + K] === void 0) &&
                  I(z, me.length - (K + 1));
            }
            function de(me, z, K, Te, H, q) {
              if (me > K || me < z) {
                const se = typeof z == "bigint" ? "n" : "";
                let Ce;
                throw (
                  (q > 3
                    ? z === 0 || z === BigInt(0)
                      ? (Ce = `>= 0${se} and < 2${se} ** ${(q + 1) * 8}${se}`)
                      : (Ce = `>= -(2${se} ** ${
                          (q + 1) * 8 - 1
                        }${se}) and < 2 ** ${(q + 1) * 8 - 1}${se}`)
                    : (Ce = `>= ${z}${se} and <= ${K}${se}`),
                  new le.ERR_OUT_OF_RANGE("value", Ce, me))
                );
              }
              ne(Te, H, q);
            }
            function re(me, z) {
              if (typeof me != "number")
                throw new le.ERR_INVALID_ARG_TYPE(z, "number", me);
            }
            function I(me, z, K) {
              throw Math.floor(me) !== me
                ? (re(me, K),
                  new le.ERR_OUT_OF_RANGE(K || "offset", "an integer", me))
                : z < 0
                ? new le.ERR_BUFFER_OUT_OF_BOUNDS()
                : new le.ERR_OUT_OF_RANGE(
                    K || "offset",
                    `>= ${K ? 1 : 0} and <= ${z}`,
                    me
                  );
            }
            const w = /[^+/0-9A-Za-z-_]/g;
            function N(me) {
              if (
                ((me = me.split("=")[0]),
                (me = me.trim().replace(w, "")),
                me.length < 2)
              )
                return "";
              for (; me.length % 4 !== 0; ) me = me + "=";
              return me;
            }
            function W(me, z) {
              z = z || 1 / 0;
              let K;
              const Te = me.length;
              let H = null;
              const q = [];
              for (let se = 0; se < Te; ++se) {
                if (((K = me.charCodeAt(se)), K > 55295 && K < 57344)) {
                  if (!H) {
                    if (K > 56319) {
                      (z -= 3) > -1 && q.push(239, 191, 189);
                      continue;
                    } else if (se + 1 === Te) {
                      (z -= 3) > -1 && q.push(239, 191, 189);
                      continue;
                    }
                    H = K;
                    continue;
                  }
                  if (K < 56320) {
                    (z -= 3) > -1 && q.push(239, 191, 189), (H = K);
                    continue;
                  }
                  K = (((H - 55296) << 10) | (K - 56320)) + 65536;
                } else H && (z -= 3) > -1 && q.push(239, 191, 189);
                if (((H = null), K < 128)) {
                  if ((z -= 1) < 0) break;
                  q.push(K);
                } else if (K < 2048) {
                  if ((z -= 2) < 0) break;
                  q.push((K >> 6) | 192, (K & 63) | 128);
                } else if (K < 65536) {
                  if ((z -= 3) < 0) break;
                  q.push(
                    (K >> 12) | 224,
                    ((K >> 6) & 63) | 128,
                    (K & 63) | 128
                  );
                } else if (K < 1114112) {
                  if ((z -= 4) < 0) break;
                  q.push(
                    (K >> 18) | 240,
                    ((K >> 12) & 63) | 128,
                    ((K >> 6) & 63) | 128,
                    (K & 63) | 128
                  );
                } else throw new Error("Invalid code point");
              }
              return q;
            }
            function he(me) {
              const z = [];
              for (let K = 0; K < me.length; ++K)
                z.push(me.charCodeAt(K) & 255);
              return z;
            }
            function ue(me, z) {
              let K, Te, H;
              const q = [];
              for (let se = 0; se < me.length && !((z -= 2) < 0); ++se)
                (K = me.charCodeAt(se)),
                  (Te = K >> 8),
                  (H = K % 256),
                  q.push(H),
                  q.push(Te);
              return q;
            }
            function ye(me) {
              return x.toByteArray(N(me));
            }
            function Oe(me, z, K, Te) {
              let H;
              for (H = 0; H < Te && !(H + K >= z.length || H >= me.length); ++H)
                z[H + K] = me[H];
              return H;
            }
            function Ae(me, z) {
              return (
                me instanceof z ||
                (me != null &&
                  me.constructor != null &&
                  me.constructor.name != null &&
                  me.constructor.name === z.name)
              );
            }
            function ke(me) {
              return me !== me;
            }
            const Ue = (function () {
              const me = "0123456789abcdef",
                z = new Array(256);
              for (let K = 0; K < 16; ++K) {
                const Te = K * 16;
                for (let H = 0; H < 16; ++H) z[Te + H] = me[K] + me[H];
              }
              return z;
            })();
            function Ge(me) {
              return typeof BigInt == "undefined" ? ht : me;
            }
            function ht() {
              throw new Error("BigInt not supported");
            }
          },
          7007: (xe) => {
            "use strict";
            var V = typeof Reflect == "object" ? Reflect : null,
              a =
                V && typeof V.apply == "function"
                  ? V.apply
                  : function (g, T, E) {
                      return Function.prototype.apply.call(g, T, E);
                    },
              A;
            V && typeof V.ownKeys == "function"
              ? (A = V.ownKeys)
              : Object.getOwnPropertySymbols
              ? (A = function (g) {
                  return Object.getOwnPropertyNames(g).concat(
                    Object.getOwnPropertySymbols(g)
                  );
                })
              : (A = function (g) {
                  return Object.getOwnPropertyNames(g);
                });
            function x(m) {
              console && console.warn && console.warn(m);
            }
            var y =
              Number.isNaN ||
              function (g) {
                return g !== g;
              };
            function c() {
              c.init.call(this);
            }
            (xe.exports = c),
              (xe.exports.once = u),
              (c.EventEmitter = c),
              (c.prototype._events = void 0),
              (c.prototype._eventsCount = 0),
              (c.prototype._maxListeners = void 0);
            var d = 10;
            function h(m) {
              if (typeof m != "function")
                throw new TypeError(
                  'The "listener" argument must be of type Function. Received type ' +
                    typeof m
                );
            }
            Object.defineProperty(c, "defaultMaxListeners", {
              enumerable: !0,
              get: function () {
                return d;
              },
              set: function (m) {
                if (typeof m != "number" || m < 0 || y(m))
                  throw new RangeError(
                    'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                      m +
                      "."
                  );
                d = m;
              },
            }),
              (c.init = function () {
                (this._events === void 0 ||
                  this._events === Object.getPrototypeOf(this)._events) &&
                  ((this._events = Object.create(null)),
                  (this._eventsCount = 0)),
                  (this._maxListeners = this._maxListeners || void 0);
              }),
              (c.prototype.setMaxListeners = function (g) {
                if (typeof g != "number" || g < 0 || y(g))
                  throw new RangeError(
                    'The value of "n" is out of range. It must be a non-negative number. Received ' +
                      g +
                      "."
                  );
                return (this._maxListeners = g), this;
              });
            function f(m) {
              return m._maxListeners === void 0
                ? c.defaultMaxListeners
                : m._maxListeners;
            }
            (c.prototype.getMaxListeners = function () {
              return f(this);
            }),
              (c.prototype.emit = function (g) {
                for (var T = [], E = 1; E < arguments.length; E++)
                  T.push(arguments[E]);
                var M = g === "error",
                  R = this._events;
                if (R !== void 0) M = M && R.error === void 0;
                else if (!M) return !1;
                if (M) {
                  var P;
                  if ((T.length > 0 && (P = T[0]), P instanceof Error)) throw P;
                  var F = new Error(
                    "Unhandled error." + (P ? " (" + P.message + ")" : "")
                  );
                  throw ((F.context = P), F);
                }
                var b = R[g];
                if (b === void 0) return !1;
                if (typeof b == "function") a(b, this, T);
                else
                  for (var D = b.length, G = e(b, D), E = 0; E < D; ++E)
                    a(G[E], this, T);
                return !0;
              });
            function s(m, g, T, E) {
              var M, R, P;
              if (
                (h(T),
                (R = m._events),
                R === void 0
                  ? ((R = m._events = Object.create(null)),
                    (m._eventsCount = 0))
                  : (R.newListener !== void 0 &&
                      (m.emit("newListener", g, T.listener ? T.listener : T),
                      (R = m._events)),
                    (P = R[g])),
                P === void 0)
              )
                (P = R[g] = T), ++m._eventsCount;
              else if (
                (typeof P == "function"
                  ? (P = R[g] = E ? [T, P] : [P, T])
                  : E
                  ? P.unshift(T)
                  : P.push(T),
                (M = f(m)),
                M > 0 && P.length > M && !P.warned)
              ) {
                P.warned = !0;
                var F = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    P.length +
                    " " +
                    String(g) +
                    " listeners added. Use emitter.setMaxListeners() to increase limit"
                );
                (F.name = "MaxListenersExceededWarning"),
                  (F.emitter = m),
                  (F.type = g),
                  (F.count = P.length),
                  x(F);
              }
              return m;
            }
            (c.prototype.addListener = function (g, T) {
              return s(this, g, T, !1);
            }),
              (c.prototype.on = c.prototype.addListener),
              (c.prototype.prependListener = function (g, T) {
                return s(this, g, T, !0);
              });
            function l() {
              if (!this.fired)
                return (
                  this.target.removeListener(this.type, this.wrapFn),
                  (this.fired = !0),
                  arguments.length === 0
                    ? this.listener.call(this.target)
                    : this.listener.apply(this.target, arguments)
                );
            }
            function n(m, g, T) {
              var E = {
                  fired: !1,
                  wrapFn: void 0,
                  target: m,
                  type: g,
                  listener: T,
                },
                M = l.bind(E);
              return (M.listener = T), (E.wrapFn = M), M;
            }
            (c.prototype.once = function (g, T) {
              return h(T), this.on(g, n(this, g, T)), this;
            }),
              (c.prototype.prependOnceListener = function (g, T) {
                return h(T), this.prependListener(g, n(this, g, T)), this;
              }),
              (c.prototype.removeListener = function (g, T) {
                var E, M, R, P, F;
                if ((h(T), (M = this._events), M === void 0)) return this;
                if (((E = M[g]), E === void 0)) return this;
                if (E === T || E.listener === T)
                  --this._eventsCount === 0
                    ? (this._events = Object.create(null))
                    : (delete M[g],
                      M.removeListener &&
                        this.emit("removeListener", g, E.listener || T));
                else if (typeof E != "function") {
                  for (R = -1, P = E.length - 1; P >= 0; P--)
                    if (E[P] === T || E[P].listener === T) {
                      (F = E[P].listener), (R = P);
                      break;
                    }
                  if (R < 0) return this;
                  R === 0 ? E.shift() : t(E, R),
                    E.length === 1 && (M[g] = E[0]),
                    M.removeListener !== void 0 &&
                      this.emit("removeListener", g, F || T);
                }
                return this;
              }),
              (c.prototype.off = c.prototype.removeListener),
              (c.prototype.removeAllListeners = function (g) {
                var T, E, M;
                if (((E = this._events), E === void 0)) return this;
                if (E.removeListener === void 0)
                  return (
                    arguments.length === 0
                      ? ((this._events = Object.create(null)),
                        (this._eventsCount = 0))
                      : E[g] !== void 0 &&
                        (--this._eventsCount === 0
                          ? (this._events = Object.create(null))
                          : delete E[g]),
                    this
                  );
                if (arguments.length === 0) {
                  var R = Object.keys(E),
                    P;
                  for (M = 0; M < R.length; ++M)
                    (P = R[M]),
                      P !== "removeListener" && this.removeAllListeners(P);
                  return (
                    this.removeAllListeners("removeListener"),
                    (this._events = Object.create(null)),
                    (this._eventsCount = 0),
                    this
                  );
                }
                if (((T = E[g]), typeof T == "function"))
                  this.removeListener(g, T);
                else if (T !== void 0)
                  for (M = T.length - 1; M >= 0; M--)
                    this.removeListener(g, T[M]);
                return this;
              });
            function o(m, g, T) {
              var E = m._events;
              if (E === void 0) return [];
              var M = E[g];
              return M === void 0
                ? []
                : typeof M == "function"
                ? T
                  ? [M.listener || M]
                  : [M]
                : T
                ? r(M)
                : e(M, M.length);
            }
            (c.prototype.listeners = function (g) {
              return o(this, g, !0);
            }),
              (c.prototype.rawListeners = function (g) {
                return o(this, g, !1);
              }),
              (c.listenerCount = function (m, g) {
                return typeof m.listenerCount == "function"
                  ? m.listenerCount(g)
                  : i.call(m, g);
              }),
              (c.prototype.listenerCount = i);
            function i(m) {
              var g = this._events;
              if (g !== void 0) {
                var T = g[m];
                if (typeof T == "function") return 1;
                if (T !== void 0) return T.length;
              }
              return 0;
            }
            c.prototype.eventNames = function () {
              return this._eventsCount > 0 ? A(this._events) : [];
            };
            function e(m, g) {
              for (var T = new Array(g), E = 0; E < g; ++E) T[E] = m[E];
              return T;
            }
            function t(m, g) {
              for (; g + 1 < m.length; g++) m[g] = m[g + 1];
              m.pop();
            }
            function r(m) {
              for (var g = new Array(m.length), T = 0; T < g.length; ++T)
                g[T] = m[T].listener || m[T];
              return g;
            }
            function u(m, g) {
              return new Promise(function (T, E) {
                function M(P) {
                  m.removeListener(g, R), E(P);
                }
                function R() {
                  typeof m.removeListener == "function" &&
                    m.removeListener("error", M),
                    T([].slice.call(arguments));
                }
                _(m, g, R, { once: !0 }),
                  g !== "error" && v(m, M, { once: !0 });
              });
            }
            function v(m, g, T) {
              typeof m.on == "function" && _(m, "error", g, T);
            }
            function _(m, g, T, E) {
              if (typeof m.on == "function") E.once ? m.once(g, T) : m.on(g, T);
              else if (typeof m.addEventListener == "function")
                m.addEventListener(g, function M(R) {
                  E.once && m.removeEventListener(g, M), T(R);
                });
              else
                throw new TypeError(
                  'The "emitter" argument must be of type EventEmitter. Received type ' +
                    typeof m
                );
            }
          },
          4196: (xe, V, a) => {
            var A, x;
            /*!
             *  howler.js v2.2.4
             *  howlerjs.com
             *
             *  (c) 2013-2020, James Simpson of GoldFire Studios
             *  goldfirestudios.com
             *
             *  MIT License
             */ (function () {
              "use strict";
              var y = function () {
                this.init();
              };
              y.prototype = {
                init: function () {
                  var e = this || c;
                  return (
                    (e._counter = 1e3),
                    (e._html5AudioPool = []),
                    (e.html5PoolSize = 10),
                    (e._codecs = {}),
                    (e._howls = []),
                    (e._muted = !1),
                    (e._volume = 1),
                    (e._canPlayEvent = "canplaythrough"),
                    (e._navigator =
                      typeof window != "undefined" && window.navigator
                        ? window.navigator
                        : null),
                    (e.masterGain = null),
                    (e.noAudio = !1),
                    (e.usingWebAudio = !0),
                    (e.autoSuspend = !0),
                    (e.ctx = null),
                    (e.autoUnlock = !0),
                    e._setup(),
                    e
                  );
                },
                volume: function (e) {
                  var t = this || c;
                  if (
                    ((e = parseFloat(e)),
                    t.ctx || i(),
                    typeof e != "undefined" && e >= 0 && e <= 1)
                  ) {
                    if (((t._volume = e), t._muted)) return t;
                    t.usingWebAudio &&
                      t.masterGain.gain.setValueAtTime(e, c.ctx.currentTime);
                    for (var r = 0; r < t._howls.length; r++)
                      if (!t._howls[r]._webAudio)
                        for (
                          var u = t._howls[r]._getSoundIds(), v = 0;
                          v < u.length;
                          v++
                        ) {
                          var _ = t._howls[r]._soundById(u[v]);
                          _ && _._node && (_._node.volume = _._volume * e);
                        }
                    return t;
                  }
                  return t._volume;
                },
                mute: function (e) {
                  var t = this || c;
                  t.ctx || i(),
                    (t._muted = e),
                    t.usingWebAudio &&
                      t.masterGain.gain.setValueAtTime(
                        e ? 0 : t._volume,
                        c.ctx.currentTime
                      );
                  for (var r = 0; r < t._howls.length; r++)
                    if (!t._howls[r]._webAudio)
                      for (
                        var u = t._howls[r]._getSoundIds(), v = 0;
                        v < u.length;
                        v++
                      ) {
                        var _ = t._howls[r]._soundById(u[v]);
                        _ && _._node && (_._node.muted = e ? !0 : _._muted);
                      }
                  return t;
                },
                stop: function () {
                  for (var e = this || c, t = 0; t < e._howls.length; t++)
                    e._howls[t].stop();
                  return e;
                },
                unload: function () {
                  for (var e = this || c, t = e._howls.length - 1; t >= 0; t--)
                    e._howls[t].unload();
                  return (
                    e.usingWebAudio &&
                      e.ctx &&
                      typeof e.ctx.close != "undefined" &&
                      (e.ctx.close(), (e.ctx = null), i()),
                    e
                  );
                },
                codecs: function (e) {
                  return (this || c)._codecs[e.replace(/^x-/, "")];
                },
                _setup: function () {
                  var e = this || c;
                  if (
                    ((e.state = (e.ctx && e.ctx.state) || "suspended"),
                    e._autoSuspend(),
                    !e.usingWebAudio)
                  )
                    if (typeof Audio != "undefined")
                      try {
                        var t = new Audio();
                        typeof t.oncanplaythrough == "undefined" &&
                          (e._canPlayEvent = "canplay");
                      } catch (r) {
                        e.noAudio = !0;
                      }
                    else e.noAudio = !0;
                  try {
                    var t = new Audio();
                    t.muted && (e.noAudio = !0);
                  } catch (r) {}
                  return e.noAudio || e._setupCodecs(), e;
                },
                _setupCodecs: function () {
                  var e = this || c,
                    t = null;
                  try {
                    t = typeof Audio != "undefined" ? new Audio() : null;
                  } catch (E) {
                    return e;
                  }
                  if (!t || typeof t.canPlayType != "function") return e;
                  var r = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                    u = e._navigator ? e._navigator.userAgent : "",
                    v = u.match(/OPR\/(\d+)/g),
                    _ = v && parseInt(v[0].split("/")[1], 10) < 33,
                    m =
                      u.indexOf("Safari") !== -1 && u.indexOf("Chrome") === -1,
                    g = u.match(/Version\/(.*?) /),
                    T = m && g && parseInt(g[1], 10) < 15;
                  return (
                    (e._codecs = {
                      mp3: !!(
                        !_ &&
                        (r || t.canPlayType("audio/mp3;").replace(/^no$/, ""))
                      ),
                      mpeg: !!r,
                      opus: !!t
                        .canPlayType('audio/ogg; codecs="opus"')
                        .replace(/^no$/, ""),
                      ogg: !!t
                        .canPlayType('audio/ogg; codecs="vorbis"')
                        .replace(/^no$/, ""),
                      oga: !!t
                        .canPlayType('audio/ogg; codecs="vorbis"')
                        .replace(/^no$/, ""),
                      wav: !!(
                        t.canPlayType('audio/wav; codecs="1"') ||
                        t.canPlayType("audio/wav")
                      ).replace(/^no$/, ""),
                      aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                      caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                      m4a: !!(
                        t.canPlayType("audio/x-m4a;") ||
                        t.canPlayType("audio/m4a;") ||
                        t.canPlayType("audio/aac;")
                      ).replace(/^no$/, ""),
                      m4b: !!(
                        t.canPlayType("audio/x-m4b;") ||
                        t.canPlayType("audio/m4b;") ||
                        t.canPlayType("audio/aac;")
                      ).replace(/^no$/, ""),
                      mp4: !!(
                        t.canPlayType("audio/x-mp4;") ||
                        t.canPlayType("audio/mp4;") ||
                        t.canPlayType("audio/aac;")
                      ).replace(/^no$/, ""),
                      weba: !!(
                        !T &&
                        t
                          .canPlayType('audio/webm; codecs="vorbis"')
                          .replace(/^no$/, "")
                      ),
                      webm: !!(
                        !T &&
                        t
                          .canPlayType('audio/webm; codecs="vorbis"')
                          .replace(/^no$/, "")
                      ),
                      dolby: !!t
                        .canPlayType('audio/mp4; codecs="ec-3"')
                        .replace(/^no$/, ""),
                      flac: !!(
                        t.canPlayType("audio/x-flac;") ||
                        t.canPlayType("audio/flac;")
                      ).replace(/^no$/, ""),
                    }),
                    e
                  );
                },
                _unlockAudio: function () {
                  var e = this || c;
                  if (!(e._audioUnlocked || !e.ctx)) {
                    (e._audioUnlocked = !1),
                      (e.autoUnlock = !1),
                      !e._mobileUnloaded &&
                        e.ctx.sampleRate !== 44100 &&
                        ((e._mobileUnloaded = !0), e.unload()),
                      (e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050));
                    var t = function (r) {
                      for (; e._html5AudioPool.length < e.html5PoolSize; )
                        try {
                          var u = new Audio();
                          (u._unlocked = !0), e._releaseHtml5Audio(u);
                        } catch (E) {
                          e.noAudio = !0;
                          break;
                        }
                      for (var v = 0; v < e._howls.length; v++)
                        if (!e._howls[v]._webAudio)
                          for (
                            var _ = e._howls[v]._getSoundIds(), m = 0;
                            m < _.length;
                            m++
                          ) {
                            var g = e._howls[v]._soundById(_[m]);
                            g &&
                              g._node &&
                              !g._node._unlocked &&
                              ((g._node._unlocked = !0), g._node.load());
                          }
                      e._autoResume();
                      var T = e.ctx.createBufferSource();
                      (T.buffer = e._scratchBuffer),
                        T.connect(e.ctx.destination),
                        typeof T.start == "undefined"
                          ? T.noteOn(0)
                          : T.start(0),
                        typeof e.ctx.resume == "function" && e.ctx.resume(),
                        (T.onended = function () {
                          T.disconnect(0),
                            (e._audioUnlocked = !0),
                            document.removeEventListener("touchstart", t, !0),
                            document.removeEventListener("touchend", t, !0),
                            document.removeEventListener("click", t, !0),
                            document.removeEventListener("keydown", t, !0);
                          for (var E = 0; E < e._howls.length; E++)
                            e._howls[E]._emit("unlock");
                        });
                    };
                    return (
                      document.addEventListener("touchstart", t, !0),
                      document.addEventListener("touchend", t, !0),
                      document.addEventListener("click", t, !0),
                      document.addEventListener("keydown", t, !0),
                      e
                    );
                  }
                },
                _obtainHtml5Audio: function () {
                  var e = this || c;
                  if (e._html5AudioPool.length) return e._html5AudioPool.pop();
                  var t = new Audio().play();
                  return (
                    t &&
                      typeof Promise != "undefined" &&
                      (t instanceof Promise || typeof t.then == "function") &&
                      t.catch(function () {
                        console.warn(
                          "HTML5 Audio pool exhausted, returning potentially locked audio object."
                        );
                      }),
                    new Audio()
                  );
                },
                _releaseHtml5Audio: function (e) {
                  var t = this || c;
                  return e._unlocked && t._html5AudioPool.push(e), t;
                },
                _autoSuspend: function () {
                  var e = this;
                  if (
                    !(
                      !e.autoSuspend ||
                      !e.ctx ||
                      typeof e.ctx.suspend == "undefined" ||
                      !c.usingWebAudio
                    )
                  ) {
                    for (var t = 0; t < e._howls.length; t++)
                      if (e._howls[t]._webAudio) {
                        for (var r = 0; r < e._howls[t]._sounds.length; r++)
                          if (!e._howls[t]._sounds[r]._paused) return e;
                      }
                    return (
                      e._suspendTimer && clearTimeout(e._suspendTimer),
                      (e._suspendTimer = setTimeout(function () {
                        if (e.autoSuspend) {
                          (e._suspendTimer = null), (e.state = "suspending");
                          var u = function () {
                            (e.state = "suspended"),
                              e._resumeAfterSuspend &&
                                (delete e._resumeAfterSuspend, e._autoResume());
                          };
                          e.ctx.suspend().then(u, u);
                        }
                      }, 3e4)),
                      e
                    );
                  }
                },
                _autoResume: function () {
                  var e = this;
                  if (
                    !(
                      !e.ctx ||
                      typeof e.ctx.resume == "undefined" ||
                      !c.usingWebAudio
                    )
                  )
                    return (
                      e.state === "running" &&
                      e.ctx.state !== "interrupted" &&
                      e._suspendTimer
                        ? (clearTimeout(e._suspendTimer),
                          (e._suspendTimer = null))
                        : e.state === "suspended" ||
                          (e.state === "running" &&
                            e.ctx.state === "interrupted")
                        ? (e.ctx.resume().then(function () {
                            e.state = "running";
                            for (var t = 0; t < e._howls.length; t++)
                              e._howls[t]._emit("resume");
                          }),
                          e._suspendTimer &&
                            (clearTimeout(e._suspendTimer),
                            (e._suspendTimer = null)))
                        : e.state === "suspending" &&
                          (e._resumeAfterSuspend = !0),
                      e
                    );
                },
              };
              var c = new y(),
                d = function (e) {
                  var t = this;
                  if (!e.src || e.src.length === 0) {
                    console.error(
                      "An array of source files must be passed with any new Howl."
                    );
                    return;
                  }
                  t.init(e);
                };
              d.prototype = {
                init: function (e) {
                  var t = this;
                  return (
                    c.ctx || i(),
                    (t._autoplay = e.autoplay || !1),
                    (t._format =
                      typeof e.format != "string" ? e.format : [e.format]),
                    (t._html5 = e.html5 || !1),
                    (t._muted = e.mute || !1),
                    (t._loop = e.loop || !1),
                    (t._pool = e.pool || 5),
                    (t._preload =
                      typeof e.preload == "boolean" || e.preload === "metadata"
                        ? e.preload
                        : !0),
                    (t._rate = e.rate || 1),
                    (t._sprite = e.sprite || {}),
                    (t._src = typeof e.src != "string" ? e.src : [e.src]),
                    (t._volume = e.volume !== void 0 ? e.volume : 1),
                    (t._xhr = {
                      method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                      headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                      withCredentials:
                        e.xhr && e.xhr.withCredentials
                          ? e.xhr.withCredentials
                          : !1,
                    }),
                    (t._duration = 0),
                    (t._state = "unloaded"),
                    (t._sounds = []),
                    (t._endTimers = {}),
                    (t._queue = []),
                    (t._playLock = !1),
                    (t._onend = e.onend ? [{ fn: e.onend }] : []),
                    (t._onfade = e.onfade ? [{ fn: e.onfade }] : []),
                    (t._onload = e.onload ? [{ fn: e.onload }] : []),
                    (t._onloaderror = e.onloaderror
                      ? [{ fn: e.onloaderror }]
                      : []),
                    (t._onplayerror = e.onplayerror
                      ? [{ fn: e.onplayerror }]
                      : []),
                    (t._onpause = e.onpause ? [{ fn: e.onpause }] : []),
                    (t._onplay = e.onplay ? [{ fn: e.onplay }] : []),
                    (t._onstop = e.onstop ? [{ fn: e.onstop }] : []),
                    (t._onmute = e.onmute ? [{ fn: e.onmute }] : []),
                    (t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : []),
                    (t._onrate = e.onrate ? [{ fn: e.onrate }] : []),
                    (t._onseek = e.onseek ? [{ fn: e.onseek }] : []),
                    (t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : []),
                    (t._onresume = []),
                    (t._webAudio = c.usingWebAudio && !t._html5),
                    typeof c.ctx != "undefined" &&
                      c.ctx &&
                      c.autoUnlock &&
                      c._unlockAudio(),
                    c._howls.push(t),
                    t._autoplay &&
                      t._queue.push({
                        event: "play",
                        action: function () {
                          t.play();
                        },
                      }),
                    t._preload && t._preload !== "none" && t.load(),
                    t
                  );
                },
                load: function () {
                  var e = this,
                    t = null;
                  if (c.noAudio) {
                    e._emit("loaderror", null, "No audio support.");
                    return;
                  }
                  typeof e._src == "string" && (e._src = [e._src]);
                  for (var r = 0; r < e._src.length; r++) {
                    var u, v;
                    if (e._format && e._format[r]) u = e._format[r];
                    else {
                      if (((v = e._src[r]), typeof v != "string")) {
                        e._emit(
                          "loaderror",
                          null,
                          "Non-string found in selected audio sources - ignoring."
                        );
                        continue;
                      }
                      (u = /^data:audio\/([^;,]+);/i.exec(v)),
                        u || (u = /\.([^.]+)$/.exec(v.split("?", 1)[0])),
                        u && (u = u[1].toLowerCase());
                    }
                    if (
                      (u ||
                        console.warn(
                          'No file extension was found. Consider using the "format" property or specify an extension.'
                        ),
                      u && c.codecs(u))
                    ) {
                      t = e._src[r];
                      break;
                    }
                  }
                  if (!t) {
                    e._emit(
                      "loaderror",
                      null,
                      "No codec support for selected audio sources."
                    );
                    return;
                  }
                  return (
                    (e._src = t),
                    (e._state = "loading"),
                    window.location.protocol === "https:" &&
                      t.slice(0, 5) === "http:" &&
                      ((e._html5 = !0), (e._webAudio = !1)),
                    new h(e),
                    e._webAudio && s(e),
                    e
                  );
                },
                play: function (e, t) {
                  var r = this,
                    u = null;
                  if (typeof e == "number") (u = e), (e = null);
                  else {
                    if (
                      typeof e == "string" &&
                      r._state === "loaded" &&
                      !r._sprite[e]
                    )
                      return null;
                    if (
                      typeof e == "undefined" &&
                      ((e = "__default"), !r._playLock)
                    ) {
                      for (var v = 0, _ = 0; _ < r._sounds.length; _++)
                        r._sounds[_]._paused &&
                          !r._sounds[_]._ended &&
                          (v++, (u = r._sounds[_]._id));
                      v === 1 ? (e = null) : (u = null);
                    }
                  }
                  var m = u ? r._soundById(u) : r._inactiveSound();
                  if (!m) return null;
                  if (
                    (u && !e && (e = m._sprite || "__default"),
                    r._state !== "loaded")
                  ) {
                    (m._sprite = e), (m._ended = !1);
                    var g = m._id;
                    return (
                      r._queue.push({
                        event: "play",
                        action: function () {
                          r.play(g);
                        },
                      }),
                      g
                    );
                  }
                  if (u && !m._paused) return t || r._loadQueue("play"), m._id;
                  r._webAudio && c._autoResume();
                  var T = Math.max(
                      0,
                      m._seek > 0 ? m._seek : r._sprite[e][0] / 1e3
                    ),
                    E = Math.max(
                      0,
                      (r._sprite[e][0] + r._sprite[e][1]) / 1e3 - T
                    ),
                    M = (E * 1e3) / Math.abs(m._rate),
                    R = r._sprite[e][0] / 1e3,
                    P = (r._sprite[e][0] + r._sprite[e][1]) / 1e3;
                  (m._sprite = e), (m._ended = !1);
                  var F = function () {
                    (m._paused = !1),
                      (m._seek = T),
                      (m._start = R),
                      (m._stop = P),
                      (m._loop = !!(m._loop || r._sprite[e][2]));
                  };
                  if (T >= P) {
                    r._ended(m);
                    return;
                  }
                  var b = m._node;
                  if (r._webAudio) {
                    var D = function () {
                      (r._playLock = !1), F(), r._refreshBuffer(m);
                      var Q = m._muted || r._muted ? 0 : m._volume;
                      b.gain.setValueAtTime(Q, c.ctx.currentTime),
                        (m._playStart = c.ctx.currentTime),
                        typeof b.bufferSource.start == "undefined"
                          ? m._loop
                            ? b.bufferSource.noteGrainOn(0, T, 86400)
                            : b.bufferSource.noteGrainOn(0, T, E)
                          : m._loop
                          ? b.bufferSource.start(0, T, 86400)
                          : b.bufferSource.start(0, T, E),
                        M !== 1 / 0 &&
                          (r._endTimers[m._id] = setTimeout(
                            r._ended.bind(r, m),
                            M
                          )),
                        t ||
                          setTimeout(function () {
                            r._emit("play", m._id), r._loadQueue();
                          }, 0);
                    };
                    c.state === "running" && c.ctx.state !== "interrupted"
                      ? D()
                      : ((r._playLock = !0),
                        r.once("resume", D),
                        r._clearTimer(m._id));
                  } else {
                    var G = function () {
                      (b.currentTime = T),
                        (b.muted = m._muted || r._muted || c._muted || b.muted),
                        (b.volume = m._volume * c.volume()),
                        (b.playbackRate = m._rate);
                      try {
                        var Q = b.play();
                        if (
                          (Q &&
                          typeof Promise != "undefined" &&
                          (Q instanceof Promise || typeof Q.then == "function")
                            ? ((r._playLock = !0),
                              F(),
                              Q.then(function () {
                                (r._playLock = !1),
                                  (b._unlocked = !0),
                                  t ? r._loadQueue() : r._emit("play", m._id);
                              }).catch(function () {
                                (r._playLock = !1),
                                  r._emit(
                                    "playerror",
                                    m._id,
                                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                  ),
                                  (m._ended = !0),
                                  (m._paused = !0);
                              }))
                            : t ||
                              ((r._playLock = !1), F(), r._emit("play", m._id)),
                          (b.playbackRate = m._rate),
                          b.paused)
                        ) {
                          r._emit(
                            "playerror",
                            m._id,
                            "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                          );
                          return;
                        }
                        e !== "__default" || m._loop
                          ? (r._endTimers[m._id] = setTimeout(
                              r._ended.bind(r, m),
                              M
                            ))
                          : ((r._endTimers[m._id] = function () {
                              r._ended(m),
                                b.removeEventListener(
                                  "ended",
                                  r._endTimers[m._id],
                                  !1
                                );
                            }),
                            b.addEventListener(
                              "ended",
                              r._endTimers[m._id],
                              !1
                            ));
                      } catch (te) {
                        r._emit("playerror", m._id, te);
                      }
                    };
                    b.src ===
                      "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" &&
                      ((b.src = r._src), b.load());
                    var X =
                      (window && window.ejecta) ||
                      (!b.readyState && c._navigator.isCocoonJS);
                    if (b.readyState >= 3 || X) G();
                    else {
                      (r._playLock = !0), (r._state = "loading");
                      var ie = function () {
                        (r._state = "loaded"),
                          G(),
                          b.removeEventListener(c._canPlayEvent, ie, !1);
                      };
                      b.addEventListener(c._canPlayEvent, ie, !1),
                        r._clearTimer(m._id);
                    }
                  }
                  return m._id;
                },
                pause: function (e) {
                  var t = this;
                  if (t._state !== "loaded" || t._playLock)
                    return (
                      t._queue.push({
                        event: "pause",
                        action: function () {
                          t.pause(e);
                        },
                      }),
                      t
                    );
                  for (var r = t._getSoundIds(e), u = 0; u < r.length; u++) {
                    t._clearTimer(r[u]);
                    var v = t._soundById(r[u]);
                    if (
                      v &&
                      !v._paused &&
                      ((v._seek = t.seek(r[u])),
                      (v._rateSeek = 0),
                      (v._paused = !0),
                      t._stopFade(r[u]),
                      v._node)
                    )
                      if (t._webAudio) {
                        if (!v._node.bufferSource) continue;
                        typeof v._node.bufferSource.stop == "undefined"
                          ? v._node.bufferSource.noteOff(0)
                          : v._node.bufferSource.stop(0),
                          t._cleanBuffer(v._node);
                      } else
                        (!isNaN(v._node.duration) ||
                          v._node.duration === 1 / 0) &&
                          v._node.pause();
                    arguments[1] || t._emit("pause", v ? v._id : null);
                  }
                  return t;
                },
                stop: function (e, t) {
                  var r = this;
                  if (r._state !== "loaded" || r._playLock)
                    return (
                      r._queue.push({
                        event: "stop",
                        action: function () {
                          r.stop(e);
                        },
                      }),
                      r
                    );
                  for (var u = r._getSoundIds(e), v = 0; v < u.length; v++) {
                    r._clearTimer(u[v]);
                    var _ = r._soundById(u[v]);
                    _ &&
                      ((_._seek = _._start || 0),
                      (_._rateSeek = 0),
                      (_._paused = !0),
                      (_._ended = !0),
                      r._stopFade(u[v]),
                      _._node &&
                        (r._webAudio
                          ? _._node.bufferSource &&
                            (typeof _._node.bufferSource.stop == "undefined"
                              ? _._node.bufferSource.noteOff(0)
                              : _._node.bufferSource.stop(0),
                            r._cleanBuffer(_._node))
                          : (!isNaN(_._node.duration) ||
                              _._node.duration === 1 / 0) &&
                            ((_._node.currentTime = _._start || 0),
                            _._node.pause(),
                            _._node.duration === 1 / 0 &&
                              r._clearSound(_._node))),
                      t || r._emit("stop", _._id));
                  }
                  return r;
                },
                mute: function (e, t) {
                  var r = this;
                  if (r._state !== "loaded" || r._playLock)
                    return (
                      r._queue.push({
                        event: "mute",
                        action: function () {
                          r.mute(e, t);
                        },
                      }),
                      r
                    );
                  if (typeof t == "undefined")
                    if (typeof e == "boolean") r._muted = e;
                    else return r._muted;
                  for (var u = r._getSoundIds(t), v = 0; v < u.length; v++) {
                    var _ = r._soundById(u[v]);
                    _ &&
                      ((_._muted = e),
                      _._interval && r._stopFade(_._id),
                      r._webAudio && _._node
                        ? _._node.gain.setValueAtTime(
                            e ? 0 : _._volume,
                            c.ctx.currentTime
                          )
                        : _._node && (_._node.muted = c._muted ? !0 : e),
                      r._emit("mute", _._id));
                  }
                  return r;
                },
                volume: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u;
                  if (t.length === 0) return e._volume;
                  if (
                    t.length === 1 ||
                    (t.length === 2 && typeof t[1] == "undefined")
                  ) {
                    var v = e._getSoundIds(),
                      _ = v.indexOf(t[0]);
                    _ >= 0 ? (u = parseInt(t[0], 10)) : (r = parseFloat(t[0]));
                  } else
                    t.length >= 2 &&
                      ((r = parseFloat(t[0])), (u = parseInt(t[1], 10)));
                  var m;
                  if (typeof r != "undefined" && r >= 0 && r <= 1) {
                    if (e._state !== "loaded" || e._playLock)
                      return (
                        e._queue.push({
                          event: "volume",
                          action: function () {
                            e.volume.apply(e, t);
                          },
                        }),
                        e
                      );
                    typeof u == "undefined" && (e._volume = r),
                      (u = e._getSoundIds(u));
                    for (var g = 0; g < u.length; g++)
                      (m = e._soundById(u[g])),
                        m &&
                          ((m._volume = r),
                          t[2] || e._stopFade(u[g]),
                          e._webAudio && m._node && !m._muted
                            ? m._node.gain.setValueAtTime(r, c.ctx.currentTime)
                            : m._node &&
                              !m._muted &&
                              (m._node.volume = r * c.volume()),
                          e._emit("volume", m._id));
                  } else
                    return (
                      (m = u ? e._soundById(u) : e._sounds[0]),
                      m ? m._volume : 0
                    );
                  return e;
                },
                fade: function (e, t, r, u) {
                  var v = this;
                  if (v._state !== "loaded" || v._playLock)
                    return (
                      v._queue.push({
                        event: "fade",
                        action: function () {
                          v.fade(e, t, r, u);
                        },
                      }),
                      v
                    );
                  (e = Math.min(Math.max(0, parseFloat(e)), 1)),
                    (t = Math.min(Math.max(0, parseFloat(t)), 1)),
                    (r = parseFloat(r)),
                    v.volume(e, u);
                  for (var _ = v._getSoundIds(u), m = 0; m < _.length; m++) {
                    var g = v._soundById(_[m]);
                    if (g) {
                      if ((u || v._stopFade(_[m]), v._webAudio && !g._muted)) {
                        var T = c.ctx.currentTime,
                          E = T + r / 1e3;
                        (g._volume = e),
                          g._node.gain.setValueAtTime(e, T),
                          g._node.gain.linearRampToValueAtTime(t, E);
                      }
                      v._startFadeInterval(
                        g,
                        e,
                        t,
                        r,
                        _[m],
                        typeof u == "undefined"
                      );
                    }
                  }
                  return v;
                },
                _startFadeInterval: function (e, t, r, u, v, _) {
                  var m = this,
                    g = t,
                    T = r - t,
                    E = Math.abs(T / 0.01),
                    M = Math.max(4, E > 0 ? u / E : u),
                    R = Date.now();
                  (e._fadeTo = r),
                    (e._interval = setInterval(function () {
                      var P = (Date.now() - R) / u;
                      (R = Date.now()),
                        (g += T * P),
                        (g = Math.round(g * 100) / 100),
                        T < 0 ? (g = Math.max(r, g)) : (g = Math.min(r, g)),
                        m._webAudio ? (e._volume = g) : m.volume(g, e._id, !0),
                        _ && (m._volume = g),
                        ((r < t && g <= r) || (r > t && g >= r)) &&
                          (clearInterval(e._interval),
                          (e._interval = null),
                          (e._fadeTo = null),
                          m.volume(r, e._id),
                          m._emit("fade", e._id));
                    }, M));
                },
                _stopFade: function (e) {
                  var t = this,
                    r = t._soundById(e);
                  return (
                    r &&
                      r._interval &&
                      (t._webAudio &&
                        r._node.gain.cancelScheduledValues(c.ctx.currentTime),
                      clearInterval(r._interval),
                      (r._interval = null),
                      t.volume(r._fadeTo, e),
                      (r._fadeTo = null),
                      t._emit("fade", e)),
                    t
                  );
                },
                loop: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u,
                    v;
                  if (t.length === 0) return e._loop;
                  if (t.length === 1)
                    if (typeof t[0] == "boolean") (r = t[0]), (e._loop = r);
                    else
                      return (
                        (v = e._soundById(parseInt(t[0], 10))), v ? v._loop : !1
                      );
                  else t.length === 2 && ((r = t[0]), (u = parseInt(t[1], 10)));
                  for (var _ = e._getSoundIds(u), m = 0; m < _.length; m++)
                    (v = e._soundById(_[m])),
                      v &&
                        ((v._loop = r),
                        e._webAudio &&
                          v._node &&
                          v._node.bufferSource &&
                          ((v._node.bufferSource.loop = r),
                          r &&
                            ((v._node.bufferSource.loopStart = v._start || 0),
                            (v._node.bufferSource.loopEnd = v._stop),
                            e.playing(_[m]) &&
                              (e.pause(_[m], !0), e.play(_[m], !0)))));
                  return e;
                },
                rate: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u;
                  if (t.length === 0) u = e._sounds[0]._id;
                  else if (t.length === 1) {
                    var v = e._getSoundIds(),
                      _ = v.indexOf(t[0]);
                    _ >= 0 ? (u = parseInt(t[0], 10)) : (r = parseFloat(t[0]));
                  } else
                    t.length === 2 &&
                      ((r = parseFloat(t[0])), (u = parseInt(t[1], 10)));
                  var m;
                  if (typeof r == "number") {
                    if (e._state !== "loaded" || e._playLock)
                      return (
                        e._queue.push({
                          event: "rate",
                          action: function () {
                            e.rate.apply(e, t);
                          },
                        }),
                        e
                      );
                    typeof u == "undefined" && (e._rate = r),
                      (u = e._getSoundIds(u));
                    for (var g = 0; g < u.length; g++)
                      if (((m = e._soundById(u[g])), m)) {
                        e.playing(u[g]) &&
                          ((m._rateSeek = e.seek(u[g])),
                          (m._playStart = e._webAudio
                            ? c.ctx.currentTime
                            : m._playStart)),
                          (m._rate = r),
                          e._webAudio && m._node && m._node.bufferSource
                            ? m._node.bufferSource.playbackRate.setValueAtTime(
                                r,
                                c.ctx.currentTime
                              )
                            : m._node && (m._node.playbackRate = r);
                        var T = e.seek(u[g]),
                          E =
                            (e._sprite[m._sprite][0] +
                              e._sprite[m._sprite][1]) /
                              1e3 -
                            T,
                          M = (E * 1e3) / Math.abs(m._rate);
                        (e._endTimers[u[g]] || !m._paused) &&
                          (e._clearTimer(u[g]),
                          (e._endTimers[u[g]] = setTimeout(
                            e._ended.bind(e, m),
                            M
                          ))),
                          e._emit("rate", m._id);
                      }
                  } else return (m = e._soundById(u)), m ? m._rate : e._rate;
                  return e;
                },
                seek: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u;
                  if (t.length === 0)
                    e._sounds.length && (u = e._sounds[0]._id);
                  else if (t.length === 1) {
                    var v = e._getSoundIds(),
                      _ = v.indexOf(t[0]);
                    _ >= 0
                      ? (u = parseInt(t[0], 10))
                      : e._sounds.length &&
                        ((u = e._sounds[0]._id), (r = parseFloat(t[0])));
                  } else
                    t.length === 2 &&
                      ((r = parseFloat(t[0])), (u = parseInt(t[1], 10)));
                  if (typeof u == "undefined") return 0;
                  if (
                    typeof r == "number" &&
                    (e._state !== "loaded" || e._playLock)
                  )
                    return (
                      e._queue.push({
                        event: "seek",
                        action: function () {
                          e.seek.apply(e, t);
                        },
                      }),
                      e
                    );
                  var m = e._soundById(u);
                  if (m)
                    if (typeof r == "number" && r >= 0) {
                      var g = e.playing(u);
                      g && e.pause(u, !0),
                        (m._seek = r),
                        (m._ended = !1),
                        e._clearTimer(u),
                        !e._webAudio &&
                          m._node &&
                          !isNaN(m._node.duration) &&
                          (m._node.currentTime = r);
                      var T = function () {
                        g && e.play(u, !0), e._emit("seek", u);
                      };
                      if (g && !e._webAudio) {
                        var E = function () {
                          e._playLock ? setTimeout(E, 0) : T();
                        };
                        setTimeout(E, 0);
                      } else T();
                    } else if (e._webAudio) {
                      var M = e.playing(u)
                          ? c.ctx.currentTime - m._playStart
                          : 0,
                        R = m._rateSeek ? m._rateSeek - m._seek : 0;
                      return m._seek + (R + M * Math.abs(m._rate));
                    } else return m._node.currentTime;
                  return e;
                },
                playing: function (e) {
                  var t = this;
                  if (typeof e == "number") {
                    var r = t._soundById(e);
                    return r ? !r._paused : !1;
                  }
                  for (var u = 0; u < t._sounds.length; u++)
                    if (!t._sounds[u]._paused) return !0;
                  return !1;
                },
                duration: function (e) {
                  var t = this,
                    r = t._duration,
                    u = t._soundById(e);
                  return u && (r = t._sprite[u._sprite][1] / 1e3), r;
                },
                state: function () {
                  return this._state;
                },
                unload: function () {
                  for (var e = this, t = e._sounds, r = 0; r < t.length; r++)
                    t[r]._paused || e.stop(t[r]._id),
                      e._webAudio ||
                        (e._clearSound(t[r]._node),
                        t[r]._node.removeEventListener(
                          "error",
                          t[r]._errorFn,
                          !1
                        ),
                        t[r]._node.removeEventListener(
                          c._canPlayEvent,
                          t[r]._loadFn,
                          !1
                        ),
                        t[r]._node.removeEventListener(
                          "ended",
                          t[r]._endFn,
                          !1
                        ),
                        c._releaseHtml5Audio(t[r]._node)),
                      delete t[r]._node,
                      e._clearTimer(t[r]._id);
                  var u = c._howls.indexOf(e);
                  u >= 0 && c._howls.splice(u, 1);
                  var v = !0;
                  for (r = 0; r < c._howls.length; r++)
                    if (
                      c._howls[r]._src === e._src ||
                      e._src.indexOf(c._howls[r]._src) >= 0
                    ) {
                      v = !1;
                      break;
                    }
                  return (
                    f && v && delete f[e._src],
                    (c.noAudio = !1),
                    (e._state = "unloaded"),
                    (e._sounds = []),
                    (e = null),
                    null
                  );
                },
                on: function (e, t, r, u) {
                  var v = this,
                    _ = v["_on" + e];
                  return (
                    typeof t == "function" &&
                      _.push(u ? { id: r, fn: t, once: u } : { id: r, fn: t }),
                    v
                  );
                },
                off: function (e, t, r) {
                  var u = this,
                    v = u["_on" + e],
                    _ = 0;
                  if ((typeof t == "number" && ((r = t), (t = null)), t || r))
                    for (_ = 0; _ < v.length; _++) {
                      var m = r === v[_].id;
                      if ((t === v[_].fn && m) || (!t && m)) {
                        v.splice(_, 1);
                        break;
                      }
                    }
                  else if (e) u["_on" + e] = [];
                  else {
                    var g = Object.keys(u);
                    for (_ = 0; _ < g.length; _++)
                      g[_].indexOf("_on") === 0 &&
                        Array.isArray(u[g[_]]) &&
                        (u[g[_]] = []);
                  }
                  return u;
                },
                once: function (e, t, r) {
                  var u = this;
                  return u.on(e, t, r, 1), u;
                },
                _emit: function (e, t, r) {
                  for (
                    var u = this, v = u["_on" + e], _ = v.length - 1;
                    _ >= 0;
                    _--
                  )
                    (!v[_].id || v[_].id === t || e === "load") &&
                      (setTimeout(
                        function (m) {
                          m.call(this, t, r);
                        }.bind(u, v[_].fn),
                        0
                      ),
                      v[_].once && u.off(e, v[_].fn, v[_].id));
                  return u._loadQueue(e), u;
                },
                _loadQueue: function (e) {
                  var t = this;
                  if (t._queue.length > 0) {
                    var r = t._queue[0];
                    r.event === e && (t._queue.shift(), t._loadQueue()),
                      e || r.action();
                  }
                  return t;
                },
                _ended: function (e) {
                  var t = this,
                    r = e._sprite;
                  if (
                    !t._webAudio &&
                    e._node &&
                    !e._node.paused &&
                    !e._node.ended &&
                    e._node.currentTime < e._stop
                  )
                    return setTimeout(t._ended.bind(t, e), 100), t;
                  var u = !!(e._loop || t._sprite[r][2]);
                  if (
                    (t._emit("end", e._id),
                    !t._webAudio && u && t.stop(e._id, !0).play(e._id),
                    t._webAudio && u)
                  ) {
                    t._emit("play", e._id),
                      (e._seek = e._start || 0),
                      (e._rateSeek = 0),
                      (e._playStart = c.ctx.currentTime);
                    var v = ((e._stop - e._start) * 1e3) / Math.abs(e._rate);
                    t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), v);
                  }
                  return (
                    t._webAudio &&
                      !u &&
                      ((e._paused = !0),
                      (e._ended = !0),
                      (e._seek = e._start || 0),
                      (e._rateSeek = 0),
                      t._clearTimer(e._id),
                      t._cleanBuffer(e._node),
                      c._autoSuspend()),
                    !t._webAudio && !u && t.stop(e._id, !0),
                    t
                  );
                },
                _clearTimer: function (e) {
                  var t = this;
                  if (t._endTimers[e]) {
                    if (typeof t._endTimers[e] != "function")
                      clearTimeout(t._endTimers[e]);
                    else {
                      var r = t._soundById(e);
                      r &&
                        r._node &&
                        r._node.removeEventListener(
                          "ended",
                          t._endTimers[e],
                          !1
                        );
                    }
                    delete t._endTimers[e];
                  }
                  return t;
                },
                _soundById: function (e) {
                  for (var t = this, r = 0; r < t._sounds.length; r++)
                    if (e === t._sounds[r]._id) return t._sounds[r];
                  return null;
                },
                _inactiveSound: function () {
                  var e = this;
                  e._drain();
                  for (var t = 0; t < e._sounds.length; t++)
                    if (e._sounds[t]._ended) return e._sounds[t].reset();
                  return new h(e);
                },
                _drain: function () {
                  var e = this,
                    t = e._pool,
                    r = 0,
                    u = 0;
                  if (!(e._sounds.length < t)) {
                    for (u = 0; u < e._sounds.length; u++)
                      e._sounds[u]._ended && r++;
                    for (u = e._sounds.length - 1; u >= 0; u--) {
                      if (r <= t) return;
                      e._sounds[u]._ended &&
                        (e._webAudio &&
                          e._sounds[u]._node &&
                          e._sounds[u]._node.disconnect(0),
                        e._sounds.splice(u, 1),
                        r--);
                    }
                  }
                },
                _getSoundIds: function (e) {
                  var t = this;
                  if (typeof e == "undefined") {
                    for (var r = [], u = 0; u < t._sounds.length; u++)
                      r.push(t._sounds[u]._id);
                    return r;
                  } else return [e];
                },
                _refreshBuffer: function (e) {
                  var t = this;
                  return (
                    (e._node.bufferSource = c.ctx.createBufferSource()),
                    (e._node.bufferSource.buffer = f[t._src]),
                    e._panner
                      ? e._node.bufferSource.connect(e._panner)
                      : e._node.bufferSource.connect(e._node),
                    (e._node.bufferSource.loop = e._loop),
                    e._loop &&
                      ((e._node.bufferSource.loopStart = e._start || 0),
                      (e._node.bufferSource.loopEnd = e._stop || 0)),
                    e._node.bufferSource.playbackRate.setValueAtTime(
                      e._rate,
                      c.ctx.currentTime
                    ),
                    t
                  );
                },
                _cleanBuffer: function (e) {
                  var t = this,
                    r =
                      c._navigator && c._navigator.vendor.indexOf("Apple") >= 0;
                  if (!e.bufferSource) return t;
                  if (
                    c._scratchBuffer &&
                    e.bufferSource &&
                    ((e.bufferSource.onended = null),
                    e.bufferSource.disconnect(0),
                    r)
                  )
                    try {
                      e.bufferSource.buffer = c._scratchBuffer;
                    } catch (u) {}
                  return (e.bufferSource = null), t;
                },
                _clearSound: function (e) {
                  var t = /MSIE |Trident\//.test(
                    c._navigator && c._navigator.userAgent
                  );
                  t ||
                    (e.src =
                      "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
                },
              };
              var h = function (e) {
                (this._parent = e), this.init();
              };
              h.prototype = {
                init: function () {
                  var e = this,
                    t = e._parent;
                  return (
                    (e._muted = t._muted),
                    (e._loop = t._loop),
                    (e._volume = t._volume),
                    (e._rate = t._rate),
                    (e._seek = 0),
                    (e._paused = !0),
                    (e._ended = !0),
                    (e._sprite = "__default"),
                    (e._id = ++c._counter),
                    t._sounds.push(e),
                    e.create(),
                    e
                  );
                },
                create: function () {
                  var e = this,
                    t = e._parent,
                    r =
                      c._muted || e._muted || e._parent._muted ? 0 : e._volume;
                  return (
                    t._webAudio
                      ? ((e._node =
                          typeof c.ctx.createGain == "undefined"
                            ? c.ctx.createGainNode()
                            : c.ctx.createGain()),
                        e._node.gain.setValueAtTime(r, c.ctx.currentTime),
                        (e._node.paused = !0),
                        e._node.connect(c.masterGain))
                      : c.noAudio ||
                        ((e._node = c._obtainHtml5Audio()),
                        (e._errorFn = e._errorListener.bind(e)),
                        e._node.addEventListener("error", e._errorFn, !1),
                        (e._loadFn = e._loadListener.bind(e)),
                        e._node.addEventListener(
                          c._canPlayEvent,
                          e._loadFn,
                          !1
                        ),
                        (e._endFn = e._endListener.bind(e)),
                        e._node.addEventListener("ended", e._endFn, !1),
                        (e._node.src = t._src),
                        (e._node.preload =
                          t._preload === !0 ? "auto" : t._preload),
                        (e._node.volume = r * c.volume()),
                        e._node.load()),
                    e
                  );
                },
                reset: function () {
                  var e = this,
                    t = e._parent;
                  return (
                    (e._muted = t._muted),
                    (e._loop = t._loop),
                    (e._volume = t._volume),
                    (e._rate = t._rate),
                    (e._seek = 0),
                    (e._rateSeek = 0),
                    (e._paused = !0),
                    (e._ended = !0),
                    (e._sprite = "__default"),
                    (e._id = ++c._counter),
                    e
                  );
                },
                _errorListener: function () {
                  var e = this;
                  e._parent._emit(
                    "loaderror",
                    e._id,
                    e._node.error ? e._node.error.code : 0
                  ),
                    e._node.removeEventListener("error", e._errorFn, !1);
                },
                _loadListener: function () {
                  var e = this,
                    t = e._parent;
                  (t._duration = Math.ceil(e._node.duration * 10) / 10),
                    Object.keys(t._sprite).length === 0 &&
                      (t._sprite = { __default: [0, t._duration * 1e3] }),
                    t._state !== "loaded" &&
                      ((t._state = "loaded"), t._emit("load"), t._loadQueue()),
                    e._node.removeEventListener(c._canPlayEvent, e._loadFn, !1);
                },
                _endListener: function () {
                  var e = this,
                    t = e._parent;
                  t._duration === 1 / 0 &&
                    ((t._duration = Math.ceil(e._node.duration * 10) / 10),
                    t._sprite.__default[1] === 1 / 0 &&
                      (t._sprite.__default[1] = t._duration * 1e3),
                    t._ended(e)),
                    e._node.removeEventListener("ended", e._endFn, !1);
                },
              };
              var f = {},
                s = function (e) {
                  var t = e._src;
                  if (f[t]) {
                    (e._duration = f[t].duration), o(e);
                    return;
                  }
                  if (/^data:[^;]+;base64,/.test(t)) {
                    for (
                      var r = atob(t.split(",")[1]),
                        u = new Uint8Array(r.length),
                        v = 0;
                      v < r.length;
                      ++v
                    )
                      u[v] = r.charCodeAt(v);
                    n(u.buffer, e);
                  } else {
                    var _ = new XMLHttpRequest();
                    _.open(e._xhr.method, t, !0),
                      (_.withCredentials = e._xhr.withCredentials),
                      (_.responseType = "arraybuffer"),
                      e._xhr.headers &&
                        Object.keys(e._xhr.headers).forEach(function (m) {
                          _.setRequestHeader(m, e._xhr.headers[m]);
                        }),
                      (_.onload = function () {
                        var m = (_.status + "")[0];
                        if (m !== "0" && m !== "2" && m !== "3") {
                          e._emit(
                            "loaderror",
                            null,
                            "Failed loading audio file with status: " +
                              _.status +
                              "."
                          );
                          return;
                        }
                        n(_.response, e);
                      }),
                      (_.onerror = function () {
                        e._webAudio &&
                          ((e._html5 = !0),
                          (e._webAudio = !1),
                          (e._sounds = []),
                          delete f[t],
                          e.load());
                      }),
                      l(_);
                  }
                },
                l = function (e) {
                  try {
                    e.send();
                  } catch (t) {
                    e.onerror();
                  }
                },
                n = function (e, t) {
                  var r = function () {
                      t._emit("loaderror", null, "Decoding audio data failed.");
                    },
                    u = function (v) {
                      v && t._sounds.length > 0
                        ? ((f[t._src] = v), o(t, v))
                        : r();
                    };
                  typeof Promise != "undefined" &&
                  c.ctx.decodeAudioData.length === 1
                    ? c.ctx.decodeAudioData(e).then(u).catch(r)
                    : c.ctx.decodeAudioData(e, u, r);
                },
                o = function (e, t) {
                  t && !e._duration && (e._duration = t.duration),
                    Object.keys(e._sprite).length === 0 &&
                      (e._sprite = { __default: [0, e._duration * 1e3] }),
                    e._state !== "loaded" &&
                      ((e._state = "loaded"), e._emit("load"), e._loadQueue());
                },
                i = function () {
                  if (c.usingWebAudio) {
                    try {
                      typeof AudioContext != "undefined"
                        ? (c.ctx = new AudioContext())
                        : typeof webkitAudioContext != "undefined"
                        ? (c.ctx = new webkitAudioContext())
                        : (c.usingWebAudio = !1);
                    } catch (v) {
                      c.usingWebAudio = !1;
                    }
                    c.ctx || (c.usingWebAudio = !1);
                    var e = /iP(hone|od|ad)/.test(
                        c._navigator && c._navigator.platform
                      ),
                      t =
                        c._navigator &&
                        c._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                      r = t ? parseInt(t[1], 10) : null;
                    if (e && r && r < 9) {
                      var u = /safari/.test(
                        c._navigator && c._navigator.userAgent.toLowerCase()
                      );
                      c._navigator && !u && (c.usingWebAudio = !1);
                    }
                    c.usingWebAudio &&
                      ((c.masterGain =
                        typeof c.ctx.createGain == "undefined"
                          ? c.ctx.createGainNode()
                          : c.ctx.createGain()),
                      c.masterGain.gain.setValueAtTime(
                        c._muted ? 0 : c._volume,
                        c.ctx.currentTime
                      ),
                      c.masterGain.connect(c.ctx.destination)),
                      c._setup();
                  }
                };
              (A = []),
                (x = function () {
                  return { Howler: c, Howl: d };
                }.apply(V, A)),
                x !== void 0 && (xe.exports = x),
                (V.Howler = c),
                (V.Howl = d),
                typeof a.g != "undefined"
                  ? ((a.g.HowlerGlobal = y),
                    (a.g.Howler = c),
                    (a.g.Howl = d),
                    (a.g.Sound = h))
                  : typeof window != "undefined" &&
                    ((window.HowlerGlobal = y),
                    (window.Howler = c),
                    (window.Howl = d),
                    (window.Sound = h));
            })();
            /*!
             *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
             *
             *  howler.js v2.2.4
             *  howlerjs.com
             *
             *  (c) 2013-2020, James Simpson of GoldFire Studios
             *  goldfirestudios.com
             *
             *  MIT License
             */ (function () {
              "use strict";
              (HowlerGlobal.prototype._pos = [0, 0, 0]),
                (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
                (HowlerGlobal.prototype.stereo = function (c) {
                  var d = this;
                  if (!d.ctx || !d.ctx.listener) return d;
                  for (var h = d._howls.length - 1; h >= 0; h--)
                    d._howls[h].stereo(c);
                  return d;
                }),
                (HowlerGlobal.prototype.pos = function (c, d, h) {
                  var f = this;
                  if (!f.ctx || !f.ctx.listener) return f;
                  if (
                    ((d = typeof d != "number" ? f._pos[1] : d),
                    (h = typeof h != "number" ? f._pos[2] : h),
                    typeof c == "number")
                  )
                    (f._pos = [c, d, h]),
                      typeof f.ctx.listener.positionX != "undefined"
                        ? (f.ctx.listener.positionX.setTargetAtTime(
                            f._pos[0],
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          f.ctx.listener.positionY.setTargetAtTime(
                            f._pos[1],
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          f.ctx.listener.positionZ.setTargetAtTime(
                            f._pos[2],
                            Howler.ctx.currentTime,
                            0.1
                          ))
                        : f.ctx.listener.setPosition(
                            f._pos[0],
                            f._pos[1],
                            f._pos[2]
                          );
                  else return f._pos;
                  return f;
                }),
                (HowlerGlobal.prototype.orientation = function (
                  c,
                  d,
                  h,
                  f,
                  s,
                  l
                ) {
                  var n = this;
                  if (!n.ctx || !n.ctx.listener) return n;
                  var o = n._orientation;
                  if (
                    ((d = typeof d != "number" ? o[1] : d),
                    (h = typeof h != "number" ? o[2] : h),
                    (f = typeof f != "number" ? o[3] : f),
                    (s = typeof s != "number" ? o[4] : s),
                    (l = typeof l != "number" ? o[5] : l),
                    typeof c == "number")
                  )
                    (n._orientation = [c, d, h, f, s, l]),
                      typeof n.ctx.listener.forwardX != "undefined"
                        ? (n.ctx.listener.forwardX.setTargetAtTime(
                            c,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.forwardY.setTargetAtTime(
                            d,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.forwardZ.setTargetAtTime(
                            h,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.upX.setTargetAtTime(
                            f,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.upY.setTargetAtTime(
                            s,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.upZ.setTargetAtTime(
                            l,
                            Howler.ctx.currentTime,
                            0.1
                          ))
                        : n.ctx.listener.setOrientation(c, d, h, f, s, l);
                  else return o;
                  return n;
                }),
                (Howl.prototype.init = (function (c) {
                  return function (d) {
                    var h = this;
                    return (
                      (h._orientation = d.orientation || [1, 0, 0]),
                      (h._stereo = d.stereo || null),
                      (h._pos = d.pos || null),
                      (h._pannerAttr = {
                        coneInnerAngle:
                          typeof d.coneInnerAngle != "undefined"
                            ? d.coneInnerAngle
                            : 360,
                        coneOuterAngle:
                          typeof d.coneOuterAngle != "undefined"
                            ? d.coneOuterAngle
                            : 360,
                        coneOuterGain:
                          typeof d.coneOuterGain != "undefined"
                            ? d.coneOuterGain
                            : 0,
                        distanceModel:
                          typeof d.distanceModel != "undefined"
                            ? d.distanceModel
                            : "inverse",
                        maxDistance:
                          typeof d.maxDistance != "undefined"
                            ? d.maxDistance
                            : 1e4,
                        panningModel:
                          typeof d.panningModel != "undefined"
                            ? d.panningModel
                            : "HRTF",
                        refDistance:
                          typeof d.refDistance != "undefined"
                            ? d.refDistance
                            : 1,
                        rolloffFactor:
                          typeof d.rolloffFactor != "undefined"
                            ? d.rolloffFactor
                            : 1,
                      }),
                      (h._onstereo = d.onstereo ? [{ fn: d.onstereo }] : []),
                      (h._onpos = d.onpos ? [{ fn: d.onpos }] : []),
                      (h._onorientation = d.onorientation
                        ? [{ fn: d.onorientation }]
                        : []),
                      c.call(this, d)
                    );
                  };
                })(Howl.prototype.init)),
                (Howl.prototype.stereo = function (c, d) {
                  var h = this;
                  if (!h._webAudio) return h;
                  if (h._state !== "loaded")
                    return (
                      h._queue.push({
                        event: "stereo",
                        action: function () {
                          h.stereo(c, d);
                        },
                      }),
                      h
                    );
                  var f =
                    typeof Howler.ctx.createStereoPanner == "undefined"
                      ? "spatial"
                      : "stereo";
                  if (typeof d == "undefined")
                    if (typeof c == "number")
                      (h._stereo = c), (h._pos = [c, 0, 0]);
                    else return h._stereo;
                  for (var s = h._getSoundIds(d), l = 0; l < s.length; l++) {
                    var n = h._soundById(s[l]);
                    if (n)
                      if (typeof c == "number")
                        (n._stereo = c),
                          (n._pos = [c, 0, 0]),
                          n._node &&
                            ((n._pannerAttr.panningModel = "equalpower"),
                            (!n._panner || !n._panner.pan) && y(n, f),
                            f === "spatial"
                              ? typeof n._panner.positionX != "undefined"
                                ? (n._panner.positionX.setValueAtTime(
                                    c,
                                    Howler.ctx.currentTime
                                  ),
                                  n._panner.positionY.setValueAtTime(
                                    0,
                                    Howler.ctx.currentTime
                                  ),
                                  n._panner.positionZ.setValueAtTime(
                                    0,
                                    Howler.ctx.currentTime
                                  ))
                                : n._panner.setPosition(c, 0, 0)
                              : n._panner.pan.setValueAtTime(
                                  c,
                                  Howler.ctx.currentTime
                                )),
                          h._emit("stereo", n._id);
                      else return n._stereo;
                  }
                  return h;
                }),
                (Howl.prototype.pos = function (c, d, h, f) {
                  var s = this;
                  if (!s._webAudio) return s;
                  if (s._state !== "loaded")
                    return (
                      s._queue.push({
                        event: "pos",
                        action: function () {
                          s.pos(c, d, h, f);
                        },
                      }),
                      s
                    );
                  if (
                    ((d = typeof d != "number" ? 0 : d),
                    (h = typeof h != "number" ? -0.5 : h),
                    typeof f == "undefined")
                  )
                    if (typeof c == "number") s._pos = [c, d, h];
                    else return s._pos;
                  for (var l = s._getSoundIds(f), n = 0; n < l.length; n++) {
                    var o = s._soundById(l[n]);
                    if (o)
                      if (typeof c == "number")
                        (o._pos = [c, d, h]),
                          o._node &&
                            ((!o._panner || o._panner.pan) && y(o, "spatial"),
                            typeof o._panner.positionX != "undefined"
                              ? (o._panner.positionX.setValueAtTime(
                                  c,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.positionY.setValueAtTime(
                                  d,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.positionZ.setValueAtTime(
                                  h,
                                  Howler.ctx.currentTime
                                ))
                              : o._panner.setPosition(c, d, h)),
                          s._emit("pos", o._id);
                      else return o._pos;
                  }
                  return s;
                }),
                (Howl.prototype.orientation = function (c, d, h, f) {
                  var s = this;
                  if (!s._webAudio) return s;
                  if (s._state !== "loaded")
                    return (
                      s._queue.push({
                        event: "orientation",
                        action: function () {
                          s.orientation(c, d, h, f);
                        },
                      }),
                      s
                    );
                  if (
                    ((d = typeof d != "number" ? s._orientation[1] : d),
                    (h = typeof h != "number" ? s._orientation[2] : h),
                    typeof f == "undefined")
                  )
                    if (typeof c == "number") s._orientation = [c, d, h];
                    else return s._orientation;
                  for (var l = s._getSoundIds(f), n = 0; n < l.length; n++) {
                    var o = s._soundById(l[n]);
                    if (o)
                      if (typeof c == "number")
                        (o._orientation = [c, d, h]),
                          o._node &&
                            (o._panner ||
                              (o._pos || (o._pos = s._pos || [0, 0, -0.5]),
                              y(o, "spatial")),
                            typeof o._panner.orientationX != "undefined"
                              ? (o._panner.orientationX.setValueAtTime(
                                  c,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.orientationY.setValueAtTime(
                                  d,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.orientationZ.setValueAtTime(
                                  h,
                                  Howler.ctx.currentTime
                                ))
                              : o._panner.setOrientation(c, d, h)),
                          s._emit("orientation", o._id);
                      else return o._orientation;
                  }
                  return s;
                }),
                (Howl.prototype.pannerAttr = function () {
                  var c = this,
                    d = arguments,
                    h,
                    f,
                    s;
                  if (!c._webAudio) return c;
                  if (d.length === 0) return c._pannerAttr;
                  if (d.length === 1)
                    if (typeof d[0] == "object")
                      (h = d[0]),
                        typeof f == "undefined" &&
                          (h.pannerAttr ||
                            (h.pannerAttr = {
                              coneInnerAngle: h.coneInnerAngle,
                              coneOuterAngle: h.coneOuterAngle,
                              coneOuterGain: h.coneOuterGain,
                              distanceModel: h.distanceModel,
                              maxDistance: h.maxDistance,
                              refDistance: h.refDistance,
                              rolloffFactor: h.rolloffFactor,
                              panningModel: h.panningModel,
                            }),
                          (c._pannerAttr = {
                            coneInnerAngle:
                              typeof h.pannerAttr.coneInnerAngle != "undefined"
                                ? h.pannerAttr.coneInnerAngle
                                : c._coneInnerAngle,
                            coneOuterAngle:
                              typeof h.pannerAttr.coneOuterAngle != "undefined"
                                ? h.pannerAttr.coneOuterAngle
                                : c._coneOuterAngle,
                            coneOuterGain:
                              typeof h.pannerAttr.coneOuterGain != "undefined"
                                ? h.pannerAttr.coneOuterGain
                                : c._coneOuterGain,
                            distanceModel:
                              typeof h.pannerAttr.distanceModel != "undefined"
                                ? h.pannerAttr.distanceModel
                                : c._distanceModel,
                            maxDistance:
                              typeof h.pannerAttr.maxDistance != "undefined"
                                ? h.pannerAttr.maxDistance
                                : c._maxDistance,
                            refDistance:
                              typeof h.pannerAttr.refDistance != "undefined"
                                ? h.pannerAttr.refDistance
                                : c._refDistance,
                            rolloffFactor:
                              typeof h.pannerAttr.rolloffFactor != "undefined"
                                ? h.pannerAttr.rolloffFactor
                                : c._rolloffFactor,
                            panningModel:
                              typeof h.pannerAttr.panningModel != "undefined"
                                ? h.pannerAttr.panningModel
                                : c._panningModel,
                          }));
                    else
                      return (
                        (s = c._soundById(parseInt(d[0], 10))),
                        s ? s._pannerAttr : c._pannerAttr
                      );
                  else d.length === 2 && ((h = d[0]), (f = parseInt(d[1], 10)));
                  for (var l = c._getSoundIds(f), n = 0; n < l.length; n++)
                    if (((s = c._soundById(l[n])), s)) {
                      var o = s._pannerAttr;
                      o = {
                        coneInnerAngle:
                          typeof h.coneInnerAngle != "undefined"
                            ? h.coneInnerAngle
                            : o.coneInnerAngle,
                        coneOuterAngle:
                          typeof h.coneOuterAngle != "undefined"
                            ? h.coneOuterAngle
                            : o.coneOuterAngle,
                        coneOuterGain:
                          typeof h.coneOuterGain != "undefined"
                            ? h.coneOuterGain
                            : o.coneOuterGain,
                        distanceModel:
                          typeof h.distanceModel != "undefined"
                            ? h.distanceModel
                            : o.distanceModel,
                        maxDistance:
                          typeof h.maxDistance != "undefined"
                            ? h.maxDistance
                            : o.maxDistance,
                        refDistance:
                          typeof h.refDistance != "undefined"
                            ? h.refDistance
                            : o.refDistance,
                        rolloffFactor:
                          typeof h.rolloffFactor != "undefined"
                            ? h.rolloffFactor
                            : o.rolloffFactor,
                        panningModel:
                          typeof h.panningModel != "undefined"
                            ? h.panningModel
                            : o.panningModel,
                      };
                      var i = s._panner;
                      i ||
                        (s._pos || (s._pos = c._pos || [0, 0, -0.5]),
                        y(s, "spatial"),
                        (i = s._panner)),
                        (i.coneInnerAngle = o.coneInnerAngle),
                        (i.coneOuterAngle = o.coneOuterAngle),
                        (i.coneOuterGain = o.coneOuterGain),
                        (i.distanceModel = o.distanceModel),
                        (i.maxDistance = o.maxDistance),
                        (i.refDistance = o.refDistance),
                        (i.rolloffFactor = o.rolloffFactor),
                        (i.panningModel = o.panningModel);
                    }
                  return c;
                }),
                (Sound.prototype.init = (function (c) {
                  return function () {
                    var d = this,
                      h = d._parent;
                    (d._orientation = h._orientation),
                      (d._stereo = h._stereo),
                      (d._pos = h._pos),
                      (d._pannerAttr = h._pannerAttr),
                      c.call(this),
                      d._stereo
                        ? h.stereo(d._stereo)
                        : d._pos &&
                          h.pos(d._pos[0], d._pos[1], d._pos[2], d._id);
                  };
                })(Sound.prototype.init)),
                (Sound.prototype.reset = (function (c) {
                  return function () {
                    var d = this,
                      h = d._parent;
                    return (
                      (d._orientation = h._orientation),
                      (d._stereo = h._stereo),
                      (d._pos = h._pos),
                      (d._pannerAttr = h._pannerAttr),
                      d._stereo
                        ? h.stereo(d._stereo)
                        : d._pos
                        ? h.pos(d._pos[0], d._pos[1], d._pos[2], d._id)
                        : d._panner &&
                          (d._panner.disconnect(0),
                          (d._panner = void 0),
                          h._refreshBuffer(d)),
                      c.call(this)
                    );
                  };
                })(Sound.prototype.reset));
              var y = function (c, d) {
                (d = d || "spatial"),
                  d === "spatial"
                    ? ((c._panner = Howler.ctx.createPanner()),
                      (c._panner.coneInnerAngle = c._pannerAttr.coneInnerAngle),
                      (c._panner.coneOuterAngle = c._pannerAttr.coneOuterAngle),
                      (c._panner.coneOuterGain = c._pannerAttr.coneOuterGain),
                      (c._panner.distanceModel = c._pannerAttr.distanceModel),
                      (c._panner.maxDistance = c._pannerAttr.maxDistance),
                      (c._panner.refDistance = c._pannerAttr.refDistance),
                      (c._panner.rolloffFactor = c._pannerAttr.rolloffFactor),
                      (c._panner.panningModel = c._pannerAttr.panningModel),
                      typeof c._panner.positionX != "undefined"
                        ? (c._panner.positionX.setValueAtTime(
                            c._pos[0],
                            Howler.ctx.currentTime
                          ),
                          c._panner.positionY.setValueAtTime(
                            c._pos[1],
                            Howler.ctx.currentTime
                          ),
                          c._panner.positionZ.setValueAtTime(
                            c._pos[2],
                            Howler.ctx.currentTime
                          ))
                        : c._panner.setPosition(
                            c._pos[0],
                            c._pos[1],
                            c._pos[2]
                          ),
                      typeof c._panner.orientationX != "undefined"
                        ? (c._panner.orientationX.setValueAtTime(
                            c._orientation[0],
                            Howler.ctx.currentTime
                          ),
                          c._panner.orientationY.setValueAtTime(
                            c._orientation[1],
                            Howler.ctx.currentTime
                          ),
                          c._panner.orientationZ.setValueAtTime(
                            c._orientation[2],
                            Howler.ctx.currentTime
                          ))
                        : c._panner.setOrientation(
                            c._orientation[0],
                            c._orientation[1],
                            c._orientation[2]
                          ))
                    : ((c._panner = Howler.ctx.createStereoPanner()),
                      c._panner.pan.setValueAtTime(
                        c._stereo,
                        Howler.ctx.currentTime
                      )),
                  c._panner.connect(c._node),
                  c._paused || c._parent.pause(c._id, !0).play(c._id, !0);
              };
            })();
          },
          251: (xe, V) => {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ (V.read =
              function (a, A, x, y, c) {
                var d,
                  h,
                  f = c * 8 - y - 1,
                  s = (1 << f) - 1,
                  l = s >> 1,
                  n = -7,
                  o = x ? c - 1 : 0,
                  i = x ? -1 : 1,
                  e = a[A + o];
                for (
                  o += i, d = e & ((1 << -n) - 1), e >>= -n, n += f;
                  n > 0;
                  d = d * 256 + a[A + o], o += i, n -= 8
                );
                for (
                  h = d & ((1 << -n) - 1), d >>= -n, n += y;
                  n > 0;
                  h = h * 256 + a[A + o], o += i, n -= 8
                );
                if (d === 0) d = 1 - l;
                else {
                  if (d === s) return h ? NaN : (e ? -1 : 1) * (1 / 0);
                  (h = h + Math.pow(2, y)), (d = d - l);
                }
                return (e ? -1 : 1) * h * Math.pow(2, d - y);
              }),
              (V.write = function (a, A, x, y, c, d) {
                var h,
                  f,
                  s,
                  l = d * 8 - c - 1,
                  n = (1 << l) - 1,
                  o = n >> 1,
                  i = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                  e = y ? 0 : d - 1,
                  t = y ? 1 : -1,
                  r = A < 0 || (A === 0 && 1 / A < 0) ? 1 : 0;
                for (
                  A = Math.abs(A),
                    isNaN(A) || A === 1 / 0
                      ? ((f = isNaN(A) ? 1 : 0), (h = n))
                      : ((h = Math.floor(Math.log(A) / Math.LN2)),
                        A * (s = Math.pow(2, -h)) < 1 && (h--, (s *= 2)),
                        h + o >= 1
                          ? (A += i / s)
                          : (A += i * Math.pow(2, 1 - o)),
                        A * s >= 2 && (h++, (s /= 2)),
                        h + o >= n
                          ? ((f = 0), (h = n))
                          : h + o >= 1
                          ? ((f = (A * s - 1) * Math.pow(2, c)), (h = h + o))
                          : ((f = A * Math.pow(2, o - 1) * Math.pow(2, c)),
                            (h = 0)));
                  c >= 8;
                  a[x + e] = f & 255, e += t, f /= 256, c -= 8
                );
                for (
                  h = (h << c) | f, l += c;
                  l > 0;
                  a[x + e] = h & 255, e += t, h /= 256, l -= 8
                );
                a[x + e - t] |= r * 128;
              });
          },
          4751: (xe, V, a) => {
            "use strict";
            a.d(V, { _: () => A });
            function A() {
              return (
                (A = Object.assign
                  ? Object.assign.bind()
                  : function (x) {
                      for (var y = 1; y < arguments.length; y++) {
                        var c = arguments[y];
                        for (var d in c)
                          Object.prototype.hasOwnProperty.call(c, d) &&
                            (x[d] = c[d]);
                      }
                      return x;
                    }),
                A.apply(this, arguments)
              );
            }
          },
          6380: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $p: () => f,
              DE: () => t,
              IF: () => i,
              KO: () => e,
              Kt: () => n,
              Mq: () => h,
              Mu: () => u,
              OY: () => m,
              PH: () => v,
              ZB: () => o,
              ZF: () => s,
              ed: () => A,
              eq: () => r,
              oo: () => x,
              rC: () => d,
              sD: () => c,
              sh: () => y,
              tV: () => l,
              u8: () => _,
              yR: () => g,
            });
            const A = "RenderFrame",
              x = "RenderFrameTime",
              y = "RenderPass",
              c = "RenderPassDetail",
              d = "RenderAction",
              h = "RenderTargetAlloc",
              f = "TextureAlloc",
              s = "ShaderAlloc",
              l = "ShaderCompile",
              n = "VRAM.Texture",
              o = "VRAM.Vb",
              i = "VRAM.Ib",
              e = "BindGroupAlloc",
              t = "BindGroupFormatAlloc",
              r = "RenderPipelineAlloc",
              u = "PipelineLayoutAlloc",
              v = "Element",
              _ = "Textures",
              m = "RenderQueue",
              g = "GpuTimings";
          },
          8506: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $W: () => y,
              NW: () => s,
              QL: () => x,
              X$: () => l,
              lA: () => d,
              p: () => h,
              rE: () => A,
              sh: () => c,
            });
            const A = "1.65.4",
              x = "02ba39454",
              y = {},
              c = {},
              d = {},
              h = {},
              f = (function () {
                const n = {},
                  o = [
                    "Array",
                    "Object",
                    "Function",
                    "Date",
                    "RegExp",
                    "Float32Array",
                  ];
                for (let i = 0; i < o.length; i++)
                  n["[object " + o[i] + "]"] = o[i].toLowerCase();
                return n;
              })();
            function s(n) {
              if (n === null) return "null";
              const o = typeof n;
              return o === "undefined" ||
                o === "number" ||
                o === "string" ||
                o === "boolean"
                ? o
                : f[Object.prototype.toString.call(n)];
            }
            function l(n, o) {
              for (const i in o) {
                const e = o[i];
                s(e) === "object"
                  ? (n[i] = l({}, e))
                  : s(e) === "array"
                  ? (n[i] = l([], e))
                  : (n[i] = e);
              }
              return n;
            }
          },
          8976: (xe, V, a) => {
            "use strict";
            a.d(V, { J: () => A });
            class A {
              constructor() {
                (this._callbacks = new Map()),
                  (this._callbackActive = new Map());
              }
              initEventHandler() {
                (this._callbacks = new Map()),
                  (this._callbackActive = new Map());
              }
              _addCallback(y, c, d, h) {
                if (!(!y || typeof y != "string" || !c)) {
                  if (
                    (this._callbacks.has(y) || this._callbacks.set(y, []),
                    this._callbackActive.has(y))
                  ) {
                    const f = this._callbackActive.get(y);
                    f &&
                      f === this._callbacks.get(y) &&
                      this._callbackActive.set(y, f.slice());
                  }
                  this._callbacks
                    .get(y)
                    .push({ callback: c, scope: d, once: h });
                }
              }
              on(y, c, d = this) {
                return this._addCallback(y, c, d, !1), this;
              }
              once(y, c, d = this) {
                return this._addCallback(y, c, d, !0), this;
              }
              off(y, c, d) {
                if (y)
                  this._callbackActive.has(y) &&
                    this._callbackActive.get(y) === this._callbacks.get(y) &&
                    this._callbackActive.set(
                      y,
                      this._callbackActive.get(y).slice()
                    );
                else
                  for (const [h, f] of this._callbackActive)
                    this._callbacks.has(h) &&
                      this._callbacks.get(h) === f &&
                      this._callbackActive.set(h, f.slice());
                if (!y) this._callbacks.clear();
                else if (!c)
                  this._callbacks.has(y) && this._callbacks.delete(y);
                else {
                  const h = this._callbacks.get(y);
                  if (!h) return this;
                  let f = h.length;
                  for (let s = 0; s < f; s++)
                    h[s].callback === c &&
                      ((d && h[s].scope !== d) || (h[s--] = h[--f]));
                  (h.length = f), h.length === 0 && this._callbacks.delete(y);
                }
                return this;
              }
              fire(y, c, d, h, f, s, l, n, o) {
                if (!y) return this;
                const i = this._callbacks.get(y);
                if (!i) return this;
                let e;
                this._callbackActive.has(y)
                  ? this._callbackActive.get(y) !== i && (e = i.slice())
                  : this._callbackActive.set(y, i);
                for (
                  let t = 0;
                  (e || this._callbackActive.get(y)) &&
                  t < (e || this._callbackActive.get(y)).length;
                  t++
                ) {
                  const r = (e || this._callbackActive.get(y))[t];
                  if (
                    (r.callback.call(r.scope, c, d, h, f, s, l, n, o), r.once)
                  ) {
                    const u = this._callbacks.get(y),
                      v = u ? u.indexOf(r) : -1;
                    if (v !== -1) {
                      this._callbackActive.get(y) === u &&
                        this._callbackActive.set(
                          y,
                          this._callbackActive.get(y).slice()
                        );
                      const _ = this._callbacks.get(y);
                      if (!_) continue;
                      _.splice(v, 1),
                        _.length === 0 && this._callbacks.delete(y);
                    }
                  }
                }
                return e || this._callbackActive.delete(y), this;
              }
              hasEvent(y) {
                var c;
                return !!((c = this._callbacks.get(y)) != null && c.length);
              }
            }
          },
          9048: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => x });
            var A = a(8976);
            const x = {
              attach: function (y) {
                const c = x;
                return (
                  (y._addCallback = c._addCallback),
                  (y.on = c.on),
                  (y.off = c.off),
                  (y.fire = c.fire),
                  (y.once = c.once),
                  (y.hasEvent = c.hasEvent),
                  A.J.prototype.initEventHandler.call(y),
                  y
                );
              },
              _addCallback: A.J.prototype._addCallback,
              on: A.J.prototype.on,
              off: A.J.prototype.off,
              fire: A.J.prototype.fire,
              once: A.J.prototype.once,
              hasEvent: A.J.prototype.hasEvent,
            };
          },
          4172: (xe, V, a) => {
            "use strict";
            a.d(V, { O: () => A });
            const A = {
              create: function () {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
                  /[xy]/g,
                  function (x) {
                    const y = (Math.random() * 16) | 0;
                    return (x === "x" ? y : (y & 3) | 8).toString(16);
                  }
                );
              },
            };
          },
          8981: (xe, V, a) => {
            "use strict";
            a.d(V, { m: () => x, s: () => A });
            function A(y) {
              let c = 0;
              for (let d = 0, h = y.length; d < h; d++)
                (c = (c << 5) - c + y.charCodeAt(d)), (c |= 0);
              return c;
            }
            function x(y) {
              let d = 2166136261;
              for (let h = 0; h < y.length; h++) (d ^= y[h]), (d *= 16777619);
              return d >>> 0;
            }
          },
          4529: (xe, V, a) => {
            "use strict";
            a.d(V, { Q: () => A });
            class A {
              constructor() {
                (this._list = []), (this._index = {});
              }
              push(y, c) {
                if (this._index[y]) throw Error("Key already in index " + y);
                const d = this._list.push(c) - 1;
                this._index[y] = d;
              }
              has(y) {
                return this._index[y] !== void 0;
              }
              get(y) {
                const c = this._index[y];
                return c !== void 0 ? this._list[c] : null;
              }
              remove(y) {
                const c = this._index[y];
                if (c !== void 0) {
                  this._list.splice(c, 1), delete this._index[y];
                  for (y in this._index) {
                    const d = this._index[y];
                    d > c && (this._index[y] = d - 1);
                  }
                  return !0;
                }
                return !1;
              }
              list() {
                return this._list;
              }
              clear() {
                this._list.length = 0;
                for (const y in this._index) delete this._index[y];
              }
            }
          },
          5917: (xe, V, a) => {
            "use strict";
            a.d(V, { p: () => A });
            const A = {
              set: function (x, y, c, d = 1) {
                return (x & ~(d << c)) | (y << c);
              },
              get: function (x, y, c = 1) {
                return (x >> y) & c;
              },
              all: function (x, y, c = 1) {
                const d = c << y;
                return (x & d) === d;
              },
              any: function (x, y, c = 1) {
                return (x & (c << y)) !== 0;
              },
            };
          },
          5227: (xe, V, a) => {
            "use strict";
            a.d(V, { Q: () => x });
            var A = a(8656);
            class x {
              constructor(c = 0, d = 0, h = 0, f = 1) {
                (this.r = void 0),
                  (this.g = void 0),
                  (this.b = void 0),
                  (this.a = void 0);
                const s = c.length;
                s === 3 || s === 4
                  ? ((this.r = c[0]),
                    (this.g = c[1]),
                    (this.b = c[2]),
                    (this.a = c[3] !== void 0 ? c[3] : 1))
                  : ((this.r = c), (this.g = d), (this.b = h), (this.a = f));
              }
              clone() {
                const c = this.constructor;
                return new c(this.r, this.g, this.b, this.a);
              }
              copy(c) {
                return (
                  (this.r = c.r),
                  (this.g = c.g),
                  (this.b = c.b),
                  (this.a = c.a),
                  this
                );
              }
              equals(c) {
                return (
                  this.r === c.r &&
                  this.g === c.g &&
                  this.b === c.b &&
                  this.a === c.a
                );
              }
              set(c, d, h, f = 1) {
                return (
                  (this.r = c), (this.g = d), (this.b = h), (this.a = f), this
                );
              }
              lerp(c, d, h) {
                return (
                  (this.r = c.r + h * (d.r - c.r)),
                  (this.g = c.g + h * (d.g - c.g)),
                  (this.b = c.b + h * (d.b - c.b)),
                  (this.a = c.a + h * (d.a - c.a)),
                  this
                );
              }
              fromString(c) {
                const d = parseInt(c.replace("#", "0x"), 16);
                let h;
                return (
                  c.length > 7
                    ? (h = A.D.intToBytes32(d))
                    : ((h = A.D.intToBytes24(d)), (h[3] = 255)),
                  this.set(h[0] / 255, h[1] / 255, h[2] / 255, h[3] / 255),
                  this
                );
              }
              toString(c) {
                let d =
                  "#" +
                  (
                    16777216 +
                    (Math.round(this.r * 255) << 16) +
                    (Math.round(this.g * 255) << 8) +
                    Math.round(this.b * 255)
                  )
                    .toString(16)
                    .slice(1);
                if (c === !0) {
                  const h = Math.round(this.a * 255).toString(16);
                  this.a < 0.06274509803921569 ? (d += "0" + h) : (d += h);
                }
                return d;
              }
            }
            (x.BLACK = Object.freeze(new x(0, 0, 0, 1))),
              (x.BLUE = Object.freeze(new x(0, 0, 1, 1))),
              (x.CYAN = Object.freeze(new x(0, 1, 1, 1))),
              (x.GRAY = Object.freeze(new x(0.5, 0.5, 0.5, 1))),
              (x.GREEN = Object.freeze(new x(0, 1, 0, 1))),
              (x.MAGENTA = Object.freeze(new x(1, 0, 1, 1))),
              (x.RED = Object.freeze(new x(1, 0, 0, 1))),
              (x.WHITE = Object.freeze(new x(1, 1, 1, 1))),
              (x.YELLOW = Object.freeze(new x(1, 1, 0, 1)));
          },
          4041: (xe, V, a) => {
            "use strict";
            a.d(V, {
              RP: () => h,
              WO: () => d,
              io: () => A,
              tS: () => x,
              vd: () => y,
              vl: () => c,
            });
            const A = 0,
              x = 1,
              y = 2,
              c = 3,
              d = 4,
              h = 5;
          },
          5275: (xe, V, a) => {
            "use strict";
            a.d(V, { h: () => y });
            var A = a(4041),
              x = a(8656);
            class y {
              constructor(d, h = 0) {
                (this._curve = void 0),
                  (this._left = -1 / 0),
                  (this._right = 1 / 0),
                  (this._recip = 0),
                  (this._p0 = 0),
                  (this._p1 = 0),
                  (this._m0 = 0),
                  (this._m1 = 0),
                  (this._curve = d),
                  this._reset(h);
              }
              evaluate(d, h = !1) {
                (h || d < this._left || d >= this._right) && this._reset(d);
                let f;
                const s = this._curve.type;
                if (s === A.RP) f = this._p0;
                else {
                  const l =
                    this._recip === 0 ? 0 : (d - this._left) * this._recip;
                  s === A.io
                    ? (f = x.D.lerp(this._p0, this._p1, l))
                    : s === A.tS
                    ? (f = x.D.lerp(this._p0, this._p1, l * l * (3 - 2 * l)))
                    : (f = this._evaluateHermite(
                        this._p0,
                        this._p1,
                        this._m0,
                        this._m1,
                        l
                      ));
                }
                return f;
              }
              _reset(d) {
                const h = this._curve.keys,
                  f = h.length;
                if (!f)
                  (this._left = -1 / 0),
                    (this._right = 1 / 0),
                    (this._recip = 0),
                    (this._p0 = this._p1 = this._m0 = this._m1 = 0);
                else if (d < h[0][0])
                  (this._left = -1 / 0),
                    (this._right = h[0][0]),
                    (this._recip = 0),
                    (this._p0 = this._p1 = h[0][1]),
                    (this._m0 = this._m1 = 0);
                else if (d >= h[f - 1][0])
                  (this._left = h[f - 1][0]),
                    (this._right = 1 / 0),
                    (this._recip = 0),
                    (this._p0 = this._p1 = h[f - 1][1]),
                    (this._m0 = this._m1 = 0);
                else {
                  let s = 0;
                  for (; d >= h[s + 1][0]; ) s++;
                  (this._left = h[s][0]), (this._right = h[s + 1][0]);
                  const l = 1 / (this._right - this._left);
                  (this._recip = isFinite(l) ? l : 0),
                    (this._p0 = h[s][1]),
                    (this._p1 = h[s + 1][1]),
                    this._isHermite() && this._calcTangents(h, s);
                }
              }
              _isHermite() {
                return (
                  this._curve.type === A.vd ||
                  this._curve.type === A.vl ||
                  this._curve.type === A.WO
                );
              }
              _calcTangents(d, h) {
                let f;
                const s = d[h],
                  l = d[h + 1];
                let n;
                if (
                  (h === 0
                    ? (f = [
                        d[0][0] + (d[0][0] - d[1][0]),
                        d[0][1] + (d[0][1] - d[1][1]),
                      ])
                    : (f = d[h - 1]),
                  h === d.length - 2
                    ? (n = [
                        d[h + 1][0] + (d[h + 1][0] - d[h][0]),
                        d[h + 1][1] + (d[h + 1][1] - d[h][1]),
                      ])
                    : (n = d[h + 2]),
                  this._curve.type === A.WO)
                ) {
                  const o = (2 * (l[0] - s[0])) / (l[0] - f[0]),
                    i = (2 * (l[0] - s[0])) / (n[0] - s[0]);
                  (this._m0 =
                    this._curve.tension *
                    (isFinite(o) ? o : 0) *
                    (l[1] - f[1])),
                    (this._m1 =
                      this._curve.tension *
                      (isFinite(i) ? i : 0) *
                      (n[1] - s[1]));
                } else {
                  const o = (l[0] - s[0]) / (s[0] - f[0]),
                    i = (l[0] - s[0]) / (n[0] - l[0]),
                    e = s[1] + (f[1] - s[1]) * (isFinite(o) ? o : 0),
                    t = l[1] + (n[1] - l[1]) * (isFinite(i) ? i : 0),
                    r = this._curve.type === A.vd ? 0.5 : this._curve.tension;
                  (this._m0 = r * (l[1] - e)), (this._m1 = r * (t - s[1]));
                }
              }
              _evaluateHermite(d, h, f, s, l) {
                const n = l * l,
                  o = l + l,
                  i = 1 - l,
                  e = i * i;
                return (
                  d * ((1 + o) * e) +
                  f * (l * e) +
                  h * (n * (3 - o)) +
                  s * (n * (l - 1))
                );
              }
            }
          },
          2358: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => c });
            var A = a(4041),
              x = a(5567),
              y = a(5275);
            class c {
              constructor() {
                if (
                  ((this.curves = []),
                  (this._type = A.tS),
                  arguments.length > 1)
                )
                  for (let h = 0; h < arguments.length; h++)
                    this.curves.push(new x.I(arguments[h]));
                else if (arguments.length === 0) this.curves.push(new x.I());
                else {
                  const h = arguments[0];
                  if (typeof h == "number")
                    for (let f = 0; f < h; f++) this.curves.push(new x.I());
                  else
                    for (let f = 0; f < h.length; f++)
                      this.curves.push(new x.I(h[f]));
                }
              }
              get length() {
                return this.curves.length;
              }
              set type(h) {
                this._type = h;
                for (let f = 0; f < this.curves.length; f++)
                  this.curves[f].type = h;
              }
              get type() {
                return this._type;
              }
              get(h) {
                return this.curves[h];
              }
              value(h, f = []) {
                const s = this.curves.length;
                f.length = s;
                for (let l = 0; l < s; l++) f[l] = this.curves[l].value(h);
                return f;
              }
              clone() {
                const h = new this.constructor();
                h.curves = [];
                for (let f = 0; f < this.curves.length; f++)
                  h.curves.push(this.curves[f].clone());
                return (h._type = this._type), h;
              }
              quantize(h) {
                h = Math.max(h, 2);
                const f = this.curves.length,
                  s = new Float32Array(h * f),
                  l = 1 / (h - 1);
                for (let n = 0; n < f; n++) {
                  const o = new y.h(this.curves[n]);
                  for (let i = 0; i < h; i++) s[i * f + n] = o.evaluate(l * i);
                }
                return s;
              }
              quantizeClamped(h, f, s) {
                const l = this.quantize(h);
                for (let n = 0; n < l.length; ++n)
                  l[n] = Math.min(s, Math.max(f, l[n]));
                return l;
              }
            }
          },
          5567: (xe, V, a) => {
            "use strict";
            a.d(V, { I: () => c });
            var A = a(8506),
              x = a(4041),
              y = a(5275);
            class c {
              constructor(h) {
                if (
                  ((this.keys = []),
                  (this.type = x.tS),
                  (this.tension = 0.5),
                  (this._eval = new y.h(this)),
                  h)
                )
                  for (let f = 0; f < h.length - 1; f += 2)
                    this.keys.push([h[f], h[f + 1]]);
                this.sort();
              }
              get length() {
                return this.keys.length;
              }
              add(h, f) {
                const s = this.keys,
                  l = s.length;
                let n = 0;
                for (; n < l && !(s[n][0] > h); n++);
                const o = [h, f];
                return this.keys.splice(n, 0, o), o;
              }
              get(h) {
                return this.keys[h];
              }
              sort() {
                this.keys.sort(function (h, f) {
                  return h[0] - f[0];
                });
              }
              value(h) {
                return this._eval.evaluate(h, !0);
              }
              closest(h) {
                const f = this.keys,
                  s = f.length;
                let l = 2,
                  n = null;
                for (let o = 0; o < s; o++) {
                  const i = Math.abs(h - f[o][0]);
                  if (l >= i) (l = i), (n = f[o]);
                  else break;
                }
                return n;
              }
              clone() {
                const h = new this.constructor();
                return (
                  (h.keys = (0, A.X$)(h.keys, this.keys)),
                  (h.type = this.type),
                  (h.tension = this.tension),
                  h
                );
              }
              quantize(h) {
                h = Math.max(h, 2);
                const f = new Float32Array(h),
                  s = 1 / (h - 1);
                f[0] = this._eval.evaluate(0, !0);
                for (let l = 1; l < h; l++) f[l] = this._eval.evaluate(s * l);
                return f;
              }
              quantizeClamped(h, f, s) {
                const l = this.quantize(h);
                for (let n = 0; n < l.length; ++n)
                  l[n] = Math.min(s, Math.max(f, l[n]));
                return l;
              }
            }
          },
          3064: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => d });
            var A = a(8656);
            const x = 1 / 255,
              y = new Float32Array(1),
              c = new Int32Array(y.buffer);
            class d {
              static float2Half(f) {
                y[0] = f;
                const s = c[0];
                let l = (s >> 16) & 32768,
                  n = (s >> 12) & 2047;
                const o = (s >> 23) & 255;
                return o < 103
                  ? l
                  : o > 142
                  ? ((l |= 31744), (l |= (o === 255 ? 0 : 1) && s & 8388607), l)
                  : o < 113
                  ? ((n |= 2048),
                    (l |= (n >> (114 - o)) + ((n >> (113 - o)) & 1)),
                    l)
                  : ((l |= ((o - 112) << 10) | (n >> 1)), (l += n & 1), l);
              }
              static float2Bytes(f, s, l, n) {
                const o = (255 * f) % 1;
                if (((s[l + 0] = Math.round(((f % 1) - x * o) * 255)), n > 1)) {
                  const i = (65025 * f) % 1;
                  if (((s[l + 1] = Math.round((o - x * i) * 255)), n > 2)) {
                    const e = (16581375 * f) % 1;
                    (s[l + 2] = Math.round((i - x * e) * 255)),
                      n > 3 && (s[l + 3] = Math.round(e * 255));
                  }
                }
              }
              static float2BytesRange(f, s, l, n, o, i) {
                (f = A.D.clamp((f - n) / (o - n), 0, 1)),
                  d.float2Bytes(f, s, l, i);
              }
              static float2MantissaExponent(f, s, l, n) {
                const o = Math.floor(Math.log2(Math.abs(f))) + 1;
                (f /= Math.pow(2, o)),
                  d.float2BytesRange(f, s, l, -1, 1, n - 1),
                  (s[l + n - 1] = Math.round(o + 127));
              }
            }
          },
          2209: (xe, V, a) => {
            "use strict";
            a.d(V, { U: () => x });
            var A = a(7481);
            class x {
              constructor() {
                (this.data = new Float32Array(9)),
                  (this.data[0] = this.data[4] = this.data[8] = 1);
              }
              clone() {
                const c = this.constructor;
                return new c().copy(this);
              }
              copy(c) {
                const d = c.data,
                  h = this.data;
                return (
                  (h[0] = d[0]),
                  (h[1] = d[1]),
                  (h[2] = d[2]),
                  (h[3] = d[3]),
                  (h[4] = d[4]),
                  (h[5] = d[5]),
                  (h[6] = d[6]),
                  (h[7] = d[7]),
                  (h[8] = d[8]),
                  this
                );
              }
              set(c) {
                const d = this.data;
                return (
                  (d[0] = c[0]),
                  (d[1] = c[1]),
                  (d[2] = c[2]),
                  (d[3] = c[3]),
                  (d[4] = c[4]),
                  (d[5] = c[5]),
                  (d[6] = c[6]),
                  (d[7] = c[7]),
                  (d[8] = c[8]),
                  this
                );
              }
              equals(c) {
                const d = this.data,
                  h = c.data;
                return (
                  d[0] === h[0] &&
                  d[1] === h[1] &&
                  d[2] === h[2] &&
                  d[3] === h[3] &&
                  d[4] === h[4] &&
                  d[5] === h[5] &&
                  d[6] === h[6] &&
                  d[7] === h[7] &&
                  d[8] === h[8]
                );
              }
              isIdentity() {
                const c = this.data;
                return (
                  c[0] === 1 &&
                  c[1] === 0 &&
                  c[2] === 0 &&
                  c[3] === 0 &&
                  c[4] === 1 &&
                  c[5] === 0 &&
                  c[6] === 0 &&
                  c[7] === 0 &&
                  c[8] === 1
                );
              }
              setIdentity() {
                const c = this.data;
                return (
                  (c[0] = 1),
                  (c[1] = 0),
                  (c[2] = 0),
                  (c[3] = 0),
                  (c[4] = 1),
                  (c[5] = 0),
                  (c[6] = 0),
                  (c[7] = 0),
                  (c[8] = 1),
                  this
                );
              }
              toString() {
                return "[" + this.data.join(", ") + "]";
              }
              transpose() {
                const c = this.data;
                let d;
                return (
                  (d = c[1]),
                  (c[1] = c[3]),
                  (c[3] = d),
                  (d = c[2]),
                  (c[2] = c[6]),
                  (c[6] = d),
                  (d = c[5]),
                  (c[5] = c[7]),
                  (c[7] = d),
                  this
                );
              }
              setFromMat4(c) {
                const d = c.data,
                  h = this.data;
                return (
                  (h[0] = d[0]),
                  (h[1] = d[1]),
                  (h[2] = d[2]),
                  (h[3] = d[4]),
                  (h[4] = d[5]),
                  (h[5] = d[6]),
                  (h[6] = d[8]),
                  (h[7] = d[9]),
                  (h[8] = d[10]),
                  this
                );
              }
              transformVector(c, d = new A.e()) {
                const h = this.data,
                  f = c.x,
                  s = c.y,
                  l = c.z;
                return (
                  (d.x = f * h[0] + s * h[3] + l * h[6]),
                  (d.y = f * h[1] + s * h[4] + l * h[7]),
                  (d.z = f * h[2] + s * h[5] + l * h[8]),
                  d
                );
              }
            }
            (x.IDENTITY = Object.freeze(new x())),
              (x.ZERO = Object.freeze(
                new x().set([0, 0, 0, 0, 0, 0, 0, 0, 0])
              ));
          },
          8484: (xe, V, a) => {
            "use strict";
            a.d(V, { $: () => n });
            var A = a(8656),
              x = a(7994),
              y = a(7481),
              c = a(5596);
            const d = new x.Z(),
              h = new y.e(),
              f = new y.e(),
              s = new y.e(),
              l = new y.e();
            class n {
              constructor() {
                (this.data = new Float32Array(16)),
                  (this.data[0] =
                    this.data[5] =
                    this.data[10] =
                    this.data[15] =
                      1);
              }
              static _getPerspectiveHalfSize(i, e, t, r, u) {
                u
                  ? ((i.x = r * Math.tan((e * Math.PI) / 360)), (i.y = i.x / t))
                  : ((i.y = r * Math.tan((e * Math.PI) / 360)),
                    (i.x = i.y * t));
              }
              add2(i, e) {
                const t = i.data,
                  r = e.data,
                  u = this.data;
                return (
                  (u[0] = t[0] + r[0]),
                  (u[1] = t[1] + r[1]),
                  (u[2] = t[2] + r[2]),
                  (u[3] = t[3] + r[3]),
                  (u[4] = t[4] + r[4]),
                  (u[5] = t[5] + r[5]),
                  (u[6] = t[6] + r[6]),
                  (u[7] = t[7] + r[7]),
                  (u[8] = t[8] + r[8]),
                  (u[9] = t[9] + r[9]),
                  (u[10] = t[10] + r[10]),
                  (u[11] = t[11] + r[11]),
                  (u[12] = t[12] + r[12]),
                  (u[13] = t[13] + r[13]),
                  (u[14] = t[14] + r[14]),
                  (u[15] = t[15] + r[15]),
                  this
                );
              }
              add(i) {
                return this.add2(this, i);
              }
              clone() {
                const i = this.constructor;
                return new i().copy(this);
              }
              copy(i) {
                const e = i.data,
                  t = this.data;
                return (
                  (t[0] = e[0]),
                  (t[1] = e[1]),
                  (t[2] = e[2]),
                  (t[3] = e[3]),
                  (t[4] = e[4]),
                  (t[5] = e[5]),
                  (t[6] = e[6]),
                  (t[7] = e[7]),
                  (t[8] = e[8]),
                  (t[9] = e[9]),
                  (t[10] = e[10]),
                  (t[11] = e[11]),
                  (t[12] = e[12]),
                  (t[13] = e[13]),
                  (t[14] = e[14]),
                  (t[15] = e[15]),
                  this
                );
              }
              equals(i) {
                const e = this.data,
                  t = i.data;
                return (
                  e[0] === t[0] &&
                  e[1] === t[1] &&
                  e[2] === t[2] &&
                  e[3] === t[3] &&
                  e[4] === t[4] &&
                  e[5] === t[5] &&
                  e[6] === t[6] &&
                  e[7] === t[7] &&
                  e[8] === t[8] &&
                  e[9] === t[9] &&
                  e[10] === t[10] &&
                  e[11] === t[11] &&
                  e[12] === t[12] &&
                  e[13] === t[13] &&
                  e[14] === t[14] &&
                  e[15] === t[15]
                );
              }
              isIdentity() {
                const i = this.data;
                return (
                  i[0] === 1 &&
                  i[1] === 0 &&
                  i[2] === 0 &&
                  i[3] === 0 &&
                  i[4] === 0 &&
                  i[5] === 1 &&
                  i[6] === 0 &&
                  i[7] === 0 &&
                  i[8] === 0 &&
                  i[9] === 0 &&
                  i[10] === 1 &&
                  i[11] === 0 &&
                  i[12] === 0 &&
                  i[13] === 0 &&
                  i[14] === 0 &&
                  i[15] === 1
                );
              }
              mul2(i, e) {
                const t = i.data,
                  r = e.data,
                  u = this.data,
                  v = t[0],
                  _ = t[1],
                  m = t[2],
                  g = t[3],
                  T = t[4],
                  E = t[5],
                  M = t[6],
                  R = t[7],
                  P = t[8],
                  F = t[9],
                  b = t[10],
                  D = t[11],
                  G = t[12],
                  X = t[13],
                  ie = t[14],
                  Q = t[15];
                let te, ae, Z, J;
                return (
                  (te = r[0]),
                  (ae = r[1]),
                  (Z = r[2]),
                  (J = r[3]),
                  (u[0] = v * te + T * ae + P * Z + G * J),
                  (u[1] = _ * te + E * ae + F * Z + X * J),
                  (u[2] = m * te + M * ae + b * Z + ie * J),
                  (u[3] = g * te + R * ae + D * Z + Q * J),
                  (te = r[4]),
                  (ae = r[5]),
                  (Z = r[6]),
                  (J = r[7]),
                  (u[4] = v * te + T * ae + P * Z + G * J),
                  (u[5] = _ * te + E * ae + F * Z + X * J),
                  (u[6] = m * te + M * ae + b * Z + ie * J),
                  (u[7] = g * te + R * ae + D * Z + Q * J),
                  (te = r[8]),
                  (ae = r[9]),
                  (Z = r[10]),
                  (J = r[11]),
                  (u[8] = v * te + T * ae + P * Z + G * J),
                  (u[9] = _ * te + E * ae + F * Z + X * J),
                  (u[10] = m * te + M * ae + b * Z + ie * J),
                  (u[11] = g * te + R * ae + D * Z + Q * J),
                  (te = r[12]),
                  (ae = r[13]),
                  (Z = r[14]),
                  (J = r[15]),
                  (u[12] = v * te + T * ae + P * Z + G * J),
                  (u[13] = _ * te + E * ae + F * Z + X * J),
                  (u[14] = m * te + M * ae + b * Z + ie * J),
                  (u[15] = g * te + R * ae + D * Z + Q * J),
                  this
                );
              }
              mulAffine2(i, e) {
                const t = i.data,
                  r = e.data,
                  u = this.data,
                  v = t[0],
                  _ = t[1],
                  m = t[2],
                  g = t[4],
                  T = t[5],
                  E = t[6],
                  M = t[8],
                  R = t[9],
                  P = t[10],
                  F = t[12],
                  b = t[13],
                  D = t[14];
                let G, X, ie;
                return (
                  (G = r[0]),
                  (X = r[1]),
                  (ie = r[2]),
                  (u[0] = v * G + g * X + M * ie),
                  (u[1] = _ * G + T * X + R * ie),
                  (u[2] = m * G + E * X + P * ie),
                  (u[3] = 0),
                  (G = r[4]),
                  (X = r[5]),
                  (ie = r[6]),
                  (u[4] = v * G + g * X + M * ie),
                  (u[5] = _ * G + T * X + R * ie),
                  (u[6] = m * G + E * X + P * ie),
                  (u[7] = 0),
                  (G = r[8]),
                  (X = r[9]),
                  (ie = r[10]),
                  (u[8] = v * G + g * X + M * ie),
                  (u[9] = _ * G + T * X + R * ie),
                  (u[10] = m * G + E * X + P * ie),
                  (u[11] = 0),
                  (G = r[12]),
                  (X = r[13]),
                  (ie = r[14]),
                  (u[12] = v * G + g * X + M * ie + F),
                  (u[13] = _ * G + T * X + R * ie + b),
                  (u[14] = m * G + E * X + P * ie + D),
                  (u[15] = 1),
                  this
                );
              }
              mul(i) {
                return this.mul2(this, i);
              }
              transformPoint(i, e = new y.e()) {
                const t = this.data,
                  r = i.x,
                  u = i.y,
                  v = i.z;
                return (
                  (e.x = r * t[0] + u * t[4] + v * t[8] + t[12]),
                  (e.y = r * t[1] + u * t[5] + v * t[9] + t[13]),
                  (e.z = r * t[2] + u * t[6] + v * t[10] + t[14]),
                  e
                );
              }
              transformVector(i, e = new y.e()) {
                const t = this.data,
                  r = i.x,
                  u = i.y,
                  v = i.z;
                return (
                  (e.x = r * t[0] + u * t[4] + v * t[8]),
                  (e.y = r * t[1] + u * t[5] + v * t[9]),
                  (e.z = r * t[2] + u * t[6] + v * t[10]),
                  e
                );
              }
              transformVec4(i, e = new c.Z()) {
                const t = this.data,
                  r = i.x,
                  u = i.y,
                  v = i.z,
                  _ = i.w;
                return (
                  (e.x = r * t[0] + u * t[4] + v * t[8] + _ * t[12]),
                  (e.y = r * t[1] + u * t[5] + v * t[9] + _ * t[13]),
                  (e.z = r * t[2] + u * t[6] + v * t[10] + _ * t[14]),
                  (e.w = r * t[3] + u * t[7] + v * t[11] + _ * t[15]),
                  e
                );
              }
              setLookAt(i, e, t) {
                s.sub2(i, e).normalize(),
                  f.copy(t).normalize(),
                  h.cross(f, s).normalize(),
                  f.cross(s, h);
                const r = this.data;
                return (
                  (r[0] = h.x),
                  (r[1] = h.y),
                  (r[2] = h.z),
                  (r[3] = 0),
                  (r[4] = f.x),
                  (r[5] = f.y),
                  (r[6] = f.z),
                  (r[7] = 0),
                  (r[8] = s.x),
                  (r[9] = s.y),
                  (r[10] = s.z),
                  (r[11] = 0),
                  (r[12] = i.x),
                  (r[13] = i.y),
                  (r[14] = i.z),
                  (r[15] = 1),
                  this
                );
              }
              setFrustum(i, e, t, r, u, v) {
                const _ = 2 * u,
                  m = e - i,
                  g = r - t,
                  T = v - u,
                  E = this.data;
                return (
                  (E[0] = _ / m),
                  (E[1] = 0),
                  (E[2] = 0),
                  (E[3] = 0),
                  (E[4] = 0),
                  (E[5] = _ / g),
                  (E[6] = 0),
                  (E[7] = 0),
                  (E[8] = (e + i) / m),
                  (E[9] = (r + t) / g),
                  (E[10] = (-v - u) / T),
                  (E[11] = -1),
                  (E[12] = 0),
                  (E[13] = 0),
                  (E[14] = (-_ * v) / T),
                  (E[15] = 0),
                  this
                );
              }
              setPerspective(i, e, t, r, u) {
                return (
                  n._getPerspectiveHalfSize(d, i, e, t, u),
                  this.setFrustum(-d.x, d.x, -d.y, d.y, t, r)
                );
              }
              setOrtho(i, e, t, r, u, v) {
                const _ = this.data;
                return (
                  (_[0] = 2 / (e - i)),
                  (_[1] = 0),
                  (_[2] = 0),
                  (_[3] = 0),
                  (_[4] = 0),
                  (_[5] = 2 / (r - t)),
                  (_[6] = 0),
                  (_[7] = 0),
                  (_[8] = 0),
                  (_[9] = 0),
                  (_[10] = -2 / (v - u)),
                  (_[11] = 0),
                  (_[12] = -(e + i) / (e - i)),
                  (_[13] = -(r + t) / (r - t)),
                  (_[14] = -(v + u) / (v - u)),
                  (_[15] = 1),
                  this
                );
              }
              setFromAxisAngle(i, e) {
                e *= A.D.DEG_TO_RAD;
                const t = i.x,
                  r = i.y,
                  u = i.z,
                  v = Math.cos(e),
                  _ = Math.sin(e),
                  m = 1 - v,
                  g = m * t,
                  T = m * r,
                  E = this.data;
                return (
                  (E[0] = g * t + v),
                  (E[1] = g * r + _ * u),
                  (E[2] = g * u - _ * r),
                  (E[3] = 0),
                  (E[4] = g * r - _ * u),
                  (E[5] = T * r + v),
                  (E[6] = T * u + _ * t),
                  (E[7] = 0),
                  (E[8] = g * u + _ * r),
                  (E[9] = T * u - t * _),
                  (E[10] = m * u * u + v),
                  (E[11] = 0),
                  (E[12] = 0),
                  (E[13] = 0),
                  (E[14] = 0),
                  (E[15] = 1),
                  this
                );
              }
              setTranslate(i, e, t) {
                const r = this.data;
                return (
                  (r[0] = 1),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = 1),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[10] = 1),
                  (r[11] = 0),
                  (r[12] = i),
                  (r[13] = e),
                  (r[14] = t),
                  (r[15] = 1),
                  this
                );
              }
              setScale(i, e, t) {
                const r = this.data;
                return (
                  (r[0] = i),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = e),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[10] = t),
                  (r[11] = 0),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[14] = 0),
                  (r[15] = 1),
                  this
                );
              }
              setViewport(i, e, t, r) {
                const u = this.data;
                return (
                  (u[0] = t * 0.5),
                  (u[1] = 0),
                  (u[2] = 0),
                  (u[3] = 0),
                  (u[4] = 0),
                  (u[5] = r * 0.5),
                  (u[6] = 0),
                  (u[7] = 0),
                  (u[8] = 0),
                  (u[9] = 0),
                  (u[10] = 0.5),
                  (u[11] = 0),
                  (u[12] = i + t * 0.5),
                  (u[13] = e + r * 0.5),
                  (u[14] = 0.5),
                  (u[15] = 1),
                  this
                );
              }
              setReflection(i, e) {
                const t = i.x,
                  r = i.y,
                  u = i.z,
                  v = this.data;
                return (
                  (v[0] = 1 - 2 * t * t),
                  (v[1] = -2 * t * r),
                  (v[2] = -2 * t * u),
                  (v[3] = 0),
                  (v[4] = -2 * t * r),
                  (v[5] = 1 - 2 * r * r),
                  (v[6] = -2 * r * u),
                  (v[7] = 0),
                  (v[8] = -2 * t * u),
                  (v[9] = -2 * r * u),
                  (v[10] = 1 - 2 * u * u),
                  (v[11] = 0),
                  (v[12] = -2 * t * e),
                  (v[13] = -2 * r * e),
                  (v[14] = -2 * u * e),
                  (v[15] = 1),
                  this
                );
              }
              invert() {
                const i = this.data,
                  e = i[0],
                  t = i[1],
                  r = i[2],
                  u = i[3],
                  v = i[4],
                  _ = i[5],
                  m = i[6],
                  g = i[7],
                  T = i[8],
                  E = i[9],
                  M = i[10],
                  R = i[11],
                  P = i[12],
                  F = i[13],
                  b = i[14],
                  D = i[15],
                  G = e * _ - t * v,
                  X = e * m - r * v,
                  ie = e * g - u * v,
                  Q = t * m - r * _,
                  te = t * g - u * _,
                  ae = r * g - u * m,
                  Z = T * F - E * P,
                  J = T * b - M * P,
                  ve = T * D - R * P,
                  _e = E * b - M * F,
                  L = E * D - R * F,
                  ge = M * D - R * b,
                  k = G * ge - X * L + ie * _e + Q * ve - te * J + ae * Z;
                if (k === 0) this.setIdentity();
                else {
                  const j = 1 / k;
                  (i[0] = (_ * ge - m * L + g * _e) * j),
                    (i[1] = (-t * ge + r * L - u * _e) * j),
                    (i[2] = (F * ae - b * te + D * Q) * j),
                    (i[3] = (-E * ae + M * te - R * Q) * j),
                    (i[4] = (-v * ge + m * ve - g * J) * j),
                    (i[5] = (e * ge - r * ve + u * J) * j),
                    (i[6] = (-P * ae + b * ie - D * X) * j),
                    (i[7] = (T * ae - M * ie + R * X) * j),
                    (i[8] = (v * L - _ * ve + g * Z) * j),
                    (i[9] = (-e * L + t * ve - u * Z) * j),
                    (i[10] = (P * te - F * ie + D * G) * j),
                    (i[11] = (-T * te + E * ie - R * G) * j),
                    (i[12] = (-v * _e + _ * J - m * Z) * j),
                    (i[13] = (e * _e - t * J + r * Z) * j),
                    (i[14] = (-P * Q + F * X - b * G) * j),
                    (i[15] = (T * Q - E * X + M * G) * j);
                }
                return this;
              }
              set(i) {
                const e = this.data;
                return (
                  (e[0] = i[0]),
                  (e[1] = i[1]),
                  (e[2] = i[2]),
                  (e[3] = i[3]),
                  (e[4] = i[4]),
                  (e[5] = i[5]),
                  (e[6] = i[6]),
                  (e[7] = i[7]),
                  (e[8] = i[8]),
                  (e[9] = i[9]),
                  (e[10] = i[10]),
                  (e[11] = i[11]),
                  (e[12] = i[12]),
                  (e[13] = i[13]),
                  (e[14] = i[14]),
                  (e[15] = i[15]),
                  this
                );
              }
              setIdentity() {
                const i = this.data;
                return (
                  (i[0] = 1),
                  (i[1] = 0),
                  (i[2] = 0),
                  (i[3] = 0),
                  (i[4] = 0),
                  (i[5] = 1),
                  (i[6] = 0),
                  (i[7] = 0),
                  (i[8] = 0),
                  (i[9] = 0),
                  (i[10] = 1),
                  (i[11] = 0),
                  (i[12] = 0),
                  (i[13] = 0),
                  (i[14] = 0),
                  (i[15] = 1),
                  this
                );
              }
              setTRS(i, e, t) {
                const r = e.x,
                  u = e.y,
                  v = e.z,
                  _ = e.w,
                  m = t.x,
                  g = t.y,
                  T = t.z,
                  E = r + r,
                  M = u + u,
                  R = v + v,
                  P = r * E,
                  F = r * M,
                  b = r * R,
                  D = u * M,
                  G = u * R,
                  X = v * R,
                  ie = _ * E,
                  Q = _ * M,
                  te = _ * R,
                  ae = this.data;
                return (
                  (ae[0] = (1 - (D + X)) * m),
                  (ae[1] = (F + te) * m),
                  (ae[2] = (b - Q) * m),
                  (ae[3] = 0),
                  (ae[4] = (F - te) * g),
                  (ae[5] = (1 - (P + X)) * g),
                  (ae[6] = (G + ie) * g),
                  (ae[7] = 0),
                  (ae[8] = (b + Q) * T),
                  (ae[9] = (G - ie) * T),
                  (ae[10] = (1 - (P + D)) * T),
                  (ae[11] = 0),
                  (ae[12] = i.x),
                  (ae[13] = i.y),
                  (ae[14] = i.z),
                  (ae[15] = 1),
                  this
                );
              }
              transpose() {
                let i;
                const e = this.data;
                return (
                  (i = e[1]),
                  (e[1] = e[4]),
                  (e[4] = i),
                  (i = e[2]),
                  (e[2] = e[8]),
                  (e[8] = i),
                  (i = e[3]),
                  (e[3] = e[12]),
                  (e[12] = i),
                  (i = e[6]),
                  (e[6] = e[9]),
                  (e[9] = i),
                  (i = e[7]),
                  (e[7] = e[13]),
                  (e[13] = i),
                  (i = e[11]),
                  (e[11] = e[14]),
                  (e[14] = i),
                  this
                );
              }
              invertTo3x3(i) {
                const e = this.data,
                  t = i.data,
                  r = e[0],
                  u = e[1],
                  v = e[2],
                  _ = e[4],
                  m = e[5],
                  g = e[6],
                  T = e[8],
                  E = e[9],
                  M = e[10],
                  R = M * m - g * E,
                  P = -M * u + v * E,
                  F = g * u - v * m,
                  b = -M * _ + g * T,
                  D = M * r - v * T,
                  G = -g * r + v * _,
                  X = E * _ - m * T,
                  ie = -E * r + u * T,
                  Q = m * r - u * _,
                  te = r * R + u * b + v * X;
                if (te === 0) return this;
                const ae = 1 / te;
                return (
                  (t[0] = ae * R),
                  (t[1] = ae * P),
                  (t[2] = ae * F),
                  (t[3] = ae * b),
                  (t[4] = ae * D),
                  (t[5] = ae * G),
                  (t[6] = ae * X),
                  (t[7] = ae * ie),
                  (t[8] = ae * Q),
                  this
                );
              }
              getTranslation(i = new y.e()) {
                return i.set(this.data[12], this.data[13], this.data[14]);
              }
              getX(i = new y.e()) {
                return i.set(this.data[0], this.data[1], this.data[2]);
              }
              getY(i = new y.e()) {
                return i.set(this.data[4], this.data[5], this.data[6]);
              }
              getZ(i = new y.e()) {
                return i.set(this.data[8], this.data[9], this.data[10]);
              }
              getScale(i = new y.e()) {
                return (
                  this.getX(h),
                  this.getY(f),
                  this.getZ(s),
                  i.set(h.length(), f.length(), s.length()),
                  i
                );
              }
              get scaleSign() {
                return (
                  this.getX(h),
                  this.getY(f),
                  this.getZ(s),
                  h.cross(h, f),
                  h.dot(s) < 0 ? -1 : 1
                );
              }
              setFromEulerAngles(i, e, t) {
                (i *= A.D.DEG_TO_RAD),
                  (e *= A.D.DEG_TO_RAD),
                  (t *= A.D.DEG_TO_RAD);
                const r = Math.sin(-i),
                  u = Math.cos(-i),
                  v = Math.sin(-e),
                  _ = Math.cos(-e),
                  m = Math.sin(-t),
                  g = Math.cos(-t),
                  T = this.data;
                return (
                  (T[0] = _ * g),
                  (T[1] = -_ * m),
                  (T[2] = v),
                  (T[3] = 0),
                  (T[4] = u * m + g * r * v),
                  (T[5] = u * g - r * v * m),
                  (T[6] = -_ * r),
                  (T[7] = 0),
                  (T[8] = r * m - u * g * v),
                  (T[9] = g * r + u * v * m),
                  (T[10] = u * _),
                  (T[11] = 0),
                  (T[12] = 0),
                  (T[13] = 0),
                  (T[14] = 0),
                  (T[15] = 1),
                  this
                );
              }
              getEulerAngles(i = new y.e()) {
                this.getScale(l);
                const e = l.x,
                  t = l.y,
                  r = l.z;
                if (e === 0 || t === 0 || r === 0) return i.set(0, 0, 0);
                const u = this.data,
                  v = Math.asin(-u[2] / e),
                  _ = Math.PI * 0.5;
                let m, g;
                return (
                  v < _
                    ? v > -_
                      ? ((m = Math.atan2(u[6] / t, u[10] / r)),
                        (g = Math.atan2(u[1] / e, u[0] / e)))
                      : ((g = 0), (m = -Math.atan2(u[4] / t, u[5] / t)))
                    : ((g = 0), (m = Math.atan2(u[4] / t, u[5] / t))),
                  i.set(m, v, g).mulScalar(A.D.RAD_TO_DEG)
                );
              }
              toString() {
                return "[" + this.data.join(", ") + "]";
              }
            }
            (n.IDENTITY = Object.freeze(new n())),
              (n.ZERO = Object.freeze(
                new n().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
              ));
          },
          8656: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => A });
            const A = {
              DEG_TO_RAD: Math.PI / 180,
              RAD_TO_DEG: 180 / Math.PI,
              clamp: function (x, y, c) {
                return x >= c ? c : x <= y ? y : x;
              },
              intToBytes24: function (x) {
                const y = (x >> 16) & 255,
                  c = (x >> 8) & 255,
                  d = x & 255;
                return [y, c, d];
              },
              intToBytes32: function (x) {
                const y = (x >> 24) & 255,
                  c = (x >> 16) & 255,
                  d = (x >> 8) & 255,
                  h = x & 255;
                return [y, c, d, h];
              },
              bytesToInt24: function (x, y, c) {
                return (
                  x.length && ((c = x[2]), (y = x[1]), (x = x[0])),
                  (x << 16) | (y << 8) | c
                );
              },
              bytesToInt32: function (x, y, c, d) {
                return (
                  x.length && ((d = x[3]), (c = x[2]), (y = x[1]), (x = x[0])),
                  ((x << 24) | (y << 16) | (c << 8) | d) >>> 0
                );
              },
              lerp: function (x, y, c) {
                return x + (y - x) * A.clamp(c, 0, 1);
              },
              lerpAngle: function (x, y, c) {
                return (
                  y - x > 180 && (y -= 360),
                  y - x < -180 && (y += 360),
                  A.lerp(x, y, A.clamp(c, 0, 1))
                );
              },
              powerOfTwo: function (x) {
                return x !== 0 && !(x & (x - 1));
              },
              nextPowerOfTwo: function (x) {
                return (
                  x--,
                  (x |= x >> 1),
                  (x |= x >> 2),
                  (x |= x >> 4),
                  (x |= x >> 8),
                  (x |= x >> 16),
                  x++,
                  x
                );
              },
              nearestPowerOfTwo: function (x) {
                return Math.pow(2, Math.round(Math.log(x) / Math.log(2)));
              },
              random: function (x, y) {
                const c = y - x;
                return Math.random() * c + x;
              },
              smoothstep: function (x, y, c) {
                return c <= x
                  ? 0
                  : c >= y
                  ? 1
                  : ((c = (c - x) / (y - x)), c * c * (3 - 2 * c));
              },
              smootherstep: function (x, y, c) {
                return c <= x
                  ? 0
                  : c >= y
                  ? 1
                  : ((c = (c - x) / (y - x)),
                    c * c * c * (c * (c * 6 - 15) + 10));
              },
              roundUp: function (x, y) {
                return y === 0 ? x : Math.ceil(x / y) * y;
              },
              between: function (x, y, c, d) {
                const h = Math.min(y, c),
                  f = Math.max(y, c);
                return d ? x >= h && x <= f : x > h && x < f;
              },
            };
          },
          3021: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => y });
            var A = a(8656),
              x = a(7481);
            class y {
              constructor(d = 0, h = 0, f = 0, s = 1) {
                (this.x = void 0),
                  (this.y = void 0),
                  (this.z = void 0),
                  (this.w = void 0),
                  d.length === 4
                    ? ((this.x = d[0]),
                      (this.y = d[1]),
                      (this.z = d[2]),
                      (this.w = d[3]))
                    : ((this.x = d), (this.y = h), (this.z = f), (this.w = s));
              }
              clone() {
                const d = this.constructor;
                return new d(this.x, this.y, this.z, this.w);
              }
              conjugate() {
                return (this.x *= -1), (this.y *= -1), (this.z *= -1), this;
              }
              copy(d) {
                return (
                  (this.x = d.x),
                  (this.y = d.y),
                  (this.z = d.z),
                  (this.w = d.w),
                  this
                );
              }
              equals(d) {
                return (
                  this.x === d.x &&
                  this.y === d.y &&
                  this.z === d.z &&
                  this.w === d.w
                );
              }
              equalsApprox(d, h = 1e-6) {
                return (
                  Math.abs(this.x - d.x) < h &&
                  Math.abs(this.y - d.y) < h &&
                  Math.abs(this.z - d.z) < h &&
                  Math.abs(this.w - d.w) < h
                );
              }
              getAxisAngle(d) {
                let h = Math.acos(this.w) * 2;
                const f = Math.sin(h / 2);
                return (
                  f !== 0
                    ? ((d.x = this.x / f),
                      (d.y = this.y / f),
                      (d.z = this.z / f),
                      (d.x < 0 || d.y < 0 || d.z < 0) &&
                        ((d.x *= -1), (d.y *= -1), (d.z *= -1), (h *= -1)))
                    : ((d.x = 1), (d.y = 0), (d.z = 0)),
                  h * A.D.RAD_TO_DEG
                );
              }
              getEulerAngles(d = new x.e()) {
                let h, f, s;
                const l = this.x,
                  n = this.y,
                  o = this.z,
                  i = this.w,
                  e = 2 * (i * n - l * o);
                return (
                  e <= -0.99999
                    ? ((h = 2 * Math.atan2(l, i)), (f = -Math.PI / 2), (s = 0))
                    : e >= 0.99999
                    ? ((h = 2 * Math.atan2(l, i)), (f = Math.PI / 2), (s = 0))
                    : ((h = Math.atan2(
                        2 * (i * l + n * o),
                        1 - 2 * (l * l + n * n)
                      )),
                      (f = Math.asin(e)),
                      (s = Math.atan2(
                        2 * (i * o + l * n),
                        1 - 2 * (n * n + o * o)
                      ))),
                  d.set(h, f, s).mulScalar(A.D.RAD_TO_DEG)
                );
              }
              invert() {
                return this.conjugate().normalize();
              }
              length() {
                return Math.sqrt(
                  this.x * this.x +
                    this.y * this.y +
                    this.z * this.z +
                    this.w * this.w
                );
              }
              lengthSq() {
                return (
                  this.x * this.x +
                  this.y * this.y +
                  this.z * this.z +
                  this.w * this.w
                );
              }
              mul(d) {
                const h = this.x,
                  f = this.y,
                  s = this.z,
                  l = this.w,
                  n = d.x,
                  o = d.y,
                  i = d.z,
                  e = d.w;
                return (
                  (this.x = l * n + h * e + f * i - s * o),
                  (this.y = l * o + f * e + s * n - h * i),
                  (this.z = l * i + s * e + h * o - f * n),
                  (this.w = l * e - h * n - f * o - s * i),
                  this
                );
              }
              mul2(d, h) {
                const f = d.x,
                  s = d.y,
                  l = d.z,
                  n = d.w,
                  o = h.x,
                  i = h.y,
                  e = h.z,
                  t = h.w;
                return (
                  (this.x = n * o + f * t + s * e - l * i),
                  (this.y = n * i + s * t + l * o - f * e),
                  (this.z = n * e + l * t + f * i - s * o),
                  (this.w = n * t - f * o - s * i - l * e),
                  this
                );
              }
              normalize() {
                let d = this.length();
                return (
                  d === 0
                    ? ((this.x = this.y = this.z = 0), (this.w = 1))
                    : ((d = 1 / d),
                      (this.x *= d),
                      (this.y *= d),
                      (this.z *= d),
                      (this.w *= d)),
                  this
                );
              }
              set(d, h, f, s) {
                return (
                  (this.x = d), (this.y = h), (this.z = f), (this.w = s), this
                );
              }
              setFromAxisAngle(d, h) {
                h *= 0.5 * A.D.DEG_TO_RAD;
                const f = Math.sin(h),
                  s = Math.cos(h);
                return (
                  (this.x = f * d.x),
                  (this.y = f * d.y),
                  (this.z = f * d.z),
                  (this.w = s),
                  this
                );
              }
              setFromEulerAngles(d, h, f) {
                if (d instanceof x.e) {
                  const r = d;
                  (d = r.x), (h = r.y), (f = r.z);
                }
                const s = 0.5 * A.D.DEG_TO_RAD;
                (d *= s), (h *= s), (f *= s);
                const l = Math.sin(d),
                  n = Math.cos(d),
                  o = Math.sin(h),
                  i = Math.cos(h),
                  e = Math.sin(f),
                  t = Math.cos(f);
                return (
                  (this.x = l * i * t - n * o * e),
                  (this.y = n * o * t + l * i * e),
                  (this.z = n * i * e - l * o * t),
                  (this.w = n * i * t + l * o * e),
                  this
                );
              }
              setFromMat4(d) {
                let h, f, s, l, n, o, i, e, t, r, u, v, _, m;
                if (
                  ((d = d.data),
                  (h = d[0]),
                  (f = d[1]),
                  (s = d[2]),
                  (l = d[4]),
                  (n = d[5]),
                  (o = d[6]),
                  (i = d[8]),
                  (e = d[9]),
                  (t = d[10]),
                  (v = h * h + f * f + s * s),
                  v === 0)
                )
                  return this;
                if (
                  ((v = 1 / Math.sqrt(v)), (_ = l * l + n * n + o * o), _ === 0)
                )
                  return this;
                if (
                  ((_ = 1 / Math.sqrt(_)), (m = i * i + e * e + t * t), m === 0)
                )
                  return this;
                (m = 1 / Math.sqrt(m)),
                  (h *= v),
                  (f *= v),
                  (s *= v),
                  (l *= _),
                  (n *= _),
                  (o *= _),
                  (i *= m),
                  (e *= m),
                  (t *= m);
                const g = h + n + t;
                return (
                  g >= 0
                    ? ((r = Math.sqrt(g + 1)),
                      (this.w = r * 0.5),
                      (r = 0.5 / r),
                      (this.x = (o - e) * r),
                      (this.y = (i - s) * r),
                      (this.z = (f - l) * r))
                    : h > n
                    ? h > t
                      ? ((u = h - (n + t) + 1),
                        (u = Math.sqrt(u)),
                        (this.x = u * 0.5),
                        (u = 0.5 / u),
                        (this.w = (o - e) * u),
                        (this.y = (f + l) * u),
                        (this.z = (s + i) * u))
                      : ((u = t - (h + n) + 1),
                        (u = Math.sqrt(u)),
                        (this.z = u * 0.5),
                        (u = 0.5 / u),
                        (this.w = (f - l) * u),
                        (this.x = (i + s) * u),
                        (this.y = (e + o) * u))
                    : n > t
                    ? ((u = n - (t + h) + 1),
                      (u = Math.sqrt(u)),
                      (this.y = u * 0.5),
                      (u = 0.5 / u),
                      (this.w = (i - s) * u),
                      (this.z = (o + e) * u),
                      (this.x = (l + f) * u))
                    : ((u = t - (h + n) + 1),
                      (u = Math.sqrt(u)),
                      (this.z = u * 0.5),
                      (u = 0.5 / u),
                      (this.w = (f - l) * u),
                      (this.x = (i + s) * u),
                      (this.y = (e + o) * u)),
                  this
                );
              }
              setFromDirections(d, h) {
                const f = 1 + d.dot(h);
                return (
                  f < Number.EPSILON
                    ? Math.abs(d.x) > Math.abs(d.y)
                      ? ((this.x = -d.z),
                        (this.y = 0),
                        (this.z = d.x),
                        (this.w = 0))
                      : ((this.x = 0),
                        (this.y = -d.z),
                        (this.z = d.y),
                        (this.w = 0))
                    : ((this.x = d.y * h.z - d.z * h.y),
                      (this.y = d.z * h.x - d.x * h.z),
                      (this.z = d.x * h.y - d.y * h.x),
                      (this.w = f)),
                  this.normalize()
                );
              }
              slerp(d, h, f) {
                const s = d.x,
                  l = d.y,
                  n = d.z,
                  o = d.w;
                let i = h.x,
                  e = h.y,
                  t = h.z,
                  r = h.w,
                  u = o * r + s * i + l * e + n * t;
                if (
                  (u < 0 && ((r = -r), (i = -i), (e = -e), (t = -t), (u = -u)),
                  Math.abs(u) >= 1)
                )
                  return (
                    (this.w = o), (this.x = s), (this.y = l), (this.z = n), this
                  );
                const v = Math.acos(u),
                  _ = Math.sqrt(1 - u * u);
                if (Math.abs(_) < 0.001)
                  return (
                    (this.w = o * 0.5 + r * 0.5),
                    (this.x = s * 0.5 + i * 0.5),
                    (this.y = l * 0.5 + e * 0.5),
                    (this.z = n * 0.5 + t * 0.5),
                    this
                  );
                const m = Math.sin((1 - f) * v) / _,
                  g = Math.sin(f * v) / _;
                return (
                  (this.w = o * m + r * g),
                  (this.x = s * m + i * g),
                  (this.y = l * m + e * g),
                  (this.z = n * m + t * g),
                  this
                );
              }
              transformVector(d, h = new x.e()) {
                const f = d.x,
                  s = d.y,
                  l = d.z,
                  n = this.x,
                  o = this.y,
                  i = this.z,
                  e = this.w,
                  t = e * f + o * l - i * s,
                  r = e * s + i * f - n * l,
                  u = e * l + n * s - o * f,
                  v = -n * f - o * s - i * l;
                return (
                  (h.x = t * e + v * -n + r * -i - u * -o),
                  (h.y = r * e + v * -o + u * -n - t * -i),
                  (h.z = u * e + v * -i + t * -o - r * -n),
                  h
                );
              }
              toString() {
                return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
              }
            }
            (y.IDENTITY = Object.freeze(new y(0, 0, 0, 1))),
              (y.ZERO = Object.freeze(new y(0, 0, 0, 0)));
          },
          9833: (xe, V, a) => {
            "use strict";
            a.d(V, { y: () => y });
            var A = a(8656);
            const x = 2.399963229728653,
              y = {
                circlePoint: function (c) {
                  const d = Math.sqrt(Math.random()),
                    h = Math.random() * 2 * Math.PI;
                  (c.x = d * Math.cos(h)), (c.y = d * Math.sin(h));
                },
                circlePointDeterministic: function (c, d, h) {
                  const f = d * x,
                    s = Math.sqrt(d) / Math.sqrt(h);
                  (c.x = s * Math.cos(f)), (c.y = s * Math.sin(f));
                },
                spherePointDeterministic: function (c, d, h, f = 0, s = 1) {
                  (f = 1 - 2 * f), (s = 1 - 2 * s);
                  const l = A.D.lerp(f, s, d / h),
                    n = Math.sqrt(1 - l * l),
                    o = x * d;
                  (c.x = Math.cos(o) * n), (c.y = l), (c.z = Math.sin(o) * n);
                },
                radicalInverse: function (c) {
                  let d = ((c << 16) | (c >>> 16)) >>> 0;
                  return (
                    (d =
                      (((d & 1431655765) << 1) | ((d & 2863311530) >>> 1)) >>>
                      0),
                    (d =
                      (((d & 858993459) << 2) | ((d & 3435973836) >>> 2)) >>>
                      0),
                    (d =
                      (((d & 252645135) << 4) | ((d & 4042322160) >>> 4)) >>>
                      0),
                    (d =
                      (((d & 16711935) << 8) | ((d & 4278255360) >>> 8)) >>> 0),
                    d * 23283064365386963e-26
                  );
                },
              };
          },
          7994: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => A });
            class A {
              constructor(y = 0, c = 0) {
                (this.x = void 0),
                  (this.y = void 0),
                  y.length === 2
                    ? ((this.x = y[0]), (this.y = y[1]))
                    : ((this.x = y), (this.y = c));
              }
              add(y) {
                return (this.x += y.x), (this.y += y.y), this;
              }
              add2(y, c) {
                return (this.x = y.x + c.x), (this.y = y.y + c.y), this;
              }
              addScalar(y) {
                return (this.x += y), (this.y += y), this;
              }
              clone() {
                const y = this.constructor;
                return new y(this.x, this.y);
              }
              copy(y) {
                return (this.x = y.x), (this.y = y.y), this;
              }
              cross(y) {
                return this.x * y.y - this.y * y.x;
              }
              distance(y) {
                const c = this.x - y.x,
                  d = this.y - y.y;
                return Math.sqrt(c * c + d * d);
              }
              div(y) {
                return (this.x /= y.x), (this.y /= y.y), this;
              }
              div2(y, c) {
                return (this.x = y.x / c.x), (this.y = y.y / c.y), this;
              }
              divScalar(y) {
                return (this.x /= y), (this.y /= y), this;
              }
              dot(y) {
                return this.x * y.x + this.y * y.y;
              }
              equals(y) {
                return this.x === y.x && this.y === y.y;
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              }
              lengthSq() {
                return this.x * this.x + this.y * this.y;
              }
              lerp(y, c, d) {
                return (
                  (this.x = y.x + d * (c.x - y.x)),
                  (this.y = y.y + d * (c.y - y.y)),
                  this
                );
              }
              mul(y) {
                return (this.x *= y.x), (this.y *= y.y), this;
              }
              mul2(y, c) {
                return (this.x = y.x * c.x), (this.y = y.y * c.y), this;
              }
              mulScalar(y) {
                return (this.x *= y), (this.y *= y), this;
              }
              normalize() {
                const y = this.x * this.x + this.y * this.y;
                if (y > 0) {
                  const c = 1 / Math.sqrt(y);
                  (this.x *= c), (this.y *= c);
                }
                return this;
              }
              floor() {
                return (
                  (this.x = Math.floor(this.x)),
                  (this.y = Math.floor(this.y)),
                  this
                );
              }
              ceil() {
                return (
                  (this.x = Math.ceil(this.x)),
                  (this.y = Math.ceil(this.y)),
                  this
                );
              }
              round() {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  this
                );
              }
              min(y) {
                return (
                  y.x < this.x && (this.x = y.x),
                  y.y < this.y && (this.y = y.y),
                  this
                );
              }
              max(y) {
                return (
                  y.x > this.x && (this.x = y.x),
                  y.y > this.y && (this.y = y.y),
                  this
                );
              }
              set(y, c) {
                return (this.x = y), (this.y = c), this;
              }
              sub(y) {
                return (this.x -= y.x), (this.y -= y.y), this;
              }
              sub2(y, c) {
                return (this.x = y.x - c.x), (this.y = y.y - c.y), this;
              }
              subScalar(y) {
                return (this.x -= y), (this.y -= y), this;
              }
              toString() {
                return `[${this.x}, ${this.y}]`;
              }
              static angleRad(y, c) {
                return Math.atan2(y.x * c.y - y.y * c.x, y.x * c.x + y.y * c.y);
              }
            }
            (A.ZERO = Object.freeze(new A(0, 0))),
              (A.ONE = Object.freeze(new A(1, 1))),
              (A.UP = Object.freeze(new A(0, 1))),
              (A.DOWN = Object.freeze(new A(0, -1))),
              (A.RIGHT = Object.freeze(new A(1, 0))),
              (A.LEFT = Object.freeze(new A(-1, 0)));
          },
          7481: (xe, V, a) => {
            "use strict";
            a.d(V, { e: () => A });
            class A {
              constructor(y = 0, c = 0, d = 0) {
                (this.x = void 0),
                  (this.y = void 0),
                  (this.z = void 0),
                  y.length === 3
                    ? ((this.x = y[0]), (this.y = y[1]), (this.z = y[2]))
                    : ((this.x = y), (this.y = c), (this.z = d));
              }
              add(y) {
                return (this.x += y.x), (this.y += y.y), (this.z += y.z), this;
              }
              add2(y, c) {
                return (
                  (this.x = y.x + c.x),
                  (this.y = y.y + c.y),
                  (this.z = y.z + c.z),
                  this
                );
              }
              addScalar(y) {
                return (this.x += y), (this.y += y), (this.z += y), this;
              }
              clone() {
                const y = this.constructor;
                return new y(this.x, this.y, this.z);
              }
              copy(y) {
                return (this.x = y.x), (this.y = y.y), (this.z = y.z), this;
              }
              cross(y, c) {
                const d = y.x,
                  h = y.y,
                  f = y.z,
                  s = c.x,
                  l = c.y,
                  n = c.z;
                return (
                  (this.x = h * n - l * f),
                  (this.y = f * s - n * d),
                  (this.z = d * l - s * h),
                  this
                );
              }
              distance(y) {
                const c = this.x - y.x,
                  d = this.y - y.y,
                  h = this.z - y.z;
                return Math.sqrt(c * c + d * d + h * h);
              }
              div(y) {
                return (this.x /= y.x), (this.y /= y.y), (this.z /= y.z), this;
              }
              div2(y, c) {
                return (
                  (this.x = y.x / c.x),
                  (this.y = y.y / c.y),
                  (this.z = y.z / c.z),
                  this
                );
              }
              divScalar(y) {
                return (this.x /= y), (this.y /= y), (this.z /= y), this;
              }
              dot(y) {
                return this.x * y.x + this.y * y.y + this.z * y.z;
              }
              equals(y) {
                return this.x === y.x && this.y === y.y && this.z === y.z;
              }
              length() {
                return Math.sqrt(
                  this.x * this.x + this.y * this.y + this.z * this.z
                );
              }
              lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
              }
              lerp(y, c, d) {
                return (
                  (this.x = y.x + d * (c.x - y.x)),
                  (this.y = y.y + d * (c.y - y.y)),
                  (this.z = y.z + d * (c.z - y.z)),
                  this
                );
              }
              mul(y) {
                return (this.x *= y.x), (this.y *= y.y), (this.z *= y.z), this;
              }
              mul2(y, c) {
                return (
                  (this.x = y.x * c.x),
                  (this.y = y.y * c.y),
                  (this.z = y.z * c.z),
                  this
                );
              }
              mulScalar(y) {
                return (this.x *= y), (this.y *= y), (this.z *= y), this;
              }
              normalize() {
                const y = this.x * this.x + this.y * this.y + this.z * this.z;
                if (y > 0) {
                  const c = 1 / Math.sqrt(y);
                  (this.x *= c), (this.y *= c), (this.z *= c);
                }
                return this;
              }
              floor() {
                return (
                  (this.x = Math.floor(this.x)),
                  (this.y = Math.floor(this.y)),
                  (this.z = Math.floor(this.z)),
                  this
                );
              }
              ceil() {
                return (
                  (this.x = Math.ceil(this.x)),
                  (this.y = Math.ceil(this.y)),
                  (this.z = Math.ceil(this.z)),
                  this
                );
              }
              round() {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  (this.z = Math.round(this.z)),
                  this
                );
              }
              min(y) {
                return (
                  y.x < this.x && (this.x = y.x),
                  y.y < this.y && (this.y = y.y),
                  y.z < this.z && (this.z = y.z),
                  this
                );
              }
              max(y) {
                return (
                  y.x > this.x && (this.x = y.x),
                  y.y > this.y && (this.y = y.y),
                  y.z > this.z && (this.z = y.z),
                  this
                );
              }
              project(y) {
                const c = this.x * y.x + this.y * y.y + this.z * y.z,
                  d = y.x * y.x + y.y * y.y + y.z * y.z,
                  h = c / d;
                return (
                  (this.x = y.x * h),
                  (this.y = y.y * h),
                  (this.z = y.z * h),
                  this
                );
              }
              set(y, c, d) {
                return (this.x = y), (this.y = c), (this.z = d), this;
              }
              sub(y) {
                return (this.x -= y.x), (this.y -= y.y), (this.z -= y.z), this;
              }
              sub2(y, c) {
                return (
                  (this.x = y.x - c.x),
                  (this.y = y.y - c.y),
                  (this.z = y.z - c.z),
                  this
                );
              }
              subScalar(y) {
                return (this.x -= y), (this.y -= y), (this.z -= y), this;
              }
              toString() {
                return `[${this.x}, ${this.y}, ${this.z}]`;
              }
            }
            (A.ZERO = Object.freeze(new A(0, 0, 0))),
              (A.ONE = Object.freeze(new A(1, 1, 1))),
              (A.UP = Object.freeze(new A(0, 1, 0))),
              (A.DOWN = Object.freeze(new A(0, -1, 0))),
              (A.RIGHT = Object.freeze(new A(1, 0, 0))),
              (A.LEFT = Object.freeze(new A(-1, 0, 0))),
              (A.FORWARD = Object.freeze(new A(0, 0, -1))),
              (A.BACK = Object.freeze(new A(0, 0, 1)));
          },
          5596: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => A });
            class A {
              constructor(y = 0, c = 0, d = 0, h = 0) {
                (this.x = void 0),
                  (this.y = void 0),
                  (this.z = void 0),
                  (this.w = void 0),
                  y.length === 4
                    ? ((this.x = y[0]),
                      (this.y = y[1]),
                      (this.z = y[2]),
                      (this.w = y[3]))
                    : ((this.x = y), (this.y = c), (this.z = d), (this.w = h));
              }
              add(y) {
                return (
                  (this.x += y.x),
                  (this.y += y.y),
                  (this.z += y.z),
                  (this.w += y.w),
                  this
                );
              }
              add2(y, c) {
                return (
                  (this.x = y.x + c.x),
                  (this.y = y.y + c.y),
                  (this.z = y.z + c.z),
                  (this.w = y.w + c.w),
                  this
                );
              }
              addScalar(y) {
                return (
                  (this.x += y),
                  (this.y += y),
                  (this.z += y),
                  (this.w += y),
                  this
                );
              }
              clone() {
                const y = this.constructor;
                return new y(this.x, this.y, this.z, this.w);
              }
              copy(y) {
                return (
                  (this.x = y.x),
                  (this.y = y.y),
                  (this.z = y.z),
                  (this.w = y.w),
                  this
                );
              }
              div(y) {
                return (
                  (this.x /= y.x),
                  (this.y /= y.y),
                  (this.z /= y.z),
                  (this.w /= y.w),
                  this
                );
              }
              div2(y, c) {
                return (
                  (this.x = y.x / c.x),
                  (this.y = y.y / c.y),
                  (this.z = y.z / c.z),
                  (this.w = y.w / c.w),
                  this
                );
              }
              divScalar(y) {
                return (
                  (this.x /= y),
                  (this.y /= y),
                  (this.z /= y),
                  (this.w /= y),
                  this
                );
              }
              dot(y) {
                return (
                  this.x * y.x + this.y * y.y + this.z * y.z + this.w * y.w
                );
              }
              equals(y) {
                return (
                  this.x === y.x &&
                  this.y === y.y &&
                  this.z === y.z &&
                  this.w === y.w
                );
              }
              length() {
                return Math.sqrt(
                  this.x * this.x +
                    this.y * this.y +
                    this.z * this.z +
                    this.w * this.w
                );
              }
              lengthSq() {
                return (
                  this.x * this.x +
                  this.y * this.y +
                  this.z * this.z +
                  this.w * this.w
                );
              }
              lerp(y, c, d) {
                return (
                  (this.x = y.x + d * (c.x - y.x)),
                  (this.y = y.y + d * (c.y - y.y)),
                  (this.z = y.z + d * (c.z - y.z)),
                  (this.w = y.w + d * (c.w - y.w)),
                  this
                );
              }
              mul(y) {
                return (
                  (this.x *= y.x),
                  (this.y *= y.y),
                  (this.z *= y.z),
                  (this.w *= y.w),
                  this
                );
              }
              mul2(y, c) {
                return (
                  (this.x = y.x * c.x),
                  (this.y = y.y * c.y),
                  (this.z = y.z * c.z),
                  (this.w = y.w * c.w),
                  this
                );
              }
              mulScalar(y) {
                return (
                  (this.x *= y),
                  (this.y *= y),
                  (this.z *= y),
                  (this.w *= y),
                  this
                );
              }
              normalize() {
                const y =
                  this.x * this.x +
                  this.y * this.y +
                  this.z * this.z +
                  this.w * this.w;
                if (y > 0) {
                  const c = 1 / Math.sqrt(y);
                  (this.x *= c), (this.y *= c), (this.z *= c), (this.w *= c);
                }
                return this;
              }
              floor() {
                return (
                  (this.x = Math.floor(this.x)),
                  (this.y = Math.floor(this.y)),
                  (this.z = Math.floor(this.z)),
                  (this.w = Math.floor(this.w)),
                  this
                );
              }
              ceil() {
                return (
                  (this.x = Math.ceil(this.x)),
                  (this.y = Math.ceil(this.y)),
                  (this.z = Math.ceil(this.z)),
                  (this.w = Math.ceil(this.w)),
                  this
                );
              }
              round() {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  (this.z = Math.round(this.z)),
                  (this.w = Math.round(this.w)),
                  this
                );
              }
              min(y) {
                return (
                  y.x < this.x && (this.x = y.x),
                  y.y < this.y && (this.y = y.y),
                  y.z < this.z && (this.z = y.z),
                  y.w < this.w && (this.w = y.w),
                  this
                );
              }
              max(y) {
                return (
                  y.x > this.x && (this.x = y.x),
                  y.y > this.y && (this.y = y.y),
                  y.z > this.z && (this.z = y.z),
                  y.w > this.w && (this.w = y.w),
                  this
                );
              }
              set(y, c, d, h) {
                return (
                  (this.x = y), (this.y = c), (this.z = d), (this.w = h), this
                );
              }
              sub(y) {
                return (
                  (this.x -= y.x),
                  (this.y -= y.y),
                  (this.z -= y.z),
                  (this.w -= y.w),
                  this
                );
              }
              sub2(y, c) {
                return (
                  (this.x = y.x - c.x),
                  (this.y = y.y - c.y),
                  (this.z = y.z - c.z),
                  (this.w = y.w - c.w),
                  this
                );
              }
              subScalar(y) {
                return (
                  (this.x -= y),
                  (this.y -= y),
                  (this.z -= y),
                  (this.w -= y),
                  this
                );
              }
              toString() {
                return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
              }
            }
            (A.ZERO = Object.freeze(new A(0, 0, 0, 0))),
              (A.ONE = Object.freeze(new A(1, 1, 1, 1)));
          },
          1870: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            const A = {
              delimiter: "/",
              join: function () {
                const x = arguments.length;
                let y = arguments[0];
                for (let c = 0; c < x - 1; ++c) {
                  const d = arguments[c],
                    h = arguments[c + 1];
                  if (h[0] === A.delimiter) {
                    y = h;
                    continue;
                  }
                  d &&
                  h &&
                  d[d.length - 1] !== A.delimiter &&
                  h[0] !== A.delimiter
                    ? (y += A.delimiter + h)
                    : (y += h);
                }
                return y;
              },
              normalize: function (x) {
                const y = x.startsWith(A.delimiter),
                  c = x.endsWith(A.delimiter),
                  d = x.split("/");
                let h = "",
                  f = [];
                for (let s = 0; s < d.length; s++)
                  if (d[s] !== "" && d[s] !== ".") {
                    if (d[s] === ".." && f.length > 0) {
                      f = f.slice(0, f.length - 2);
                      continue;
                    }
                    s > 0 && f.push(A.delimiter), f.push(d[s]);
                  }
                return (
                  (h = f.join("")),
                  !y && h[0] === A.delimiter && (h = h.slice(1)),
                  c && h[h.length - 1] !== A.delimiter && (h += A.delimiter),
                  h
                );
              },
              split: function (x) {
                const y = x.lastIndexOf(A.delimiter);
                return y !== -1
                  ? [x.substring(0, y), x.substring(y + 1)]
                  : ["", x];
              },
              getBasename: function (x) {
                return A.split(x)[1];
              },
              getDirectory: function (x) {
                return A.split(x)[0];
              },
              getExtension: function (x) {
                const y = x.split("?")[0].split(".").pop();
                return y !== x ? "." + y : "";
              },
              isRelativePath: function (x) {
                return x.charAt(0) !== "/" && x.match(/:\/\//) === null;
              },
              extractPath: function (x) {
                let y = "";
                const c = x.split("/");
                let d = 0;
                if (c.length > 1)
                  if (A.isRelativePath(x))
                    if (c[0] === ".")
                      for (d = 0; d < c.length - 1; ++d)
                        y += d === 0 ? c[d] : "/" + c[d];
                    else if (c[0] === "..")
                      for (d = 0; d < c.length - 1; ++d)
                        y += d === 0 ? c[d] : "/" + c[d];
                    else
                      for (y = ".", d = 0; d < c.length - 1; ++d)
                        y += "/" + c[d];
                  else
                    for (d = 0; d < c.length - 1; ++d)
                      y += d === 0 ? c[d] : "/" + c[d];
                return y;
              },
            };
          },
          9222: (xe, V, a) => {
            "use strict";
            a.d(V, { i: () => o });
            const A = () => {
                let i = !1;
                try {
                  const e = Object.defineProperty({}, "passive", {
                    get: function () {
                      return (i = !0), !1;
                    },
                  });
                  window.addEventListener("testpassive", null, e),
                    window.removeEventListener("testpassive", null, e);
                } catch (e) {}
                return i;
              },
              x = typeof navigator != "undefined" ? navigator.userAgent : "",
              y = typeof window != "undefined" ? "browser" : "node",
              c = /android/i.test(x)
                ? "android"
                : /ip([ao]d|hone)/i.test(x)
                ? "ios"
                : /windows/i.test(x)
                ? "windows"
                : /mac os/i.test(x)
                ? "osx"
                : /linux/i.test(x)
                ? "linux"
                : /cros/i.test(x)
                ? "cros"
                : null,
              d =
                y !== "browser"
                  ? null
                  : /(Chrome\/|Chromium\/|Edg.*\/)/.test(x)
                  ? "chrome"
                  : /Safari\//.test(x)
                  ? "safari"
                  : /Firefox\//.test(x)
                  ? "firefox"
                  : "other",
              h = /xbox/i.test(x),
              f =
                y === "browser" &&
                ("ontouchstart" in window ||
                  ("maxTouchPoints" in navigator &&
                    navigator.maxTouchPoints > 0)),
              s =
                y === "browser" &&
                (!!navigator.getGamepads || !!navigator.webkitGetGamepads),
              l = typeof Worker != "undefined",
              n = A(),
              o = {
                environment: y,
                global: y === "browser" ? window : a.g,
                browser: y === "browser",
                desktop: ["windows", "osx", "linux", "cros"].includes(c),
                mobile: ["android", "ios"].includes(c),
                ios: c === "ios",
                android: c === "android",
                xbox: h,
                gamepads: s,
                touch: f,
                workers: l,
                passiveEvents: n,
                browserName: d,
              };
          },
          9482: (xe, V, a) => {
            "use strict";
            a.d(V, { B: () => A });
            class A {
              constructor(y) {
                (this.arraybuffer = y),
                  (this.dataView = new DataView(y)),
                  (this.offset = 0),
                  (this.stack = []);
              }
              get remainingBytes() {
                return this.dataView.byteLength - this.offset;
              }
              reset(y = 0) {
                this.offset = y;
              }
              skip(y) {
                this.offset += y;
              }
              align(y) {
                this.offset = (this.offset + y - 1) & ~(y - 1);
              }
              _inc(y) {
                return (this.offset += y), this.offset - y;
              }
              readChar() {
                return String.fromCharCode(
                  this.dataView.getUint8(this.offset++)
                );
              }
              readChars(y) {
                let c = "";
                for (let d = 0; d < y; ++d) c += this.readChar();
                return c;
              }
              readU8() {
                return this.dataView.getUint8(this.offset++);
              }
              readU16() {
                return this.dataView.getUint16(this._inc(2), !0);
              }
              readU32() {
                return this.dataView.getUint32(this._inc(4), !0);
              }
              readU64() {
                return this.readU32() + 4294967296 * this.readU32();
              }
              readU32be() {
                return this.dataView.getUint32(this._inc(4), !1);
              }
              readArray(y) {
                for (let c = 0; c < y.length; ++c) y[c] = this.readU8();
              }
              readLine() {
                const y = this.dataView;
                let c = "";
                for (; !(this.offset >= y.byteLength); ) {
                  const d = String.fromCharCode(this.readU8());
                  if (
                    d ===
                    `
`
                  )
                    break;
                  c += d;
                }
                return c;
              }
            }
          },
          4460: (xe, V, a) => {
            "use strict";
            a.d(V, { p: () => A });
            class A {
              constructor() {
                this._refCount = 0;
              }
              incRefCount() {
                this._refCount++;
              }
              decRefCount() {
                this._refCount--;
              }
              get refCount() {
                return this._refCount;
              }
            }
          },
          7915: (xe, V, a) => {
            "use strict";
            a.d(V, { I: () => f });
            var A = a(7481);
            const x = new A.e(),
              y = new A.e(),
              c = new A.e(),
              d = new A.e(),
              h = new A.e();
            class f {
              constructor(l = new A.e(), n = new A.e(0.5, 0.5, 0.5)) {
                (this.center = void 0),
                  (this.halfExtents = void 0),
                  (this._min = new A.e()),
                  (this._max = new A.e()),
                  (this.center = l),
                  (this.halfExtents = n);
              }
              add(l) {
                const n = this.center,
                  o = n.x,
                  i = n.y,
                  e = n.z,
                  t = this.halfExtents,
                  r = t.x,
                  u = t.y,
                  v = t.z;
                let _ = o - r,
                  m = o + r,
                  g = i - u,
                  T = i + u,
                  E = e - v,
                  M = e + v;
                const R = l.center,
                  P = R.x,
                  F = R.y,
                  b = R.z,
                  D = l.halfExtents,
                  G = D.x,
                  X = D.y,
                  ie = D.z,
                  Q = P - G,
                  te = P + G,
                  ae = F - X,
                  Z = F + X,
                  J = b - ie,
                  ve = b + ie;
                Q < _ && (_ = Q),
                  te > m && (m = te),
                  ae < g && (g = ae),
                  Z > T && (T = Z),
                  J < E && (E = J),
                  ve > M && (M = ve),
                  (n.x = (_ + m) * 0.5),
                  (n.y = (g + T) * 0.5),
                  (n.z = (E + M) * 0.5),
                  (t.x = (m - _) * 0.5),
                  (t.y = (T - g) * 0.5),
                  (t.z = (M - E) * 0.5);
              }
              copy(l) {
                this.center.copy(l.center),
                  this.halfExtents.copy(l.halfExtents);
              }
              clone() {
                return new f(this.center.clone(), this.halfExtents.clone());
              }
              intersects(l) {
                const n = this.getMax(),
                  o = this.getMin(),
                  i = l.getMax(),
                  e = l.getMin();
                return (
                  o.x <= i.x &&
                  n.x >= e.x &&
                  o.y <= i.y &&
                  n.y >= e.y &&
                  o.z <= i.z &&
                  n.z >= e.z
                );
              }
              _intersectsRay(l, n) {
                const o = x.copy(this.getMin()).sub(l.origin),
                  i = y.copy(this.getMax()).sub(l.origin),
                  e = l.direction;
                e.x === 0
                  ? ((o.x = o.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE),
                    (i.x = i.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE))
                  : ((o.x /= e.x), (i.x /= e.x)),
                  e.y === 0
                    ? ((o.y = o.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE),
                      (i.y = i.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE))
                    : ((o.y /= e.y), (i.y /= e.y)),
                  e.z === 0
                    ? ((o.z = o.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE),
                      (i.z = i.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE))
                    : ((o.z /= e.z), (i.z /= e.z));
                const t = c.set(
                    Math.min(o.x, i.x),
                    Math.min(o.y, i.y),
                    Math.min(o.z, i.z)
                  ),
                  r = d.set(
                    Math.max(o.x, i.x),
                    Math.max(o.y, i.y),
                    Math.max(o.z, i.z)
                  ),
                  u = Math.min(Math.min(r.x, r.y), r.z),
                  v = Math.max(Math.max(t.x, t.y), t.z),
                  _ = u >= v && v >= 0;
                return _ && n.copy(l.direction).mulScalar(v).add(l.origin), _;
              }
              _fastIntersectsRay(l) {
                const n = x,
                  o = y,
                  i = c,
                  e = d,
                  t = h,
                  r = l.direction;
                return (
                  n.sub2(l.origin, this.center),
                  e.set(Math.abs(n.x), Math.abs(n.y), Math.abs(n.z)),
                  i.mul2(n, r),
                  !(
                    (e.x > this.halfExtents.x && i.x >= 0) ||
                    (e.y > this.halfExtents.y && i.y >= 0) ||
                    (e.z > this.halfExtents.z && i.z >= 0) ||
                    (t.set(Math.abs(r.x), Math.abs(r.y), Math.abs(r.z)),
                    o.cross(r, n),
                    o.set(Math.abs(o.x), Math.abs(o.y), Math.abs(o.z)),
                    o.x >
                      this.halfExtents.y * t.z + this.halfExtents.z * t.y) ||
                    o.y > this.halfExtents.x * t.z + this.halfExtents.z * t.x ||
                    o.z > this.halfExtents.x * t.y + this.halfExtents.y * t.x
                  )
                );
              }
              intersectsRay(l, n) {
                return n
                  ? this._intersectsRay(l, n)
                  : this._fastIntersectsRay(l);
              }
              setMinMax(l, n) {
                this.center.add2(n, l).mulScalar(0.5),
                  this.halfExtents.sub2(n, l).mulScalar(0.5);
              }
              getMin() {
                return this._min.copy(this.center).sub(this.halfExtents);
              }
              getMax() {
                return this._max.copy(this.center).add(this.halfExtents);
              }
              containsPoint(l) {
                const n = this.getMin(),
                  o = this.getMax();
                return !(
                  l.x < n.x ||
                  l.x > o.x ||
                  l.y < n.y ||
                  l.y > o.y ||
                  l.z < n.z ||
                  l.z > o.z
                );
              }
              setFromTransformedAabb(l, n, o = !1) {
                const i = l.center,
                  e = l.halfExtents,
                  t = n.data;
                let r = t[0],
                  u = t[4],
                  v = t[8],
                  _ = t[1],
                  m = t[5],
                  g = t[9],
                  T = t[2],
                  E = t[6],
                  M = t[10];
                if (o) {
                  let R = r * r + u * u + v * v;
                  if (R > 0) {
                    const P = 1 / Math.sqrt(R);
                    (r *= P), (u *= P), (v *= P);
                  }
                  if (((R = _ * _ + m * m + g * g), R > 0)) {
                    const P = 1 / Math.sqrt(R);
                    (_ *= P), (m *= P), (g *= P);
                  }
                  if (((R = T * T + E * E + M * M), R > 0)) {
                    const P = 1 / Math.sqrt(R);
                    (T *= P), (E *= P), (M *= P);
                  }
                }
                this.center.set(
                  t[12] + r * i.x + u * i.y + v * i.z,
                  t[13] + _ * i.x + m * i.y + g * i.z,
                  t[14] + T * i.x + E * i.y + M * i.z
                ),
                  this.halfExtents.set(
                    Math.abs(r) * e.x + Math.abs(u) * e.y + Math.abs(v) * e.z,
                    Math.abs(_) * e.x + Math.abs(m) * e.y + Math.abs(g) * e.z,
                    Math.abs(T) * e.x + Math.abs(E) * e.y + Math.abs(M) * e.z
                  );
              }
              static computeMinMax(l, n, o, i = l.length / 3) {
                if (i > 0) {
                  let e = l[0],
                    t = l[1],
                    r = l[2],
                    u = e,
                    v = t,
                    _ = r;
                  const m = i * 3;
                  for (let g = 3; g < m; g += 3) {
                    const T = l[g],
                      E = l[g + 1],
                      M = l[g + 2];
                    T < e && (e = T),
                      E < t && (t = E),
                      M < r && (r = M),
                      T > u && (u = T),
                      E > v && (v = E),
                      M > _ && (_ = M);
                  }
                  n.set(e, t, r), o.set(u, v, _);
                }
              }
              compute(l, n) {
                f.computeMinMax(l, x, y, n), this.setMinMax(x, y);
              }
              intersectsBoundingSphere(l) {
                return (
                  this._distanceToBoundingSphereSq(l) <= l.radius * l.radius
                );
              }
              _distanceToBoundingSphereSq(l) {
                const n = this.getMin(),
                  o = this.getMax();
                let i = 0;
                const e = ["x", "y", "z"];
                for (let t = 0; t < 3; ++t) {
                  let r = 0;
                  const u = l.center[e[t]],
                    v = n[e[t]],
                    _ = o[e[t]];
                  let m = 0;
                  u < v && ((m = v - u), (r += m * m)),
                    u > _ && ((m = u - _), (r += m * m)),
                    (i += r);
                }
                return i;
              }
              _expand(l, n) {
                x.add2(this.getMin(), l),
                  y.add2(this.getMax(), n),
                  this.setMinMax(x, y);
              }
            }
          },
          5145: (xe, V, a) => {
            "use strict";
            a.d(V, { i: () => c });
            var A = a(7481);
            const x = new A.e(),
              y = new A.e();
            class c {
              constructor(h = new A.e(), f = 0.5) {
                (this.center = void 0),
                  (this.radius = void 0),
                  (this.center = h),
                  (this.radius = f);
              }
              containsPoint(h) {
                const f = x.sub2(h, this.center).lengthSq(),
                  s = this.radius;
                return f < s * s;
              }
              intersectsRay(h, f) {
                const s = x.copy(h.origin).sub(this.center),
                  l = s.dot(y.copy(h.direction).normalize()),
                  n = s.dot(s) - this.radius * this.radius;
                if (n > 0 && l > 0) return !1;
                const o = l * l - n;
                if (o < 0) return !1;
                const i = Math.abs(-l - Math.sqrt(o));
                return f && f.copy(h.direction).mulScalar(i).add(h.origin), !0;
              }
              intersectsBoundingSphere(h) {
                x.sub2(h.center, this.center);
                const f = h.radius + this.radius;
                return x.lengthSq() <= f * f;
              }
            }
          },
          3221: (xe, V, a) => {
            "use strict";
            a.d(V, { P: () => A });
            class A {
              constructor() {
                this.planes = [];
                for (let y = 0; y < 6; y++) this.planes[y] = [];
              }
              setFromMat4(y) {
                const c = y.data;
                let d;
                const h = this.planes;
                (d = h[0]),
                  (d[0] = c[3] - c[0]),
                  (d[1] = c[7] - c[4]),
                  (d[2] = c[11] - c[8]),
                  (d[3] = c[15] - c[12]);
                let f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
                (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[1]),
                  (d[0] = c[3] + c[0]),
                  (d[1] = c[7] + c[4]),
                  (d[2] = c[11] + c[8]),
                  (d[3] = c[15] + c[12]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[2]),
                  (d[0] = c[3] + c[1]),
                  (d[1] = c[7] + c[5]),
                  (d[2] = c[11] + c[9]),
                  (d[3] = c[15] + c[13]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[3]),
                  (d[0] = c[3] - c[1]),
                  (d[1] = c[7] - c[5]),
                  (d[2] = c[11] - c[9]),
                  (d[3] = c[15] - c[13]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[4]),
                  (d[0] = c[3] - c[2]),
                  (d[1] = c[7] - c[6]),
                  (d[2] = c[11] - c[10]),
                  (d[3] = c[15] - c[14]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[5]),
                  (d[0] = c[3] + c[2]),
                  (d[1] = c[7] + c[6]),
                  (d[2] = c[11] + c[10]),
                  (d[3] = c[15] + c[14]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f);
              }
              containsPoint(y) {
                let c, d;
                for (c = 0; c < 6; c++)
                  if (
                    ((d = this.planes[c]),
                    d[0] * y.x + d[1] * y.y + d[2] * y.z + d[3] <= 0)
                  )
                    return !1;
                return !0;
              }
              containsSphere(y) {
                let c = 0,
                  d,
                  h;
                const f = y.radius,
                  s = y.center,
                  l = s.x,
                  n = s.y,
                  o = s.z,
                  i = this.planes;
                let e;
                for (h = 0; h < 6; h++) {
                  if (
                    ((e = i[h]),
                    (d = e[0] * l + e[1] * n + e[2] * o + e[3]),
                    d <= -f)
                  )
                    return 0;
                  d > f && c++;
                }
                return c === 6 ? 2 : 1;
              }
            }
          },
          7337: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => x });
            var A = a(7481);
            class x {
              constructor(c = A.e.UP, d = 0) {
                (this.normal = new A.e()),
                  (this.distance = void 0),
                  this.normal.copy(c),
                  (this.distance = d);
              }
              setFromPointNormal(c, d) {
                return (
                  this.normal.copy(d),
                  (this.distance = -this.normal.dot(c)),
                  this
                );
              }
              intersectsLine(c, d, h) {
                const f = this.distance,
                  s = this.normal.dot(c) + f,
                  l = this.normal.dot(d) + f,
                  n = s / (s - l),
                  o = n >= 0 && n <= 1;
                return o && h && h.lerp(c, d, n), o;
              }
              intersectsRay(c, d) {
                const h = this.normal.dot(c.direction);
                if (h === 0) return !1;
                const f = -(this.normal.dot(c.origin) + this.distance) / h;
                return (
                  f >= 0 && d && d.copy(c.direction).mulScalar(f).add(c.origin),
                  f >= 0
                );
              }
              copy(c) {
                return (
                  this.normal.copy(c.normal), (this.distance = c.distance), this
                );
              }
              clone() {
                const c = this.constructor;
                return new c().copy(this);
              }
            }
          },
          9663: (xe, V, a) => {
            "use strict";
            a.d(V, { R: () => x });
            var A = a(7481);
            class x {
              constructor(c, d) {
                (this.origin = new A.e()),
                  (this.direction = A.e.FORWARD.clone()),
                  c && this.origin.copy(c),
                  d && this.direction.copy(d);
              }
              set(c, d) {
                return this.origin.copy(c), this.direction.copy(d), this;
              }
              copy(c) {
                return this.set(c.origin, c.direction);
              }
              clone() {
                return new this.constructor(this.origin, this.direction);
              }
            }
          },
          1014: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => x });
            const A = (y, c) => y.priority - c.priority,
              x = (y) => y.sort(A);
          },
          5767: (xe, V, a) => {
            "use strict";
            a.d(V, { B: () => A });
            class A {
              constructor(y) {
                (this.items = []),
                  (this.length = 0),
                  (this.loopIndex = -1),
                  (this._sortBy = void 0),
                  (this._sortHandler = void 0),
                  (this._sortBy = y.sortBy),
                  (this._sortHandler = this._doSort.bind(this));
              }
              _binarySearch(y) {
                let c = 0,
                  d = this.items.length - 1;
                const h = y[this._sortBy];
                let f, s;
                for (; c <= d; )
                  (f = Math.floor((c + d) / 2)),
                    (s = this.items[f][this._sortBy]),
                    s <= h ? (c = f + 1) : s > h && (d = f - 1);
                return c;
              }
              _doSort(y, c) {
                const d = this._sortBy;
                return y[d] - c[d];
              }
              insert(y) {
                const c = this._binarySearch(y);
                this.items.splice(c, 0, y),
                  this.length++,
                  this.loopIndex >= c && this.loopIndex++;
              }
              append(y) {
                this.items.push(y), this.length++;
              }
              remove(y) {
                const c = this.items.indexOf(y);
                c < 0 ||
                  (this.items.splice(c, 1),
                  this.length--,
                  this.loopIndex >= c && this.loopIndex--);
              }
              sort() {
                const y =
                  this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
                this.items.sort(this._sortHandler),
                  y !== null && (this.loopIndex = this.items.indexOf(y));
              }
            }
          },
          271: (xe, V, a) => {
            "use strict";
            a.d(V, { w: () => A });
            class A {
              constructor() {
                (this.map = new Map()), (this.id = 0);
              }
              get(y) {
                let c = this.map.get(y);
                return c === void 0 && ((c = this.id++), this.map.set(y, c)), c;
              }
            }
          },
          8772: (xe, V, a) => {
            "use strict";
            a.d(V, { Y: () => g });
            const A = "abcdefghijklmnopqrstuvwxyz",
              x = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
              y = A + x,
              c = 55296,
              d = 56319,
              h = 56320,
              f = 57343,
              s = 8205,
              l = 127462,
              n = 127487,
              o = 127995,
              i = 127999,
              e = 8400,
              t = 8447,
              r = 65024,
              u = 65039;
            function v(T, E = 0) {
              const M = T.length;
              if (E < 0 || E >= M) return null;
              const R = T.charCodeAt(E);
              if (M > 1 && R >= c && R <= d) {
                const P = T.charCodeAt(E + 1);
                if (P >= h && P <= f)
                  return { code: (R - c) * 1024 + P - h + 65536, long: !0 };
              }
              return { code: R, long: !1 };
            }
            function _(T, E, M) {
              if (!T) return !1;
              const R = v(T);
              if (R) {
                const P = R.code;
                return P >= E && P <= M;
              }
              return !1;
            }
            function m(T, E) {
              if (E === T.length - 1) return 1;
              if (_(T[E], c, d)) {
                const M = T.substring(E, E + 2),
                  R = T.substring(E + 2, E + 4);
                return _(R, o, i) || (_(M, l, n) && _(R, l, n))
                  ? 4
                  : _(R, r, u)
                  ? 3
                  : 2;
              }
              return _(T[E + 1], r, u) ? 2 : 1;
            }
            const g = {
              ASCII_LOWERCASE: A,
              ASCII_UPPERCASE: x,
              ASCII_LETTERS: y,
              format: function (T, ...E) {
                for (let M = 0; M < E.length; M++)
                  T = T.replace(`{${M}}`, E[M]);
                return T;
              },
              getCodePoint: function (T, E) {
                const M = v(T, E);
                return M && M.code;
              },
              getCodePoints: function (T) {
                if (typeof T != "string") throw new TypeError("Not a string");
                let E = 0;
                const M = [];
                let R;
                for (; (R = v(T, E)); ) M.push(R.code), (E += R.long ? 2 : 1);
                return M;
              },
              getSymbols: function (T) {
                if (typeof T != "string") throw new TypeError("Not a string");
                let E = 0;
                const M = T.length,
                  R = [];
                let P = 0,
                  F;
                for (; E < M; ) {
                  if (
                    ((P += m(T, E + P)),
                    (F = T[E + P]),
                    _(F, e, t) && (F = T[E + P++]),
                    _(F, r, u) && (F = T[E + P++]),
                    F && F.charCodeAt(0) === s)
                  ) {
                    F = T[E + P++];
                    continue;
                  }
                  const b = T.substring(E, E + P);
                  R.push(b), (E += P), (P = 0);
                }
                return R;
              },
              fromCodePoint: function () {
                const T = [];
                let E, M, R;
                for (let P = 0; P < arguments.length; ++P)
                  (E = Number(arguments[P])),
                    (M = E - 65536),
                    (R =
                      E > 65535
                        ? [(M >> 10) + 55296, (M % 1024) + 56320]
                        : [E]),
                    T.push(String.fromCharCode.apply(null, R));
                return T.join("");
              },
            };
          },
          244: (xe, V, a) => {
            "use strict";
            a.d(V, { Y: () => x });
            var A = a(8976);
            class x extends A.J {
              constructor(c) {
                super(),
                  (this._index = {}),
                  (this._list = []),
                  (this._parent = c);
              }
              add() {
                let c = !1;
                const d = this._processArguments(arguments, !0);
                if (!d.length) return c;
                for (let h = 0; h < d.length; h++)
                  this._index[d[h]] ||
                    ((c = !0),
                    (this._index[d[h]] = !0),
                    this._list.push(d[h]),
                    this.fire("add", d[h], this._parent));
                return c && this.fire("change", this._parent), c;
              }
              remove() {
                let c = !1;
                if (!this._list.length) return c;
                const d = this._processArguments(arguments, !0);
                if (!d.length) return c;
                for (let h = 0; h < d.length; h++)
                  this._index[d[h]] &&
                    ((c = !0),
                    delete this._index[d[h]],
                    this._list.splice(this._list.indexOf(d[h]), 1),
                    this.fire("remove", d[h], this._parent));
                return c && this.fire("change", this._parent), c;
              }
              clear() {
                if (!this._list.length) return;
                const c = this._list.slice(0);
                (this._list = []), (this._index = {});
                for (let d = 0; d < c.length; d++)
                  this.fire("remove", c[d], this._parent);
                this.fire("change", this._parent);
              }
              has() {
                return this._list.length
                  ? this._has(this._processArguments(arguments))
                  : !1;
              }
              _has(c) {
                if (!this._list.length || !c.length) return !1;
                for (let d = 0; d < c.length; d++)
                  if (c[d].length === 1) {
                    if (this._index[c[d][0]]) return !0;
                  } else {
                    let h = !0;
                    for (let f = 0; f < c[d].length; f++)
                      if (!this._index[c[d][f]]) {
                        h = !1;
                        break;
                      }
                    if (h) return !0;
                  }
                return !1;
              }
              list() {
                return this._list.slice(0);
              }
              _processArguments(c, d) {
                const h = [];
                let f = [];
                if (!c || !c.length) return h;
                for (let s = 0; s < c.length; s++)
                  if (c[s] instanceof Array) {
                    d || (f = []);
                    for (let l = 0; l < c[s].length; l++)
                      typeof c[s][l] == "string" &&
                        (d ? h.push(c[s][l]) : f.push(c[s][l]));
                    !d && f.length && h.push(f);
                  } else
                    typeof c[s] == "string" &&
                      (d ? h.push(c[s]) : h.push([c[s]]));
                return h;
              }
              get size() {
                return this._list.length;
              }
            }
          },
          9516: (xe, V, a) => {
            "use strict";
            a.d(V, { t: () => A });
            const A =
              typeof window != "undefined" &&
              window.performance &&
              window.performance.now
                ? performance.now.bind(performance)
                : Date.now;
          },
          27: (xe, V, a) => {
            "use strict";
            a.d(V, { l: () => A });
            class A {
              static set(y, c = !0) {}
              static get(y) {
                return A._traceChannels.has(y);
              }
            }
            (A._traceChannels = new Set()), (A.stack = !1);
          },
          2079: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => A, r: () => y });
            function A(c) {
              let d = "";
              if ((c.authority || c.scheme) && (c.host || c.hostpath))
                throw new Error(
                  "Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option"
                );
              if (c.host && c.hostpath)
                throw new Error("Can't have 'host' and 'hostpath' option");
              if (c.path && c.hostpath)
                throw new Error("Can't have 'path' and 'hostpath' option");
              return (
                c.scheme && (d += c.scheme + ":"),
                c.authority && (d += "//" + c.authority),
                c.host && (d += c.host),
                c.path && (d += c.path),
                c.hostpath && (d += c.hostpath),
                c.query && (d += "?" + c.query),
                c.fragment && (d += "#" + c.fragment),
                d
              );
            }
            const x =
              /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
            class y {
              constructor(d) {
                (this.scheme = void 0),
                  (this.authority = void 0),
                  (this.path = void 0),
                  (this.query = void 0),
                  (this.fragment = void 0);
                const h = d.match(x);
                (this.scheme = h[2]),
                  (this.authority = h[4]),
                  (this.path = h[5]),
                  (this.query = h[7]),
                  (this.fragment = h[9]);
              }
              toString() {
                let d = "";
                return (
                  this.scheme && (d += this.scheme + ":"),
                  this.authority && (d += "//" + this.authority),
                  (d += this.path),
                  this.query && (d += "?" + this.query),
                  this.fragment && (d += "#" + this.fragment),
                  d
                );
              }
              getQuery() {
                const d = {};
                if (this.query) {
                  const h = decodeURIComponent(this.query).split("&");
                  for (const f of h) {
                    const s = f.split("=");
                    d[s[0]] = s[1];
                  }
                }
                return d;
              }
              setQuery(d) {
                let h = "";
                for (const f in d)
                  d.hasOwnProperty(f) &&
                    (h !== "" && (h += "&"),
                    (h +=
                      encodeURIComponent(f) + "=" + encodeURIComponent(d[f])));
                this.query = h;
              }
            }
          },
          5562: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => y });
            const A = (c) => {
              const d = {};
              let h = d;
              return () => (h === d && (h = c()), h);
            };
            class x {
              static loadScript(d, h) {
                const f = document.createElement("script");
                f.setAttribute("src", d),
                  (f.onload = () => {
                    h(null);
                  }),
                  (f.onerror = () => {
                    h(`Failed to load script='${d}'`);
                  }),
                  document.body.appendChild(f);
              }
              static loadWasm(d, h, f) {
                const s =
                  x.wasmSupported() && h.glueUrl && h.wasmUrl
                    ? h.glueUrl
                    : h.fallbackUrl;
                s
                  ? x.loadScript(s, (l) => {
                      if (l) f(l, null);
                      else {
                        const n = window[d];
                        (window[d] = void 0),
                          n({
                            locateFile: () => h.wasmUrl,
                            onAbort: () => {
                              f("wasm module aborted.");
                            },
                          }).then((o) => {
                            f(null, o);
                          });
                      }
                    })
                  : f("No supported wasm modules found.", null);
              }
              static getModule(d) {
                return (
                  x.modules.hasOwnProperty(d) ||
                    (x.modules[d] = {
                      config: null,
                      initializing: !1,
                      instance: null,
                      callbacks: [],
                    }),
                  x.modules[d]
                );
              }
              static initialize(d, h) {
                if (h.initializing) return;
                const f = h.config;
                (f.glueUrl || f.wasmUrl || f.fallbackUrl) &&
                  ((h.initializing = !0),
                  x.loadWasm(d, f, (s, l) => {
                    s
                      ? f.errorHandler
                        ? f.errorHandler(s)
                        : console.error(
                            `failed to initialize module=${d} error=${s}`
                          )
                      : ((h.instance = l),
                        h.callbacks.forEach((n) => {
                          n(l);
                        }));
                  }));
              }
            }
            (x.modules = {}),
              (x.wasmSupported = A(() => {
                try {
                  if (
                    typeof WebAssembly == "object" &&
                    typeof WebAssembly.instantiate == "function"
                  ) {
                    const c = new WebAssembly.Module(
                      Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)
                    );
                    if (c instanceof WebAssembly.Module)
                      return (
                        new WebAssembly.Instance(c) instanceof
                        WebAssembly.Instance
                      );
                  }
                } catch (c) {}
                return !1;
              }));
            class y {
              static setConfig(d, h) {
                const f = x.getModule(d);
                (f.config = h), f.callbacks.length > 0 && x.initialize(d, f);
              }
              static getConfig(d) {
                var h;
                return (h = x.modules) == null || (h = h[d]) == null
                  ? void 0
                  : h.config;
              }
              static getInstance(d, h) {
                const f = x.getModule(d);
                f.instance
                  ? h(f.instance)
                  : (f.callbacks.push(h), f.config && x.initialize(d, f));
              }
            }
          },
          54: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $I: () => _t,
              $n: () => xt,
              A$: () => $s,
              A5: () => Ps,
              A6: () => nt,
              B: () => $e,
              B1: () => hi,
              B5: () => Ze,
              Br: () => Ve,
              Gd: () => Ye,
              H6: () => rt,
              Hy: () => Ms,
              Ib: () => Ne,
              JH: () => es,
              LY: () => Xe,
              O_: () => Js,
              Qe: () => Cs,
              R0: () => ii,
              Rm: () => Xt,
              Rs: () => ci,
              S9: () => Ke,
              W2: () => pe,
              WC: () => wt,
              XA: () => Qe,
              Xt: () => Os,
              YF: () => fs,
              _o: () => ft,
              _r: () => ot,
              bl: () => De,
              cW: () => ct,
              cb: () => Nt,
              dt: () => Ts,
              eW: () => et,
              fQ: () => fe,
              gv: () => Je,
              hF: () => vs,
              k5: () => li,
              kB: () => Pe,
              kQ: () => Tt,
              lB: () => ce,
              lZ: () => Gs,
              mn: () => lt,
              o7: () => Bt,
              om: () => Qt,
              rm: () => bs,
              s5: () => ze,
              s_: () => at,
              xY: () => Fe,
              z7: () => us,
            });
            var A = a(8506),
              x = a(8772),
              y = a(9516),
              c = a(8656),
              d = a(5227),
              h = a(8484),
              f = a(7994),
              s = a(7481),
              l = a(5596),
              n = a(7915),
              o = a(5145),
              i = a(3221),
              e = a(7337),
              t = a(1630),
              r = a(4559),
              u = a(8524),
              v = a(2910),
              _ = a(4461),
              m = a(970),
              g = a(4294),
              T = a(2205),
              E = a(6874),
              M = a(783),
              R = a(9061),
              P = a(4113),
              F = a(8526),
              b = a(5321),
              D = a(1208),
              G = a(5860),
              X = a(6089),
              ie = a(1984),
              Q = a(9855),
              te = a(8136),
              ae = a(1268),
              Z = a(4870),
              J = a(9391),
              ve = a(8531),
              _e = a(2310),
              L = a(597),
              ge = a(600),
              k = a(3035),
              j = a(2658),
              B = a(7197),
              $ = a(528),
              le = a(3637),
              O = a(9611),
              Y = a(2863),
              ne = a(6306),
              de = a(1036),
              re = a(8097),
              I = a(8777),
              w = a(1369),
              N = a(4471),
              W = a(1594),
              he = a(6261),
              ue = a(8944),
              ye = a(2223),
              Oe = a(5465),
              Ae = a(7284),
              ke = a(3231),
              Ue = a(8844),
              Ge = a(5009),
              ht = a(6122),
              me = a(2378),
              z = a(0),
              K = a(7223),
              Te = a(5588),
              H = a(7896),
              q = a(2921),
              se = a(8789),
              Ce = a(4967),
              we = a(9273),
              Me = a(9800),
              Ie = a(8520),
              Le = a(7500),
              tt = a(7788),
              vt = a(4530),
              it = a(2364),
              At = a(9763),
              Rt = a(7654),
              Ft = a(8103),
              ut = a(8379),
              Pt = a(6225),
              bt = a(1849),
              Zt = a(7712);
            const Xt = {
              write: function (je) {
                console.log(je);
              },
              open: function () {
                Xt.write("Powered by PlayCanvas " + A.rE + " " + A.QL);
              },
              info: function (je) {
                console.info("INFO:    " + je);
              },
              debug: function (je) {
                console.debug("DEBUG:   " + je);
              },
              error: function (je) {
                console.error("ERROR:   " + je);
              },
              warning: function (je) {
                console.warn("WARNING: " + je);
              },
              alert: function (je) {
                Xt.write("ALERT:   " + je), alert(je);
              },
              assert: function (je, mt) {
                je === !1 && Xt.write("ASSERT:  " + mt);
              },
            };
            (x.Y.endsWith = function (je, mt) {
              return je.endsWith(mt);
            }),
              (x.Y.startsWith = function (je, mt) {
                return je.startsWith(mt);
              });
            class yt {
              constructor() {
                (this._isRunning = !1), (this._a = 0), (this._b = 0);
              }
              start() {
                (this._isRunning = !0), (this._a = (0, y.t)());
              }
              stop() {
                (this._isRunning = !1), (this._b = (0, y.t)());
              }
              getMilliseconds() {
                return this._b - this._a;
              }
            }
            const Pe = { now: y.t, Timer: yt };
            Object.defineProperty(d.Q.prototype, "data", {
              get: function () {
                return (
                  this._data || (this._data = new Float32Array(4)),
                  (this._data[0] = this.r),
                  (this._data[1] = this.g),
                  (this._data[2] = this.b),
                  (this._data[3] = this.a),
                  this._data
                );
              },
            }),
              Object.defineProperty(d.Q.prototype, "data3", {
                get: function () {
                  return (
                    this._data3 || (this._data3 = new Float32Array(3)),
                    (this._data3[0] = this.r),
                    (this._data3[1] = this.g),
                    (this._data3[2] = this.b),
                    this._data3
                  );
                },
              });
            function $e(je, mt) {
              const Ot = function () {},
                ss = function (is, Ls, js, fi, pi, _i, mi, gi) {
                  mt.call(this, is, Ls, js, fi, pi, _i, mi, gi),
                    je.call(this, is, Ls, js, fi, pi, _i, mi, gi);
                };
              return (
                (ss._super = mt.prototype),
                (Ot.prototype = mt.prototype),
                (ss.prototype = new Ot()),
                ss
              );
            }
            function Je(je) {
              return Array.prototype.slice.call(je);
            }
            function rt(je) {
              const mt = document.createElement("style");
              return (
                (mt.type = "text/css"),
                mt.styleSheet
                  ? (mt.styleSheet.cssText = je)
                  : mt.appendChild(document.createTextNode(je)),
                mt
              );
            }
            (c.D.INV_LOG2 = Math.LOG2E),
              (c.D.intToBytes = c.D.intToBytes32),
              (c.D.bytesToInt = c.D.bytesToInt32),
              Object.defineProperty(f.Z.prototype, "data", {
                get: function () {
                  return (
                    this._data || (this._data = new Float32Array(2)),
                    (this._data[0] = this.x),
                    (this._data[1] = this.y),
                    this._data
                  );
                },
              }),
              (f.Z.prototype.scale = f.Z.prototype.mulScalar),
              Object.defineProperty(s.e.prototype, "data", {
                get: function () {
                  return (
                    this._data || (this._data = new Float32Array(3)),
                    (this._data[0] = this.x),
                    (this._data[1] = this.y),
                    (this._data[2] = this.z),
                    this._data
                  );
                },
              }),
              (s.e.prototype.scale = s.e.prototype.mulScalar),
              Object.defineProperty(l.Z.prototype, "data", {
                get: function () {
                  return (
                    this._data || (this._data = new Float32Array(4)),
                    (this._data[0] = this.x),
                    (this._data[1] = this.y),
                    (this._data[2] = this.z),
                    (this._data[3] = this.w),
                    this._data
                  );
                },
              }),
              (l.Z.prototype.scale = l.Z.prototype.mulScalar);
            const ct = { Aabb: n.I, Sphere: o.i, Plane: e.Z };
            (o.i.prototype.intersectRay = o.i.prototype.intersectsRay),
              (i.P.prototype.update = function (je, mt) {
                const Ot = new h.$();
                Ot.mul2(je, mt), this.setFromMat4(Ot);
              });
            const Ve = t.VSW,
              wt = t.EUX,
              at = t.kF,
              ce = t.rvO,
              pe = t.uVx,
              De = t.Bz3,
              fe = t.n$B,
              Ze = t._3,
              Ne = t.kqw,
              Ye = t.zIz,
              Ke = t.LDn,
              nt = t.akF,
              ot = t.Lxj,
              ze = t.IrR,
              et = t.iQ7,
              _t = t.IrR,
              Qe = t.iQ7;
            function lt(je) {
              (this.name = "UnsupportedBrowserError"),
                (this.message = je || "");
            }
            lt.prototype = Error.prototype;
            function xt(je) {
              (this.name = "ContextCreationError"), (this.message = je || "");
            }
            xt.prototype = Error.prototype;
            const Tt = {
                begin: r.qN,
                dummyFragmentCode: Q.l.dummyFragmentCode,
                end: r._N,
                fogCode: r.cu,
                gammaCode: r.PY,
                precisionCode: Q.l.precisionCode,
                skinCode: r.P1,
                tonemapCode: r.K,
                versionCode: Q.l.versionCode,
              },
              ft = {
                ADDRESS_CLAMP_TO_EDGE: t.vq6,
                ADDRESS_MIRRORED_REPEAT: t.qoY,
                ADDRESS_REPEAT: t.x3I,
                BLENDMODE_ZERO: t.seI,
                BLENDMODE_ONE: t.qa5,
                BLENDMODE_SRC_COLOR: t.iRx,
                BLENDMODE_ONE_MINUS_SRC_COLOR: t.UCl,
                BLENDMODE_DST_COLOR: t.FHY,
                BLENDMODE_ONE_MINUS_DST_COLOR: t.$Qt,
                BLENDMODE_SRC_ALPHA: t.LDz,
                BLENDMODE_SRC_ALPHA_SATURATE: t.Jjv,
                BLENDMODE_ONE_MINUS_SRC_ALPHA: t.dIP,
                BLENDMODE_DST_ALPHA: t.OUj,
                BLENDMODE_ONE_MINUS_DST_ALPHA: t.u_5,
                BUFFER_STATIC: t.y1K,
                BUFFER_DYNAMIC: t.pCO,
                BUFFER_STREAM: t.oDV,
                CULLFACE_NONE: t.pLF,
                CULLFACE_BACK: t.K1r,
                CULLFACE_FRONT: t.CWw,
                CULLFACE_FRONTANDBACK: t.AQ1,
                ELEMENTTYPE_INT8: t.VSW,
                ELEMENTTYPE_UINT8: t.EUX,
                ELEMENTTYPE_INT16: t.kF,
                ELEMENTTYPE_UINT16: t.rvO,
                ELEMENTTYPE_INT32: t.uVx,
                ELEMENTTYPE_UINT32: t.Bz3,
                ELEMENTTYPE_FLOAT32: t.n$B,
                FILTER_NEAREST: t.uhC,
                FILTER_LINEAR: t.DrA,
                FILTER_NEAREST_MIPMAP_NEAREST: t.GLw,
                FILTER_NEAREST_MIPMAP_LINEAR: t.hs2,
                FILTER_LINEAR_MIPMAP_NEAREST: t.reG,
                FILTER_LINEAR_MIPMAP_LINEAR: t.qn_,
                INDEXFORMAT_UINT8: t.zYw,
                INDEXFORMAT_UINT16: t.c02,
                INDEXFORMAT_UINT32: t.gpl,
                PIXELFORMAT_RGB565: t.kqw,
                PIXELFORMAT_RGB8: t.akF,
                PIXELFORMAT_RGBA8: t.Lxj,
                PRIMITIVE_POINTS: t._AA,
                PRIMITIVE_LINES: t.EEU,
                PRIMITIVE_LINELOOP: t.HsS,
                PRIMITIVE_LINESTRIP: t.PTM,
                PRIMITIVE_TRIANGLES: t.Qpk,
                PRIMITIVE_TRISTRIP: t.SF$,
                PRIMITIVE_TRIFAN: t.zl$,
                SEMANTIC_POSITION: t.JYe,
                SEMANTIC_NORMAL: t.XF6,
                SEMANTIC_COLOR: t.F8$,
                SEMANTIC_TEXCOORD: t.CWz,
                SEMANTIC_TEXCOORD0: t.slc,
                SEMANTIC_TEXCOORD1: t.zEd,
                SEMANTIC_ATTR0: t.NFm,
                SEMANTIC_ATTR1: t.UhA,
                SEMANTIC_ATTR2: t.$1R,
                SEMANTIC_ATTR3: t.G3_,
                TEXTURELOCK_READ: t.odD,
                TEXTURELOCK_WRITE: t.$Q8,
                drawQuadWithShader: u.l,
                programlib: Tt,
                shaderChunks: v.G,
                ContextCreationError: xt,
                Device: _.G,
                IndexBuffer: m.h,
                ProgramLibrary: E.M,
                RenderTarget: R.O,
                ScopeId: P.w,
                Shader: F.M,
                ShaderInput: b.j,
                Texture: D.g,
                UnsupportedBrowserError: lt,
                VertexBuffer: G.R,
                VertexFormat: X.y,
                VertexIterator: ie.P,
              },
              gt = new l.Z();
            function Fe(je, mt, Ot, ss, qt) {
              let is;
              if (qt) {
                const Ls = mt ? mt.width : je.width,
                  js = mt ? mt.height : je.height;
                is = gt.set(qt.x * Ls, qt.y * js, qt.z * Ls, qt.w * js);
              }
              (0, u.l)(je, mt, ss, is);
            }
            const Qt = {
              createFullscreenQuad: (je) => je.quadVertexBuffer,
              drawFullscreenQuad: Fe,
              PostEffect: g.o,
              PostEffectQueue: T.T,
            };
            Object.defineProperty(v.G, "transformSkinnedVS", {
              get: function () {
                return (
                  `#define SKIN
` + v.G.transformVS
                );
              },
            }),
              Object.keys({
                "ambientPrefilteredCube.frag": "ambientEnv.frag",
                "ambientPrefilteredCubeLod.frag": "ambientEnv.frag",
                "dpAtlasQuad.frag": null,
                "genParaboloid.frag": null,
                "prefilterCubemap.frag": null,
                "reflectionDpAtlas.frag": "reflectionEnv.frag",
                "reflectionPrefilteredCube.frag": "reflectionEnv.frag",
                "reflectionPrefilteredCubeLod.frag": "reflectionEnv.frag",
              }).forEach((je) => {
                Object.defineProperty(v.G, je, {
                  get: function () {
                    return null;
                  },
                  set: function () {},
                });
              }),
              Object.defineProperties(R.O.prototype, {
                _glFrameBuffer: {
                  get: function () {
                    return this.impl._glFrameBuffer;
                  },
                  set: function (je) {},
                },
              }),
              Object.defineProperty(X.y, "defaultInstancingFormat", {
                get: function () {
                  return X.y.getDefaultInstancingFormat(te.A.get());
                },
              }),
              Object.defineProperties(D.g.prototype, {
                rgbm: {
                  get: function () {
                    return this.type === t.fW0;
                  },
                  set: function (je) {
                    this.type = je ? t.fW0 : t.s64;
                  },
                },
                swizzleGGGR: {
                  get: function () {
                    return this.type === t.wmq;
                  },
                  set: function (je) {
                    this.type = je ? t.wmq : t.s64;
                  },
                },
                _glTexture: {
                  get: function () {
                    return this.impl._glTexture;
                  },
                },
                autoMipmap: {
                  get: function () {
                    return this._mipmaps;
                  },
                  set: function (je) {
                    this._mipmaps = je;
                  },
                },
              }),
              (_.G.prototype.getProgramLibrary = function () {
                return (0, M.k)(this);
              }),
              (_.G.prototype.setProgramLibrary = function (je) {
                (0, M.o)(this, je);
              }),
              (_.G.prototype.removeShaderFromCache = function (je) {
                (0, M.k)(this).removeFromCache(je);
              }),
              (ae.t.DEFAULT = Object.freeze(new ae.t()));
            const Lt = new ae.t(),
              $t = new Z.H();
            (_.G.prototype.setBlendFunction = function (je, mt) {
              const Ot = this.blendState;
              Lt.copy(Ot),
                Lt.setColorBlend(Ot.colorOp, je, mt),
                Lt.setAlphaBlend(Ot.alphaOp, je, mt),
                this.setBlendState(Lt);
            }),
              (_.G.prototype.setBlendFunctionSeparate = function (
                je,
                mt,
                Ot,
                ss
              ) {
                const qt = this.blendState;
                Lt.copy(qt),
                  Lt.setColorBlend(qt.colorOp, je, mt),
                  Lt.setAlphaBlend(qt.alphaOp, Ot, ss),
                  this.setBlendState(Lt);
              }),
              (_.G.prototype.setBlendEquation = function (je) {
                const mt = this.blendState;
                Lt.copy(mt),
                  Lt.setColorBlend(je, mt.colorSrcFactor, mt.colorDstFactor),
                  Lt.setAlphaBlend(je, mt.alphaSrcFactor, mt.alphaDstFactor),
                  this.setBlendState(Lt);
              }),
              (_.G.prototype.setBlendEquationSeparate = function (je, mt) {
                const Ot = this.blendState;
                Lt.copy(Ot),
                  Lt.setColorBlend(je, Ot.colorSrcFactor, Ot.colorDstFactor),
                  Lt.setAlphaBlend(mt, Ot.alphaSrcFactor, Ot.alphaDstFactor),
                  this.setBlendState(Lt);
              }),
              (_.G.prototype.setColorWrite = function (je, mt, Ot, ss) {
                const qt = this.blendState;
                Lt.copy(qt),
                  Lt.setColorWrite(je, mt, Ot, ss),
                  this.setBlendState(Lt);
              }),
              (_.G.prototype.getBlending = function () {
                return this.blendState.blend;
              }),
              (_.G.prototype.setBlending = function (je) {
                Lt.copy(this.blendState),
                  (Lt.blend = je),
                  this.setBlendState(Lt);
              }),
              (_.G.prototype.setDepthWrite = function (je) {
                $t.copy(this.depthState),
                  ($t.write = je),
                  this.setDepthState($t);
              }),
              (_.G.prototype.setDepthFunc = function (je) {
                $t.copy(this.depthState),
                  ($t.func = je),
                  this.setDepthState($t);
              }),
              (_.G.prototype.setDepthTest = function (je) {
                $t.copy(this.depthState),
                  ($t.test = je),
                  this.setDepthState($t);
              }),
              (_.G.prototype.getCullMode = function () {
                return this.cullMode;
              });
            const Bt = w.F,
              Nt = ue.n,
              es = {
                partitionSkin: _e.g,
                procedural: {
                  calculateTangents: ve.hS,
                  createMesh: ve.qk,
                  createTorus: ve.s6,
                  createCylinder: ve.T8,
                  createCapsule: ve.qY,
                  createCone: ve.Eu,
                  createSphere: ve.wh,
                  createPlane: ve.FK,
                  createBox: ve.ge,
                },
                BasicMaterial: L.E,
                Command: le.u,
                ForwardRenderer: ge.v,
                GraphNode: k.t,
                Material: j.i,
                Mesh: B.e,
                MeshInstance: le.F,
                Model: O.K,
                ParticleEmitter: Y.v,
                PhongMaterial: w.F,
                Picker: ne.L,
                Projection: { ORTHOGRAPHIC: J.RD, PERSPECTIVE: J.$J },
                Scene: de.Z,
                Skin: re.M,
                SkinInstance: I.h,
              };
            Object.defineProperty(de.Z.prototype, "defaultMaterial", {
              get: function () {
                return (0, W.h)((0, vt.D)().graphicsDevice);
              },
            }),
              ["128", "64", "32", "16", "8", "4"].forEach((je, mt) => {
                Object.defineProperty(
                  de.Z.prototype,
                  `skyboxPrefiltered${je}`,
                  {
                    get: function () {
                      return this._prefilteredCubemaps[mt];
                    },
                    set: function (Ot) {
                      (this._prefilteredCubemaps[mt] = Ot),
                        (this.updateShaders = !0);
                    },
                  }
                );
              }),
              Object.defineProperty(de.Z.prototype, "models", {
                get: function () {
                  return this._models || (this._models = []), this._models;
                },
              }),
              Object.defineProperty(ye.W.prototype, "renderTarget", {
                set: function (je) {
                  (this._renderTarget = je), (this._dirtyCameras = !0);
                },
                get: function () {
                  return this._renderTarget;
                },
              }),
              (de.Z.prototype._updateSkybox = function (je) {
                this._updateSky(je);
              }),
              (de.Z.prototype.addModel = function (je) {
                if (this.containsModel(je)) return;
                const mt = this.layers.getLayerById(J.uE);
                mt &&
                  (mt.addMeshInstances(je.meshInstances), this.models.push(je));
              }),
              (de.Z.prototype.addShadowCaster = function (je) {
                const mt = this.layers.getLayerById(J.uE);
                mt && mt.addShadowCasters(je.meshInstances);
              }),
              (de.Z.prototype.removeModel = function (je) {
                const mt = this.models.indexOf(je);
                if (mt !== -1) {
                  const Ot = this.layers.getLayerById(J.uE);
                  if (!Ot) return;
                  Ot.removeMeshInstances(je.meshInstances),
                    this.models.splice(mt, 1);
                }
              }),
              (de.Z.prototype.removeShadowCasters = function (je) {
                const mt = this.layers.getLayerById(J.uE);
                mt && mt.removeShadowCasters(je.meshInstances);
              }),
              (de.Z.prototype.containsModel = function (je) {
                return this.models.indexOf(je) >= 0;
              }),
              (de.Z.prototype.getModels = function (je) {
                return this.models;
              }),
              Object.defineProperty(N.l.prototype, "model", {
                get: function () {
                  return null;
                },
              }),
              (ge.v.prototype.renderComposition = function (je) {
                (0, vt.D)().renderComposition(je);
              }),
              (le.F.prototype.syncAabb = function () {}),
              ($.T.prototype.getTarget = function (je) {
                return this.targets[je];
              }),
              (k.t.prototype._dirtify = function (je) {
                je ? this._dirtifyLocal() : this._dirtifyWorld();
              }),
              (k.t.prototype.addLabel = function (je) {
                this._labels[je] = !0;
              }),
              (k.t.prototype.getLabels = function () {
                return Object.keys(this._labels);
              }),
              (k.t.prototype.hasLabel = function (je) {
                return !!this._labels[je];
              }),
              (k.t.prototype.removeLabel = function (je) {
                delete this._labels[je];
              }),
              (k.t.prototype.findByLabel = function (je, mt = []) {
                this.hasLabel(je) && mt.push(this);
                for (let Ot = 0; Ot < this._children.length; ++Ot)
                  mt = this._children[Ot].findByLabel(je, mt);
                return mt;
              }),
              (k.t.prototype.getChildren = function () {
                return this.children;
              }),
              (k.t.prototype.getName = function () {
                return this.name;
              }),
              (k.t.prototype.getPath = function () {
                return this.path;
              }),
              (k.t.prototype.getRoot = function () {
                return this.root;
              }),
              (k.t.prototype.getParent = function () {
                return this.parent;
              }),
              (k.t.prototype.setName = function (je) {
                this.name = je;
              }),
              (j.i.prototype.getName = function () {
                return this.name;
              }),
              (j.i.prototype.setName = function (je) {
                this.name = je;
              }),
              (j.i.prototype.getShader = function () {
                return this.shader;
              }),
              (j.i.prototype.setShader = function (je) {
                this.shader = je;
              }),
              Object.defineProperty(j.i.prototype, "blend", {
                set: function (je) {
                  this.blendState.blend = je;
                },
                get: function () {
                  return this.blendState.blend;
                },
              }),
              Object.defineProperty(j.i.prototype, "blendSrc", {
                set: function (je) {
                  const mt = this.blendState;
                  Lt.copy(mt),
                    Lt.setColorBlend(mt.colorOp, je, mt.colorDstFactor),
                    Lt.setAlphaBlend(mt.alphaOp, je, mt.alphaDstFactor),
                    (this.blendState = Lt);
                },
                get: function () {
                  return this.blendState.colorSrcFactor;
                },
              }),
              Object.defineProperty(j.i.prototype, "blendDst", {
                set: function (je) {
                  const mt = this.blendState;
                  Lt.copy(mt),
                    Lt.setColorBlend(mt.colorOp, mt.colorSrcFactor, je),
                    Lt.setAlphaBlend(mt.alphaOp, mt.alphaSrcFactor, je),
                    (this.blendState = Lt);
                },
                get: function () {
                  return this.blendState.colorDstFactor;
                },
              }),
              Object.defineProperty(w.F.prototype, "shininess", {
                get: function () {
                  return this.gloss * 100;
                },
                set: function (je) {
                  this.gloss = je * 0.01;
                },
              });
            function kt(je, mt) {
              Object.defineProperty(w.F.prototype, mt, {
                get: function () {
                  return this[je];
                },
                set: function (Ot) {
                  this[je] = Ot;
                },
              });
            }
            kt("diffuseTint", "diffuseMapTint"),
              kt("specularTint", "specularMapTint"),
              kt("emissiveTint", "emissiveMapTint"),
              kt("aoVertexColor", "aoMapVertexColor"),
              kt("diffuseVertexColor", "diffuseMapVertexColor"),
              kt("specularVertexColor", "specularMapVertexColor"),
              kt("emissiveVertexColor", "emissiveMapVertexColor"),
              kt("metalnessVertexColor", "metalnessMapVertexColor"),
              kt("glossVertexColor", "glossMapVertexColor"),
              kt("opacityVertexColor", "opacityMapVertexColor"),
              kt("lightVertexColor", "lightMapVertexColor"),
              kt("sheenGloss", "sheenGlossiess"),
              kt("clearCoatGloss", "clearCostGlossiness");
            function ds(je, mt) {
              je !== "pass" &&
                Object.defineProperty(he.l.prototype, je, {
                  get: function () {
                    return this.litOptions[mt || je];
                  },
                  set: function (Ot) {
                    this.litOptions[mt || je] = Ot;
                  },
                });
            }
            ds("refraction", "useRefraction");
            const os = new ue.n(),
              ls = Object.getOwnPropertyNames(os);
            for (const je in ls) ds(ls[je]);
            const Ps = {
              Animation: Oe.X5,
              Key: Oe.Uz,
              Node: Oe.bP,
              Skeleton: Ae.E,
            };
            (Oe.X5.prototype.getDuration = function () {
              return this.duration;
            }),
              (Oe.X5.prototype.getName = function () {
                return this.name;
              }),
              (Oe.X5.prototype.getNodes = function () {
                return this.nodes;
              }),
              (Oe.X5.prototype.setDuration = function (je) {
                this.duration = je;
              }),
              (Oe.X5.prototype.setName = function (je) {
                this.name = je;
              }),
              (Ae.E.prototype.getAnimation = function () {
                return this.animation;
              }),
              (Ae.E.prototype.getCurrentTime = function () {
                return this.currentTime;
              }),
              (Ae.E.prototype.getLooping = function () {
                return this.looping;
              }),
              (Ae.E.prototype.getNumNodes = function () {
                return this.numNodes;
              }),
              (Ae.E.prototype.setAnimation = function (je) {
                this.animation = je;
              }),
              (Ae.E.prototype.setCurrentTime = function (je) {
                this.currentTime = je;
              }),
              (Ae.E.prototype.setLooping = function (je) {
                this.looping = je;
              });
            const us = {
              AudioManager: me.x,
              Channel: ke.c,
              Channel3d: Ue.j,
              Listener: Ge.r,
              Sound: ht.A,
            };
            (me.x.prototype.getListener = function () {
              return this.listener;
            }),
              (me.x.prototype.getVolume = function () {
                return this.volume;
              }),
              (me.x.prototype.setVolume = function (je) {
                this.volume = je;
              });
            const Xe = {
              ASSET_ANIMATION: "animation",
              ASSET_AUDIO: "audio",
              ASSET_IMAGE: "image",
              ASSET_JSON: "json",
              ASSET_MODEL: "model",
              ASSET_MATERIAL: "material",
              ASSET_TEXT: "text",
              ASSET_TEXTURE: "texture",
              ASSET_CUBEMAP: "cubemap",
              ASSET_SCRIPT: "script",
            };
            (z.k.prototype.getAssetById = function (je) {
              return this.get(je);
            }),
              Object.defineProperty(K.g.prototype, "ray", {
                get: function () {
                  return this._rayLocal;
                },
              }),
              Object.defineProperty(K.g.prototype, "position", {
                get: function () {
                  return this._localPosition;
                },
              }),
              Object.defineProperty(K.g.prototype, "rotation", {
                get: function () {
                  return this._localRotation;
                },
              });
            const vs = {
              getTouchTargetCoords: Le.rT,
              Controller: Te.x,
              GamePads: q.$1,
              Keyboard: se.s,
              KeyboardEvent: Ce.k,
              Mouse: we.K,
              MouseEvent: Me.C,
              Touch: Le.Up,
              TouchDevice: Ie.a,
              TouchEvent: Le.sD,
            };
            Object.defineProperty(H.FW.prototype, "wheel", {
              get: function () {
                return this.wheelDelta * -2;
              },
            }),
              Object.defineProperty(Me.C.prototype, "wheel", {
                get: function () {
                  return this.wheelDelta * -2;
                },
              });
            const fs = ut.I3,
              bs = ut.DA,
              Ms = ut.LY,
              Ts = ut.uU,
              Js = ut.Fm,
              Os = ut.ce,
              li = ut.UQ,
              $s = ut.oo,
              Cs = ut.kp,
              Gs = ut.dC,
              hi = ut.$5;
            (tt.v.prototype.isFullscreen = function () {
              return !!document.fullscreenElement;
            }),
              (tt.v.prototype.enableFullscreen = function (je, mt, Ot) {
                je = je || this.graphicsDevice.canvas;
                const ss = function is() {
                    mt(), document.removeEventListener("fullscreenchange", is);
                  },
                  qt = function is() {
                    Ot(), document.removeEventListener("fullscreenerror", is);
                  };
                mt && document.addEventListener("fullscreenchange", ss, !1),
                  Ot && document.addEventListener("fullscreenerror", qt, !1),
                  je.requestFullscreen
                    ? je.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT)
                    : Ot();
              }),
              (tt.v.prototype.disableFullscreen = function (je) {
                const mt = function Ot() {
                  je(), document.removeEventListener("fullscreenchange", Ot);
                };
                je && document.addEventListener("fullscreenchange", mt, !1),
                  document.exitFullscreen();
              }),
              (tt.v.prototype.getSceneUrl = function (je) {
                const mt = this.scenes.find(je);
                return mt ? mt.url : null;
              }),
              (tt.v.prototype.loadScene = function (je, mt) {
                this.scenes.loadScene(je, mt);
              }),
              (tt.v.prototype.loadSceneHierarchy = function (je, mt) {
                this.scenes.loadSceneHierarchy(je, mt);
              }),
              (tt.v.prototype.loadSceneSettings = function (je, mt) {
                this.scenes.loadSceneSettings(je, mt);
              }),
              (tt.v.prototype.renderMeshInstance = function (je, mt) {
                const Ot =
                  mt != null && mt.layer
                    ? mt.layer
                    : this.scene.defaultDrawLayer;
                this.scene.immediate.drawMesh(null, null, null, je, Ot);
              }),
              (tt.v.prototype.renderMesh = function (je, mt, Ot, ss) {
                const qt =
                  ss != null && ss.layer
                    ? ss.layer
                    : this.scene.defaultDrawLayer;
                this.scene.immediate.drawMesh(mt, Ot, je, null, qt);
              }),
              (tt.v.prototype._addLines = function (je, mt, Ot) {
                const ss =
                    Ot && Ot.layer
                      ? Ot.layer
                      : this.scene.layers.getLayerById(J.t0),
                  qt = Ot && Ot.depthTest !== void 0 ? Ot.depthTest : !0;
                this.scene.immediate.getBatch(ss, qt).addLines(je, mt);
              }),
              (tt.v.prototype.renderLine = function (je, mt, Ot) {
                let ss = Ot,
                  qt;
                const is = arguments[3],
                  Ls = arguments[4];
                is instanceof d.Q
                  ? ((ss = is),
                    typeof Ls == "number"
                      ? Ls === J.On
                        ? (qt = {
                            layer: this.scene.layers.getLayerById(J.t0),
                            depthTest: !1,
                          })
                        : (qt = {
                            layer: this.scene.layers.getLayerById(J.t0),
                            depthTest: !0,
                          })
                      : (qt = Ls))
                  : typeof is == "number"
                  ? ((ss = Ot),
                    is === J.On
                      ? (qt = {
                          layer: this.scene.layers.getLayerById(J.t0),
                          depthTest: !1,
                        })
                      : (qt = {
                          layer: this.scene.layers.getLayerById(J.t0),
                          depthTest: !0,
                        }))
                  : is && (qt = is),
                  this._addLines([je, mt], [Ot, ss], qt);
              }),
              (tt.v.prototype.renderLines = function (je, mt, Ot) {
                if (
                  (Ot
                    ? typeof Ot == "number" &&
                      (Ot === J.On
                        ? (Ot = {
                            layer: this.scene.layers.getLayerById(J.t0),
                            depthTest: !1,
                          })
                        : (Ot = {
                            layer: this.scene.layers.getLayerById(J.t0),
                            depthTest: !0,
                          }))
                    : (Ot = {
                        layer: this.scene.layers.getLayerById(J.t0),
                        depthTest: !0,
                      }),
                  !!mt.length && je.length !== mt.length)
                ) {
                  console.error(
                    "renderLines: position/color arrays have different lengths"
                  );
                  return;
                }
                if (je.length % 2 !== 0) {
                  console.error(
                    "renderLines: array length is not divisible by 2"
                  );
                  return;
                }
                this._addLines(je, mt, Ot);
              }),
              (tt.v.prototype.enableVr = function () {}),
              Object.defineProperty(it.n.prototype, "node", {
                get: function () {
                  return this.entity;
                },
              }),
              Object.defineProperty(At.Mm.prototype, "enable", {
                get: function () {
                  return this.enabled;
                },
                set: function (je) {
                  this.enabled = je;
                },
              }),
              (Rt.D.prototype.setVisible = function (je) {
                this.enabled = je;
              }),
              Object.defineProperty(Rt.D.prototype, "aabb", {
                get: function () {
                  return null;
                },
                set: function (je) {},
              }),
              Object.defineProperty(Ft.y.prototype, "aabb", {
                get: function () {
                  return null;
                },
                set: function (je) {},
              }),
              Object.defineProperty(Pt.H.prototype, "bodyType", {
                get: function () {
                  return this.type;
                },
                set: function (je) {
                  this.type = je;
                },
              }),
              (Pt.H.prototype.syncBodyToEntity = function () {
                this._updateDynamic();
              }),
              (bt.K1.prototype.setGravity = function () {
                arguments.length === 1
                  ? this.gravity.copy(arguments[0])
                  : this.gravity.set(arguments[0], arguments[1], arguments[2]);
              });
            function ci(je, mt, Ot) {
              (0, Zt.r)({
                glueUrl: je,
                wasmUrl: mt,
                fallbackUrl: Ot,
                lazyInit: !0,
              });
            }
            function ii(je) {}
          },
          8635: (xe, V, a) => {
            "use strict";
            a.d(V, { E: () => A });
            class A {
              static joinPath(y, c) {
                c = c || ".";
                const d = function (f) {
                  return f
                    .replace(/\\/g, "\\\\")
                    .replace(new RegExp("\\" + c, "g"), "\\" + c);
                };
                return y.map(d).join(c);
              }
              static splitPath(y, c) {
                c = c || ".";
                const d = [];
                let h = "",
                  f = 0;
                for (; f < y.length; ) {
                  let s = y[f++];
                  s === "\\" && f < y.length
                    ? ((s = y[f++]),
                      s === "\\" || s === c ? (h += s) : (h += "\\" + s))
                    : s === c
                    ? (d.push(h), (h = ""))
                    : (h += s);
                }
                return h.length > 0 && d.push(h), d;
              }
              static encode(y, c, d) {
                return `${Array.isArray(y) ? y.join("/") : y}/${c}/${
                  Array.isArray(d) ? d.join("/") : d
                }`;
              }
              resolve(y) {
                return null;
              }
              unresolve(y) {}
              update(y) {}
            }
          },
          7747: (xe, V, a) => {
            "use strict";
            a.d(V, { x: () => c });
            var A = a(8635),
              x = a(8265),
              y = a(371);
            class c {
              constructor(h) {
                if (
                  ((this._isPathInMask = (n, o) => {
                    const i = this._mask[n];
                    if (i) {
                      if (i.children || (o && i.value !== !1)) return !0;
                    } else return !1;
                    return !1;
                  }),
                  (this.graph = h),
                  !h)
                )
                  return;
                this._mask = null;
                const f = {};
                (function n(o) {
                  f[o.name] = o;
                  for (let i = 0; i < o.children.length; ++i) n(o.children[i]);
                })(h),
                  (this.nodes = f),
                  (this.targetCache = {});
                const l = function (o) {
                  let i = o;
                  for (; i && !(i instanceof y.w); ) i = i.parent;
                  let e;
                  return (
                    i &&
                      (i.render
                        ? (e = i.render.meshInstances)
                        : i.model && (e = i.model.meshInstances)),
                    e
                  );
                };
                (this.nodeCounts = {}),
                  (this.activeNodes = []),
                  (this.handlers = {
                    localPosition: function (n) {
                      const o = n.localPosition,
                        i = function (t) {
                          o.set(...t);
                        };
                      return c.createAnimTarget(
                        i,
                        "vector",
                        3,
                        n,
                        "localPosition"
                      );
                    },
                    localRotation: function (n) {
                      const o = n.localRotation,
                        i = function (t) {
                          o.set(...t);
                        };
                      return c.createAnimTarget(
                        i,
                        "quaternion",
                        4,
                        n,
                        "localRotation"
                      );
                    },
                    localScale: function (n) {
                      const o = n.localScale,
                        i = function (t) {
                          o.set(...t);
                        };
                      return c.createAnimTarget(
                        i,
                        "vector",
                        3,
                        n,
                        "localScale"
                      );
                    },
                    weight: function (n, o) {
                      o.indexOf("name.") === 0
                        ? (o = o.replace("name.", ""))
                        : (o = Number(o));
                      const i = l(n);
                      let e;
                      if (i) {
                        for (let t = 0; t < i.length; ++t)
                          if (i[t].node.name === n.name && i[t].morphInstance) {
                            const r = i[t].morphInstance,
                              u = (v) => {
                                r.setWeight(o, v[0]);
                              };
                            e || (e = []), e.push(u);
                          }
                      }
                      if (e) {
                        const t = (r) => {
                          for (let u = 0; u < e.length; ++u) e[u](r);
                        };
                        return c.createAnimTarget(
                          t,
                          "number",
                          1,
                          n,
                          `weight.${o}`
                        );
                      }
                      return null;
                    },
                    materialTexture: (n, o) => {
                      const i = l(n);
                      if (i) {
                        let e;
                        for (let t = 0; t < i.length; ++t)
                          if (i[t].node.name === n.name) {
                            e = i[t];
                            break;
                          }
                        if (e) {
                          const t = (r) => {
                            const u = this.animComponent.system.app.assets.get(
                              r[0]
                            );
                            u &&
                              u.resource &&
                              u.type === "texture" &&
                              ((e.material[o] = u.resource),
                              e.material.update());
                          };
                          return c.createAnimTarget(
                            t,
                            "vector",
                            1,
                            n,
                            "materialTexture",
                            "material"
                          );
                        }
                      }
                      return null;
                    },
                  });
              }
              _isPathActive(h) {
                if (!this._mask) return !0;
                const f = [h.entityPath[0], this.graph.name];
                for (let s = 0; s < f.length; ++s) {
                  let l = f[s];
                  if (this._isPathInMask(l, h.entityPath.length === 1))
                    return !0;
                  for (let n = 1; n < h.entityPath.length; n++)
                    if (
                      ((l += "/" + h.entityPath[n]),
                      this._isPathInMask(l, n === h.entityPath.length - 1))
                    )
                      return !0;
                }
                return !1;
              }
              findNode(h) {
                if (!this._isPathActive(h)) return null;
                let f;
                return (
                  this.graph &&
                    ((f = this.graph.findByPath(h.entityPath)),
                    f || (f = this.graph.findByPath(h.entityPath.slice(1)))),
                  f ||
                    (f =
                      this.nodes[h.entityPath[h.entityPath.length - 1] || ""]),
                  f
                );
              }
              static createAnimTarget(h, f, s, l, n, o) {
                const i = A.E.encode(l.path, o || "entity", n);
                return new x.z(h, f, s, i);
              }
              resolve(h) {
                const f = A.E.encode(h.entityPath, h.component, h.propertyPath);
                let s = this.targetCache[f];
                if (s) return s;
                const l = this.findNode(h);
                if (!l) return null;
                const n = this.handlers[h.propertyPath];
                return !n || ((s = n(l)), !s)
                  ? null
                  : ((this.targetCache[f] = s),
                    this.nodeCounts[l.path]
                      ? this.nodeCounts[l.path]++
                      : (this.activeNodes.push(l),
                        (this.nodeCounts[l.path] = 1)),
                    s);
              }
              unresolve(h) {
                if (h.component !== "graph") return;
                const f =
                  this.nodes[h.entityPath[h.entityPath.length - 1] || ""];
                if (
                  (this.nodeCounts[f.path]--, this.nodeCounts[f.path] === 0)
                ) {
                  const s = this.activeNodes,
                    l = s.indexOf(f.node),
                    n = s.length;
                  l < n - 1 && (s[l] = s[n - 1]), s.pop();
                }
              }
              update(h) {
                const f = this.activeNodes;
                for (let s = 0; s < f.length; ++s) f[s]._dirtifyLocal();
              }
              assignMask(h) {
                return h !== this._mask ? ((this._mask = h), !0) : !1;
              }
            }
          },
          871: (xe, V, a) => {
            "use strict";
            a.d(V, { Un: () => A, tF: () => x, yQ: () => y });
            const A = 0,
              x = 1,
              y = 2;
          },
          2414: (xe, V, a) => {
            "use strict";
            a.d(V, { o: () => u });
            var A = a(4751),
              x = a(1014),
              y = a(70),
              c = a(9645),
              d = a(8656),
              h = a(7994);
            class f {
              constructor(_, m, g, T, E = 1) {
                (this._state = _),
                  (this._parent = m),
                  (this._name = g),
                  Array.isArray(T)
                    ? ((this._point = new h.Z(T[0], T[1])),
                      (this._pointLength = this._point.length()))
                    : ((this._point = T), (this._pointLength = T)),
                  (this._speed = E),
                  (this._weightedSpeed = 1),
                  (this._weight = 1),
                  (this._animTrack = null);
              }
              get parent() {
                return this._parent;
              }
              get name() {
                return this._name;
              }
              get path() {
                return this._parent
                  ? this._parent.path + "." + this._name
                  : this._name;
              }
              get point() {
                return this._point;
              }
              get pointLength() {
                return this._pointLength;
              }
              set weight(_) {
                this._weight = _;
              }
              get weight() {
                return this._parent
                  ? this._parent.weight * this._weight
                  : this._weight;
              }
              get normalizedWeight() {
                const _ = this._state.totalWeight;
                return _ === 0 ? 0 : this.weight / _;
              }
              get speed() {
                return this._weightedSpeed * this._speed;
              }
              get absoluteSpeed() {
                return Math.abs(this._speed);
              }
              set weightedSpeed(_) {
                this._weightedSpeed = _;
              }
              get weightedSpeed() {
                return this._weightedSpeed;
              }
              set animTrack(_) {
                this._animTrack = _;
              }
              get animTrack() {
                return this._animTrack;
              }
            }
            class s extends f {
              constructor(_, m, g, T, E, M, R, P, F) {
                super(_, m, g, T),
                  (this._parameters = E),
                  (this._parameterValues = new Array(E.length)),
                  (this._children = []),
                  (this._findParameter = F),
                  (this._syncAnimations = R !== !1),
                  (this._pointCache = {});
                for (let b = 0; b < M.length; b++) {
                  const D = M[b];
                  D.children
                    ? this._children.push(
                        P(
                          D.type,
                          this,
                          null,
                          g,
                          1,
                          D.parameter ? [D.parameter] : D.parameters,
                          D.children,
                          P,
                          F
                        )
                      )
                    : this._children.push(
                        new f(_, this, D.name, D.point, D.speed)
                      );
                }
              }
              get weight() {
                return (
                  this.calculateWeights(),
                  this._parent
                    ? this._parent.weight * this._weight
                    : this._weight
                );
              }
              get syncAnimations() {
                return this._syncAnimations;
              }
              getChild(_) {
                for (let m = 0; m < this._children.length; m++)
                  if (this._children[m].name === _) return this._children[m];
                return null;
              }
              updateParameterValues() {
                let _ = !0;
                for (let m = 0; m < this._parameterValues.length; m++) {
                  const g = this._findParameter(this._parameters[m]).value;
                  this._parameterValues[m] !== g &&
                    ((this._parameterValues[m] = g), (_ = !1));
                }
                return _;
              }
              getNodeWeightedDuration(_) {
                return (
                  (this._children[_].animTrack.duration /
                    this._children[_].speedMultiplier) *
                  this._children[_].weight
                );
              }
              getNodeCount() {
                let _ = 0;
                for (let m = 0; m < this._children.length; m++)
                  this._children[m].constructor === s
                    ? (_ += this._children[m].getNodeCount())
                    : _++;
                return _;
              }
            }
            class l extends s {
              constructor(_, m, g, T, E, M, R, P, F) {
                M.sort((b, D) => b.point - D.point),
                  super(_, m, g, T, E, M, R, P, F);
              }
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let _ = 0;
                this._children[0].weight = 0;
                for (let m = 0; m < this._children.length; m++) {
                  const g = this._children[m];
                  if (m !== this._children.length - 1) {
                    const T = this._children[m + 1];
                    if (g.point === T.point) (g.weight = 0.5), (T.weight = 0.5);
                    else if (
                      d.D.between(
                        this._parameterValues[0],
                        g.point,
                        T.point,
                        !0
                      )
                    ) {
                      const E = Math.abs(g.point - T.point),
                        M = Math.abs(g.point - this._parameterValues[0]),
                        R = (E - M) / E;
                      (g.weight = R), (T.weight = 1 - R);
                    } else T.weight = 0;
                  }
                  this._syncAnimations &&
                    (_ += (g.animTrack.duration / g.absoluteSpeed) * g.weight);
                }
                if (this._syncAnimations)
                  for (let m = 0; m < this._children.length; m++) {
                    const g = this._children[m];
                    g.weightedSpeed =
                      g.animTrack.duration / g.absoluteSpeed / _;
                  }
              }
            }
            class n extends s {
              pointDistanceCache(_, m) {
                const g = `${_}${m}`;
                return (
                  this._pointCache[g] ||
                    (this._pointCache[g] = this._children[m].point
                      .clone()
                      .sub(this._children[_].point)),
                  this._pointCache[g]
                );
              }
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let _, m;
                n._p.set(...this._parameterValues), (_ = 0), (m = 0);
                for (let g = 0; g < this._children.length; g++) {
                  const T = this._children[g],
                    E = T.point;
                  n._pip.set(n._p.x, n._p.y).sub(E);
                  let M = Number.MAX_VALUE;
                  for (let R = 0; R < this._children.length; R++) {
                    if (g === R) continue;
                    const P = this.pointDistanceCache(g, R),
                      F = d.D.clamp(1 - n._pip.dot(P) / P.lengthSq(), 0, 1);
                    F < M && (M = F);
                  }
                  (T.weight = M),
                    (_ += M),
                    this._syncAnimations &&
                      (m +=
                        (T.animTrack.duration / T.absoluteSpeed) * T.weight);
                }
                for (let g = 0; g < this._children.length; g++) {
                  const T = this._children[g];
                  (T.weight = T._weight / _),
                    this._syncAnimations &&
                      (T.weightedSpeed =
                        T.animTrack.duration / T.absoluteSpeed / m);
                }
              }
            }
            (n._p = new h.Z()), (n._pip = new h.Z());
            class o extends s {
              pointCache(_, m) {
                const g = `${_}${m}`;
                return (
                  this._pointCache[g] ||
                    (this._pointCache[g] = new h.Z(
                      (this._children[m].pointLength -
                        this._children[_].pointLength) /
                        ((this._children[m].pointLength +
                          this._children[_].pointLength) /
                          2),
                      h.Z.angleRad(
                        this._children[_].point,
                        this._children[m].point
                      ) * 2
                    )),
                  this._pointCache[g]
                );
              }
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let _, m;
                o._p.set(...this._parameterValues);
                const g = o._p.length();
                (_ = 0), (m = 0);
                for (let T = 0; T < this._children.length; T++) {
                  const E = this._children[T],
                    M = E.point,
                    R = E.pointLength;
                  let P = Number.MAX_VALUE;
                  for (let F = 0; F < this._children.length; F++) {
                    if (T === F) continue;
                    const b = this.pointCache(T, F),
                      D = this._children[F].pointLength;
                    o._pip.set(
                      (g - R) / ((D + R) / 2),
                      h.Z.angleRad(M, o._p) * 2
                    );
                    const G = d.D.clamp(
                      1 - Math.abs(o._pip.dot(b) / b.lengthSq()),
                      0,
                      1
                    );
                    G < P && (P = G);
                  }
                  (E.weight = P),
                    (_ += P),
                    this._syncAnimations &&
                      (m +=
                        (E.animTrack.duration / E.absoluteSpeed) * E.weight);
                }
                for (let T = 0; T < this._children.length; T++) {
                  const E = this._children[T];
                  if (((E.weight = E._weight / _), this._syncAnimations)) {
                    const M = (E.animTrack.duration / m) * _;
                    E.weightedSpeed = E.absoluteSpeed * M;
                  }
                }
              }
            }
            (o._p = new h.Z()), (o._pip = new h.Z());
            class i extends s {
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let _ = 0,
                  m = 0;
                for (let g = 0; g < this._children.length; g++)
                  if (
                    ((_ += Math.max(this._parameterValues[g], 0)),
                    this._syncAnimations)
                  ) {
                    const T = this._children[g];
                    m += (T.animTrack.duration / T.absoluteSpeed) * T.weight;
                  }
                for (let g = 0; g < this._children.length; g++) {
                  const T = this._children[g],
                    E = Math.max(this._parameterValues[g], 0);
                  _
                    ? ((T.weight = E / _),
                      this._syncAnimations &&
                        (T.weightedSpeed =
                          T.animTrack.duration / T.absoluteSpeed / m))
                    : ((T.weight = 0),
                      this._syncAnimations && (T.weightedSpeed = 0));
                }
              }
            }
            var e = a(4474);
            class t {
              constructor(_, m, g = 1, T = !0, E) {
                (this._animations = {}),
                  (this._animationList = []),
                  (this._controller = _),
                  (this._name = m),
                  (this._speed = g),
                  (this._loop = T),
                  (this._hasAnimations = !1),
                  E
                    ? (this._blendTree = this._createTree(
                        E.type,
                        this,
                        null,
                        m,
                        1,
                        E.parameter ? [E.parameter] : E.parameters,
                        E.children,
                        E.syncAnimations,
                        this._createTree,
                        this._controller.findParameter
                      ))
                    : (this._blendTree = new f(this, null, m, 1, g));
              }
              _createTree(_, m, g, T, E, M, R, P, F, b) {
                switch (_) {
                  case e.m_:
                    return new l(m, g, T, E, M, R, P, F, b);
                  case e.yP:
                    return new n(m, g, T, E, M, R, P, F, b);
                  case e.sP:
                    return new o(m, g, T, E, M, R, P, F, b);
                  case e.Sq:
                    return new i(m, g, T, E, M, R, P, F, b);
                }
              }
              _getNodeFromPath(_) {
                let m = this._blendTree;
                for (let g = 1; g < _.length; g++) m = m.getChild(_[g]);
                return m;
              }
              addAnimation(_, m) {
                const g = _.join("."),
                  T = this._animationList.findIndex(function (E) {
                    return E.path === g;
                  });
                if (T >= 0) this._animationList[T].animTrack = m;
                else {
                  const E = this._getNodeFromPath(_);
                  (E.animTrack = m), this._animationList.push(E);
                }
                this._updateHasAnimations();
              }
              _updateHasAnimations() {
                this._hasAnimations =
                  this._animationList.length > 0 &&
                  this._animationList.every(
                    (_) => _.animTrack && _.animTrack !== c.z.EMPTY
                  );
              }
              get name() {
                return this._name;
              }
              set animations(_) {
                (this._animationList = _), this._updateHasAnimations();
              }
              get animations() {
                return this._animationList;
              }
              get hasAnimations() {
                return this._hasAnimations;
              }
              set speed(_) {
                this._speed = _;
              }
              get speed() {
                return this._speed;
              }
              set loop(_) {
                this._loop = _;
              }
              get loop() {
                return this._loop;
              }
              get nodeCount() {
                return !this._blendTree || this._blendTree.constructor === f
                  ? 1
                  : this._blendTree.getNodeCount();
              }
              get playable() {
                return (
                  e.BA.indexOf(this.name) !== -1 ||
                  this.animations.length === this.nodeCount
                );
              }
              get looping() {
                if (this.animations.length > 0) {
                  const _ = this.name + "." + this.animations[0].animTrack.name,
                    m = this._controller.animEvaluator.findClip(_);
                  if (m) return m.loop;
                }
                return !1;
              }
              get totalWeight() {
                let _ = 0;
                for (let m = 0; m < this.animations.length; m++)
                  _ += this.animations[m].weight;
                return _;
              }
              get timelineDuration() {
                let _ = 0;
                for (let m = 0; m < this.animations.length; m++) {
                  const g = this.animations[m];
                  g.animTrack.duration > _ && (_ = g.animTrack.duration);
                }
                return _;
              }
            }
            var r = a(5828);
            class u {
              constructor(_, m, g, T, E, M, R) {
                (this.findParameter = (P) => this._findParameter(P)),
                  (this._animEvaluator = _),
                  (this._states = {}),
                  (this._stateNames = []),
                  (this._eventHandler = E),
                  (this._findParameter = M),
                  (this._consumeTrigger = R);
                for (let P = 0; P < m.length; P++)
                  (this._states[m[P].name] = new t(
                    this,
                    m[P].name,
                    m[P].speed,
                    m[P].loop,
                    m[P].blendTree
                  )),
                    this._stateNames.push(m[P].name);
                (this._transitions = g.map((P) => new r.R((0, A._)({}, P)))),
                  (this._findTransitionsFromStateCache = {}),
                  (this._findTransitionsBetweenStatesCache = {}),
                  (this._previousStateName = null),
                  (this._activeStateName = e.NA),
                  (this._activeStateDuration = 0),
                  (this._activeStateDurationDirty = !0),
                  (this._playing = !1),
                  (this._activate = T),
                  (this._currTransitionTime = 1),
                  (this._totalTransitionTime = 1),
                  (this._isTransitioning = !1),
                  (this._transitionInterruptionSource = e.b1),
                  (this._transitionPreviousStates = []),
                  (this._timeInState = 0),
                  (this._timeInStateBefore = 0);
              }
              get animEvaluator() {
                return this._animEvaluator;
              }
              set activeState(_) {
                this._activeStateName = _;
              }
              get activeState() {
                return this._findState(this._activeStateName);
              }
              get activeStateName() {
                return this._activeStateName;
              }
              get activeStateAnimations() {
                return this.activeState.animations;
              }
              set previousState(_) {
                this._previousStateName = _;
              }
              get previousState() {
                return this._findState(this._previousStateName);
              }
              get previousStateName() {
                return this._previousStateName;
              }
              get playable() {
                let _ = !0;
                for (let m = 0; m < this._stateNames.length; m++)
                  this._states[this._stateNames[m]].playable || (_ = !1);
                return _;
              }
              set playing(_) {
                this._playing = _;
              }
              get playing() {
                return this._playing;
              }
              get activeStateProgress() {
                return this._getActiveStateProgressForTime(this._timeInState);
              }
              get activeStateDuration() {
                if (this._activeStateDurationDirty) {
                  let _ = 0;
                  for (let m = 0; m < this.activeStateAnimations.length; m++) {
                    const g = this._animEvaluator.findClip(
                      this.activeStateAnimations[m].name
                    );
                    g && (_ = Math.max(_, g.track.duration));
                  }
                  (this._activeStateDuration = _),
                    (this._activeStateDurationDirty = !1);
                }
                return this._activeStateDuration;
              }
              set activeStateCurrentTime(_) {
                (this._timeInStateBefore = _), (this._timeInState = _);
                for (let m = 0; m < this.activeStateAnimations.length; m++) {
                  const g = this.animEvaluator.findClip(
                    this.activeStateAnimations[m].name
                  );
                  g && (g.time = _);
                }
              }
              get activeStateCurrentTime() {
                return this._timeInState;
              }
              get transitioning() {
                return this._isTransitioning;
              }
              get transitionProgress() {
                return this._currTransitionTime / this._totalTransitionTime;
              }
              get states() {
                return this._stateNames;
              }
              assignMask(_) {
                return this._animEvaluator.assignMask(_);
              }
              _findState(_) {
                return this._states[_];
              }
              _getActiveStateProgressForTime(_) {
                if (
                  this.activeStateName === e.NA ||
                  this.activeStateName === e.gF ||
                  this.activeStateName === e.JP
                )
                  return 1;
                const m = this._animEvaluator.findClip(
                  this.activeStateAnimations[0].name
                );
                return m ? m.progressForTime(_) : null;
              }
              _findTransitionsFromState(_) {
                let m = this._findTransitionsFromStateCache[_];
                return (
                  m ||
                    ((m = this._transitions.filter(function (g) {
                      return g.from === _;
                    })),
                    (0, x.Z)(m),
                    (this._findTransitionsFromStateCache[_] = m)),
                  m
                );
              }
              _findTransitionsBetweenStates(_, m) {
                let g = this._findTransitionsBetweenStatesCache[_ + "->" + m];
                return (
                  g ||
                    ((g = this._transitions.filter(function (T) {
                      return T.from === _ && T.to === m;
                    })),
                    (0, x.Z)(g),
                    (this._findTransitionsBetweenStatesCache[_ + "->" + m] =
                      g)),
                  g
                );
              }
              _transitionHasConditionsMet(_) {
                const m = _.conditions;
                for (let g = 0; g < m.length; g++) {
                  const T = m[g],
                    E = this._findParameter(T.parameterName);
                  switch (T.predicate) {
                    case e.JO:
                      if (!(E.value > T.value)) return !1;
                      break;
                    case e.O1:
                      if (!(E.value < T.value)) return !1;
                      break;
                    case e.Uk:
                      if (!(E.value >= T.value)) return !1;
                      break;
                    case e.XO:
                      if (!(E.value <= T.value)) return !1;
                      break;
                    case e.HJ:
                      if (E.value !== T.value) return !1;
                      break;
                    case e.R5:
                      if (E.value === T.value) return !1;
                      break;
                  }
                }
                return !0;
              }
              _findTransition(_, m) {
                let g = [];
                if (_ && m)
                  g = g.concat(this._findTransitionsBetweenStates(_, m));
                else if (!this._isTransitioning)
                  (g = g.concat(
                    this._findTransitionsFromState(this._activeStateName)
                  )),
                    (g = g.concat(this._findTransitionsFromState(e.JP)));
                else
                  switch (this._transitionInterruptionSource) {
                    case e.ez:
                      (g = g.concat(
                        this._findTransitionsFromState(this._previousStateName)
                      )),
                        (g = g.concat(this._findTransitionsFromState(e.JP)));
                      break;
                    case e.a1:
                      (g = g.concat(
                        this._findTransitionsFromState(this._activeStateName)
                      )),
                        (g = g.concat(this._findTransitionsFromState(e.JP)));
                      break;
                    case e.Q2:
                      (g = g.concat(
                        this._findTransitionsFromState(this._previousStateName)
                      )),
                        (g = g.concat(
                          this._findTransitionsFromState(this._activeStateName)
                        )),
                        (g = g.concat(this._findTransitionsFromState(e.JP)));
                      break;
                    case e.YA:
                      (g = g.concat(
                        this._findTransitionsFromState(this._activeStateName)
                      )),
                        (g = g.concat(
                          this._findTransitionsFromState(
                            this._previousStateName
                          )
                        )),
                        (g = g.concat(this._findTransitionsFromState(e.JP)));
                      break;
                  }
                if (
                  ((g = g.filter((T) => {
                    if (T.to === this.activeStateName) return !1;
                    if (T.hasExitTime) {
                      let E = this._getActiveStateProgressForTime(
                          this._timeInStateBefore
                        ),
                        M = this._getActiveStateProgressForTime(
                          this._timeInState
                        );
                      if (
                        (T.exitTime < 1 &&
                          this.activeState.loop &&
                          ((E -= Math.floor(E)), (M -= Math.floor(M))),
                        M === E)
                      ) {
                        if (M !== T.exitTime) return null;
                      } else if (!(T.exitTime > E && T.exitTime <= M))
                        return null;
                    }
                    return this._transitionHasConditionsMet(T);
                  })),
                  g.length > 0)
                ) {
                  const T = g[0];
                  if (T.to === e.gF) {
                    const E = this._findTransitionsFromState(e.NA)[0];
                    T.to = E.to;
                  }
                  return T;
                }
                return null;
              }
              updateStateFromTransition(_) {
                let m, g, T;
                (this.previousState = _.from ? this.activeStateName : null),
                  (this.activeState = _.to),
                  (this._activeStateDurationDirty = !0);
                for (let F = 0; F < _.conditions.length; F++) {
                  const b = _.conditions[F];
                  this._findParameter(b.parameterName).type === e.p$ &&
                    this._consumeTrigger(b.parameterName);
                }
                if (this.previousState) {
                  this._isTransitioning ||
                    (this._transitionPreviousStates = []),
                    this._transitionPreviousStates.push({
                      name: this._previousStateName,
                      weight: 1,
                    });
                  const F = Math.min(
                    this._totalTransitionTime !== 0
                      ? this._currTransitionTime / this._totalTransitionTime
                      : 1,
                    1
                  );
                  for (
                    let b = 0;
                    b < this._transitionPreviousStates.length;
                    b++
                  ) {
                    this._isTransitioning
                      ? b !== this._transitionPreviousStates.length - 1
                        ? (this._transitionPreviousStates[b].weight *= 1 - F)
                        : (this._transitionPreviousStates[b].weight = F)
                      : (this._transitionPreviousStates[b].weight = 1),
                      (m = this._findState(
                        this._transitionPreviousStates[b].name
                      ));
                    for (let D = 0; D < m.animations.length; D++)
                      (g = m.animations[D]),
                        (T = this._animEvaluator.findClip(
                          g.name + ".previous." + b
                        )),
                        T ||
                          ((T = this._animEvaluator.findClip(g.name)),
                          (T.name = g.name + ".previous." + b)),
                        b !== this._transitionPreviousStates.length - 1 &&
                          T.pause();
                  }
                }
                (this._isTransitioning = !0),
                  (this._totalTransitionTime = _.time),
                  (this._currTransitionTime = 0),
                  (this._transitionInterruptionSource = _.interruptionSource);
                const E = this.activeState,
                  M =
                    _.transitionOffset &&
                    _.transitionOffset > 0 &&
                    _.transitionOffset < 1;
                let R = 0,
                  P = 0;
                if (M) {
                  const F = E.timelineDuration * _.transitionOffset;
                  (R = F), (P = F);
                }
                (this._timeInState = R), (this._timeInStateBefore = P);
                for (let F = 0; F < E.animations.length; F++) {
                  if (
                    ((T = this._animEvaluator.findClip(E.animations[F].name)),
                    T)
                  )
                    T.reset();
                  else {
                    const b = Number.isFinite(E.animations[F].speed)
                      ? E.animations[F].speed
                      : E.speed;
                    (T = new y.W(
                      E.animations[F].animTrack,
                      this._timeInState,
                      b,
                      !0,
                      E.loop,
                      this._eventHandler
                    )),
                      (T.name = E.animations[F].name),
                      this._animEvaluator.addClip(T);
                  }
                  if (
                    (_.time > 0
                      ? (T.blendWeight = 0)
                      : (T.blendWeight = E.animations[F].normalizedWeight),
                    T.play(),
                    M)
                  )
                    T.time = E.timelineDuration * _.transitionOffset;
                  else {
                    const b = E.speed >= 0 ? 0 : this.activeStateDuration;
                    T.time = b;
                  }
                }
              }
              _transitionToState(_) {
                if (!this._findState(_)) return;
                let m = this._findTransition(this._activeStateName, _);
                m ||
                  (this._animEvaluator.removeClips(),
                  (m = new r.R({ from: null, to: _ }))),
                  this.updateStateFromTransition(m);
              }
              assignAnimation(_, m, g, T) {
                const E = _.split(".");
                let M = this._findState(E[0]);
                M ||
                  ((M = new t(this, E[0], g)),
                  (this._states[E[0]] = M),
                  this._stateNames.push(E[0])),
                  M.addAnimation(E, m),
                  this._animEvaluator.updateClipTrack(M.name, m),
                  g !== void 0 && (M.speed = g),
                  T !== void 0 && (M.loop = T),
                  !this._playing &&
                    this._activate &&
                    this.playable &&
                    this.play(),
                  (this._activeStateDurationDirty = !0);
              }
              removeNodeAnimations(_) {
                if (e.BA.indexOf(_) !== -1) return !1;
                const m = this._findState(_);
                return m ? ((m.animations = []), !0) : !1;
              }
              play(_) {
                _ && this._transitionToState(_), (this._playing = !0);
              }
              pause() {
                this._playing = !1;
              }
              reset() {
                (this._previousStateName = null),
                  (this._activeStateName = e.NA),
                  (this._playing = !1),
                  (this._currTransitionTime = 1),
                  (this._totalTransitionTime = 1),
                  (this._isTransitioning = !1),
                  (this._timeInState = 0),
                  (this._timeInStateBefore = 0),
                  this._animEvaluator.removeClips();
              }
              rebind() {
                this._animEvaluator.rebind();
              }
              update(_) {
                if (!this._playing) return;
                let m, g, T;
                (this.activeState.loop ||
                  this._timeInState < this.activeStateDuration) &&
                  ((this._timeInStateBefore = this._timeInState),
                  (this._timeInState += _ * this.activeState.speed),
                  !this.activeState.loop &&
                    this._timeInState > this.activeStateDuration &&
                    ((this._timeInState = this.activeStateDuration),
                    (_ = this.activeStateDuration - this._timeInStateBefore)));
                const E = this._findTransition(this._activeStateName);
                if (
                  (E && this.updateStateFromTransition(E),
                  this._isTransitioning)
                )
                  if (
                    ((this._currTransitionTime += _),
                    this._currTransitionTime <= this._totalTransitionTime)
                  ) {
                    const M =
                      this._totalTransitionTime !== 0
                        ? this._currTransitionTime / this._totalTransitionTime
                        : 1;
                    for (
                      let R = 0;
                      R < this._transitionPreviousStates.length;
                      R++
                    ) {
                      m = this._findState(
                        this._transitionPreviousStates[R].name
                      );
                      const P = this._transitionPreviousStates[R].weight;
                      for (let F = 0; F < m.animations.length; F++)
                        (g = m.animations[F]),
                          (T = this._animEvaluator.findClip(
                            g.name + ".previous." + R
                          )),
                          T &&
                            (T.blendWeight = (1 - M) * g.normalizedWeight * P);
                    }
                    m = this.activeState;
                    for (let R = 0; R < m.animations.length; R++)
                      (g = m.animations[R]),
                        (this._animEvaluator.findClip(g.name).blendWeight =
                          M * g.normalizedWeight);
                  } else {
                    this._isTransitioning = !1;
                    const M = this.activeStateAnimations.length,
                      R = this._animEvaluator.clips.length;
                    for (let P = 0; P < R - M; P++)
                      this._animEvaluator.removeClip(0);
                    (this._transitionPreviousStates = []),
                      (m = this.activeState);
                    for (let P = 0; P < m.animations.length; P++)
                      (g = m.animations[P]),
                        (T = this._animEvaluator.findClip(g.name)),
                        T && (T.blendWeight = g.normalizedWeight);
                  }
                else if (this.activeState._blendTree.constructor !== f) {
                  m = this.activeState;
                  for (let M = 0; M < m.animations.length; M++)
                    (g = m.animations[M]),
                      (T = this._animEvaluator.findClip(g.name)),
                      T &&
                        ((T.blendWeight = g.normalizedWeight),
                        g.parent.syncAnimations && (T.speed = g.speed));
                }
                this._animEvaluator.update(_, this.activeState.hasAnimations);
              }
            }
          },
          5828: (xe, V, a) => {
            "use strict";
            a.d(V, { R: () => x });
            var A = a(4474);
            class x {
              constructor({
                from: c,
                to: d,
                time: h = 0,
                priority: f = 0,
                conditions: s = [],
                exitTime: l = null,
                transitionOffset: n = null,
                interruptionSource: o = A.b1,
              }) {
                (this._from = c),
                  (this._to = d),
                  (this._time = h),
                  (this._priority = f),
                  (this._conditions = s),
                  (this._exitTime = l),
                  (this._transitionOffset = n),
                  (this._interruptionSource = o);
              }
              get from() {
                return this._from;
              }
              set to(c) {
                this._to = c;
              }
              get to() {
                return this._to;
              }
              get time() {
                return this._time;
              }
              get priority() {
                return this._priority;
              }
              get conditions() {
                return this._conditions;
              }
              get exitTime() {
                return this._exitTime;
              }
              get transitionOffset() {
                return this._transitionOffset;
              }
              get interruptionSource() {
                return this._interruptionSource;
              }
              get hasExitTime() {
                return !!this.exitTime;
              }
            }
          },
          4474: (xe, V, a) => {
            "use strict";
            a.d(V, {
              BA: () => M,
              HJ: () => n,
              JO: () => h,
              JP: () => E,
              NA: () => g,
              O1: () => f,
              Q2: () => c,
              R5: () => o,
              Sq: () => m,
              Uk: () => s,
              XO: () => l,
              XY: () => P,
              YA: () => d,
              a1: () => y,
              b1: () => A,
              dF: () => t,
              eU: () => R,
              ez: () => x,
              gF: () => T,
              h0: () => e,
              m_: () => u,
              nl: () => i,
              p$: () => r,
              sP: () => v,
              yP: () => _,
            });
            const A = "NONE",
              x = "PREV_STATE",
              y = "NEXT_STATE",
              c = "PREV_STATE_NEXT_STATE",
              d = "NEXT_STATE_PREV_STATE",
              h = "GREATER_THAN",
              f = "LESS_THAN",
              s = "GREATER_THAN_EQUAL_TO",
              l = "LESS_THAN_EQUAL_TO",
              n = "EQUAL_TO",
              o = "NOT_EQUAL_TO",
              i = "INTEGER",
              e = "FLOAT",
              t = "BOOLEAN",
              r = "TRIGGER",
              u = "1D",
              v = "2D_DIRECTIONAL",
              _ = "2D_CARTESIAN",
              m = "DIRECT",
              g = "START",
              T = "END",
              E = "ANY",
              M = [g, T, E],
              R = "OVERWRITE",
              P = "ADDITIVE";
          },
          70: (xe, V, a) => {
            "use strict";
            a.d(V, { W: () => y });
            var A = a(4751),
              x = a(5745);
            class y {
              constructor(d, h, f, s, l, n) {
                (this._name = d.name),
                  (this._track = d),
                  (this._snapshot = new x.g(d)),
                  (this._playing = s),
                  (this._time = h),
                  (this._speed = f),
                  (this._loop = l),
                  (this._blendWeight = 1),
                  (this._blendOrder = 0),
                  (this._eventHandler = n),
                  this.alignCursorToCurrentTime();
              }
              set name(d) {
                this._name = d;
              }
              get name() {
                return this._name;
              }
              set track(d) {
                (this._track = d), (this._snapshot = new x.g(d));
              }
              get track() {
                return this._track;
              }
              get snapshot() {
                return this._snapshot;
              }
              set time(d) {
                (this._time = d), this.alignCursorToCurrentTime();
              }
              get time() {
                return this._time;
              }
              set speed(d) {
                const h = Math.sign(d) !== Math.sign(this._speed);
                (this._speed = d), h && this.alignCursorToCurrentTime();
              }
              get speed() {
                return this._speed;
              }
              set loop(d) {
                this._loop = d;
              }
              get loop() {
                return this._loop;
              }
              set blendWeight(d) {
                this._blendWeight = d;
              }
              get blendWeight() {
                return this._blendWeight;
              }
              set blendOrder(d) {
                this._blendOrder = d;
              }
              get blendOrder() {
                return this._blendOrder;
              }
              set eventCursor(d) {
                this._eventCursor = d;
              }
              get eventCursor() {
                return this._eventCursor;
              }
              get eventCursorEnd() {
                return this.isReverse ? 0 : this._track.events.length - 1;
              }
              get nextEvent() {
                return this._track.events[this._eventCursor];
              }
              get isReverse() {
                return this._speed < 0;
              }
              nextEventAheadOfTime(d) {
                return this.nextEvent
                  ? this.isReverse
                    ? this.nextEvent.time <= d
                    : this.nextEvent.time >= d
                  : !1;
              }
              nextEventBehindTime(d) {
                return this.nextEvent
                  ? d === this.track.duration
                    ? this.isReverse
                      ? this.nextEvent.time >= d
                      : this.nextEvent.time <= d
                    : this.isReverse
                    ? this.nextEvent.time > d
                    : this.nextEvent.time < d
                  : !1;
              }
              resetEventCursor() {
                this._eventCursor = this.isReverse
                  ? this._track.events.length - 1
                  : 0;
              }
              moveEventCursor() {
                (this._eventCursor += this.isReverse ? -1 : 1),
                  this._eventCursor >= this.track.events.length
                    ? (this._eventCursor = 0)
                    : this._eventCursor < 0 &&
                      (this._eventCursor = this.track.events.length - 1);
              }
              clipFrameTime(d) {
                const h = y.eventFrame;
                (h.start = 0),
                  (h.end = d),
                  (h.residual = 0),
                  this.isReverse
                    ? d < 0 &&
                      ((h.start = this.track.duration),
                      (h.end = 0),
                      (h.residual = d + this.track.duration))
                    : d > this.track.duration &&
                      ((h.start = 0),
                      (h.end = this.track.duration),
                      (h.residual = d - this.track.duration));
              }
              alignCursorToCurrentTime() {
                for (
                  this.resetEventCursor();
                  this.nextEventBehindTime(this._time) &&
                  this._eventCursor !== this.eventCursorEnd;

                )
                  this.moveEventCursor();
              }
              fireNextEvent() {
                this._eventHandler.fire(
                  this.nextEvent.name,
                  (0, A._)({ track: this.track }, this.nextEvent)
                ),
                  this.moveEventCursor();
              }
              fireNextEventInFrame(d, h) {
                return this.nextEventAheadOfTime(d) &&
                  this.nextEventBehindTime(h)
                  ? (this.fireNextEvent(), !0)
                  : !1;
              }
              activeEventsForFrame(d, h) {
                const f = y.eventFrame;
                this.clipFrameTime(h);
                const s = this.eventCursor;
                for (
                  ;
                  this.fireNextEventInFrame(d, f.end) && s !== this.eventCursor;

                );
                this.loop &&
                  Math.abs(f.residual) > 0 &&
                  this.activeEventsForFrame(f.start, f.residual);
              }
              progressForTime(d) {
                return (d * this._speed) / this._track.duration;
              }
              _update(d) {
                if (this._playing) {
                  let h = this._time;
                  const f = this._track.duration,
                    s = this._speed,
                    l = this._loop;
                  this._track.events.length > 0 &&
                    f > 0 &&
                    this.activeEventsForFrame(h, h + s * d),
                    (h += s * d),
                    s >= 0
                      ? h > f &&
                        (l
                          ? (h = h % f || 0)
                          : ((h = this._track.duration), this.pause()))
                      : h < 0 &&
                        (l ? (h = f + (h % f || 0)) : ((h = 0), this.pause())),
                    (this._time = h);
                }
                this._time !== this._snapshot._time &&
                  this._track.eval(this._time, this._snapshot);
              }
              play() {
                (this._playing = !0), (this._time = 0);
              }
              stop() {
                (this._playing = !1), (this._time = 0);
              }
              pause() {
                this._playing = !1;
              }
              resume() {
                this._playing = !0;
              }
              reset() {
                this._time = 0;
              }
            }
            y.eventFrame = { start: 0, end: 0, residual: 0 };
          },
          541: (xe, V, a) => {
            "use strict";
            a.d(V, { v: () => A });
            class A {
              constructor(y, c, d, h) {
                (this._paths = y),
                  (this._input = c),
                  (this._output = d),
                  (this._interpolation = h);
              }
              get paths() {
                return this._paths;
              }
              get input() {
                return this._input;
              }
              get output() {
                return this._output;
              }
              get interpolation() {
                return this._interpolation;
              }
            }
          },
          7448: (xe, V, a) => {
            "use strict";
            a.d(V, { C: () => A });
            class A {
              constructor(y, c) {
                (this._components = y), (this._data = c);
              }
              get components() {
                return this._components;
              }
              get data() {
                return this._data;
              }
            }
          },
          7433: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => h });
            var A = a(3021),
              x = a(4474);
            class y {
              static dot(s, l) {
                const n = s.length;
                let o = 0;
                for (let i = 0; i < n; ++i) o += s[i] * l[i];
                return o;
              }
              static normalize(s) {
                let l = y.dot(s, s);
                if (l > 0) {
                  l = 1 / Math.sqrt(l);
                  const n = s.length;
                  for (let o = 0; o < n; ++o) s[o] *= l;
                }
              }
              static set(s, l, n) {
                const o = s.length;
                if (n === "quaternion") {
                  let i = y.dot(l, l);
                  i > 0 && (i = 1 / Math.sqrt(i));
                  for (let e = 0; e < o; ++e) s[e] = l[e] * i;
                } else for (let i = 0; i < o; ++i) s[i] = l[i];
              }
              static blendVec(s, l, n, o) {
                const i = o ? 1 : 1 - n,
                  e = s.length;
                for (let t = 0; t < e; ++t) s[t] = s[t] * i + l[t] * n;
              }
              static blendQuat(s, l, n, o) {
                const i = s.length,
                  e = o ? 1 : 1 - n;
                y.dot(s, l) < 0 && (n = -n);
                for (let t = 0; t < i; ++t) s[t] = s[t] * e + l[t] * n;
                o || y.normalize(s);
              }
              static blend(s, l, n, o, i) {
                o === "quaternion"
                  ? y.blendQuat(s, l, n, i)
                  : y.blendVec(s, l, n, i);
              }
              static stableSort(s, l) {
                const n = s.length;
                for (let o = 0; o < n - 1; ++o)
                  for (let i = o + 1; i < n; ++i)
                    if (l(s[i], s[o])) {
                      const e = s[o];
                      (s[o] = s[i]), (s[i] = e);
                    }
              }
            }
            var c = a(8656);
            class d {
              constructor(s, l) {
                (this._component = s),
                  (this.mask = new Int8Array(s.layers.length)),
                  (this.weights = new Float32Array(s.layers.length)),
                  (this.totalWeight = 0),
                  (this.counter = 0),
                  (this.layerCounter = 0),
                  (this.valueType = l),
                  (this.dirty = !0),
                  (this.value = l === d.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0]),
                  (this.baseValue = null),
                  (this.setter = null);
              }
              get _normalizeWeights() {
                return this._component.normalizeWeights;
              }
              getWeight(s) {
                return (
                  this.dirty && this.updateWeights(),
                  (this._normalizeWeights && this.totalWeight === 0) ||
                  !this.mask[s]
                    ? 0
                    : this._normalizeWeights
                    ? this.weights[s] / this.totalWeight
                    : c.D.clamp(this.weights[s], 0, 1)
                );
              }
              _layerBlendType(s) {
                return this._component.layers[s].blendType;
              }
              setMask(s, l) {
                (this.mask[s] = l),
                  this._normalizeWeights &&
                    (this._component.layers[s].blendType === x.eU &&
                      (this.mask = this.mask.fill(0, 0, s)),
                    (this.dirty = !0));
              }
              updateWeights() {
                this.totalWeight = 0;
                for (let s = 0; s < this.weights.length; s++)
                  (this.weights[s] = this._component.layers[s].weight),
                    (this.totalWeight += this.mask[s] * this.weights[s]);
                this.dirty = !1;
              }
              updateValue(s, l) {
                if (
                  (this.counter === 0 &&
                    (y.set(this.value, d.IDENTITY_QUAT_ARR, this.valueType),
                    this._normalizeWeights ||
                      y.blend(this.value, this.baseValue, 1, this.valueType)),
                  !(!this.mask[s] || this.getWeight(s) === 0))
                ) {
                  if (
                    this._layerBlendType(s) === x.XY &&
                    !this._normalizeWeights
                  )
                    if (this.valueType === d.TYPE_QUAT) {
                      const n = d.q1.set(
                          this.value[0],
                          this.value[1],
                          this.value[2],
                          this.value[3]
                        ),
                        o = d.q2.set(
                          this.baseValue[0],
                          this.baseValue[1],
                          this.baseValue[2],
                          this.baseValue[3]
                        ),
                        i = d.q3.set(l[0], l[1], l[2], l[3]),
                        e = o.invert().mul(i);
                      e.slerp(A.k.IDENTITY, e, this.getWeight(s)),
                        n.mul(e),
                        (d.quatArr[0] = n.x),
                        (d.quatArr[1] = n.y),
                        (d.quatArr[2] = n.z),
                        (d.quatArr[3] = n.w),
                        y.set(this.value, d.quatArr, this.valueType);
                    } else
                      (d.vecArr[0] = l[0] - this.baseValue[0]),
                        (d.vecArr[1] = l[1] - this.baseValue[1]),
                        (d.vecArr[2] = l[2] - this.baseValue[2]),
                        y.blend(
                          this.value,
                          d.vecArr,
                          this.getWeight(s),
                          this.valueType,
                          !0
                        );
                  else
                    y.blend(this.value, l, this.getWeight(s), this.valueType);
                  this.setter && this.setter(this.value);
                }
              }
              unbind() {
                this.setter && this.setter(this.baseValue);
              }
            }
            (d.TYPE_QUAT = "quaternion"),
              (d.TYPE_VEC3 = "vector3"),
              (d.q1 = new A.k()),
              (d.q2 = new A.k()),
              (d.q3 = new A.k()),
              (d.quatArr = [0, 0, 0, 1]),
              (d.vecArr = [0, 0, 0]),
              (d.IDENTITY_QUAT_ARR = [0, 0, 0, 1]);
            class h {
              constructor(s) {
                (this._binder = s),
                  (this._clips = []),
                  (this._inputs = []),
                  (this._outputs = []),
                  (this._targets = {});
              }
              get clips() {
                return this._clips;
              }
              addClip(s) {
                const l = this._targets,
                  n = this._binder,
                  o = s.track.curves,
                  i = s.snapshot,
                  e = [],
                  t = [];
                for (let r = 0; r < o.length; ++r) {
                  const v = o[r].paths;
                  for (let _ = 0; _ < v.length; ++_) {
                    const m = v[_],
                      g = n.resolve(m);
                    let T = l[(g && g.targetPath) || null];
                    if (!T && g) {
                      T = { target: g, value: [], curves: 0, blendCounter: 0 };
                      for (let E = 0; E < T.target.components; ++E)
                        T.value.push(0);
                      if (((l[g.targetPath] = T), n.animComponent)) {
                        if (!n.animComponent.targets[g.targetPath]) {
                          let E;
                          g.targetPath.substring(g.targetPath.length - 13) ===
                          "localRotation"
                            ? (E = d.TYPE_QUAT)
                            : (E = d.TYPE_VEC3),
                            (n.animComponent.targets[g.targetPath] = new d(
                              n.animComponent,
                              E
                            ));
                        }
                        n.animComponent.targets[g.targetPath].layerCounter++,
                          n.animComponent.targets[g.targetPath].setMask(
                            n.layerIndex,
                            1
                          );
                      }
                    }
                    T && (T.curves++, e.push(i._results[r]), t.push(T));
                  }
                }
                this._clips.push(s),
                  this._inputs.push(e),
                  this._outputs.push(t);
              }
              removeClip(s) {
                const l = this._targets,
                  n = this._binder,
                  o = this._clips,
                  e = o[s].track.curves;
                for (let t = 0; t < e.length; ++t) {
                  const u = e[t].paths;
                  for (let v = 0; v < u.length; ++v) {
                    const _ = u[v],
                      m = this._binder.resolve(_);
                    m &&
                      (m.curves--,
                      m.curves === 0 &&
                        (n.unresolve(_),
                        delete l[m.targetPath],
                        n.animComponent &&
                          n.animComponent.targets[m.targetPath]
                            .layerCounter--));
                  }
                }
                o.splice(s, 1),
                  this._inputs.splice(s, 1),
                  this._outputs.splice(s, 1);
              }
              removeClips() {
                for (; this._clips.length > 0; ) this.removeClip(0);
              }
              updateClipTrack(s, l) {
                this._clips.forEach((n) => {
                  n.name.includes(s) && (n.track = l);
                }),
                  this.rebind();
              }
              findClip(s) {
                const l = this._clips;
                for (let n = 0; n < l.length; ++n) {
                  const o = l[n];
                  if (o.name === s) return o;
                }
                return null;
              }
              rebind() {
                this._binder.rebind(), (this._targets = {});
                const s = [...this.clips];
                this.removeClips(),
                  s.forEach((l) => {
                    this.addClip(l);
                  });
              }
              assignMask(s) {
                return this._binder.assignMask(s);
              }
              update(s, l = !0) {
                const n = this._clips,
                  o = n.map(function (t, r) {
                    return r;
                  });
                y.stableSort(o, function (t, r) {
                  return n[t].blendOrder < n[r].blendOrder;
                });
                for (let t = 0; t < o.length; ++t) {
                  const r = o[t],
                    u = n[r],
                    v = this._inputs[r],
                    _ = this._outputs[r],
                    m = u.blendWeight;
                  if ((m > 0 && u._update(s), !l)) break;
                  let g, T, E;
                  if (m >= 1)
                    for (let M = 0; M < v.length; ++M)
                      (g = v[M]),
                        (T = _[M]),
                        (E = T.value),
                        y.set(E, g, T.target.type),
                        T.blendCounter++;
                  else if (m > 0)
                    for (let M = 0; M < v.length; ++M)
                      (g = v[M]),
                        (T = _[M]),
                        (E = T.value),
                        T.blendCounter === 0
                          ? y.set(E, g, T.target.type)
                          : y.blend(E, g, m, T.target.type),
                        T.blendCounter++;
                }
                const i = this._targets,
                  e = this._binder;
                for (const t in i)
                  if (i.hasOwnProperty(t)) {
                    const r = i[t];
                    if (e.animComponent && r.target.isTransform) {
                      const u = e.animComponent.targets[t];
                      u.counter === u.layerCounter && (u.counter = 0),
                        u.path ||
                          ((u.path = t),
                          (u.baseValue = r.target.get()),
                          (u.setter = r.target.set)),
                        u.updateValue(e.layerIndex, r.value),
                        u.counter++;
                    } else r.target.set(r.value);
                    r.blendCounter = 0;
                  }
                this._binder.update(s);
              }
            }
          },
          7825: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => A });
            class A {
              constructor(y) {
                (this._events = [...y]),
                  this._events.sort((c, d) => c.time - d.time);
              }
              get events() {
                return this._events;
              }
            }
          },
          5745: (xe, V, a) => {
            "use strict";
            a.d(V, { g: () => c });
            var A = a(8656),
              x = a(871);
            class y {
              constructor() {
                (this._left = 1 / 0),
                  (this._right = -1 / 0),
                  (this._len = 0),
                  (this._recip = 0),
                  (this._p0 = 0),
                  (this._p1 = 0),
                  (this._t = 0),
                  (this._hermite = { valid: !1, p0: 0, m0: 0, p1: 0, m1: 0 });
              }
              update(h, f) {
                if (h < this._left || h >= this._right) {
                  const s = f.length;
                  if (!s)
                    (this._left = -1 / 0),
                      (this._right = 1 / 0),
                      (this._len = 0),
                      (this._recip = 0),
                      (this._p0 = this._p1 = 0);
                  else if (h < f[0])
                    (this._left = -1 / 0),
                      (this._right = f[0]),
                      (this._len = 0),
                      (this._recip = 0),
                      (this._p0 = this._p1 = 0);
                  else if (h >= f[s - 1])
                    (this._left = f[s - 1]),
                      (this._right = 1 / 0),
                      (this._len = 0),
                      (this._recip = 0),
                      (this._p0 = this._p1 = s - 1);
                  else {
                    const l = this._findKey(h, f);
                    (this._left = f[l]),
                      (this._right = f[l + 1]),
                      (this._len = this._right - this._left);
                    const n = 1 / this._len;
                    (this._recip = isFinite(n) ? n : 0),
                      (this._p0 = l),
                      (this._p1 = l + 1);
                  }
                }
                (this._t =
                  this._recip === 0 ? 0 : (h - this._left) * this._recip),
                  (this._hermite.valid = !1);
              }
              _findKey(h, f) {
                let s = 0;
                for (; h >= f[s + 1]; ) s++;
                return s;
              }
              eval(h, f, s) {
                const l = s._data,
                  n = s._components,
                  o = this._p0 * n;
                if (f === x.Un) for (let i = 0; i < n; ++i) h[i] = l[o + i];
                else {
                  const i = this._t,
                    e = this._p1 * n;
                  switch (f) {
                    case x.tF:
                      for (let t = 0; t < n; ++t)
                        h[t] = A.D.lerp(l[o + t], l[e + t], i);
                      break;
                    case x.yQ: {
                      const t = this._hermite;
                      if (!t.valid) {
                        const m = i * i,
                          g = i + i,
                          T = 1 - i,
                          E = T * T;
                        (t.valid = !0),
                          (t.p0 = (1 + g) * E),
                          (t.m0 = i * E),
                          (t.p1 = m * (3 - g)),
                          (t.m1 = m * (i - 1));
                      }
                      const r = (this._p0 * 3 + 1) * n,
                        u = (this._p0 * 3 + 2) * n,
                        v = (this._p1 * 3 + 1) * n,
                        _ = (this._p1 * 3 + 0) * n;
                      for (let m = 0; m < n; ++m)
                        h[m] =
                          t.p0 * l[r + m] +
                          t.m0 * l[u + m] * this._len +
                          t.p1 * l[v + m] +
                          t.m1 * l[_ + m] * this._len;
                      break;
                    }
                  }
                }
              }
            }
            class c {
              constructor(h) {
                (this._name = h.name + "Snapshot"),
                  (this._time = -1),
                  (this._cache = []),
                  (this._results = []);
                for (let l = 0; l < h._inputs.length; ++l)
                  this._cache[l] = new y();
                const f = h._curves,
                  s = h._outputs;
                for (let l = 0; l < f.length; ++l) {
                  const n = f[l],
                    o = s[n._output],
                    i = [];
                  for (let e = 0; e < o._components; ++e) i[e] = 0;
                  this._results[l] = i;
                }
              }
            }
          },
          8265: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => A });
            class A {
              constructor(y, c, d, h) {
                y.set
                  ? ((this._set = y.set), (this._get = y.get))
                  : (this._set = y),
                  (this._type = c),
                  (this._components = d),
                  (this._targetPath = h),
                  (this._isTransform =
                    this._targetPath.substring(this._targetPath.length - 13) ===
                      "localRotation" ||
                    this._targetPath.substring(this._targetPath.length - 13) ===
                      "localPosition" ||
                    this._targetPath.substring(this._targetPath.length - 10) ===
                      "localScale");
              }
              get set() {
                return this._set;
              }
              get get() {
                return this._get;
              }
              get type() {
                return this._type;
              }
              get components() {
                return this._components;
              }
              get targetPath() {
                return this._targetPath;
              }
              get isTransform() {
                return this._isTransform;
              }
            }
          },
          9645: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => x });
            var A = a(7825);
            class x {
              constructor(c, d, h, f, s, l = new A.F([])) {
                (this._name = c),
                  (this._duration = d),
                  (this._inputs = h),
                  (this._outputs = f),
                  (this._curves = s),
                  (this._animEvents = l);
              }
              get name() {
                return this._name;
              }
              get duration() {
                return this._duration;
              }
              get inputs() {
                return this._inputs;
              }
              get outputs() {
                return this._outputs;
              }
              get curves() {
                return this._curves;
              }
              set events(c) {
                this._animEvents = c;
              }
              get events() {
                return this._animEvents.events;
              }
              eval(c, d) {
                d._time = c;
                const h = this._inputs,
                  f = this._outputs,
                  s = this._curves,
                  l = d._cache,
                  n = d._results;
                for (let o = 0; o < h.length; ++o) l[o].update(c, h[o]._data);
                for (let o = 0; o < s.length; ++o) {
                  const i = s[o],
                    e = f[i._output],
                    t = n[o];
                  l[i._input].eval(t, i._interpolation, e);
                }
              }
            }
            x.EMPTY = Object.freeze(
              new x("empty", Number.MAX_VALUE, [], [], [])
            );
          },
          949: (xe, V, a) => {
            "use strict";
            a.d(V, { R: () => A });
            class A {
              constructor(y) {
                if (
                  ((this._layers = []),
                  (this._parameters = {}),
                  Array.isArray(y.layers))
                )
                  this._layers = y.layers;
                else
                  for (const c in y.layers) {
                    const d = y.layers[c],
                      h = {
                        name: d.name,
                        blendType: d.blendType,
                        weight: d.weight,
                        states: [],
                        transitions: [],
                      };
                    for (let f = 0; f < d.states.length; f++)
                      h.states.push(y.states[d.states[f]]);
                    for (let f = 0; f < d.transitions.length; f++) {
                      const s = y.transitions[d.transitions[f]];
                      if (s.conditions && !Array.isArray(s.conditions)) {
                        const l = Object.keys(s.conditions),
                          n = [];
                        for (let o = 0; o < l.length; o++) {
                          const i = s.conditions[l[o]];
                          i.parameterName && n.push(i);
                        }
                        s.conditions = n;
                      }
                      Number.isInteger(s.from) &&
                        (s.from = y.states[s.from].name),
                        Number.isInteger(s.to) && (s.to = y.states[s.to].name),
                        h.transitions.push(s);
                    }
                    this._layers.push(h);
                  }
                for (const c in y.parameters) {
                  const d = y.parameters[c];
                  this._parameters[d.name] = { type: d.type, value: d.value };
                }
              }
              get parameters() {
                return Object.assign({}, this._parameters);
              }
              get layers() {
                return this._layers;
              }
            }
          },
          7788: (xe, V, a) => {
            "use strict";
            a.d(V, { v: () => ne, y: () => Y });
            var A = a(9222),
              x = a(9516),
              y = a(1870),
              c = a(8976),
              d = a(5227),
              h = a(8484),
              f = a(8656),
              s = a(3021),
              l = a(7481),
              n = a(1630),
              o = a(8136),
              i = a(8633),
              e = a(9391),
              t = a(783),
              r = a(6874),
              u = a(600);
            class v {
              constructor() {
                (this.renderPasses = []), (this.renderTargetMap = new Map());
              }
              addRenderPass(w) {
                this.renderPasses.push(w);
              }
              reset() {
                this.renderPasses.length = 0;
              }
              compile() {
                const w = this.renderTargetMap,
                  N = this.renderPasses;
                for (let ue = 0; ue < N.length; ue++) {
                  const ye = N[ue],
                    Oe = ye.renderTarget;
                  if (Oe !== void 0) {
                    const Ae = w.get(Oe);
                    if (Ae) {
                      const ke = ye.colorArrayOps.length;
                      for (let Ue = 0; Ue < ke; Ue++)
                        ye.colorArrayOps[Ue].clear ||
                          (Ae.colorArrayOps[Ue].store = !0);
                      ye.depthStencilOps.clearDepth ||
                        (Ae.depthStencilOps.storeDepth = !0),
                        ye.depthStencilOps.clearStencil ||
                          (Ae.depthStencilOps.storeStencil = !0);
                    }
                    w.set(Oe, ye);
                  }
                }
                let W = null,
                  he = null;
                for (let ue = 0; ue < N.length; ue++) {
                  const ye = N[ue],
                    Oe = ye.renderTarget,
                    Ae = Oe == null ? void 0 : Oe.colorBuffer;
                  if (Ae != null && Ae.cubemap) {
                    if (W === Ae) {
                      const ke = he.colorArrayOps.length;
                      for (let Ue = 0; Ue < ke; Ue++)
                        he.colorArrayOps[Ue].mipmaps = !1;
                    }
                    (W = Oe.colorBuffer), (he = ye);
                  } else ye.requiresCubemaps && ((W = null), (he = null));
                }
                w.forEach((ue, ye) => {
                  ye === null &&
                    ((ue.colorOps.store = !0),
                    (ue.colorOps.resolve = !1),
                    (ue.colorOps.mipmaps = !1));
                }),
                  w.clear();
              }
              render(w) {
                this.compile();
                const N = this.renderPasses;
                for (let W = 0; W < N.length; W++) N[W].render();
              }
            }
            var _ = a(3064),
              m = a(1208),
              g = a(5950);
            class T {
              constructor(w, N) {
                (this.texture0 = w), (this.texture1 = N);
              }
              destroy() {
                var w, N;
                (w = this.texture0) == null || w.destroy(),
                  (N = this.texture1) == null || N.destroy();
              }
            }
            const E = new g.N();
            class M {
              static createTexture(w, N, W, he = "") {
                return new m.g(w, {
                  name: `AreaLightLUT${he}`,
                  width: W,
                  height: W,
                  format: N,
                  addressU: n.vq6,
                  addressV: n.vq6,
                  type: n.s64,
                  magFilter: n.DrA,
                  minFilter: n.uhC,
                  anisotropy: 1,
                  mipmaps: !1,
                });
              }
              static applyTextures(w, N, W) {
                E.remove(w),
                  E.get(w, () => new T(N, N === W ? null : W)),
                  w.scope.resolve("areaLightsLutTex1").setValue(N),
                  w.scope.resolve("areaLightsLutTex2").setValue(W);
              }
              static createPlaceholder(w) {
                const N = M.createTexture(
                  w,
                  w.areaLightLutFormat,
                  2,
                  "placeholder"
                );
                N.lock().fill(0), N.unlock(), M.applyTextures(w, N, N);
              }
              static set(w, N, W) {
                function he(K, Te, H) {
                  const q = M.createTexture(K, H, 64);
                  return q.lock().set(Te), q.unlock(), q;
                }
                function ue(K, Te, H) {
                  const q = K.length,
                    se = new Float32Array(q);
                  for (let Ce = 0; Ce < q; Ce++) {
                    const we = Ce % 4;
                    se[Ce] = (K[Ce] + Te[we]) * H[we];
                  }
                  return se;
                }
                function ye(K) {
                  const Te = K.length,
                    H = new Uint16Array(Te),
                    q = _.A.float2Half;
                  for (let se = 0; se < Te; se++) H[se] = q(K[se]);
                  return H;
                }
                function Oe(K) {
                  const Te = K.length,
                    H = new Uint8ClampedArray(Te);
                  for (let q = 0; q < Te; q++) H[q] = K[q] * 255;
                  return H;
                }
                const Ae = N,
                  ke = W;
                let Ue, Ge;
                const ht = w.areaLightLutFormat;
                if (ht === n.s7h) (Ue = Ae), (Ge = ke);
                else if (ht === n.WBN) (Ue = ye(Ae)), (Ge = ye(ke));
                else {
                  const K = [0, 0.2976, 0.01381, 0],
                    Te = [0.999, 3.08737, 1.6546, 0.603249],
                    H = [-0.306897, 0, 0, 0],
                    q = [1.442787, 1, 1, 1];
                  (Ue = Oe(ue(Ae, K, Te))), (Ge = Oe(ue(ke, H, q)));
                }
                const me = he(w, Ue, ht),
                  z = he(w, Ge, ht);
                M.applyTextures(w, me, z);
              }
            }
            var R = a(2223),
              P = a(1232),
              F = a(1036),
              b = a(2658),
              D = a(9877),
              G = a(1369),
              X = a(1594),
              ie = a(3953),
              Q = a(0),
              te = a(5691),
              ae = a(972),
              Z = a(8197),
              J = a(6498),
              ve = a(9992),
              _e = a(4446),
              L = a(4277),
              ge = a(371),
              k = a(8576),
              j = a(4595),
              B = a(4530);
            class $ {
              constructor(w) {
                (this.frame = {
                  fps: 0,
                  ms: 0,
                  dt: 0,
                  updateStart: 0,
                  updateTime: 0,
                  renderStart: 0,
                  renderTime: 0,
                  physicsStart: 0,
                  physicsTime: 0,
                  cullTime: 0,
                  sortTime: 0,
                  skinTime: 0,
                  morphTime: 0,
                  instancingTime: 0,
                  triangles: 0,
                  otherPrimitives: 0,
                  shaders: 0,
                  materials: 0,
                  cameras: 0,
                  shadowMapUpdates: 0,
                  shadowMapTime: 0,
                  depthMapTime: 0,
                  forwardTime: 0,
                  lightClustersTime: 0,
                  lightClusters: 0,
                  _timeToCountFrames: 0,
                  _fpsAccum: 0,
                }),
                  (this.drawCalls = {
                    forward: 0,
                    depth: 0,
                    shadow: 0,
                    immediate: 0,
                    misc: 0,
                    total: 0,
                    skinned: 0,
                    instanced: 0,
                    removedByInstancing: 0,
                  }),
                  (this.misc = { renderTargetCreationTime: 0 }),
                  (this.particles = {
                    updatesPerFrame: 0,
                    _updatesPerFrame: 0,
                    frameTime: 0,
                    _frameTime: 0,
                  }),
                  (this.shaders = w._shaderStats),
                  (this.vram = w._vram),
                  Object.defineProperty(this.vram, "totalUsed", {
                    get: function () {
                      return this.tex + this.vb + this.ib;
                    },
                  }),
                  Object.defineProperty(this.vram, "geom", {
                    get: function () {
                      return this.vb + this.ib;
                    },
                  });
              }
              get scene() {
                return (0, B.D)().scene._stats;
              }
              get lightmapper() {
                var w;
                return (w = (0, B.D)().lightmapper) == null ? void 0 : w.stats;
              }
              get batcher() {
                const w = (0, B.D)()._batcher;
                return w ? w._stats : null;
              }
            }
            var le = a(8947);
            class O {
              constructor(w) {
                (this.length = w), (this.count = 0);
              }
              inc() {
                this.count++;
              }
              done() {
                return this.count === this.length;
              }
            }
            let Y = null;
            class ne extends c.J {
              constructor(w) {
                super(),
                  (ne._applications[w.id] = this),
                  (0, B.V)(this),
                  (Y = this),
                  (this._destroyRequested = !1),
                  (this._inFrameUpdate = !1),
                  (this._time = 0),
                  (this.timeScale = 1),
                  (this.maxDeltaTime = 0.1),
                  (this.frame = 0),
                  (this.autoRender = !0),
                  (this.renderNextFrame = !1),
                  (this.useLegacyScriptAttributeCloning = j.K.legacy),
                  (this._librariesLoaded = !1),
                  (this._fillMode = le.Wx),
                  (this._resolutionMode = le.GL),
                  (this._allowResize = !0),
                  (this.context = this);
              }
              init(w) {
                const N = w.graphicsDevice;
                (this.graphicsDevice = N),
                  o.A.set(N),
                  this._initDefaultMaterial(),
                  this._initProgramLibrary(),
                  (this.stats = new $(N)),
                  (this._soundManager = w.soundManager),
                  (this.loader = new ve.W(this)),
                  D.u.init(N),
                  (this._entityIndex = {}),
                  (this.scene = new F.Z(N)),
                  this._registerSceneImmediate(this.scene),
                  (this.root = new ge.w()),
                  (this.root._enabledInHierarchy = !0),
                  (this.assets = new Q.k(this.loader)),
                  w.assetPrefix && (this.assets.prefix = w.assetPrefix),
                  (this.bundles = new te.a(this.assets)),
                  (this.enableBundles = typeof TextDecoder != "undefined"),
                  (this.scriptsOrder = w.scriptsOrder || []),
                  (this.scripts = new L.r(this)),
                  (this.i18n = new _e.F(this)),
                  (this.scenes = new k.C(this));
                const W = this;
                (this.defaultLayerWorld = new R.W({ name: "World", id: e.uE })),
                  (this.sceneGrab = new Z.f(this.graphicsDevice, this.scene)),
                  (this.defaultLayerDepth = this.sceneGrab.layer),
                  (this.defaultLayerSkybox = new R.W({
                    enabled: !0,
                    name: "Skybox",
                    id: e.CT,
                    opaqueSortMode: e.lU,
                  })),
                  (this.defaultLayerUi = new R.W({
                    enabled: !0,
                    name: "UI",
                    id: e.Qe,
                    transparentSortMode: e.BE,
                    passThrough: !1,
                  })),
                  (this.defaultLayerImmediate = new R.W({
                    enabled: !0,
                    name: "Immediate",
                    id: e.t0,
                    opaqueSortMode: e.lU,
                    passThrough: !0,
                  }));
                const he = new P.e("default");
                he.pushOpaque(this.defaultLayerWorld),
                  he.pushOpaque(this.defaultLayerDepth),
                  he.pushOpaque(this.defaultLayerSkybox),
                  he.pushTransparent(this.defaultLayerWorld),
                  he.pushOpaque(this.defaultLayerImmediate),
                  he.pushTransparent(this.defaultLayerImmediate),
                  he.pushTransparent(this.defaultLayerUi),
                  (this.scene.layers = he),
                  this.scene.on("set:layers", function (ue, ye) {
                    const Oe = ye.layerList;
                    let Ae;
                    for (let ke = 0; ke < Oe.length; ke++)
                      switch (((Ae = Oe[ke]), Ae.id)) {
                        case e.$9:
                          W.sceneGrab.patch(Ae);
                          break;
                        case e.Qe:
                          Ae.passThrough = W.defaultLayerUi.passThrough;
                          break;
                        case e.t0:
                          Ae.passThrough = W.defaultLayerImmediate.passThrough;
                          break;
                      }
                  }),
                  M.createPlaceholder(N),
                  (this.renderer = new u.v(N)),
                  (this.renderer.scene = this.scene),
                  (this.frameGraph = new v()),
                  (this.lightmapper = null),
                  w.lightmapper &&
                    ((this.lightmapper = new w.lightmapper(
                      N,
                      this.root,
                      this.scene,
                      this.renderer,
                      this.assets
                    )),
                    this.once("prerender", this._firstBake, this)),
                  (this._batcher = null),
                  w.batchManager &&
                    ((this._batcher = new w.batchManager(
                      N,
                      this.root,
                      this.scene
                    )),
                    this.once("prerender", this._firstBatch, this)),
                  (this.keyboard = w.keyboard || null),
                  (this.mouse = w.mouse || null),
                  (this.touch = w.touch || null),
                  (this.gamepads = w.gamepads || null),
                  (this.elementInput = w.elementInput || null),
                  this.elementInput && (this.elementInput.app = this),
                  (this.xr = w.xr ? new w.xr(this) : null),
                  this.elementInput && this.elementInput.attachSelectEvents(),
                  (this._inTools = !1),
                  (this._skyboxAsset = null),
                  (this._scriptPrefix = w.scriptPrefix || ""),
                  this.enableBundles &&
                    this.loader.addHandler("bundle", new J.z(this)),
                  w.resourceHandlers.forEach((ue) => {
                    const ye = new ue(this);
                    this.loader.addHandler(ye.handlerType, ye);
                  }),
                  (this.systems = new ae.S()),
                  w.componentSystems.forEach((ue) => {
                    this.systems.add(new ue(this));
                  }),
                  (this._visibilityChangeHandler =
                    this.onVisibilityChange.bind(this)),
                  typeof document != "undefined" &&
                    (document.hidden !== void 0
                      ? ((this._hiddenAttr = "hidden"),
                        document.addEventListener(
                          "visibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))
                      : document.mozHidden !== void 0
                      ? ((this._hiddenAttr = "mozHidden"),
                        document.addEventListener(
                          "mozvisibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))
                      : document.msHidden !== void 0
                      ? ((this._hiddenAttr = "msHidden"),
                        document.addEventListener(
                          "msvisibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))
                      : document.webkitHidden !== void 0 &&
                        ((this._hiddenAttr = "webkitHidden"),
                        document.addEventListener(
                          "webkitvisibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))),
                  (this.tick = re(this));
              }
              static getApplication(w) {
                return w ? ne._applications[w] : (0, B.D)();
              }
              _initDefaultMaterial() {
                const w = new G.F();
                (w.name = "Default Material"),
                  (w.shadingModel = e.SB),
                  (0, X.z)(this.graphicsDevice, w);
              }
              _initProgramLibrary() {
                const w = new r.M(this.graphicsDevice, new G.F());
                (0, t.o)(this.graphicsDevice, w);
              }
              get soundManager() {
                return this._soundManager;
              }
              get batcher() {
                return this._batcher;
              }
              get fillMode() {
                return this._fillMode;
              }
              get resolutionMode() {
                return this._resolutionMode;
              }
              configure(w, N) {
                i.L.get(w, (W, he) => {
                  if (W) {
                    N(W);
                    return;
                  }
                  const ue = he.application_properties,
                    ye = he.scenes,
                    Oe = he.assets;
                  this._parseApplicationProperties(ue, (Ae) => {
                    this._parseScenes(ye), this._parseAssets(Oe), N(Ae || null);
                  });
                });
              }
              preload(w) {
                this.fire("preload:start");
                const N = this.assets.list({ preload: !0 }),
                  W = new O(N.length);
                let he = !1;
                const ue = () => {
                    this.graphicsDevice &&
                      !he &&
                      W.done() &&
                      ((he = !0), this.fire("preload:end"), w());
                  },
                  ye = N.length;
                if (W.length) {
                  const Oe = (ke) => {
                      W.inc(),
                        this.fire("preload:progress", W.count / ye),
                        W.done() && ue();
                    },
                    Ae = (ke, Ue) => {
                      W.inc(),
                        this.fire("preload:progress", W.count / ye),
                        W.done() && ue();
                    };
                  for (let ke = 0; ke < N.length; ke++)
                    N[ke].loaded
                      ? (W.inc(),
                        this.fire("preload:progress", W.count / ye),
                        W.done() && ue())
                      : (N[ke].once("load", Oe),
                        N[ke].once("error", Ae),
                        this.assets.load(N[ke]));
                } else ue();
              }
              _preloadScripts(w, N) {
                if (!j.K.legacy) {
                  N();
                  return;
                }
                this.systems.script.preloading = !0;
                const W = this._getScriptReferences(w),
                  he = W.length,
                  ue = new O(he),
                  ye = /^http(s)?:\/\//;
                if (he) {
                  const Oe = (Ae, ke) => {
                    Ae && console.error(Ae),
                      ue.inc(),
                      ue.done() && ((this.systems.script.preloading = !1), N());
                  };
                  for (let Ae = 0; Ae < he; Ae++) {
                    let ke = W[Ae];
                    !ye.test(ke.toLowerCase()) &&
                      this._scriptPrefix &&
                      (ke = y.A.join(this._scriptPrefix, W[Ae])),
                      this.loader.load(ke, "script", Oe);
                  }
                } else (this.systems.script.preloading = !1), N();
              }
              _parseApplicationProperties(w, N) {
                if (
                  (typeof w.maxAssetRetries == "number" &&
                    w.maxAssetRetries > 0 &&
                    this.loader.enableRetry(w.maxAssetRetries),
                  w.useDevicePixelRatio ||
                    (w.useDevicePixelRatio = w.use_device_pixel_ratio),
                  w.resolutionMode || (w.resolutionMode = w.resolution_mode),
                  w.fillMode || (w.fillMode = w.fill_mode),
                  (this._width = w.width),
                  (this._height = w.height),
                  w.useDevicePixelRatio &&
                    (this.graphicsDevice.maxPixelRatio =
                      window.devicePixelRatio),
                  this.setCanvasResolution(
                    w.resolutionMode,
                    this._width,
                    this._height
                  ),
                  this.setCanvasFillMode(w.fillMode, this._width, this._height),
                  w.layers && w.layerOrder)
                ) {
                  const W = new P.e("application"),
                    he = {};
                  for (const ue in w.layers) {
                    const ye = w.layers[ue];
                    (ye.id = parseInt(ue, 10)),
                      (ye.enabled = ye.id !== e.$9),
                      (he[ue] = new R.W(ye));
                  }
                  for (let ue = 0, ye = w.layerOrder.length; ue < ye; ue++) {
                    const Oe = w.layerOrder[ue],
                      Ae = he[Oe.layer];
                    Ae &&
                      (Oe.transparent
                        ? W.pushTransparent(Ae)
                        : W.pushOpaque(Ae),
                      (W.subLayerEnabled[ue] = Oe.enabled));
                  }
                  this.scene.layers = W;
                }
                if (w.batchGroups) {
                  const W = this.batcher;
                  if (W)
                    for (let he = 0, ue = w.batchGroups.length; he < ue; he++) {
                      const ye = w.batchGroups[he];
                      W.addGroup(
                        ye.name,
                        ye.dynamic,
                        ye.maxAabbSize,
                        ye.id,
                        ye.layers
                      );
                    }
                }
                w.i18nAssets && (this.i18n.assets = w.i18nAssets),
                  this._loadLibraries(w.libraries, N);
              }
              _loadLibraries(w, N) {
                const W = w.length;
                let he = W;
                const ue = /^http(s)?:\/\//;
                if (W) {
                  const ye = (Oe, Ae) => {
                    he--,
                      Oe
                        ? N(Oe)
                        : he === 0 && (this.onLibrariesLoaded(), N(null));
                  };
                  for (let Oe = 0; Oe < W; ++Oe) {
                    let Ae = w[Oe];
                    !ue.test(Ae.toLowerCase()) &&
                      this._scriptPrefix &&
                      (Ae = y.A.join(this._scriptPrefix, Ae)),
                      this.loader.load(Ae, "script", ye);
                  }
                } else this.onLibrariesLoaded(), N(null);
              }
              _parseScenes(w) {
                if (w)
                  for (let N = 0; N < w.length; N++)
                    this.scenes.add(w[N].name, w[N].url);
              }
              _parseAssets(w) {
                const N = [],
                  W = {},
                  he = {};
                if (j.K.legacy) {
                  if (this.enableBundles)
                    for (const ue in w)
                      w[ue].type === "bundle" && ((he[ue] = !0), N.push(w[ue]));
                  for (const ue in w) he[ue] || N.push(w[ue]);
                } else {
                  for (let ue = 0; ue < this.scriptsOrder.length; ue++) {
                    const ye = this.scriptsOrder[ue];
                    w[ye] && ((W[ye] = !0), N.push(w[ye]));
                  }
                  if (this.enableBundles)
                    for (const ue in w)
                      w[ue].type === "bundle" && ((he[ue] = !0), N.push(w[ue]));
                  for (const ue in w) W[ue] || he[ue] || N.push(w[ue]);
                }
                for (let ue = 0; ue < N.length; ue++) {
                  const ye = N[ue],
                    Oe = new ie.V(ye.name, ye.type, ye.file, ye.data);
                  if (
                    ((Oe.id = parseInt(ye.id, 10)),
                    (Oe.preload = ye.preload ? ye.preload : !1),
                    (Oe.loaded =
                      ye.type === "script" &&
                      ye.data &&
                      ye.data.loadingType > 0),
                    Oe.tags.add(ye.tags),
                    ye.i18n)
                  )
                    for (const Ae in ye.i18n)
                      Oe.addLocalizedAssetId(Ae, ye.i18n[Ae]);
                  this.assets.add(Oe);
                }
              }
              _getScriptReferences(w) {
                let N = [];
                w.settings.priority_scripts &&
                  (N = w.settings.priority_scripts);
                const W = [],
                  he = {};
                for (let ye = 0; ye < N.length; ye++)
                  W.push(N[ye]), (he[N[ye]] = !0);
                const ue = w.entities;
                for (const ye in ue) {
                  if (!ue[ye].components.script) continue;
                  const Oe = ue[ye].components.script.scripts;
                  for (let Ae = 0; Ae < Oe.length; Ae++)
                    he[Oe[Ae].url] ||
                      (W.push(Oe[Ae].url), (he[Oe[Ae].url] = !0));
                }
                return W;
              }
              start() {
                (this.frame = 0),
                  this.fire("start", { timestamp: (0, x.t)(), target: this }),
                  this._librariesLoaded || this.onLibrariesLoaded(),
                  this.systems.fire("initialize", this.root),
                  this.fire("initialize"),
                  this.systems.fire("postInitialize", this.root),
                  this.systems.fire("postPostInitialize", this.root),
                  this.fire("postinitialize"),
                  this.tick();
              }
              inputUpdate(w) {
                this.controller && this.controller.update(w),
                  this.mouse && this.mouse.update(),
                  this.keyboard && this.keyboard.update(),
                  this.gamepads && this.gamepads.update();
              }
              update(w) {
                this.frame++,
                  this.graphicsDevice.updateClientRect(),
                  j.K.legacy &&
                    this.systems.fire("fixedUpdate", 0.016666666666666666),
                  this.systems.fire(
                    this._inTools ? "toolsUpdate" : "update",
                    w
                  ),
                  this.systems.fire("animationUpdate", w),
                  this.systems.fire("postUpdate", w),
                  this.fire("update", w),
                  this.inputUpdate(w);
              }
              frameStart() {
                this.graphicsDevice.frameStart();
              }
              frameEnd() {
                this.graphicsDevice.frameEnd();
              }
              render() {
                this.fire("prerender"),
                  this.root.syncHierarchy(),
                  this._batcher && this._batcher.updateAll(),
                  this.renderComposition(this.scene.layers),
                  this.fire("postrender");
              }
              renderComposition(w) {
                this.renderer.buildFrameGraph(this.frameGraph, w),
                  this.frameGraph.render(this.graphicsDevice);
              }
              _fillFrameStatsBasic(w, N, W) {
                const he = this.stats.frame;
                (he.dt = N),
                  (he.ms = W),
                  w > he._timeToCountFrames
                    ? ((he.fps = he._fpsAccum),
                      (he._fpsAccum = 0),
                      (he._timeToCountFrames = w + 1e3))
                    : he._fpsAccum++,
                  (this.stats.drawCalls.total =
                    this.graphicsDevice._drawCallsPerFrame),
                  (this.graphicsDevice._drawCallsPerFrame = 0);
              }
              _fillFrameStats() {
                let w = this.stats.frame;
                (w.cameras = this.renderer._camerasRendered),
                  (w.materials = this.renderer._materialSwitches),
                  (w.shaders = this.graphicsDevice._shaderSwitchesPerFrame),
                  (w.shadowMapUpdates = this.renderer._shadowMapUpdates),
                  (w.shadowMapTime = this.renderer._shadowMapTime),
                  (w.depthMapTime = this.renderer._depthMapTime),
                  (w.forwardTime = this.renderer._forwardTime);
                const N = this.graphicsDevice._primsPerFrame;
                (w.triangles =
                  N[n.Qpk] / 3 +
                  Math.max(N[n.SF$] - 2, 0) +
                  Math.max(N[n.zl$] - 2, 0)),
                  (w.cullTime = this.renderer._cullTime),
                  (w.sortTime = this.renderer._sortTime),
                  (w.skinTime = this.renderer._skinTime),
                  (w.morphTime = this.renderer._morphTime),
                  (w.lightClusters = this.renderer._lightClusters),
                  (w.lightClustersTime = this.renderer._lightClustersTime),
                  (w.otherPrimitives = 0);
                for (let W = 0; W < N.length; W++)
                  W < n.Qpk && (w.otherPrimitives += N[W]), (N[W] = 0);
                (this.renderer._camerasRendered = 0),
                  (this.renderer._materialSwitches = 0),
                  (this.renderer._shadowMapUpdates = 0),
                  (this.graphicsDevice._shaderSwitchesPerFrame = 0),
                  (this.renderer._cullTime = 0),
                  (this.renderer._layerCompositionUpdateTime = 0),
                  (this.renderer._lightClustersTime = 0),
                  (this.renderer._sortTime = 0),
                  (this.renderer._skinTime = 0),
                  (this.renderer._morphTime = 0),
                  (this.renderer._shadowMapTime = 0),
                  (this.renderer._depthMapTime = 0),
                  (this.renderer._forwardTime = 0),
                  (w = this.stats.drawCalls),
                  (w.forward = this.renderer._forwardDrawCalls),
                  (w.culled = this.renderer._numDrawCallsCulled),
                  (w.depth = 0),
                  (w.shadow = this.renderer._shadowDrawCalls),
                  (w.skinned = this.renderer._skinDrawCalls),
                  (w.immediate = 0),
                  (w.instanced = 0),
                  (w.removedByInstancing = 0),
                  (w.misc = w.total - (w.forward + w.shadow)),
                  (this.renderer._depthDrawCalls = 0),
                  (this.renderer._shadowDrawCalls = 0),
                  (this.renderer._forwardDrawCalls = 0),
                  (this.renderer._numDrawCallsCulled = 0),
                  (this.renderer._skinDrawCalls = 0),
                  (this.renderer._immediateRendered = 0),
                  (this.renderer._instancedDrawCalls = 0),
                  (this.stats.misc.renderTargetCreationTime =
                    this.graphicsDevice.renderTargetCreationTime),
                  (w = this.stats.particles),
                  (w.updatesPerFrame = w._updatesPerFrame),
                  (w.frameTime = w._frameTime),
                  (w._updatesPerFrame = 0),
                  (w._frameTime = 0);
              }
              setCanvasFillMode(w, N, W) {
                (this._fillMode = w), this.resizeCanvas(N, W);
              }
              setCanvasResolution(w, N, W) {
                (this._resolutionMode = w),
                  w === le.hD &&
                    N === void 0 &&
                    ((N = this.graphicsDevice.canvas.clientWidth),
                    (W = this.graphicsDevice.canvas.clientHeight)),
                  this.graphicsDevice.resizeCanvas(N, W);
              }
              isHidden() {
                return document[this._hiddenAttr];
              }
              onVisibilityChange() {
                this.isHidden()
                  ? this._soundManager && this._soundManager.suspend()
                  : this._soundManager && this._soundManager.resume();
              }
              resizeCanvas(w, N) {
                if (!this._allowResize || (this.xr && this.xr.session)) return;
                const W = window.innerWidth,
                  he = window.innerHeight;
                if (this._fillMode === le.Wx) {
                  const ue =
                      this.graphicsDevice.canvas.width /
                      this.graphicsDevice.canvas.height,
                    ye = W / he;
                  ue > ye ? ((w = W), (N = w / ue)) : ((N = he), (w = N * ue));
                } else this._fillMode === le.kY && ((w = W), (N = he));
                return (
                  (this.graphicsDevice.canvas.style.width = w + "px"),
                  (this.graphicsDevice.canvas.style.height = N + "px"),
                  this.updateCanvasSize(),
                  { width: w, height: N }
                );
              }
              updateCanvasSize() {
                var w;
                if (
                  !(
                    !this._allowResize ||
                    ((w = this.xr) != null && w.active)
                  ) &&
                  this._resolutionMode === le.hD
                ) {
                  const N = this.graphicsDevice.canvas;
                  this.graphicsDevice.resizeCanvas(
                    N.clientWidth,
                    N.clientHeight
                  );
                }
              }
              onLibrariesLoaded() {
                (this._librariesLoaded = !0),
                  this.systems.rigidbody &&
                    this.systems.rigidbody.onLibraryLoaded();
              }
              applySceneSettings(w) {
                let N;
                if (this.systems.rigidbody && typeof Ammo != "undefined") {
                  const W = w.physics.gravity;
                  this.systems.rigidbody.gravity.set(W[0], W[1], W[2]);
                }
                this.scene.applySettings(w),
                  w.render.hasOwnProperty("skybox") &&
                    (w.render.skybox
                      ? ((N = this.assets.get(w.render.skybox)),
                        N
                          ? this.setSkybox(N)
                          : this.assets.once(
                              "add:" + w.render.skybox,
                              this.setSkybox,
                              this
                            ))
                      : this.setSkybox(null));
              }
              setAreaLightLuts(w, N) {
                w && N && M.set(this.graphicsDevice, w, N);
              }
              setSkybox(w) {
                if (w !== this._skyboxAsset) {
                  const N = () => {
                      this.setSkybox(null);
                    },
                    W = () => {
                      this.scene.setSkybox(
                        this._skyboxAsset ? this._skyboxAsset.resources : null
                      );
                    };
                  this._skyboxAsset &&
                    (this.assets.off("load:" + this._skyboxAsset.id, W, this),
                    this.assets.off("remove:" + this._skyboxAsset.id, N, this),
                    this._skyboxAsset.off("change", W, this)),
                    (this._skyboxAsset = w),
                    this._skyboxAsset &&
                      (this.assets.on("load:" + this._skyboxAsset.id, W, this),
                      this.assets.once(
                        "remove:" + this._skyboxAsset.id,
                        N,
                        this
                      ),
                      this._skyboxAsset.on("change", W, this),
                      this.scene.skyboxMip === 0 &&
                        !this._skyboxAsset.loadFaces &&
                        (this._skyboxAsset.loadFaces = !0),
                      this.assets.load(this._skyboxAsset)),
                    W();
                }
              }
              _firstBake() {
                var w;
                (w = this.lightmapper) == null ||
                  w.bake(null, this.scene.lightmapMode);
              }
              _firstBatch() {
                var w;
                (w = this.batcher) == null || w.generate();
              }
              _processTimestamp(w) {
                return w;
              }
              drawLine(w, N, W, he, ue) {
                this.scene.drawLine(w, N, W, he, ue);
              }
              drawLines(w, N, W = !0, he = this.scene.defaultDrawLayer) {
                this.scene.drawLines(w, N, W, he);
              }
              drawLineArrays(w, N, W = !0, he = this.scene.defaultDrawLayer) {
                this.scene.drawLineArrays(w, N, W, he);
              }
              drawWireSphere(
                w,
                N,
                W = d.Q.WHITE,
                he = 20,
                ue = !0,
                ye = this.scene.defaultDrawLayer
              ) {
                this.scene.immediate.drawWireSphere(w, N, W, he, ue, ye);
              }
              drawWireAlignedBox(
                w,
                N,
                W = d.Q.WHITE,
                he = !0,
                ue = this.scene.defaultDrawLayer
              ) {
                this.scene.immediate.drawWireAlignedBox(w, N, W, he, ue);
              }
              drawMeshInstance(w, N = this.scene.defaultDrawLayer) {
                this.scene.immediate.drawMesh(null, null, null, w, N);
              }
              drawMesh(w, N, W, he = this.scene.defaultDrawLayer) {
                this.scene.immediate.drawMesh(N, W, w, null, he);
              }
              drawQuad(w, N, W = this.scene.defaultDrawLayer) {
                this.scene.immediate.drawMesh(
                  N,
                  w,
                  this.scene.immediate.getQuadMesh(),
                  null,
                  W
                );
              }
              drawTexture(
                w,
                N,
                W,
                he,
                ue,
                ye,
                Oe = this.scene.defaultDrawLayer,
                Ae = !0
              ) {
                if (Ae === !1 && !this.graphicsDevice.isWebGPU) return;
                const ke = new h.$();
                ke.setTRS(new l.e(w, N, 0), s.k.IDENTITY, new l.e(W, -he, 0)),
                  ye ||
                    ((ye = new b.i()),
                    (ye.cull = n.pLF),
                    ye.setParameter("colorMap", ue),
                    (ye.shader = Ae
                      ? this.scene.immediate.getTextureShader()
                      : this.scene.immediate.getUnfilterableTextureShader()),
                    ye.update()),
                  this.drawQuad(ke, ye, Oe);
              }
              drawDepthTexture(w, N, W, he, ue = this.scene.defaultDrawLayer) {
                const ye = new b.i();
                (ye.cull = n.pLF),
                  (ye.shader = this.scene.immediate.getDepthTextureShader()),
                  ye.update(),
                  this.drawTexture(w, N, W, he, null, ye, ue);
              }
              destroy() {
                var w, N, W, he;
                if (this._inFrameUpdate) {
                  this._destroyRequested = !0;
                  return;
                }
                const ue = this.graphicsDevice.canvas.id;
                this.off("librariesloaded"),
                  typeof document != "undefined" &&
                    (document.removeEventListener(
                      "visibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    ),
                    document.removeEventListener(
                      "mozvisibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    ),
                    document.removeEventListener(
                      "msvisibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    ),
                    document.removeEventListener(
                      "webkitvisibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    )),
                  (this._visibilityChangeHandler = null),
                  this.root.destroy(),
                  (this.root = null),
                  this.mouse &&
                    (this.mouse.off(),
                    this.mouse.detach(),
                    (this.mouse = null)),
                  this.keyboard &&
                    (this.keyboard.off(),
                    this.keyboard.detach(),
                    (this.keyboard = null)),
                  this.touch &&
                    (this.touch.off(),
                    this.touch.detach(),
                    (this.touch = null)),
                  this.elementInput &&
                    (this.elementInput.detach(), (this.elementInput = null)),
                  this.gamepads &&
                    (this.gamepads.destroy(), (this.gamepads = null)),
                  this.controller && (this.controller = null),
                  this.systems.destroy(),
                  this.scene.layers && this.scene.layers.destroy();
                const ye = this.assets.list();
                for (let Ae = 0; Ae < ye.length; Ae++)
                  ye[Ae].unload(), ye[Ae].off();
                this.assets.off(),
                  this.bundles.destroy(),
                  (this.bundles = null),
                  this.i18n.destroy(),
                  (this.i18n = null);
                const Oe = this.loader.getHandler("script");
                Oe == null || Oe.clearCache(),
                  this.loader.destroy(),
                  (this.loader = null),
                  this.scene.destroy(),
                  (this.scene = null),
                  (this.systems = null),
                  (this.context = null),
                  this.scripts.destroy(),
                  (this.scripts = null),
                  this.scenes.destroy(),
                  (this.scenes = null),
                  (w = this.lightmapper) == null || w.destroy(),
                  (this.lightmapper = null),
                  this._batcher &&
                    (this._batcher.destroy(), (this._batcher = null)),
                  (this._entityIndex = {}),
                  (this.defaultLayerDepth.onPreRenderOpaque = null),
                  (this.defaultLayerDepth.onPostRenderOpaque = null),
                  (this.defaultLayerDepth.onDisable = null),
                  (this.defaultLayerDepth.onEnable = null),
                  (this.defaultLayerDepth = null),
                  (this.defaultLayerWorld = null),
                  (N = this.xr) == null || N.end(),
                  (W = this.xr) == null || W.destroy(),
                  this.renderer.destroy(),
                  (this.renderer = null),
                  this.graphicsDevice.destroy(),
                  (this.graphicsDevice = null),
                  (this.tick = null),
                  this.off(),
                  (he = this._soundManager) == null || he.destroy(),
                  (this._soundManager = null),
                  (j.K.app = null),
                  (ne._applications[ue] = null),
                  (0, B.D)() === this && (0, B.V)(null);
              }
              getEntityFromIndex(w) {
                return this._entityIndex[w];
              }
              _registerSceneImmediate(w) {
                this.on("postrender", w.immediate.onPostRender, w.immediate);
              }
            }
            ne._applications = {};
            const de = {},
              re = function (w) {
                const N = w;
                let W;
                return function (he, ue) {
                  var ye;
                  if (!N.graphicsDevice) return;
                  (0, B.V)(N),
                    W && (window.cancelAnimationFrame(W), (W = null)),
                    (Y = N);
                  const Oe = N._processTimestamp(he) || (0, x.t)(),
                    Ae = Oe - (N._time || Oe);
                  let ke = Ae / 1e3;
                  if (
                    ((ke = f.D.clamp(ke, 0, N.maxDeltaTime)),
                    (ke *= N.timeScale),
                    (N._time = Oe),
                    (ye = N.xr) != null && ye.session
                      ? (W = N.xr.session.requestAnimationFrame(N.tick))
                      : (W = A.i.browser
                          ? window.requestAnimationFrame(N.tick)
                          : null),
                    N.graphicsDevice.contextLost)
                  )
                    return;
                  N._fillFrameStatsBasic(Oe, ke, Ae),
                    (N._inFrameUpdate = !0),
                    N.fire("frameupdate", Ae);
                  let Ue = !0;
                  if (ue) {
                    var Ge;
                    (Ue = (Ge = N.xr) == null ? void 0 : Ge.update(ue)),
                      (N.graphicsDevice.defaultFramebuffer =
                        ue.session.renderState.baseLayer.framebuffer);
                  } else N.graphicsDevice.defaultFramebuffer = null;
                  Ue &&
                    (N.update(ke),
                    N.fire("framerender"),
                    (N.autoRender || N.renderNextFrame) &&
                      (N.updateCanvasSize(),
                      N.frameStart(),
                      N.render(),
                      N.frameEnd(),
                      (N.renderNextFrame = !1)),
                    (de.timestamp = (0, x.t)()),
                    (de.target = N),
                    N.fire("frameend", de)),
                    (N._inFrameUpdate = !1),
                    N._destroyRequested && N.destroy();
                };
              };
          },
          3042: (xe, V, a) => {
            "use strict";
            a.d(V, { q: () => A });
            class A {
              constructor() {
                (this.elementInput = void 0),
                  (this.keyboard = void 0),
                  (this.mouse = void 0),
                  (this.touch = void 0),
                  (this.gamepads = void 0),
                  (this.scriptPrefix = void 0),
                  (this.assetPrefix = void 0),
                  (this.scriptsOrder = void 0),
                  (this.soundManager = void 0),
                  (this.graphicsDevice = void 0),
                  (this.lightmapper = void 0),
                  (this.batchManager = void 0),
                  (this.xr = void 0),
                  (this.componentSystems = []),
                  (this.resourceHandlers = []);
              }
            }
          },
          5616: (xe, V, a) => {
            "use strict";
            a.d(V, { l: () => Oe });
            var A = a(9222),
              x = a(3317),
              y = a(2378),
              c = a(9686),
              d = a(5833),
              h = a(7788),
              f = a(3042),
              s = a(4595),
              l = a(8974),
              n = a(4561),
              o = a(6029),
              i = a(392),
              e = a(6732),
              t = a(6686),
              r = a(6528),
              u = a(7436),
              v = a(1341),
              _ = a(5680),
              m = a(8441),
              g = a(5580),
              T = a(5080),
              E = a(1849),
              M = a(3756),
              R = a(8037),
              P = a(2281),
              F = a(5902),
              b = a(5003),
              D = a(4237),
              G = a(6862),
              X = a(9619),
              ie = a(3188),
              Q = a(8871),
              te = a(1552),
              ae = a(4060),
              Z = a(6348),
              J = a(2436),
              ve = a(792),
              _e = a(2629),
              L = a(3484),
              ge = a(6341),
              k = a(8363),
              j = a(1872),
              B = a(7369),
              $ = a(3037),
              le = a(2581),
              O = a(4230),
              Y = a(6153),
              ne = a(2200),
              de = a(2489),
              re = a(7367),
              I = a(8501),
              w = a(473),
              N = a(8774),
              W = a(1351),
              he = a(9319),
              ue = a(5676),
              ye = a(3205);
            class Oe extends h.v {
              constructor(ke, Ue = {}) {
                super(ke);
                const Ge = new f.q();
                (Ge.graphicsDevice = this.createDevice(ke, Ue)),
                  this.addComponentSystems(Ge),
                  this.addResourceHandles(Ge),
                  (Ge.elementInput = Ue.elementInput),
                  (Ge.keyboard = Ue.keyboard),
                  (Ge.mouse = Ue.mouse),
                  (Ge.touch = Ue.touch),
                  (Ge.gamepads = Ue.gamepads),
                  (Ge.scriptPrefix = Ue.scriptPrefix),
                  (Ge.assetPrefix = Ue.assetPrefix),
                  (Ge.scriptsOrder = Ue.scriptsOrder),
                  (Ge.soundManager = new y.x()),
                  (Ge.lightmapper = c.W),
                  (Ge.batchManager = d.Y),
                  (Ge.xr = ye.M),
                  this.init(Ge);
              }
              createDevice(ke, Ue) {
                return (
                  Ue.graphicsDeviceOptions || (Ue.graphicsDeviceOptions = {}),
                  A.i.browser &&
                    navigator.xr &&
                    (Ue.graphicsDeviceOptions.xrCompatible = !0),
                  (Ue.graphicsDeviceOptions.alpha =
                    Ue.graphicsDeviceOptions.alpha || !1),
                  new x.z(ke, Ue.graphicsDeviceOptions)
                );
              }
              addComponentSystems(ke) {
                ke.componentSystems = [
                  E.K1,
                  t.v,
                  u.X,
                  l.X,
                  n.k,
                  m.a,
                  T.J,
                  X.k,
                  ie.t,
                  s.K.legacy ? R.B : Q.k,
                  i.o,
                  b.m,
                  o.X,
                  g.s,
                  M.R,
                  r.B,
                  e.z,
                  P.D,
                  F.z,
                  D.Y,
                  _.K,
                  v.h,
                  G.b,
                ];
              }
              addResourceHandles(ke) {
                ke.resourceHandlers = [
                  te.H,
                  ae.T,
                  Z.e,
                  J.r,
                  ne.s,
                  Y.U,
                  ue.y,
                  W.O,
                  O.F,
                  ve.z,
                  re.S,
                  de.f,
                  k.s,
                  le.g,
                  ge.C,
                  I.e,
                  $.u,
                  j.p,
                  B.q,
                  _e._,
                  he.P,
                  w.Q,
                  N.R,
                  L.a,
                ];
              }
            }
          },
          5853: (xe, V, a) => {
            "use strict";
            a.d(V, { w: () => y });
            var A = a(8976),
              x = a(3953);
            class y extends A.J {
              constructor(d) {
                super(),
                  (this._app = d),
                  d.i18n.on("set:locale", this._onSetLocale, this),
                  (this._autoLoad = !1),
                  (this._disableLocalization = !1),
                  (this._defaultAsset = null),
                  (this._localizedAsset = null);
              }
              set defaultAsset(d) {
                const h = d instanceof x.V ? d.id : d;
                this._defaultAsset !== h &&
                  (this._defaultAsset && this._unbindDefaultAsset(),
                  (this._defaultAsset = h),
                  this._defaultAsset && this._bindDefaultAsset(),
                  this._onSetLocale(this._app.i18n.locale));
              }
              get defaultAsset() {
                return this._defaultAsset;
              }
              set localizedAsset(d) {
                const h = d instanceof x.V ? d.id : d;
                this._localizedAsset !== h &&
                  (this._localizedAsset &&
                    (this._app.assets.off(
                      "add:" + this._localizedAsset,
                      this._onLocalizedAssetAdd,
                      this
                    ),
                    this._unbindLocalizedAsset(),
                    (this._localizedAsset = null)),
                  (this._localizedAsset = h),
                  this._localizedAsset &&
                    (this._app.assets.get(this._localizedAsset)
                      ? this._bindLocalizedAsset()
                      : this._app.assets.once(
                          "add:" + this._localizedAsset,
                          this._onLocalizedAssetAdd,
                          this
                        )));
              }
              get localizedAsset() {
                return this._localizedAsset;
              }
              set autoLoad(d) {
                this._autoLoad !== d &&
                  ((this._autoLoad = d),
                  this._autoLoad &&
                    this._localizedAsset &&
                    (this._unbindLocalizedAsset(), this._bindLocalizedAsset()));
              }
              get autoLoad() {
                return this._autoLoad;
              }
              set disableLocalization(d) {
                this._disableLocalization !== d &&
                  ((this._disableLocalization = d),
                  this._onSetLocale(this._app.i18n.locale));
              }
              get disableLocalization() {
                return this._disableLocalization;
              }
              _bindDefaultAsset() {
                const d = this._app.assets.get(this._defaultAsset);
                d
                  ? this._onDefaultAssetAdd(d)
                  : this._app.assets.once(
                      "add:" + this._defaultAsset,
                      this._onDefaultAssetAdd,
                      this
                    );
              }
              _unbindDefaultAsset() {
                if (!this._defaultAsset) return;
                this._app.assets.off(
                  "add:" + this._defaultAsset,
                  this._onDefaultAssetAdd,
                  this
                );
                const d = this._app.assets.get(this._defaultAsset);
                d &&
                  (d.off("add:localized", this._onLocaleAdd, this),
                  d.off("remove:localized", this._onLocaleRemove, this),
                  d.off("remove", this._onDefaultAssetRemove, this));
              }
              _onDefaultAssetAdd(d) {
                this._defaultAsset === d.id &&
                  (d.on("add:localized", this._onLocaleAdd, this),
                  d.on("remove:localized", this._onLocaleRemove, this),
                  d.once("remove", this._onDefaultAssetRemove, this));
              }
              _onDefaultAssetRemove(d) {
                this._defaultAsset === d.id &&
                  (d.off("add:localized", this._onLocaleAdd, this),
                  d.off("remove:localized", this._onLocaleAdd, this),
                  this._app.assets.once(
                    "add:" + this._defaultAsset,
                    this._onDefaultAssetAdd,
                    this
                  ));
              }
              _bindLocalizedAsset() {
                if (!this._autoLoad) return;
                const d = this._app.assets.get(this._localizedAsset);
                d &&
                  (d.on("load", this._onLocalizedAssetLoad, this),
                  d.on("change", this._onLocalizedAssetChange, this),
                  d.on("remove", this._onLocalizedAssetRemove, this),
                  d.resource
                    ? this._onLocalizedAssetLoad(d)
                    : this._app.assets.load(d));
              }
              _unbindLocalizedAsset() {
                const d = this._app.assets.get(this._localizedAsset);
                d &&
                  (d.off("load", this._onLocalizedAssetLoad, this),
                  d.off("change", this._onLocalizedAssetChange, this),
                  d.off("remove", this._onLocalizedAssetRemove, this));
              }
              _onLocalizedAssetAdd(d) {
                this._localizedAsset === d.id && this._bindLocalizedAsset();
              }
              _onLocalizedAssetLoad(d) {
                this.fire("load", d);
              }
              _onLocalizedAssetChange(d, h, f, s) {
                this.fire("change", d, h, f, s);
              }
              _onLocalizedAssetRemove(d) {
                this._localizedAsset === d.id &&
                  (this.localizedAsset = this._defaultAsset),
                  this.fire("remove", d);
              }
              _onLocaleAdd(d, h) {
                this._app.i18n.locale === d && this._onSetLocale(d);
              }
              _onLocaleRemove(d, h) {
                this._app.i18n.locale === d && this._onSetLocale(d);
              }
              _onSetLocale(d) {
                if (!this._defaultAsset) {
                  this.localizedAsset = null;
                  return;
                }
                const h = this._app.assets.get(this._defaultAsset);
                if (!h || this._disableLocalization) {
                  this.localizedAsset = this._defaultAsset;
                  return;
                }
                const f = h.getLocalizedAssetId(d);
                if (!f) {
                  this.localizedAsset = this._defaultAsset;
                  return;
                }
                this.localizedAsset = f;
              }
              destroy() {
                (this.defaultAsset = null),
                  this._app.i18n.off("set:locale", this._onSetLocale, this),
                  this.off();
              }
            }
          },
          3029: (xe, V, a) => {
            "use strict";
            a.d(V, { Y: () => A });
            class A {
              constructor(y, c, d, h, f) {
                (this.propertyName = y),
                  (this.parent = c),
                  (this._scope = f),
                  (this._registry = d),
                  (this.id = null),
                  (this.url = null),
                  (this.asset = null),
                  (this._onAssetLoad = h.load),
                  (this._onAssetAdd = h.add),
                  (this._onAssetRemove = h.remove),
                  (this._onAssetUnload = h.unload);
              }
              set id(y) {
                if (this.url) throw Error("Can't set id and url");
                this._unbind(),
                  (this._id = y),
                  (this.asset = this._registry.get(this._id)),
                  this._bind();
              }
              get id() {
                return this._id;
              }
              set url(y) {
                if (this.id) throw Error("Can't set id and url");
                this._unbind(),
                  (this._url = y),
                  (this.asset = this._registry.getByUrl(this._url)),
                  this._bind();
              }
              get url() {
                return this._url;
              }
              _bind() {
                this.id &&
                  (this._onAssetLoad &&
                    this._registry.on("load:" + this.id, this._onLoad, this),
                  this._onAssetAdd &&
                    this._registry.once("add:" + this.id, this._onAdd, this),
                  this._onAssetRemove &&
                    this._registry.on(
                      "remove:" + this.id,
                      this._onRemove,
                      this
                    ),
                  this._onAssetUnload &&
                    this._registry.on(
                      "unload:" + this.id,
                      this._onUnload,
                      this
                    )),
                  this.url &&
                    (this._onAssetLoad &&
                      this._registry.on(
                        "load:url:" + this.url,
                        this._onLoad,
                        this
                      ),
                    this._onAssetAdd &&
                      this._registry.once(
                        "add:url:" + this.url,
                        this._onAdd,
                        this
                      ),
                    this._onAssetRemove &&
                      this._registry.on(
                        "remove:url:" + this.url,
                        this._onRemove,
                        this
                      ));
              }
              _unbind() {
                this.id &&
                  (this._onAssetLoad &&
                    this._registry.off("load:" + this.id, this._onLoad, this),
                  this._onAssetAdd &&
                    this._registry.off("add:" + this.id, this._onAdd, this),
                  this._onAssetRemove &&
                    this._registry.off(
                      "remove:" + this.id,
                      this._onRemove,
                      this
                    ),
                  this._onAssetUnload &&
                    this._registry.off(
                      "unload:" + this.id,
                      this._onUnload,
                      this
                    )),
                  this.url &&
                    (this._onAssetLoad &&
                      this._registry.off(
                        "load:" + this.url,
                        this._onLoad,
                        this
                      ),
                    this._onAssetAdd &&
                      this._registry.off("add:" + this.url, this._onAdd, this),
                    this._onAssetRemove &&
                      this._registry.off(
                        "remove:" + this.url,
                        this._onRemove,
                        this
                      ));
              }
              _onLoad(y) {
                this._onAssetLoad.call(
                  this._scope,
                  this.propertyName,
                  this.parent,
                  y
                );
              }
              _onAdd(y) {
                (this.asset = y),
                  this._onAssetAdd.call(
                    this._scope,
                    this.propertyName,
                    this.parent,
                    y
                  );
              }
              _onRemove(y) {
                this._onAssetRemove.call(
                  this._scope,
                  this.propertyName,
                  this.parent,
                  y
                ),
                  (this.asset = null);
              }
              _onUnload(y) {
                this._onAssetUnload.call(
                  this._scope,
                  this.propertyName,
                  this.parent,
                  y
                );
              }
            }
          },
          0: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => f });
            var A = a(1870),
              x = a(8976);
            class y {
              constructor(l = null) {
                (this._index = {}), (this._key = void 0), (this._key = l);
              }
              addItem(l) {
                const n = l.tags._list;
                for (const o of n) this.add(o, l);
              }
              removeItem(l) {
                const n = l.tags._list;
                for (const o of n) this.remove(o, l);
              }
              add(l, n) {
                (this._index[l] && this._index[l].list.indexOf(n) !== -1) ||
                  (this._index[l] ||
                    ((this._index[l] = { list: [] }),
                    this._key && (this._index[l].keys = {})),
                  this._index[l].list.push(n),
                  this._key && (this._index[l].keys[n[this._key]] = n));
              }
              remove(l, n) {
                if (
                  !this._index[l] ||
                  (this._key && !this._index[l].keys[n[this._key]])
                )
                  return;
                const o = this._index[l].list.indexOf(n);
                o !== -1 &&
                  (this._index[l].list.splice(o, 1),
                  this._key && delete this._index[l].keys[n[this._key]],
                  this._index[l].list.length === 0 && delete this._index[l]);
              }
              find(l) {
                const n = {},
                  o = [];
                let i, e, t, r, u;
                const v = (_, m) =>
                  this._index[_].list.length - this._index[m].list.length;
                for (let _ = 0; _ < l.length; _++) {
                  if (((e = l[_]), e instanceof Array)) {
                    if (e.length === 0) continue;
                    if (e.length === 1) e = e[0];
                    else {
                      u = !1;
                      for (let m = 0; m < e.length; m++)
                        if (!this._index[e[m]]) {
                          u = !0;
                          break;
                        }
                      if (u) continue;
                      (t = e.slice(0).sort(v)),
                        (r = t.slice(1)),
                        r.length === 1 && (r = r[0]);
                      for (let m = 0; m < this._index[t[0]].list.length; m++)
                        (i = this._index[t[0]].list[m]),
                          (this._key
                            ? !n[i[this._key]]
                            : o.indexOf(i) === -1) &&
                            i.tags.has(r) &&
                            (this._key && (n[i[this._key]] = !0), o.push(i));
                      continue;
                    }
                  }
                  if (e && typeof e == "string" && this._index[e])
                    for (let m = 0; m < this._index[e].list.length; m++)
                      (i = this._index[e].list[m]),
                        this._key
                          ? n[i[this._key]] ||
                            ((n[i[this._key]] = !0), o.push(i))
                          : o.indexOf(i) === -1 && o.push(i);
                }
                return o;
              }
            }
            var c = a(6679),
              d = a(4595),
              h = a(3953);
            class f extends x.J {
              constructor(l) {
                super(),
                  (this._assets = new Set()),
                  (this._idToAsset = new Map()),
                  (this._urlToAsset = new Map()),
                  (this._nameToAsset = new Map()),
                  (this._tags = new y("_id")),
                  (this.prefix = null),
                  (this._loader = l);
              }
              list(l = {}) {
                const n = Array.from(this._assets);
                return l.preload !== void 0
                  ? n.filter((o) => o.preload === l.preload)
                  : n;
              }
              add(l) {
                var n, o;
                this._assets.has(l) ||
                  (this._assets.add(l),
                  this._idToAsset.set(l.id, l),
                  (n = l.file) != null &&
                    n.url &&
                    this._urlToAsset.set(l.file.url, l),
                  this._nameToAsset.has(l.name) ||
                    this._nameToAsset.set(l.name, new Set()),
                  this._nameToAsset.get(l.name).add(l),
                  l.on("name", this._onNameChange, this),
                  (l.registry = this),
                  this._tags.addItem(l),
                  l.tags.on("add", this._onTagAdd, this),
                  l.tags.on("remove", this._onTagRemove, this),
                  this.fire("add", l),
                  this.fire("add:" + l.id, l),
                  (o = l.file) != null &&
                    o.url &&
                    this.fire("add:url:" + l.file.url, l),
                  l.preload && this.load(l));
              }
              remove(l) {
                var n, o;
                if (!this._assets.has(l)) return !1;
                if (
                  (this._assets.delete(l),
                  this._idToAsset.delete(l.id),
                  (n = l.file) != null &&
                    n.url &&
                    this._urlToAsset.delete(l.file.url),
                  l.off("name", this._onNameChange, this),
                  this._nameToAsset.has(l.name))
                ) {
                  const i = this._nameToAsset.get(l.name);
                  i.delete(l), i.size === 0 && this._nameToAsset.delete(l.name);
                }
                return (
                  this._tags.removeItem(l),
                  l.tags.off("add", this._onTagAdd, this),
                  l.tags.off("remove", this._onTagRemove, this),
                  l.fire("remove", l),
                  this.fire("remove", l),
                  this.fire("remove:" + l.id, l),
                  (o = l.file) != null &&
                    o.url &&
                    this.fire("remove:url:" + l.file.url, l),
                  !0
                );
              }
              get(l) {
                return this._idToAsset.get(Number(l));
              }
              getByUrl(l) {
                return this._urlToAsset.get(l);
              }
              load(l) {
                if (l.loading || l.loaded) return;
                const n = l.file,
                  o = (e) => {
                    e instanceof Array ? (l.resources = e) : (l.resource = e),
                      this._loader.patch(l, this),
                      this.fire("load", l),
                      this.fire("load:" + l.id, l),
                      n && n.url && this.fire("load:url:" + n.url, l),
                      l.fire("load", l);
                  },
                  i = (e, t, r) => {
                    if (((l.loaded = !0), (l.loading = !1), e))
                      this.fire("error", e, l),
                        this.fire("error:" + l.id, e, l),
                        l.fire("error", e, l);
                    else {
                      if (!d.K.legacy && l.type === "script") {
                        const u = this._loader.getHandler("script");
                        u._cache[l.id] &&
                          u._cache[l.id].parentNode === document.head &&
                          document.head.removeChild(u._cache[l.id]),
                          (u._cache[l.id] = r);
                      }
                      o(t);
                    }
                  };
                if (n || l.type === "cubemap")
                  this.fire("load:start", l),
                    this.fire("load:" + l.id + ":start", l),
                    (l.loading = !0),
                    this._loader.load(l.getFileUrl(), l.type, i, l);
                else {
                  const e = this._loader.open(l.type, l.data);
                  (l.loaded = !0), o(e);
                }
              }
              loadFromUrl(l, n, o) {
                this.loadFromUrlAndFilename(l, null, n, o);
              }
              loadFromUrlAndFilename(l, n, o, i) {
                const e = A.A.getBasename(n || l),
                  t = { filename: n || e, url: l };
                let r = this.getByUrl(l);
                if (!r) (r = new h.V(e, o, t)), this.add(r);
                else if (r.loaded) {
                  i(r.loadFromUrlError || null, r);
                  return;
                }
                const u = (v) => {
                  v.once("load", (_) => {
                    o === "material"
                      ? this._loadTextures(_, (m, g) => {
                          i(m, _);
                        })
                      : i(null, _);
                  }),
                    v.once("error", (_) => {
                      _ && (this.loadFromUrlError = _), i(_, v);
                    }),
                    this.load(v);
                };
                r.resource
                  ? i(null, r)
                  : o === "model"
                  ? this._loadModel(r, u)
                  : u(r);
              }
              _loadModel(l, n) {
                const o = l.getFileUrl(),
                  i = A.A.getExtension(o);
                if (i === ".json" || i === ".glb") {
                  const e = A.A.getDirectory(o),
                    t = A.A.getBasename(o),
                    r = A.A.join(e, t.replace(i, ".mapping.json"));
                  this._loader.load(r, "json", (u, v) => {
                    u
                      ? ((l.data = { mapping: [] }), n(l))
                      : this._loadMaterials(l, v, (_, m) => {
                          (l.data = v), n(l);
                        });
                  });
                } else n(l);
              }
              _loadMaterials(l, n, o) {
                const i = [];
                let e = 0;
                const t = (r, u) => {
                  this._loadTextures(u, (v, _) => {
                    i.push(u), i.length === e && o(null, i);
                  });
                };
                for (let r = 0; r < n.mapping.length; r++) {
                  const u = n.mapping[r].path;
                  if (u) {
                    e++;
                    const v = l.getAbsoluteUrl(u);
                    this.loadFromUrl(v, "material", t);
                  }
                }
                e === 0 && o(null, i);
              }
              _loadTextures(l, n) {
                const o = [];
                let i = 0;
                const e = l.data;
                if (e.mappingFormat !== "path") {
                  n(null, o);
                  return;
                }
                const t = (u, v) => {
                    u && console.error(u),
                      o.push(v),
                      o.length === i && n(null, o);
                  },
                  r = c.Gc;
                for (let u = 0; u < r.length; u++) {
                  const v = e[r[u]];
                  if (v && typeof v == "string") {
                    i++;
                    const _ = l.getAbsoluteUrl(v);
                    this.loadFromUrl(_, "texture", t);
                  }
                }
                i === 0 && n(null, o);
              }
              _onTagAdd(l, n) {
                this._tags.add(l, n);
              }
              _onTagRemove(l, n) {
                this._tags.remove(l, n);
              }
              _onNameChange(l, n, o) {
                if (this._nameToAsset.has(o)) {
                  const i = this._nameToAsset.get(o);
                  i.delete(l), i.size === 0 && this._nameToAsset.delete(o);
                }
                this._nameToAsset.has(l.name) ||
                  this._nameToAsset.set(l.name, new Set()),
                  this._nameToAsset.get(l.name).add(l);
              }
              findByTag() {
                return this._tags.find(arguments);
              }
              filter(l) {
                return Array.from(this._assets).filter((n) => l(n));
              }
              find(l, n) {
                const o = this._nameToAsset.get(l);
                if (!o) return null;
                for (const i of o) if (!n || i.type === n) return i;
                return null;
              }
              findAll(l, n) {
                const o = this._nameToAsset.get(l);
                if (!o) return [];
                const i = Array.from(o);
                return n ? i.filter((e) => e.type === n) : i;
              }
            }
          },
          3953: (xe, V, a) => {
            "use strict";
            a.d(V, { V: () => i });
            var A = a(1870),
              x = a(244),
              y = a(8976),
              c = a(8866),
              d = a(148);
            class h {
              constructor(
                t = "",
                r = "",
                u = null,
                v = null,
                _ = null,
                m = null
              ) {
                (this.url = t),
                  (this.filename = r),
                  (this.hash = u),
                  (this.size = v),
                  (this.opt = _),
                  (this.contents = m);
              }
              equals(t) {
                return (
                  this.url === t.url &&
                  this.filename === t.filename &&
                  this.hash === t.hash &&
                  this.size === t.size &&
                  this.opt === t.opt &&
                  this.contents === t.contents
                );
              }
            }
            var f = a(4530),
              s = a(8633);
            let l = -1;
            const n = {
                pvr: "extCompressedTexturePVRTC",
                dxt: "extCompressedTextureS3TC",
                etc2: "extCompressedTextureETC",
                etc1: "extCompressedTextureETC1",
                basis: "canvas",
              },
              o = ["pvr", "dxt", "etc2", "etc1", "basis"];
            class i extends y.J {
              constructor(t, r, u, v, _) {
                super(),
                  (this._id = l--),
                  (this._name = t || ""),
                  (this.type = r),
                  (this.tags = new x.Y(this)),
                  (this._preload = !1),
                  (this._file = null),
                  (this._data = v || {}),
                  (this.options = _ || {}),
                  (this._resources = []),
                  (this._i18n = {}),
                  (this.loaded = !1),
                  (this.loading = !1),
                  (this.registry = null),
                  u && (this.file = u);
              }
              set id(t) {
                this._id = t;
              }
              get id() {
                return this._id;
              }
              set name(t) {
                if (this._name === t) return;
                const r = this._name;
                (this._name = t), this.fire("name", this, this._name, r);
              }
              get name() {
                return this._name;
              }
              set file(t) {
                if (
                  t &&
                  t.variants &&
                  ["texture", "textureatlas", "bundle"].indexOf(this.type) !==
                    -1
                ) {
                  var r;
                  const _ =
                      ((r = this.registry) == null || (r = r._loader) == null
                        ? void 0
                        : r._app) || (0, f.D)(),
                    m = _ == null ? void 0 : _.graphicsDevice;
                  if (m)
                    for (let g = 0, T = o.length; g < T; g++) {
                      const E = o[g];
                      if (t.variants[E] && m[n[E]]) {
                        t = t.variants[E];
                        break;
                      }
                      if (_.enableBundles) {
                        const M = _.bundles.listBundlesForAsset(this);
                        if (
                          M &&
                          M.find((R) => {
                            var P;
                            return R == null || (P = R.file) == null
                              ? void 0
                              : P.variants[E];
                          })
                        )
                          break;
                      }
                    }
                }
                const u = this._file,
                  v = t
                    ? new h(
                        t.url,
                        t.filename,
                        t.hash,
                        t.size,
                        t.opt,
                        t.contents
                      )
                    : null;
                (!!v != !!u || (v && !v.equals(u))) &&
                  ((this._file = v),
                  this.fire("change", this, "file", v, u),
                  this.reload());
              }
              get file() {
                return this._file;
              }
              set data(t) {
                const r = this._data;
                (this._data = t),
                  t !== r &&
                    (this.fire("change", this, "data", t, r),
                    this.loaded &&
                      this.registry._loader.patch(this, this.registry));
              }
              get data() {
                return this._data;
              }
              set resource(t) {
                const r = this._resources[0];
                (this._resources[0] = t),
                  this.fire("change", this, "resource", t, r);
              }
              get resource() {
                return this._resources[0];
              }
              set resources(t) {
                const r = this._resources;
                (this._resources = t),
                  this.fire("change", this, "resources", t, r);
              }
              get resources() {
                return this._resources;
              }
              set preload(t) {
                (t = !!t),
                  this._preload !== t &&
                    ((this._preload = t),
                    this._preload &&
                      !this.loaded &&
                      !this.loading &&
                      this.registry &&
                      this.registry.load(this));
              }
              get preload() {
                return this._preload;
              }
              set loadFaces(t) {
                (t = !!t),
                  (!this.hasOwnProperty("_loadFaces") ||
                    t !== this._loadFaces) &&
                    ((this._loadFaces = t),
                    this.loaded &&
                      this.registry._loader.patch(this, this.registry));
              }
              get loadFaces() {
                return this._loadFaces;
              }
              getFileUrl() {
                const t = this.file;
                if (!t || !t.url) return null;
                let r = t.url;
                if (
                  (this.registry &&
                    this.registry.prefix &&
                    !d._3.test(r) &&
                    (r = this.registry.prefix + r),
                  this.type !== "script" && t.hash)
                ) {
                  const u = r.indexOf("?") !== -1 ? "&" : "?";
                  r += u + "t=" + t.hash;
                }
                return r;
              }
              getAbsoluteUrl(t) {
                if (t.startsWith("blob:") || t.startsWith("data:")) return t;
                const r = A.A.getDirectory(this.file.url);
                return A.A.join(r, t);
              }
              getLocalizedAssetId(t) {
                return (t = (0, c.Tw)(t, this._i18n)), this._i18n[t] || null;
              }
              addLocalizedAssetId(t, r) {
                (this._i18n[t] = r), this.fire("add:localized", t, r);
              }
              removeLocalizedAssetId(t) {
                const r = this._i18n[t];
                r &&
                  (delete this._i18n[t], this.fire("remove:localized", t, r));
              }
              ready(t, r) {
                (r = r || this),
                  this.loaded
                    ? t.call(r, this)
                    : this.once("load", function (u) {
                        t.call(r, u);
                      });
              }
              reload() {
                this.loaded && ((this.loaded = !1), this.registry.load(this));
              }
              unload() {
                if (!this.loaded && this._resources.length === 0) return;
                this.fire("unload", this),
                  this.registry.fire("unload:" + this.id, this);
                const t = this._resources;
                (this.resources = []),
                  (this.loaded = !1),
                  this.file &&
                    this.registry._loader.clearCache(
                      this.getFileUrl(),
                      this.type
                    );
                for (let r = 0; r < t.length; ++r) {
                  const u = t[r];
                  u && u.destroy && u.destroy();
                }
              }
              static fetchArrayBuffer(t, r, u, v = 0) {
                var _;
                u != null && (_ = u.file) != null && _.contents
                  ? setTimeout(() => {
                      r(null, u.file.contents);
                    })
                  : s.L.get(
                      t,
                      {
                        cache: !0,
                        responseType: "arraybuffer",
                        retry: v > 0,
                        maxRetries: v,
                      },
                      r
                    );
              }
            }
          },
          148: (xe, V, a) => {
            "use strict";
            a.d(V, {
              Js: () => f,
              Jw: () => o,
              Mc: () => n,
              Nd: () => u,
              Ps: () => l,
              Rx: () => r,
              St: () => x,
              _3: () => A,
              _z: () => d,
              bN: () => t,
              c4: () => y,
              fA: () => s,
              fX: () => c,
              jS: () => e,
              nD: () => h,
              rX: () => i,
            });
            const A = new RegExp(
                "^\\s*(?:(?:[a-z]+[a-z0-9\\-\\+\\.]*:)?//|data:|blob:)",
                "i"
              ),
              x = "animation",
              y = "audio",
              c = "image",
              d = "json",
              h = "model",
              f = "material",
              s = "text",
              l = "texture",
              n = "textureatlas",
              o = "cubemap",
              i = "shader",
              e = "css",
              t = "html",
              r = "script",
              u = "container";
          },
          5691: (xe, V, a) => {
            "use strict";
            a.d(V, { a: () => A });
            class A {
              constructor(y) {
                (this._assets = y),
                  (this._bundleAssets = {}),
                  (this._assetsInBundles = {}),
                  (this._urlsInBundles = {}),
                  (this._fileRequests = {}),
                  this._assets.on("add", this._onAssetAdded, this),
                  this._assets.on("remove", this._onAssetRemoved, this);
              }
              _onAssetAdded(y) {
                if (y.type === "bundle") {
                  (this._bundleAssets[y.id] = y),
                    this._registerBundleEventListeners(y.id);
                  for (let c = 0, d = y.data.assets.length; c < d; c++)
                    this._indexAssetInBundle(y.data.assets[c], y);
                } else
                  this._assetsInBundles[y.id] && this._indexAssetFileUrls(y);
              }
              _registerBundleEventListeners(y) {
                this._assets.on("load:" + y, this._onBundleLoaded, this),
                  this._assets.on("error:" + y, this._onBundleError, this);
              }
              _unregisterBundleEventListeners(y) {
                this._assets.off("load:" + y, this._onBundleLoaded, this),
                  this._assets.off("error:" + y, this._onBundleError, this);
              }
              _indexAssetInBundle(y, c) {
                if (!this._assetsInBundles[y]) this._assetsInBundles[y] = [c];
                else {
                  const h = this._assetsInBundles[y];
                  h.indexOf(c) === -1 && h.push(c);
                }
                const d = this._assets.get(y);
                d && this._indexAssetFileUrls(d);
              }
              _indexAssetFileUrls(y) {
                const c = this._getAssetFileUrls(y);
                if (c)
                  for (let d = 0, h = c.length; d < h; d++) {
                    const f = c[d];
                    this._urlsInBundles[f] = this._assetsInBundles[y.id];
                  }
              }
              _getAssetFileUrls(y) {
                let c = y.getFileUrl();
                if (!c) return null;
                c = this._normalizeUrl(c);
                const d = [c];
                if (y.type === "font") {
                  const h = y.data.info.maps.length;
                  for (let f = 1; f < h; f++)
                    d.push(c.replace(".png", f + ".png"));
                }
                return d;
              }
              _normalizeUrl(y) {
                return y && y.split("?")[0];
              }
              _onAssetRemoved(y) {
                if (y.type === "bundle") {
                  delete this._bundleAssets[y.id],
                    this._unregisterBundleEventListeners(y.id);
                  for (const c in this._assetsInBundles) {
                    const d = this._assetsInBundles[c],
                      h = d.indexOf(y);
                    if (h !== -1 && (d.splice(h, 1), !d.length)) {
                      delete this._assetsInBundles[c];
                      for (const f in this._urlsInBundles)
                        this._urlsInBundles[f] === d &&
                          delete this._urlsInBundles[f];
                    }
                  }
                  this._onBundleError(`Bundle ${y.id} was removed`, y);
                } else if (this._assetsInBundles[y.id]) {
                  delete this._assetsInBundles[y.id];
                  const c = this._getAssetFileUrls(y);
                  for (let d = 0, h = c.length; d < h; d++)
                    delete this._urlsInBundles[c[d]];
                }
              }
              _onBundleLoaded(y) {
                if (!y.resource) {
                  this._onBundleError(`Bundle ${y.id} failed to load`, y);
                  return;
                }
                requestAnimationFrame(() => {
                  if (this._fileRequests)
                    for (const c in this._fileRequests) {
                      const d = this._urlsInBundles[c];
                      if (!d || d.indexOf(y) === -1) continue;
                      const h = decodeURIComponent(c);
                      let f = null;
                      y.resource.hasBlobUrl(h) ||
                        (f = `Bundle ${y.id} does not contain URL ${c}`);
                      const s = this._fileRequests[c];
                      for (let l = 0, n = s.length; l < n; l++)
                        f ? s[l](f) : s[l](null, y.resource.getBlobUrl(h));
                      delete this._fileRequests[c];
                    }
                });
              }
              _onBundleError(y, c) {
                for (const d in this._fileRequests)
                  if (!this._findLoadedOrLoadingBundleForUrl(d)) {
                    const f = this._fileRequests[d];
                    for (let s = 0, l = f.length; s < l; s++) f[s](y);
                    delete this._fileRequests[d];
                  }
              }
              _findLoadedOrLoadingBundleForUrl(y) {
                const c = this._urlsInBundles[y];
                if (!c) return null;
                const d = c.length;
                for (let h = 0; h < d; h++)
                  if (c[h].loaded && c[h].resource) return c[h];
                for (let h = 0; h < d; h++) if (c[h].loading) return c[h];
                return null;
              }
              listBundlesForAsset(y) {
                return this._assetsInBundles[y.id] || null;
              }
              list() {
                const y = [];
                for (const c in this._bundleAssets)
                  y.push(this._bundleAssets[c]);
                return y;
              }
              hasUrl(y) {
                return !!this._urlsInBundles[y];
              }
              canLoadUrl(y) {
                return !!this._findLoadedOrLoadingBundleForUrl(y);
              }
              loadUrl(y, c) {
                const d = this._findLoadedOrLoadingBundleForUrl(y);
                if (!d) {
                  c(`URL ${y} not found in any bundles`);
                  return;
                }
                if (d.loaded) {
                  const h = decodeURIComponent(y);
                  if (!d.resource.hasBlobUrl(h)) {
                    c(`Bundle ${d.id} does not contain URL ${y}`);
                    return;
                  }
                  c(null, d.resource.getBlobUrl(h));
                } else
                  this._fileRequests.hasOwnProperty(y)
                    ? this._fileRequests[y].push(c)
                    : (this._fileRequests[y] = [c]);
              }
              destroy() {
                this._assets.off("add", this._onAssetAdded, this),
                  this._assets.off("remove", this._onAssetRemoved, this);
                for (const y in this._bundleAssets)
                  this._unregisterBundleEventListeners(y);
                (this._assets = null),
                  (this._bundleAssets = null),
                  (this._assetsInBundles = null),
                  (this._urlsInBundles = null),
                  (this._fileRequests = null);
              }
            }
          },
          3259: (xe, V, a) => {
            "use strict";
            a.d(V, { N: () => A });
            class A {
              constructor(y) {
                this._blobUrls = {};
                for (let c = 0, d = y.length; c < d; c++)
                  y[c].url && (this._blobUrls[y[c].name] = y[c].url);
              }
              hasBlobUrl(y) {
                return !!this._blobUrls[y];
              }
              getBlobUrl(y) {
                return this._blobUrls[y];
              }
              destroy() {
                for (const y in this._blobUrls)
                  URL.revokeObjectURL(this._blobUrls[y]);
                this._blobUrls = null;
              }
            }
          },
          7358: (xe, V, a) => {
            "use strict";
            a.d(V, { E: () => d });
            var A = a(8656),
              x = a(9645),
              y = a(5828),
              c = a(4474);
            class d {
              constructor(f, s, l, n = 1, o = c.eU, i = !0) {
                (this._name = f),
                  (this._controller = s),
                  (this._component = l),
                  (this._weight = n),
                  (this._blendType = o),
                  (this._normalizedWeight = i),
                  (this._mask = null),
                  (this._blendTime = 0),
                  (this._blendTimeElapsed = 0),
                  (this._startingWeight = 0),
                  (this._targetWeight = 0);
              }
              get name() {
                return this._name;
              }
              set playing(f) {
                this._controller.playing = f;
              }
              get playing() {
                return this._controller.playing;
              }
              get playable() {
                return this._controller.playable;
              }
              get activeState() {
                return this._controller.activeStateName;
              }
              get previousState() {
                return this._controller.previousStateName;
              }
              get activeStateProgress() {
                return this._controller.activeStateProgress;
              }
              get activeStateDuration() {
                return this._controller.activeStateDuration;
              }
              set activeStateCurrentTime(f) {
                const s = this._controller,
                  l = s.playing;
                (s.playing = !0),
                  (s.activeStateCurrentTime = f),
                  l || s.update(0),
                  (s.playing = l);
              }
              get activeStateCurrentTime() {
                return this._controller.activeStateCurrentTime;
              }
              get transitioning() {
                return this._controller.transitioning;
              }
              get transitionProgress() {
                return this.transitioning
                  ? this._controller.transitionProgress
                  : null;
              }
              get states() {
                return this._controller.states;
              }
              set weight(f) {
                (this._weight = f), this._component.dirtifyTargets();
              }
              get weight() {
                return this._weight;
              }
              set blendType(f) {
                f !== this._blendType &&
                  ((this._blendType = f),
                  this._controller.normalizeWeights &&
                    this._component.rebind());
              }
              get blendType() {
                return this._blendType;
              }
              set mask(f) {
                this._controller.assignMask(f) && this._component.rebind(),
                  (this._mask = f);
              }
              get mask() {
                return this._mask;
              }
              play(f) {
                this._controller.play(f);
              }
              pause() {
                this._controller.pause();
              }
              reset() {
                this._controller.reset();
              }
              rebind() {
                this._controller.rebind();
              }
              update(f) {
                this._blendTime &&
                  (this._blendTimeElapsed < this._blendTime
                    ? ((this.weight = A.D.lerp(
                        this._startingWeight,
                        this._targetWeight,
                        this._blendTimeElapsed / this._blendTime
                      )),
                      (this._blendTimeElapsed += f))
                    : ((this.weight = this._targetWeight),
                      (this._blendTime = 0),
                      (this._blendTimeElapsed = 0),
                      (this._startingWeight = 0),
                      (this._targetWeight = 0))),
                  this._controller.update(f);
              }
              blendToWeight(f, s) {
                (this._startingWeight = this.weight),
                  (this._targetWeight = f),
                  (this._blendTime = Math.max(0, s)),
                  (this._blendTimeElapsed = 0);
              }
              assignMask(f) {
                this._controller.assignMask(f) && this._component.rebind(),
                  (this._mask = f);
              }
              assignAnimation(f, s, l, n) {
                s instanceof x.z &&
                  (this._controller.assignAnimation(f, s, l, n),
                  this._controller._transitions.length === 0 &&
                    this._controller._transitions.push(
                      new y.R({ from: "START", to: f })
                    ),
                  this._component.activate &&
                    this._component.playable &&
                    (this._component.playing = !0));
              }
              removeNodeAnimations(f) {
                this._controller.removeNodeAnimations(f) &&
                  (this._component.playing = !1);
              }
              getAnimationAsset(f) {
                return this._component.animationAssets[`${this.name}:${f}`];
              }
              transition(f, s = 0, l = null) {
                this._controller.updateStateFromTransition(
                  new y.R({
                    from: this._controller.activeStateName,
                    to: f,
                    time: s,
                    transitionOffset: l,
                  })
                );
              }
            }
          },
          5695: (xe, V, a) => {
            "use strict";
            a.d(V, { H: () => P });
            var A = a(4751),
              x = a(3953),
              y = a(7433),
              c = a(2414),
              d = a(4124),
              h = a(4474),
              f = a(8265),
              s = a(7747),
              l = a(8635),
              n = a(5227),
              o = a(3021),
              i = a(7994),
              e = a(7481),
              t = a(5596);
            const r = new i.Z(),
              u = new e.e(),
              v = new t.Z(),
              _ = new n.Q(),
              m = new o.k();
            class g extends s.x {
              constructor(b, D, G, X, ie) {
                super(D),
                  (this.animComponent = b),
                  (this._mask = X),
                  (this.layerName = G),
                  (this.layerIndex = ie);
              }
              static _packFloat(b) {
                return b[0];
              }
              static _packBoolean(b) {
                return !!b[0];
              }
              static _packVec2(b) {
                return (r.x = b[0]), (r.y = b[1]), r;
              }
              static _packVec3(b) {
                return (u.x = b[0]), (u.y = b[1]), (u.z = b[2]), u;
              }
              static _packVec4(b) {
                return (
                  (v.x = b[0]), (v.y = b[1]), (v.z = b[2]), (v.w = b[3]), v
                );
              }
              static _packColor(b) {
                return (
                  (_.r = b[0]), (_.g = b[1]), (_.b = b[2]), (_.a = b[3]), _
                );
              }
              static _packQuat(b) {
                return (
                  (m.x = b[0]), (m.y = b[1]), (m.z = b[2]), (m.w = b[3]), m
                );
              }
              resolve(b) {
                const D = l.E.encode(b.entityPath, b.component, b.propertyPath);
                let G = this.targetCache[D];
                if (G) return G;
                let X, ie, Q;
                switch (b.component) {
                  case "entity":
                    (X = this._getEntityFromHierarchy(b.entityPath)),
                      (Q = l.E.encode(X.path, "entity", b.propertyPath)),
                      (ie = X);
                    break;
                  case "graph":
                    if (((ie = this.findNode(b)), !ie)) return null;
                    Q = l.E.encode(ie.path, "graph", b.propertyPath);
                    break;
                  default:
                    if (
                      ((X = this._getEntityFromHierarchy(b.entityPath)),
                      (ie = X.findComponent(b.component)),
                      !ie)
                    )
                      return null;
                    Q = l.E.encode(X.path, b.component, b.propertyPath);
                    break;
                }
                return (
                  (G = this._createAnimTargetForProperty(
                    ie,
                    b.propertyPath,
                    Q
                  )),
                  (this.targetCache[D] = G),
                  G
                );
              }
              update(b) {
                const D = this.activeNodes;
                if (D) for (let G = 0; G < D.length; G++) D[G]._dirtifyLocal();
              }
              _getEntityFromHierarchy(b) {
                if (!this.animComponent.entity.name === b[0]) return null;
                const D = this.animComponent.entity;
                return b.length === 1 ? D : D._parent.findByPath(b);
              }
              _resolvePath(b, D, G) {
                const X = D.length - (G ? 0 : 1);
                for (let ie = 0; ie < X; ie++) b = b[D[ie]];
                return b;
              }
              _setter(b, D, G) {
                const X = this._resolvePath(b, D),
                  ie = D[D.length - 1],
                  Q =
                    "set" + ie.substring(0, 1).toUpperCase() + ie.substring(1);
                if (X[Q]) {
                  let Z =
                    X[
                      "get" + ie.substring(0, 1).toUpperCase() + ie.substring(1)
                    ].bind(X)();
                  Z = [Z.x, Z.y, Z.z, Z.w];
                  const J = X[Q].bind(X);
                  return {
                    set: (ve) => {
                      J(G(ve));
                    },
                    get: () => Z,
                  };
                }
                const te = X[ie];
                if (typeof te == "object" && te.hasOwnProperty("copy"))
                  return function (ae) {
                    te.copy(G(ae));
                  };
                if (
                  [i.Z, e.e, t.Z, n.Q, o.k].indexOf(X.constructor) !== -1 &&
                  D.length > 1
                ) {
                  const ae =
                      D.length > 2 ? this._resolvePath(b, D.slice(0, -1)) : b,
                    Z = D[D.length - 2];
                  return function (J) {
                    (X[ie] = G(J)), (ae[Z] = X);
                  };
                }
                return function (ae) {
                  X[ie] = G(ae);
                };
              }
              _createAnimTargetForProperty(b, D, G) {
                if (this.handlers && D[0].startsWith("weight."))
                  return this.handlers.weight(b, D[0].replace("weight.", ""));
                if (this.handlers && D[0] === "material" && D.length === 2) {
                  const ae = D[1];
                  if (ae.endsWith("Map"))
                    return this.handlers.materialTexture(b, ae);
                }
                const X = this._resolvePath(b, D, !0);
                if (typeof X == "undefined") return null;
                let ie, Q, te;
                if (typeof X == "number")
                  (ie = this._setter(b, D, g._packFloat)),
                    (Q = "vector"),
                    (te = 1);
                else if (typeof X == "boolean")
                  (ie = this._setter(b, D, g._packBoolean)),
                    (Q = "vector"),
                    (te = 1);
                else if (typeof X == "object")
                  switch (X.constructor) {
                    case i.Z:
                      (ie = this._setter(b, D, g._packVec2)),
                        (Q = "vector"),
                        (te = 2);
                      break;
                    case e.e:
                      (ie = this._setter(b, D, g._packVec3)),
                        (Q = "vector"),
                        (te = 3);
                      break;
                    case t.Z:
                      (ie = this._setter(b, D, g._packVec4)),
                        (Q = "vector"),
                        (te = 4);
                      break;
                    case n.Q:
                      (ie = this._setter(b, D, g._packColor)),
                        (Q = "vector"),
                        (te = 4);
                      break;
                    case o.k:
                      (ie = this._setter(b, D, g._packQuat)),
                        (Q = "quaternion"),
                        (te = 4);
                      break;
                    default:
                      return null;
                  }
                return D.indexOf("material") !== -1
                  ? new f.z(
                      function (ae) {
                        ie(ae), b.material.update();
                      },
                      Q,
                      te,
                      G
                    )
                  : new f.z(ie, Q, te, G);
              }
              rebind() {
                (this.targetCache = {}),
                  this.animComponent.rootBone
                    ? (this.graph = this.animComponent.rootBone)
                    : (this.graph = this.animComponent.entity);
                const b = {};
                (function G(X) {
                  b[X.name] = X;
                  for (let ie = 0; ie < X.children.length; ++ie)
                    G(X.children[ie]);
                })(this.graph),
                  (this.nodes = b);
              }
            }
            var T = a(7358),
              E = a(949),
              M = a(371),
              R = a(9645);
            class P extends d.u {
              constructor(b, D) {
                super(b, D),
                  (this.findParameter = (G) => this._parameters[G]),
                  (this.consumeTrigger = (G) => {
                    this._consumedTriggers.add(G);
                  }),
                  (this._stateGraphAsset = null),
                  (this._animationAssets = {}),
                  (this._speed = 1),
                  (this._activate = !0),
                  (this._playing = !1),
                  (this._rootBone = null),
                  (this._stateGraph = null),
                  (this._layers = []),
                  (this._layerIndices = {}),
                  (this._parameters = {}),
                  (this._targets = {}),
                  (this._consumedTriggers = new Set()),
                  (this._normalizeWeights = !1);
              }
              set stateGraphAsset(b) {
                if (b === null) {
                  this.removeStateGraph();
                  return;
                }
                this._stateGraphAsset &&
                  this.system.app.assets
                    .get(this._stateGraphAsset)
                    .off("change", this._onStateGraphAssetChangeEvent, this);
                let D, G;
                b instanceof x.V
                  ? ((D = b.id),
                    (G = this.system.app.assets.get(D)),
                    G ||
                      (this.system.app.assets.add(b),
                      (G = this.system.app.assets.get(D))))
                  : ((D = b), (G = this.system.app.assets.get(D))),
                  !(!G || this._stateGraphAsset === D) &&
                    (G.resource
                      ? ((this._stateGraph = G.resource),
                        this.loadStateGraph(this._stateGraph),
                        G.on(
                          "change",
                          this._onStateGraphAssetChangeEvent,
                          this
                        ))
                      : (G.once("load", (X) => {
                          (this._stateGraph = X.resource),
                            this.loadStateGraph(this._stateGraph);
                        }),
                        G.on(
                          "change",
                          this._onStateGraphAssetChangeEvent,
                          this
                        ),
                        this.system.app.assets.load(G)),
                    (this._stateGraphAsset = D));
              }
              get stateGraphAsset() {
                return this._stateGraphAsset;
              }
              set normalizeWeights(b) {
                (this._normalizeWeights = b), this.unbind();
              }
              get normalizeWeights() {
                return this._normalizeWeights;
              }
              set animationAssets(b) {
                (this._animationAssets = b), this.loadAnimationAssets();
              }
              get animationAssets() {
                return this._animationAssets;
              }
              set speed(b) {
                this._speed = b;
              }
              get speed() {
                return this._speed;
              }
              set activate(b) {
                this._activate = b;
              }
              get activate() {
                return this._activate;
              }
              set playing(b) {
                this._playing = b;
              }
              get playing() {
                return this._playing;
              }
              set rootBone(b) {
                if (typeof b == "string") {
                  const D = this.entity.root.findByGuid(b);
                  this._rootBone = D;
                } else
                  b instanceof M.w
                    ? (this._rootBone = b)
                    : (this._rootBone = null);
                this.rebind();
              }
              get rootBone() {
                return this._rootBone;
              }
              set stateGraph(b) {
                this._stateGraph = b;
              }
              get stateGraph() {
                return this._stateGraph;
              }
              get layers() {
                return this._layers;
              }
              set layerIndices(b) {
                this._layerIndices = b;
              }
              get layerIndices() {
                return this._layerIndices;
              }
              set parameters(b) {
                this._parameters = b;
              }
              get parameters() {
                return this._parameters;
              }
              set targets(b) {
                this._targets = b;
              }
              get targets() {
                return this._targets;
              }
              get playable() {
                for (let b = 0; b < this._layers.length; b++)
                  if (!this._layers[b].playable) return !1;
                return !0;
              }
              get baseLayer() {
                return this._layers.length > 0 ? this._layers[0] : null;
              }
              _onStateGraphAssetChangeEvent(b) {
                const D = this.animationAssets,
                  G = this.layers.map((X) => X.mask);
                this.removeStateGraph(),
                  (this._stateGraph = new E.R(b._data)),
                  this.loadStateGraph(this._stateGraph),
                  (this.animationAssets = D),
                  this.loadAnimationAssets(),
                  this.layers.forEach((X, ie) => {
                    X.mask = G[ie];
                  }),
                  this.rebind();
              }
              dirtifyTargets() {
                const b = Object.values(this._targets);
                for (let D = 0; D < b.length; D++) b[D].dirty = !0;
              }
              _addLayer({
                name: b,
                states: D,
                transitions: G,
                weight: X,
                mask: ie,
                blendType: Q,
              }) {
                let te;
                this.rootBone ? (te = this.rootBone) : (te = this.entity);
                const ae = this._layers.length,
                  Z = new g(this, te, b, ie, ae),
                  J = new y.Z(Z),
                  ve = new c.o(
                    J,
                    D,
                    G,
                    this._activate,
                    this,
                    this.findParameter,
                    this.consumeTrigger
                  );
                return (
                  this._layers.push(new T.E(b, ve, this, X, Q)),
                  (this._layerIndices[b] = ae),
                  this._layers[ae]
                );
              }
              addLayer(b, D, G, X) {
                const ie = this.findAnimationLayer(b);
                if (ie) return ie;
                const Q = [{ name: "START", speed: 1 }],
                  te = [];
                return this._addLayer({
                  name: b,
                  states: Q,
                  transitions: te,
                  weight: D,
                  mask: G,
                  blendType: X,
                });
              }
              _assignParameters(b) {
                this._parameters = {};
                const D = Object.keys(b.parameters);
                for (let G = 0; G < D.length; G++) {
                  const X = D[G];
                  this._parameters[X] = {
                    type: b.parameters[X].type,
                    value: b.parameters[X].value,
                  };
                }
              }
              loadStateGraph(b) {
                (this._stateGraph = b),
                  this._assignParameters(b),
                  (this._layers = []);
                let D = !1;
                for (let G = 0; G < b.layers.length; G++) {
                  const X = b.layers[G];
                  this._addLayer.bind(this)((0, A._)({}, X)),
                    X.states.some((ie) => ie.blendTree) && (D = !0);
                }
                D || this.setupAnimationAssets();
              }
              setupAnimationAssets() {
                for (let b = 0; b < this._layers.length; b++) {
                  const D = this._layers[b],
                    G = D.name;
                  for (let X = 0; X < D.states.length; X++) {
                    const ie = D.states[X];
                    if (h.BA.indexOf(ie) === -1) {
                      const Q = G + ":" + ie;
                      this._animationAssets[Q] ||
                        (this._animationAssets[Q] = { asset: null });
                    }
                  }
                }
                this.loadAnimationAssets();
              }
              loadAnimationAssets() {
                for (let b = 0; b < this._layers.length; b++) {
                  const D = this._layers[b];
                  for (let G = 0; G < D.states.length; G++) {
                    const X = D.states[G];
                    if (h.BA.indexOf(X) !== -1) continue;
                    const ie = this._animationAssets[D.name + ":" + X];
                    if (!ie || !ie.asset) {
                      this.findAnimationLayer(D.name).assignAnimation(
                        X,
                        R.z.EMPTY
                      );
                      continue;
                    }
                    const Q = ie.asset,
                      te = this.system.app.assets.get(Q);
                    te &&
                      (te.resource
                        ? this.onAnimationAssetLoaded(D.name, X, te)
                        : (te.once(
                            "load",
                            function (ae, Z) {
                              return function (J) {
                                this.onAnimationAssetLoaded(ae, Z, J);
                              }.bind(this);
                            }.bind(this)(D.name, X)
                          ),
                          this.system.app.assets.load(te)));
                  }
                }
              }
              onAnimationAssetLoaded(b, D, G) {
                this.findAnimationLayer(b).assignAnimation(D, G.resource);
              }
              removeStateGraph() {
                (this._stateGraph = null),
                  (this._stateGraphAsset = null),
                  (this._animationAssets = {}),
                  (this._layers = []),
                  (this._layerIndices = {}),
                  (this._parameters = {}),
                  (this._playing = !1),
                  this.unbind(),
                  (this._targets = {});
              }
              reset() {
                this._assignParameters(this._stateGraph);
                for (let b = 0; b < this._layers.length; b++) {
                  const D = this._layers[b].playing;
                  this._layers[b].reset(), (this._layers[b].playing = D);
                }
              }
              unbind() {
                this._normalizeWeights ||
                  Object.keys(this._targets).forEach((b) => {
                    this._targets[b].unbind();
                  });
              }
              rebind() {
                this._targets = {};
                for (let b = 0; b < this._layers.length; b++)
                  this._layers[b].rebind();
              }
              findAnimationLayer(b) {
                const D = this._layerIndices[b];
                return this._layers[D] || null;
              }
              addAnimationState(b, D, G = 1, X = !0, ie = "Base") {
                this._stateGraph ||
                  this.loadStateGraph(
                    new E.R({
                      layers: [
                        {
                          name: ie,
                          states: [
                            { name: "START", speed: 1 },
                            { name: b, speed: G, loop: X, defaultState: !0 },
                          ],
                          transitions: [{ from: "START", to: b }],
                        },
                      ],
                      parameters: {},
                    })
                  );
                const Q = this.findAnimationLayer(ie);
                if (Q) Q.assignAnimation(b, D, G, X);
                else {
                  var te;
                  (te = this.addLayer(ie)) == null ||
                    te.assignAnimation(b, D, G, X);
                }
              }
              assignAnimation(b, D, G, X = 1, ie = !0) {
                if (!this._stateGraph && b.indexOf(".") === -1) {
                  this.loadStateGraph(
                    new E.R({
                      layers: [
                        {
                          name: "Base",
                          states: [
                            { name: "START", speed: 1 },
                            { name: b, speed: X, loop: ie, defaultState: !0 },
                          ],
                          transitions: [{ from: "START", to: b }],
                        },
                      ],
                      parameters: {},
                    })
                  ),
                    this.baseLayer.assignAnimation(b, D);
                  return;
                }
                const Q = G ? this.findAnimationLayer(G) : this.baseLayer;
                Q && Q.assignAnimation(b, D, X, ie);
              }
              removeNodeAnimations(b, D) {
                const G = D ? this.findAnimationLayer(D) : this.baseLayer;
                G && G.removeNodeAnimations(b);
              }
              getParameterValue(b, D) {
                const G = this._parameters[b];
                if (G && G.type === D) return G.value;
              }
              setParameterValue(b, D, G) {
                const X = this._parameters[b];
                if (X && X.type === D) {
                  X.value = G;
                  return;
                }
              }
              getFloat(b) {
                return this.getParameterValue(b, h.h0);
              }
              setFloat(b, D) {
                this.setParameterValue(b, h.h0, D);
              }
              getInteger(b) {
                return this.getParameterValue(b, h.nl);
              }
              setInteger(b, D) {
                typeof D == "number" &&
                  D % 1 === 0 &&
                  this.setParameterValue(b, h.nl, D);
              }
              getBoolean(b) {
                return this.getParameterValue(b, h.dF);
              }
              setBoolean(b, D) {
                this.setParameterValue(b, h.dF, !!D);
              }
              getTrigger(b) {
                return this.getParameterValue(b, h.p$);
              }
              setTrigger(b, D = !1) {
                this.setParameterValue(b, h.p$, !0),
                  D && this._consumedTriggers.add(b);
              }
              resetTrigger(b) {
                this.setParameterValue(b, h.p$, !1);
              }
              onBeforeRemove() {
                Number.isFinite(this._stateGraphAsset) &&
                  this.system.app.assets
                    .get(this._stateGraphAsset)
                    .off("change", this._onStateGraphAssetChangeEvent, this);
              }
              update(b) {
                for (let D = 0; D < this.layers.length; D++)
                  this.layers[D].update(b * this.speed);
                this._consumedTriggers.forEach((D) => {
                  this.parameters[D].value = !1;
                }),
                  this._consumedTriggers.clear();
              }
              resolveDuplicatedEntityReferenceProperties(b, D) {
                b.rootBone && D[b.rootBone.getGuid()]
                  ? (this.rootBone = D[b.rootBone.getGuid()])
                  : this.rebind();
              }
            }
          },
          4561: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => f });
            var A = a(9645),
              x = a(4124),
              y = a(2930),
              c = a(5695);
            class d {
              constructor() {
                this.enabled = !0;
              }
            }
            const h = ["enabled"];
            class f extends y.r {
              constructor(l) {
                super(l),
                  (this.id = "anim"),
                  (this.ComponentType = c.H),
                  (this.DataType = d),
                  (this.schema = h),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on(
                    "animationUpdate",
                    this.onAnimationUpdate,
                    this
                  );
              }
              initializeComponentData(l, n, o) {
                super.initializeComponentData(l, n, h);
                const i = ["animationAssets", "stateGraph", "layers", "masks"];
                Object.keys(n).forEach((e) => {
                  i.includes(e) || (l[e] = n[e]);
                }),
                  n.stateGraph &&
                    ((l.stateGraph = n.stateGraph),
                    l.loadStateGraph(l.stateGraph)),
                  n.layers
                    ? n.layers.forEach((e, t) => {
                        e._controller.states.forEach((r) => {
                          e._controller._states[r]._animationList.forEach(
                            (u) => {
                              if (!u.animTrack || u.animTrack === A.z.EMPTY) {
                                const v = this.app.assets.get(
                                  e._component._animationAssets[
                                    e.name + ":" + u.name
                                  ].asset
                                );
                                v &&
                                  !v.loaded &&
                                  v.once("load", () => {
                                    l.layers[t].assignAnimation(
                                      u.name,
                                      v.resource
                                    );
                                  });
                              } else
                                l.layers[t].assignAnimation(
                                  u.name,
                                  u.animTrack
                                );
                            }
                          );
                        });
                      })
                    : n.animationAssets &&
                      (l.animationAssets = Object.assign(
                        l.animationAssets,
                        n.animationAssets
                      )),
                  n.masks &&
                    Object.keys(n.masks).forEach((e) => {
                      if (l.layers[e]) {
                        const t = n.masks[e].mask,
                          r = {};
                        Object.keys(t).forEach((u) => {
                          r[decodeURI(u)] = t[u];
                        }),
                          (l.layers[e].mask = r);
                      }
                    });
              }
              onAnimationUpdate(l) {
                const n = this.store;
                for (const o in n)
                  if (n.hasOwnProperty(o)) {
                    const i = n[o].entity.anim;
                    i.data.enabled &&
                      i.entity.enabled &&
                      i.playing &&
                      i.update(l);
                  }
              }
              cloneComponent(l, n) {
                let o;
                (!l.anim.rootBone || l.anim.rootBone === l) &&
                  ((o = {}),
                  l.anim.layers.forEach((e, t) => {
                    if (e.mask) {
                      const r = {};
                      Object.keys(e.mask).forEach((u) => {
                        const v = u.split("/");
                        v.shift();
                        const _ = [n.name, ...v].join("/");
                        r[_] = e.mask[u];
                      }),
                        (o[t] = { mask: r });
                    }
                  }));
                const i = {
                  stateGraphAsset: l.anim.stateGraphAsset,
                  animationAssets: l.anim.animationAssets,
                  speed: l.anim.speed,
                  activate: l.anim.activate,
                  playing: l.anim.playing,
                  rootBone: l.anim.rootBone,
                  stateGraph: l.anim.stateGraph,
                  layers: l.anim.layers,
                  layerIndices: l.anim.layerIndices,
                  parameters: l.anim.parameters,
                  normalizeWeights: l.anim.normalizeWeights,
                  masks: o,
                };
                return this.addComponent(n, i);
              }
              onBeforeRemove(l, n) {
                n.onBeforeRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off(
                    "animationUpdate",
                    this.onAnimationUpdate,
                    this
                  );
              }
            }
            x.u._buildAccessors(c.H.prototype, h);
          },
          377: (xe, V, a) => {
            "use strict";
            a.d(V, { C: () => s });
            var A = a(70),
              x = a(7433),
              y = a(9645),
              c = a(7747),
              d = a(7284),
              h = a(3953),
              f = a(4124);
            class s extends f.u {
              constructor(n, o) {
                super(n, o),
                  (this._animations = {}),
                  (this._assets = []),
                  (this._loop = !0),
                  (this.animEvaluator = null),
                  (this.model = null),
                  (this.skeleton = null),
                  (this.fromSkel = null),
                  (this.toSkel = null),
                  (this.animationsIndex = {}),
                  (this.prevAnim = null),
                  (this.currAnim = null),
                  (this.blend = 0),
                  (this.blending = !1),
                  (this.blendSpeed = 0),
                  (this.activate = !0),
                  (this.speed = 1);
              }
              set animations(n) {
                (this._animations = n), this.onSetAnimations();
              }
              get animations() {
                return this._animations;
              }
              set assets(n) {
                const o = this._assets;
                if (o && o.length) {
                  for (let e = 0; e < o.length; e++)
                    if (o[e]) {
                      const t = this.system.app.assets.get(o[e]);
                      if (t) {
                        t.off("change", this.onAssetChanged, this),
                          t.off("remove", this.onAssetRemoved, this);
                        const r = this.animationsIndex[t.id];
                        this.currAnim === r && this._stopCurrentAnimation(),
                          delete this.animations[r],
                          delete this.animationsIndex[t.id];
                      }
                    }
                }
                this._assets = n;
                const i = n.map((e) => (e instanceof h.V ? e.id : e));
                this.loadAnimationAssets(i);
              }
              get assets() {
                return this._assets;
              }
              set currentTime(n) {
                if (
                  (this.skeleton &&
                    ((this.skeleton.currentTime = n),
                    this.skeleton.addTime(0),
                    this.skeleton.updateGraph()),
                  this.animEvaluator)
                ) {
                  const o = this.animEvaluator.clips;
                  for (let i = 0; i < o.length; ++i) o[i].time = n;
                }
              }
              get currentTime() {
                if (this.skeleton) return this.skeleton._time;
                if (this.animEvaluator) {
                  const n = this.animEvaluator.clips;
                  if (n.length > 0) return n[n.length - 1].time;
                }
                return 0;
              }
              get duration() {
                return this.currAnim
                  ? this.animations[this.currAnim].duration
                  : 0;
              }
              set loop(n) {
                if (
                  ((this._loop = n),
                  this.skeleton && (this.skeleton.looping = n),
                  this.animEvaluator)
                )
                  for (let o = 0; o < this.animEvaluator.clips.length; ++o)
                    this.animEvaluator.clips[o].loop = n;
              }
              get loop() {
                return this._loop;
              }
              play(n, o = 0) {
                if (
                  !(!this.enabled || !this.entity.enabled) &&
                  this.animations[n]
                ) {
                  if (
                    ((this.prevAnim = this.currAnim),
                    (this.currAnim = n),
                    this.model)
                  ) {
                    !this.skeleton &&
                      !this.animEvaluator &&
                      this._createAnimationController();
                    const i = this.animations[this.prevAnim],
                      e = this.animations[this.currAnim];
                    if (
                      ((this.blending = o > 0 && !!this.prevAnim),
                      this.blending &&
                        ((this.blend = 0), (this.blendSpeed = 1 / o)),
                      this.skeleton &&
                        (this.blending
                          ? ((this.fromSkel.animation = i),
                            this.fromSkel.addTime(this.skeleton._time),
                            (this.toSkel.animation = e))
                          : (this.skeleton.animation = e)),
                      this.animEvaluator)
                    ) {
                      const t = this.animEvaluator;
                      if (this.blending)
                        for (; t.clips.length > 1; ) t.removeClip(0);
                      else this.animEvaluator.removeClips();
                      const r = new A.W(
                        this.animations[this.currAnim],
                        0,
                        1,
                        !0,
                        this.loop
                      );
                      (r.name = this.currAnim),
                        (r.blendWeight = this.blending ? 0 : 1),
                        r.reset(),
                        this.animEvaluator.addClip(r);
                    }
                  }
                  this.playing = !0;
                }
              }
              getAnimation(n) {
                return this.animations[n];
              }
              setModel(n) {
                n !== this.model &&
                  (this._resetAnimationController(),
                  (this.model = n),
                  this.animations &&
                    this.currAnim &&
                    this.animations[this.currAnim] &&
                    this.play(this.currAnim));
              }
              onSetAnimations() {
                const n = this.entity.model;
                if (n) {
                  const o = n.model;
                  o && o !== this.model && this.setModel(o);
                }
                if (
                  !this.currAnim &&
                  this.activate &&
                  this.enabled &&
                  this.entity.enabled
                ) {
                  const o = Object.keys(this._animations);
                  o.length > 0 && this.play(o[0]);
                }
              }
              _resetAnimationController() {
                (this.skeleton = null),
                  (this.fromSkel = null),
                  (this.toSkel = null),
                  (this.animEvaluator = null);
              }
              _createAnimationController() {
                const n = this.model,
                  o = this.animations;
                let i = !1,
                  e = !1;
                for (const r in o)
                  o.hasOwnProperty(r) &&
                    (o[r].constructor === y.z ? (e = !0) : (i = !0));
                const t = n.getGraph();
                i
                  ? ((this.fromSkel = new d.E(t)),
                    (this.toSkel = new d.E(t)),
                    (this.skeleton = new d.E(t)),
                    (this.skeleton.looping = this.loop),
                    this.skeleton.setGraph(t))
                  : e && (this.animEvaluator = new x.Z(new c.x(this.entity)));
              }
              loadAnimationAssets(n) {
                if (!n || !n.length) return;
                const o = this.system.app.assets,
                  i = (t) => {
                    if (t.resources.length > 1)
                      for (let r = 0; r < t.resources.length; r++)
                        (this.animations[t.resources[r].name] = t.resources[r]),
                          (this.animationsIndex[t.id] = t.resources[r].name);
                    else
                      (this.animations[t.name] = t.resource),
                        (this.animationsIndex[t.id] = t.name);
                    this.animations = this.animations;
                  },
                  e = (t) => {
                    t.off("change", this.onAssetChanged, this),
                      t.on("change", this.onAssetChanged, this),
                      t.off("remove", this.onAssetRemoved, this),
                      t.on("remove", this.onAssetRemoved, this),
                      t.resource
                        ? i(t)
                        : (t.once("load", i, this),
                          this.enabled && this.entity.enabled && o.load(t));
                  };
                for (let t = 0, r = n.length; t < r; t++) {
                  const u = o.get(n[t]);
                  u ? e(u) : o.on("add:" + n[t], e);
                }
              }
              onAssetChanged(n, o, i, e) {
                if (o === "resource" || o === "resources")
                  if (
                    (o === "resources" && i && i.length === 0 && (i = null), i)
                  ) {
                    let t = !1;
                    if (i.length > 1) {
                      if (e && e.length > 1)
                        for (let r = 0; r < e.length; r++)
                          delete this.animations[e[r].name];
                      else delete this.animations[n.name];
                      t = !1;
                      for (let r = 0; r < i.length; r++)
                        (this.animations[i[r].name] = i[r]),
                          !t &&
                            this.currAnim === i[r].name &&
                            this.playing &&
                            this.enabled &&
                            this.entity.enabled &&
                            ((t = !0), this.play(i[r].name));
                      t ||
                        (this._stopCurrentAnimation(), this.onSetAnimations());
                    } else {
                      if (e && e.length > 1)
                        for (let r = 0; r < e.length; r++)
                          delete this.animations[e[r].name];
                      (this.animations[n.name] = i[0] || i),
                        (t = !1),
                        this.currAnim === n.name &&
                          this.playing &&
                          this.enabled &&
                          this.entity.enabled &&
                          ((t = !0), this.play(n.name)),
                        t ||
                          (this._stopCurrentAnimation(),
                          this.onSetAnimations());
                    }
                    this.animationsIndex[n.id] = n.name;
                  } else {
                    if (e.length > 1)
                      for (let t = 0; t < e.length; t++)
                        delete this.animations[e[t].name],
                          this.currAnim === e[t].name &&
                            this._stopCurrentAnimation();
                    else
                      delete this.animations[n.name],
                        this.currAnim === n.name &&
                          this._stopCurrentAnimation();
                    delete this.animationsIndex[n.id];
                  }
              }
              onAssetRemoved(n) {
                if (
                  (n.off("remove", this.onAssetRemoved, this), this.animations)
                ) {
                  if (n.resources.length > 1)
                    for (let o = 0; o < n.resources.length; o++)
                      delete this.animations[n.resources[o].name],
                        this.currAnim === n.resources[o].name &&
                          this._stopCurrentAnimation();
                  else
                    delete this.animations[n.name],
                      this.currAnim === n.name && this._stopCurrentAnimation();
                  delete this.animationsIndex[n.id];
                }
              }
              _stopCurrentAnimation() {
                if (
                  ((this.currAnim = null),
                  (this.playing = !1),
                  this.skeleton &&
                    ((this.skeleton.currentTime = 0),
                    (this.skeleton.animation = null)),
                  this.animEvaluator)
                ) {
                  for (let n = 0; n < this.animEvaluator.clips.length; ++n)
                    this.animEvaluator.clips[n].stop();
                  this.animEvaluator.update(0),
                    this.animEvaluator.removeClips();
                }
              }
              onEnable() {
                super.onEnable();
                const n = this.assets,
                  o = this.system.app.assets;
                if (n)
                  for (let i = 0, e = n.length; i < e; i++) {
                    let t = n[i];
                    t instanceof h.V || (t = o.get(t)),
                      t && !t.resource && o.load(t);
                  }
                if (this.activate && !this.currAnim) {
                  const i = Object.keys(this.animations);
                  i.length > 0 && this.play(i[0]);
                }
              }
              onBeforeRemove() {
                for (let n = 0; n < this.assets.length; n++) {
                  let o = this.assets[n];
                  typeof o == "number" && (o = this.system.app.assets.get(o)),
                    o &&
                      (o.off("change", this.onAssetChanged, this),
                      o.off("remove", this.onAssetRemoved, this));
                }
                (this.skeleton = null),
                  (this.fromSkel = null),
                  (this.toSkel = null),
                  (this.animEvaluator = null);
              }
              update(n) {
                if (
                  (this.blending &&
                    ((this.blend += n * this.blendSpeed),
                    this.blend >= 1 && (this.blend = 1)),
                  this.playing)
                ) {
                  const i = this.skeleton;
                  if (i !== null && this.model !== null) {
                    if (this.blending)
                      i.blend(this.fromSkel, this.toSkel, this.blend);
                    else {
                      const e = n * this.speed;
                      i.addTime(e),
                        this.speed > 0 &&
                        i._time === i.animation.duration &&
                        !this.loop
                          ? (this.playing = !1)
                          : this.speed < 0 &&
                            i._time === 0 &&
                            !this.loop &&
                            (this.playing = !1);
                    }
                    this.blending &&
                      this.blend === 1 &&
                      (i.animation = this.toSkel.animation),
                      i.updateGraph();
                  }
                }
                const o = this.animEvaluator;
                if (o) {
                  for (let i = 0; i < o.clips.length; ++i) {
                    const e = o.clips[i];
                    (e.speed = this.speed),
                      this.playing ? e.resume() : e.pause();
                  }
                  this.blending &&
                    o.clips.length > 1 &&
                    (o.clips[1].blendWeight = this.blend),
                    o.update(n);
                }
                this.blending && this.blend === 1 && (this.blending = !1);
              }
            }
          },
          8974: (xe, V, a) => {
            "use strict";
            a.d(V, { X: () => h });
            var A = a(4124),
              x = a(2930),
              y = a(377);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends x.r {
              constructor(s) {
                super(s),
                  (this.id = "animation"),
                  (this.ComponentType = y.C),
                  (this.DataType = c),
                  (this.schema = d),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(s, l, n) {
                n = ["activate", "enabled", "loop", "speed", "assets"];
                for (const o of n) l.hasOwnProperty(o) && (s[o] = l[o]);
                super.initializeComponentData(s, l, d);
              }
              cloneComponent(s, l) {
                this.addComponent(l, {}),
                  (l.animation.assets = s.animation.assets.slice()),
                  (l.animation.speed = s.animation.speed),
                  (l.animation.loop = s.animation.loop),
                  (l.animation.activate = s.animation.activate),
                  (l.animation.enabled = s.animation.enabled);
                const n = {},
                  o = s.animation.animations;
                for (const t in o) o.hasOwnProperty(t) && (n[t] = o[t]);
                l.animation.animations = n;
                const i = {},
                  e = s.animation.animationsIndex;
                for (const t in e) e.hasOwnProperty(t) && (i[t] = e[t]);
                return (l.animation.animationsIndex = i), l.animation;
              }
              onBeforeRemove(s, l) {
                l.onBeforeRemove();
              }
              onUpdate(s) {
                const l = this.store;
                for (const n in l)
                  if (l.hasOwnProperty(n)) {
                    const o = l[n];
                    o.data.enabled &&
                      o.entity.enabled &&
                      o.entity.animation.update(s);
                  }
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            A.u._buildAccessors(y.C.prototype, d);
          },
          5418: (xe, V, a) => {
            "use strict";
            a.d(V, { e: () => x });
            var A = a(4124);
            class x extends A.u {
              constructor(c, d) {
                super(c, d);
              }
              setCurrentListener() {
                if (
                  this.enabled &&
                  this.entity.audiolistener &&
                  this.entity.enabled
                ) {
                  this.system.current = this.entity;
                  const c = this.system.current.getPosition();
                  this.system.manager.listener.setPosition(c);
                }
              }
              onEnable() {
                this.setCurrentListener();
              }
              onDisable() {
                this.system.current === this.entity &&
                  (this.system.current = null);
              }
            }
          },
          6029: (xe, V, a) => {
            "use strict";
            a.d(V, { X: () => h });
            var A = a(4124),
              x = a(2930),
              y = a(5418);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends x.r {
              constructor(s) {
                super(s),
                  (this.id = "audiolistener"),
                  (this.ComponentType = y.e),
                  (this.DataType = c),
                  (this.schema = d),
                  (this.manager = s.soundManager),
                  (this.current = null),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(s, l, n) {
                (n = ["enabled"]), super.initializeComponentData(s, l, n);
              }
              onUpdate(s) {
                if (this.current) {
                  const l = this.current.getPosition();
                  this.manager.listener.setPosition(l);
                  const n = this.current.getWorldTransform();
                  this.manager.listener.setOrientation(n);
                }
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            A.u._buildAccessors(y.e.prototype, d);
          },
          3527: (xe, V, a) => {
            "use strict";
            a.d(V, { N: () => c });
            var A = a(3953),
              x = a(8844),
              y = a(4124);
            class c extends y.u {
              constructor(h, f) {
                super(h, f),
                  this.on("set_assets", this.onSetAssets, this),
                  this.on("set_loop", this.onSetLoop, this),
                  this.on("set_volume", this.onSetVolume, this),
                  this.on("set_pitch", this.onSetPitch, this),
                  this.on("set_minDistance", this.onSetMinDistance, this),
                  this.on("set_maxDistance", this.onSetMaxDistance, this),
                  this.on("set_rollOffFactor", this.onSetRollOffFactor, this),
                  this.on("set_distanceModel", this.onSetDistanceModel, this),
                  this.on("set_3d", this.onSet3d, this);
              }
              play(h) {
                if (!this.enabled || !this.entity.enabled) return;
                this.channel && this.stop();
                let f;
                const s = this.data;
                if (s.sources[h])
                  if (!s["3d"])
                    (f = this.system.manager.playSound(s.sources[h], s)),
                      (s.currentSource = h),
                      (s.channel = f);
                  else {
                    const l = this.entity.getPosition();
                    (f = this.system.manager.playSound3d(s.sources[h], l, s)),
                      (s.currentSource = h),
                      (s.channel = f);
                  }
              }
              pause() {
                this.channel && this.channel.pause();
              }
              unpause() {
                this.channel && this.channel.paused && this.channel.unpause();
              }
              stop() {
                this.channel && (this.channel.stop(), (this.channel = null));
              }
              onSetAssets(h, f, s) {
                const l = [],
                  n = s.length;
                if (f && f.length) {
                  for (let o = 0; o < f.length; o++)
                    if (f[o]) {
                      const i = this.system.app.assets.get(f[o]);
                      i &&
                        (i.off("change", this.onAssetChanged, this),
                        i.off("remove", this.onAssetRemoved, this),
                        this.currentSource === i.name && this.stop());
                    }
                }
                if (n)
                  for (let o = 0; o < n; o++)
                    f.indexOf(s[o]) < 0 &&
                      (s[o] instanceof A.V ? l.push(s[o].id) : l.push(s[o]));
                !this.system._inTools &&
                  l.length &&
                  this.loadAudioSourceAssets(l);
              }
              onAssetChanged(h, f, s, l) {
                f === "resource" &&
                  this.data.sources &&
                  ((this.data.sources[h.name] = s),
                  this.data.currentSource === h.name &&
                    this.channel &&
                    (this.channel.paused
                      ? (this.play(h.name), this.pause())
                      : this.play(h.name)));
              }
              onAssetRemoved(h) {
                h.off("remove", this.onAssetRemoved, this),
                  this.data.sources[h.name] &&
                    (delete this.data.sources[h.name],
                    this.data.currentSource === h.name &&
                      (this.stop(), (this.data.currentSource = null)));
              }
              onSetLoop(h, f, s) {
                f !== s && this.channel && this.channel.setLoop(s);
              }
              onSetVolume(h, f, s) {
                f !== s && this.channel && this.channel.setVolume(s);
              }
              onSetPitch(h, f, s) {
                f !== s && this.channel && this.channel.setPitch(s);
              }
              onSetMaxDistance(h, f, s) {
                f !== s &&
                  this.channel instanceof x.j &&
                  this.channel.setMaxDistance(s);
              }
              onSetMinDistance(h, f, s) {
                f !== s &&
                  this.channel instanceof x.j &&
                  this.channel.setMinDistance(s);
              }
              onSetRollOffFactor(h, f, s) {
                f !== s &&
                  this.channel instanceof x.j &&
                  this.channel.setRollOffFactor(s);
              }
              onSetDistanceModel(h, f, s) {
                f !== s &&
                  this.channel instanceof x.j &&
                  this.channel.setDistanceModel(s);
              }
              onSet3d(h, f, s) {
                if (f !== s && this.system.initialized && this.currentSource) {
                  let l = !1,
                    n = !1;
                  this.channel &&
                    ((l = this.channel.paused), (n = this.channel.suspended)),
                    this.play(this.currentSource),
                    this.channel &&
                      ((this.channel.paused = l), (this.channel.suspended = n));
                }
              }
              onEnable() {
                const h = this.data.assets;
                if (h) {
                  const f = this.system.app.assets;
                  for (let s = 0, l = h.length; s < l; s++) {
                    let n = h[s];
                    n instanceof A.V || (n = f.get(n)),
                      n && !n.resource && f.load(n);
                  }
                }
                this.system.initialized &&
                  (this.data.activate && !this.channel
                    ? this.play(this.currentSource)
                    : this.unpause());
              }
              onDisable() {
                this.pause();
              }
              loadAudioSourceAssets(h) {
                const f = h.map((e) => this.system.app.assets.get(e)),
                  s = {};
                let l = null,
                  n = f.length;
                const o = (e) => {
                    n--;
                  },
                  i = () => {
                    (this.data.sources = s),
                      (this.data.currentSource = l),
                      this.enabled && this.activate && l && this.onEnable();
                  };
                f.forEach((e, t) => {
                  e
                    ? ((l = l || e.name),
                      e.off("change", this.onAssetChanged, this),
                      e.on("change", this.onAssetChanged, this),
                      e.off("remove", this.onAssetRemoved, this),
                      e.on("remove", this.onAssetRemoved, this),
                      e.off("error", o, this),
                      e.on("error", o, this),
                      e.ready((r) => {
                        (s[r.name] = r.resource), n--, n === 0 && i();
                      }),
                      !e.resource &&
                        this.enabled &&
                        this.entity.enabled &&
                        this.system.app.assets.load(e))
                    : (n--,
                      n === 0 && i(),
                      this.system.app.assets.on("add:" + h[t], (r) => {
                        r.ready((u) => {
                          this.data.sources[u.name] = u.resource;
                        }),
                          r.resource || this.system.app.assets.load(r);
                      }));
                });
              }
            }
          },
          392: (xe, V, a) => {
            "use strict";
            a.d(V, { o: () => l });
            var A = a(8844),
              x = a(371),
              y = a(4124),
              c = a(2930),
              d = a(3527),
              h = a(1145);
            class f {
              constructor() {
                (this.enabled = !0),
                  (this.assets = []),
                  (this.activate = !0),
                  (this.volume = 1),
                  (this.pitch = 1),
                  (this.loop = !1),
                  (this["3d"] = !0),
                  (this.minDistance = 1),
                  (this.maxDistance = 1e4),
                  (this.rollOffFactor = 1),
                  (this.distanceModel = h.Jq),
                  (this.paused = !0),
                  (this.sources = {}),
                  (this.currentSource = null),
                  (this.channel = null);
              }
            }
            const s = [
              "enabled",
              "assets",
              "volume",
              "pitch",
              "loop",
              "activate",
              "3d",
              "minDistance",
              "maxDistance",
              "rollOffFactor",
              "distanceModel",
              "sources",
              "currentSource",
              "channel",
            ];
            class l extends c.r {
              constructor(o) {
                super(o),
                  (this.id = "audiosource"),
                  (this.ComponentType = d.N),
                  (this.DataType = f),
                  (this.schema = s),
                  (this.manager = o.soundManager),
                  (this.initialized = !1),
                  this.app.systems.on("initialize", this.onInitialize, this),
                  this.app.systems.on("update", this.onUpdate, this),
                  this.on("remove", this.onRemove, this);
              }
              initializeComponentData(o, i, e) {
                (e = [
                  "activate",
                  "volume",
                  "pitch",
                  "loop",
                  "3d",
                  "minDistance",
                  "maxDistance",
                  "rollOffFactor",
                  "distanceModel",
                  "enabled",
                  "assets",
                ]),
                  super.initializeComponentData(o, i, e),
                  (o.paused = !(o.enabled && o.activate));
              }
              onInitialize(o) {
                o.audiosource &&
                  o.enabled &&
                  o.audiosource.enabled &&
                  o.audiosource.activate &&
                  o.audiosource.play(o.audiosource.currentSource);
                const i = o._children;
                for (let e = 0, t = i.length; e < t; e++)
                  i[e] instanceof x.w && this.onInitialize(i[e]);
                this.initialized = !0;
              }
              onUpdate(o) {
                const i = this.store;
                for (const e in i)
                  if (i.hasOwnProperty(e)) {
                    const t = i[e],
                      r = t.entity,
                      u = t.data;
                    if (u.enabled && r.enabled && u.channel instanceof A.j) {
                      const v = r.getPosition();
                      u.channel.setPosition(v);
                    }
                  }
              }
              onRemove(o, i) {
                i.channel && (i.channel.stop(), (i.channel = null));
              }
              setVolume(o) {
                this.manager.setVolume(o);
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("initialize", this.onInitialize, this),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            y.u._buildAccessors(d.N.prototype, s);
          },
          5339: (xe, V, a) => {
            "use strict";
            a.d(V, { Q: () => i });
            var A = a(9516),
              x = a(8656),
              y = a(5227),
              c = a(1657),
              d = a(4124),
              h = a(8593),
              f = a(9189);
            const s = {
                DEFAULT: "DEFAULT",
                HOVER: "HOVER",
                PRESSED: "PRESSED",
                INACTIVE: "INACTIVE",
              },
              l = {};
            (l[s.DEFAULT] = "_defaultTint"),
              (l[s.HOVER] = "hoverTint"),
              (l[s.PRESSED] = "pressedTint"),
              (l[s.INACTIVE] = "inactiveTint");
            const n = {};
            (n[s.DEFAULT] = "_defaultSpriteAsset"),
              (n[s.HOVER] = "hoverSpriteAsset"),
              (n[s.PRESSED] = "pressedSpriteAsset"),
              (n[s.INACTIVE] = "inactiveSpriteAsset");
            const o = {};
            (o[s.DEFAULT] = "_defaultSpriteFrame"),
              (o[s.HOVER] = "hoverSpriteFrame"),
              (o[s.PRESSED] = "pressedSpriteFrame"),
              (o[s.INACTIVE] = "inactiveSpriteFrame");
            class i extends d.u {
              constructor(r, u) {
                super(r, u),
                  (this._visualState = s.DEFAULT),
                  (this._isHovering = !1),
                  (this._hoveringCounter = 0),
                  (this._isPressed = !1),
                  (this._defaultTint = new y.Q(1, 1, 1, 1)),
                  (this._defaultSpriteAsset = null),
                  (this._defaultSpriteFrame = 0),
                  (this._imageReference = new c.D(this, "imageEntity", {
                    "element#gain": this._onImageElementGain,
                    "element#lose": this._onImageElementLose,
                    "element#set:color": this._onSetColor,
                    "element#set:opacity": this._onSetOpacity,
                    "element#set:spriteAsset": this._onSetSpriteAsset,
                    "element#set:spriteFrame": this._onSetSpriteFrame,
                  })),
                  this._toggleLifecycleListeners("on", r);
              }
              _toggleLifecycleListeners(r, u) {
                this[r]("set_active", this._onSetActive, this),
                  this[r](
                    "set_transitionMode",
                    this._onSetTransitionMode,
                    this
                  ),
                  this[r]("set_hoverTint", this._onSetTransitionValue, this),
                  this[r]("set_pressedTint", this._onSetTransitionValue, this),
                  this[r]("set_inactiveTint", this._onSetTransitionValue, this),
                  this[r](
                    "set_hoverSpriteAsset",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_hoverSpriteFrame",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_pressedSpriteAsset",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_pressedSpriteFrame",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_inactiveSpriteAsset",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_inactiveSpriteFrame",
                    this._onSetTransitionValue,
                    this
                  ),
                  u.app.systems.element[r](
                    "add",
                    this._onElementComponentAdd,
                    this
                  ),
                  u.app.systems.element[r](
                    "beforeremove",
                    this._onElementComponentRemove,
                    this
                  );
              }
              _onSetActive(r, u, v) {
                u !== v && this._updateVisualState();
              }
              _onSetTransitionMode(r, u, v) {
                u !== v &&
                  (this._cancelTween(),
                  this._resetToDefaultVisualState(u),
                  this._forceReapplyVisualState());
              }
              _onSetTransitionValue(r, u, v) {
                u !== v && this._forceReapplyVisualState();
              }
              _onElementComponentRemove(r) {
                this.entity === r && this._toggleHitElementListeners("off");
              }
              _onElementComponentAdd(r) {
                this.entity === r && this._toggleHitElementListeners("on");
              }
              _onImageElementLose() {
                this._cancelTween(),
                  this._resetToDefaultVisualState(this.transitionMode);
              }
              _onImageElementGain() {
                this._storeDefaultVisualState(),
                  this._forceReapplyVisualState();
              }
              _toggleHitElementListeners(r) {
                if (this.entity.element) {
                  const u = r === "on";
                  if (u && this._hasHitElementListeners) return;
                  this.entity.element[r](
                    "mouseenter",
                    this._onMouseEnter,
                    this
                  ),
                    this.entity.element[r](
                      "mouseleave",
                      this._onMouseLeave,
                      this
                    ),
                    this.entity.element[r](
                      "mousedown",
                      this._onMouseDown,
                      this
                    ),
                    this.entity.element[r]("mouseup", this._onMouseUp, this),
                    this.entity.element[r](
                      "touchstart",
                      this._onTouchStart,
                      this
                    ),
                    this.entity.element[r]("touchend", this._onTouchEnd, this),
                    this.entity.element[r](
                      "touchleave",
                      this._onTouchLeave,
                      this
                    ),
                    this.entity.element[r](
                      "touchcancel",
                      this._onTouchCancel,
                      this
                    ),
                    this.entity.element[r](
                      "selectstart",
                      this._onSelectStart,
                      this
                    ),
                    this.entity.element[r](
                      "selectend",
                      this._onSelectEnd,
                      this
                    ),
                    this.entity.element[r](
                      "selectenter",
                      this._onSelectEnter,
                      this
                    ),
                    this.entity.element[r](
                      "selectleave",
                      this._onSelectLeave,
                      this
                    ),
                    this.entity.element[r]("click", this._onClick, this),
                    (this._hasHitElementListeners = u);
                }
              }
              _storeDefaultVisualState() {
                if (this._imageReference.hasComponent("element")) {
                  const r = this._imageReference.entity.element;
                  r.type !== f.Dk &&
                    (this._storeDefaultColor(r.color),
                    this._storeDefaultOpacity(r.opacity),
                    this._storeDefaultSpriteAsset(r.spriteAsset),
                    this._storeDefaultSpriteFrame(r.spriteFrame));
                }
              }
              _storeDefaultColor(r) {
                (this._defaultTint.r = r.r),
                  (this._defaultTint.g = r.g),
                  (this._defaultTint.b = r.b);
              }
              _storeDefaultOpacity(r) {
                this._defaultTint.a = r;
              }
              _storeDefaultSpriteAsset(r) {
                this._defaultSpriteAsset = r;
              }
              _storeDefaultSpriteFrame(r) {
                this._defaultSpriteFrame = r;
              }
              _onSetColor(r) {
                this._isApplyingTint ||
                  (this._storeDefaultColor(r), this._forceReapplyVisualState());
              }
              _onSetOpacity(r) {
                this._isApplyingTint ||
                  (this._storeDefaultOpacity(r),
                  this._forceReapplyVisualState());
              }
              _onSetSpriteAsset(r) {
                this._isApplyingSprite ||
                  (this._storeDefaultSpriteAsset(r),
                  this._forceReapplyVisualState());
              }
              _onSetSpriteFrame(r) {
                this._isApplyingSprite ||
                  (this._storeDefaultSpriteFrame(r),
                  this._forceReapplyVisualState());
              }
              _onMouseEnter(r) {
                (this._isHovering = !0),
                  this._updateVisualState(),
                  this._fireIfActive("mouseenter", r);
              }
              _onMouseLeave(r) {
                (this._isHovering = !1),
                  (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("mouseleave", r);
              }
              _onMouseDown(r) {
                (this._isPressed = !0),
                  this._updateVisualState(),
                  this._fireIfActive("mousedown", r);
              }
              _onMouseUp(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("mouseup", r);
              }
              _onTouchStart(r) {
                (this._isPressed = !0),
                  this._updateVisualState(),
                  this._fireIfActive("touchstart", r);
              }
              _onTouchEnd(r) {
                r.event.preventDefault(),
                  (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("touchend", r);
              }
              _onTouchLeave(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("touchleave", r);
              }
              _onTouchCancel(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("touchcancel", r);
              }
              _onSelectStart(r) {
                (this._isPressed = !0),
                  this._updateVisualState(),
                  this._fireIfActive("selectstart", r);
              }
              _onSelectEnd(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("selectend", r);
              }
              _onSelectEnter(r) {
                this._hoveringCounter++,
                  this._hoveringCounter === 1 &&
                    ((this._isHovering = !0), this._updateVisualState()),
                  this._fireIfActive("selectenter", r);
              }
              _onSelectLeave(r) {
                this._hoveringCounter--,
                  this._hoveringCounter === 0 &&
                    ((this._isHovering = !1),
                    (this._isPressed = !1),
                    this._updateVisualState()),
                  this._fireIfActive("selectleave", r);
              }
              _onClick(r) {
                this._fireIfActive("click", r);
              }
              _fireIfActive(r, u) {
                this.data.active && this.fire(r, u);
              }
              _updateVisualState(r) {
                const u = this._visualState,
                  v = this._determineVisualState();
                if ((u !== v || r) && this.enabled)
                  switch (
                    ((this._visualState = v),
                    u === s.HOVER && this._fireIfActive("hoverend"),
                    u === s.PRESSED && this._fireIfActive("pressedend"),
                    v === s.HOVER && this._fireIfActive("hoverstart"),
                    v === s.PRESSED && this._fireIfActive("pressedstart"),
                    this.transitionMode)
                  ) {
                    case h.Z: {
                      const _ = l[this._visualState],
                        m = this[_];
                      this._applyTint(m);
                      break;
                    }
                    case h.s: {
                      const _ = n[this._visualState],
                        m = o[this._visualState],
                        g = this[_],
                        T = this[m];
                      this._applySprite(g, T);
                      break;
                    }
                  }
              }
              _forceReapplyVisualState() {
                this._updateVisualState(!0);
              }
              _resetToDefaultVisualState(r) {
                if (this._imageReference.hasComponent("element"))
                  switch (r) {
                    case h.Z:
                      this._cancelTween(),
                        this._applyTintImmediately(this._defaultTint);
                      break;
                    case h.s:
                      this._applySprite(
                        this._defaultSpriteAsset,
                        this._defaultSpriteFrame
                      );
                      break;
                  }
              }
              _determineVisualState() {
                if (this.active) {
                  if (this._isPressed) return s.PRESSED;
                  if (this._isHovering) return s.HOVER;
                } else return s.INACTIVE;
                return s.DEFAULT;
              }
              _applySprite(r, u) {
                (u = u || 0),
                  this._imageReference.hasComponent("element") &&
                    ((this._isApplyingSprite = !0),
                    this._imageReference.entity.element.spriteAsset !== r &&
                      (this._imageReference.entity.element.spriteAsset = r),
                    this._imageReference.entity.element.spriteFrame !== u &&
                      (this._imageReference.entity.element.spriteFrame = u),
                    (this._isApplyingSprite = !1));
              }
              _applyTint(r) {
                this._cancelTween(),
                  this.fadeDuration === 0
                    ? this._applyTintImmediately(r)
                    : this._applyTintWithTween(r);
              }
              _applyTintImmediately(r) {
                if (
                  !r ||
                  !this._imageReference.hasComponent("element") ||
                  this._imageReference.entity.element.type === f.Dk
                )
                  return;
                const u = e(r);
                (this._isApplyingTint = !0),
                  u.equals(this._imageReference.entity.element.color) ||
                    (this._imageReference.entity.element.color = u),
                  this._imageReference.entity.element.opacity !== r.a &&
                    (this._imageReference.entity.element.opacity = r.a),
                  (this._isApplyingTint = !1);
              }
              _applyTintWithTween(r) {
                if (
                  !r ||
                  !this._imageReference.hasComponent("element") ||
                  this._imageReference.entity.element.type === f.Dk
                )
                  return;
                const u = e(r),
                  v = this._imageReference.entity.element.color,
                  _ = this._imageReference.entity.element.opacity;
                (u.equals(v) && r.a === _) ||
                  (this._tweenInfo = {
                    startTime: (0, A.t)(),
                    from: new y.Q(v.r, v.g, v.b, _),
                    to: r.clone(),
                    lerpColor: new y.Q(),
                  });
              }
              _updateTintTween() {
                const r = (0, A.t)() - this._tweenInfo.startTime;
                let u = this.fadeDuration === 0 ? 1 : r / this.fadeDuration;
                if (((u = x.D.clamp(u, 0, 1)), Math.abs(u - 1) > 1e-5)) {
                  const v = this._tweenInfo.lerpColor;
                  v.lerp(this._tweenInfo.from, this._tweenInfo.to, u),
                    this._applyTintImmediately(new y.Q(v.r, v.g, v.b, v.a));
                } else
                  this._applyTintImmediately(this._tweenInfo.to),
                    this._cancelTween();
              }
              _cancelTween() {
                delete this._tweenInfo;
              }
              onUpdate() {
                this._tweenInfo && this._updateTintTween();
              }
              onEnable() {
                (this._isHovering = !1),
                  (this._hoveringCounter = 0),
                  (this._isPressed = !1),
                  this._imageReference.onParentComponentEnable(),
                  this._toggleHitElementListeners("on"),
                  this._forceReapplyVisualState();
              }
              onDisable() {
                this._toggleHitElementListeners("off"),
                  this._resetToDefaultVisualState(this.transitionMode);
              }
              onRemove() {
                this._toggleLifecycleListeners("off", this.system),
                  this.onDisable();
              }
            }
            function e(t) {
              return new y.Q(t.r, t.g, t.b);
            }
          },
          8593: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => A, s: () => x });
            const A = 0,
              x = 1;
          },
          6732: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => l });
            var A = a(4124),
              x = a(2930),
              y = a(5339),
              c = a(5227),
              d = a(5596),
              h = a(8593);
            class f {
              constructor() {
                (this.enabled = !0),
                  (this.active = !0),
                  (this.imageEntity = null),
                  (this.hitPadding = new d.Z()),
                  (this.transitionMode = h.Z),
                  (this.hoverTint = new c.Q(0.75, 0.75, 0.75)),
                  (this.pressedTint = new c.Q(0.5, 0.5, 0.5)),
                  (this.inactiveTint = new c.Q(0.25, 0.25, 0.25)),
                  (this.fadeDuration = 0),
                  (this.hoverSpriteAsset = null),
                  (this.hoverSpriteFrame = 0),
                  (this.pressedSpriteAsset = null),
                  (this.pressedSpriteFrame = 0),
                  (this.inactiveSpriteAsset = null),
                  (this.inactiveSpriteFrame = 0);
              }
            }
            const s = [
              "enabled",
              "active",
              { name: "imageEntity", type: "entity" },
              { name: "hitPadding", type: "vec4" },
              "transitionMode",
              { name: "hoverTint", type: "rgba" },
              { name: "pressedTint", type: "rgba" },
              { name: "inactiveTint", type: "rgba" },
              "fadeDuration",
              "hoverSpriteAsset",
              "hoverSpriteFrame",
              "pressedSpriteAsset",
              "pressedSpriteFrame",
              "inactiveSpriteAsset",
              "inactiveSpriteFrame",
            ];
            class l extends x.r {
              constructor(o) {
                super(o),
                  (this.id = "button"),
                  (this.ComponentType = y.Q),
                  (this.DataType = f),
                  (this.schema = s),
                  this.on("beforeremove", this._onRemoveComponent, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(o, i, e) {
                super.initializeComponentData(o, i, s);
              }
              onUpdate(o) {
                const i = this.store;
                for (const e in i) {
                  const t = i[e].entity,
                    r = t.button;
                  r.enabled && t.enabled && r.onUpdate();
                }
              }
              _onRemoveComponent(o, i) {
                i.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            A.u._buildAccessors(y.Q.prototype, s);
          },
          2364: (xe, V, a) => {
            "use strict";
            a.d(V, { n: () => h });
            var A = a(9391),
              x = a(5463),
              y = a(4639),
              c = a(4124),
              d = a(2205);
            class h extends c.u {
              constructor(s, l) {
                super(s, l),
                  (this.onPostprocessing = null),
                  (this.onPreRender = null),
                  (this.onPostRender = null),
                  (this._renderSceneDepthMap = 0),
                  (this._renderSceneColorMap = 0),
                  (this._sceneDepthMapRequested = !1),
                  (this._sceneColorMapRequested = !1),
                  (this._priority = 0),
                  (this._disablePostEffectsLayer = A.Qe),
                  (this._camera = new x.i()),
                  (this._camera.node = l),
                  (this._postEffects = new d.T(s.app, this));
              }
              setShaderPass(s) {
                const l = y.p.get(this.system.app.graphicsDevice),
                  n = s ? l.allocate(s, { isForward: !0 }) : null;
                return (this._camera.shaderPassInfo = n), n.index;
              }
              getShaderPass() {
                var s;
                return (s = this._camera.shaderPassInfo) == null
                  ? void 0
                  : s.name;
              }
              set aperture(s) {
                this._camera.aperture = s;
              }
              get aperture() {
                return this._camera.aperture;
              }
              set aspectRatio(s) {
                this._camera.aspectRatio = s;
              }
              get aspectRatio() {
                return this._camera.aspectRatio;
              }
              set aspectRatioMode(s) {
                this._camera.aspectRatioMode = s;
              }
              get aspectRatioMode() {
                return this._camera.aspectRatioMode;
              }
              set calculateProjection(s) {
                this._camera.calculateProjection = s;
              }
              get calculateProjection() {
                return this._camera.calculateProjection;
              }
              set calculateTransform(s) {
                this._camera.calculateTransform = s;
              }
              get calculateTransform() {
                return this._camera.calculateTransform;
              }
              get camera() {
                return this._camera;
              }
              set clearColor(s) {
                this._camera.clearColor = s;
              }
              get clearColor() {
                return this._camera.clearColor;
              }
              set clearColorBuffer(s) {
                (this._camera.clearColorBuffer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get clearColorBuffer() {
                return this._camera.clearColorBuffer;
              }
              set clearDepthBuffer(s) {
                (this._camera.clearDepthBuffer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get clearDepthBuffer() {
                return this._camera.clearDepthBuffer;
              }
              set clearStencilBuffer(s) {
                (this._camera.clearStencilBuffer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get clearStencilBuffer() {
                return this._camera.clearStencilBuffer;
              }
              set cullFaces(s) {
                this._camera.cullFaces = s;
              }
              get cullFaces() {
                return this._camera.cullFaces;
              }
              set disablePostEffectsLayer(s) {
                (this._disablePostEffectsLayer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get disablePostEffectsLayer() {
                return this._disablePostEffectsLayer;
              }
              set farClip(s) {
                this._camera.farClip = s;
              }
              get farClip() {
                return this._camera.farClip;
              }
              set flipFaces(s) {
                this._camera.flipFaces = s;
              }
              get flipFaces() {
                return this._camera.flipFaces;
              }
              set fov(s) {
                this._camera.fov = s;
              }
              get fov() {
                return this._camera.fov;
              }
              get frustum() {
                return this._camera.frustum;
              }
              set frustumCulling(s) {
                this._camera.frustumCulling = s;
              }
              get frustumCulling() {
                return this._camera.frustumCulling;
              }
              set horizontalFov(s) {
                this._camera.horizontalFov = s;
              }
              get horizontalFov() {
                return this._camera.horizontalFov;
              }
              set layers(s) {
                const l = this._camera.layers;
                for (let n = 0; n < l.length; n++) {
                  const o = this.system.app.scene.layers.getLayerById(l[n]);
                  o && o.removeCamera(this);
                }
                if (
                  ((this._camera.layers = s),
                  !(!this.enabled || !this.entity.enabled))
                )
                  for (let n = 0; n < s.length; n++) {
                    const o = this.system.app.scene.layers.getLayerById(s[n]);
                    o && o.addCamera(this);
                  }
              }
              get layers() {
                return this._camera.layers;
              }
              get layersSet() {
                return this._camera.layersSet;
              }
              set nearClip(s) {
                this._camera.nearClip = s;
              }
              get nearClip() {
                return this._camera.nearClip;
              }
              set orthoHeight(s) {
                this._camera.orthoHeight = s;
              }
              get orthoHeight() {
                return this._camera.orthoHeight;
              }
              get postEffects() {
                return this._postEffects;
              }
              get postEffectsEnabled() {
                return this._postEffects.enabled;
              }
              set priority(s) {
                (this._priority = s), this.dirtyLayerCompositionCameras();
              }
              get priority() {
                return this._priority;
              }
              set projection(s) {
                this._camera.projection = s;
              }
              get projection() {
                return this._camera.projection;
              }
              get projectionMatrix() {
                return this._camera.projectionMatrix;
              }
              set rect(s) {
                (this._camera.rect = s),
                  this.fire("set:rect", this._camera.rect);
              }
              get rect() {
                return this._camera.rect;
              }
              set renderSceneColorMap(s) {
                s && !this._sceneColorMapRequested
                  ? (this.requestSceneColorMap(!0),
                    (this._sceneColorMapRequested = !0))
                  : this._sceneColorMapRequested &&
                    (this.requestSceneColorMap(!1),
                    (this._sceneColorMapRequested = !1));
              }
              get renderSceneColorMap() {
                return this._renderSceneColorMap > 0;
              }
              set renderSceneDepthMap(s) {
                s && !this._sceneDepthMapRequested
                  ? (this.requestSceneDepthMap(!0),
                    (this._sceneDepthMapRequested = !0))
                  : this._sceneDepthMapRequested &&
                    (this.requestSceneDepthMap(!1),
                    (this._sceneDepthMapRequested = !1));
              }
              get renderSceneDepthMap() {
                return this._renderSceneDepthMap > 0;
              }
              set renderTarget(s) {
                (this._camera.renderTarget = s),
                  this.dirtyLayerCompositionCameras();
              }
              get renderTarget() {
                return this._camera.renderTarget;
              }
              set scissorRect(s) {
                this._camera.scissorRect = s;
              }
              get scissorRect() {
                return this._camera.scissorRect;
              }
              set sensitivity(s) {
                this._camera.sensitivity = s;
              }
              get sensitivity() {
                return this._camera.sensitivity;
              }
              set shutter(s) {
                this._camera.shutter = s;
              }
              get shutter() {
                return this._camera.shutter;
              }
              get viewMatrix() {
                return this._camera.viewMatrix;
              }
              _enableDepthLayer(s) {
                if (this.layers.find((n) => n === A.$9)) {
                  const n = this.system.app.scene.layers.getLayerById(A.$9);
                  s
                    ? n == null || n.incrementCounter()
                    : n == null || n.decrementCounter();
                } else if (s) return !1;
                return !0;
              }
              requestSceneColorMap(s) {
                (this._renderSceneColorMap += s ? 1 : -1),
                  this._enableDepthLayer(s);
              }
              requestSceneDepthMap(s) {
                (this._renderSceneDepthMap += s ? 1 : -1),
                  this._enableDepthLayer(s);
              }
              dirtyLayerCompositionCameras() {
                const s = this.system.app.scene.layers;
                s._dirtyCameras = !0;
              }
              screenToWorld(s, l, n, o) {
                const i = this.system.app.graphicsDevice,
                  e = i.clientRect.width,
                  t = i.clientRect.height;
                return this._camera.screenToWorld(s, l, n, e, t, o);
              }
              worldToScreen(s, l) {
                const n = this.system.app.graphicsDevice,
                  o = n.clientRect.width,
                  i = n.clientRect.height;
                return this._camera.worldToScreen(s, o, i, l);
              }
              onAppPrerender() {
                (this._camera._viewMatDirty = !0),
                  (this._camera._viewProjMatDirty = !0);
              }
              addCameraToLayers() {
                const s = this.layers;
                for (let l = 0; l < s.length; l++) {
                  const n = this.system.app.scene.layers.getLayerById(s[l]);
                  n && n.addCamera(this);
                }
              }
              removeCameraFromLayers() {
                const s = this.layers;
                for (let l = 0; l < s.length; l++) {
                  const n = this.system.app.scene.layers.getLayerById(s[l]);
                  n && n.removeCamera(this);
                }
              }
              onLayersChanged(s, l) {
                this.addCameraToLayers(),
                  s.off("add", this.onLayerAdded, this),
                  s.off("remove", this.onLayerRemoved, this),
                  l.on("add", this.onLayerAdded, this),
                  l.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(s) {
                this.layers.indexOf(s.id) < 0 || s.addCamera(this);
              }
              onLayerRemoved(s) {
                this.layers.indexOf(s.id) < 0 || s.removeCamera(this);
              }
              onEnable() {
                const s = this.system,
                  l = s.app.scene,
                  n = l.layers;
                s.addCamera(this),
                  l.on("set:layers", this.onLayersChanged, this),
                  n &&
                    (n.on("add", this.onLayerAdded, this),
                    n.on("remove", this.onLayerRemoved, this)),
                  this.enabled &&
                    this.entity.enabled &&
                    this.addCameraToLayers(),
                  this.postEffects.enable();
              }
              onDisable() {
                const s = this.system,
                  l = s.app.scene,
                  n = l.layers;
                this.postEffects.disable(),
                  this.removeCameraFromLayers(),
                  l.off("set:layers", this.onLayersChanged, this),
                  n &&
                    (n.off("add", this.onLayerAdded, this),
                    n.off("remove", this.onLayerRemoved, this)),
                  s.removeCamera(this);
              }
              onRemove() {
                this.onDisable(), this.off();
              }
              calculateAspectRatio(s) {
                const l = this.system.app.graphicsDevice,
                  n = s ? s.width : l.width,
                  o = s ? s.height : l.height;
                return (n * this.rect.z) / (o * this.rect.w);
              }
              frameUpdate(s) {
                this.aspectRatioMode === A.LF &&
                  (this.aspectRatio = this.calculateAspectRatio(s));
              }
              startXr(s, l, n) {
                this.system.app.xr.start(this, s, l, n);
              }
              endXr(s) {
                if (!this._camera.xr) {
                  s && s(new Error("Camera is not in XR"));
                  return;
                }
                this._camera.xr.end(s);
              }
              copy(s) {
                (this.aperture = s.aperture),
                  (this.aspectRatio = s.aspectRatio),
                  (this.aspectRatioMode = s.aspectRatioMode),
                  (this.calculateProjection = s.calculateProjection),
                  (this.calculateTransform = s.calculateTransform),
                  (this.clearColor = s.clearColor),
                  (this.clearColorBuffer = s.clearColorBuffer),
                  (this.clearDepthBuffer = s.clearDepthBuffer),
                  (this.clearStencilBuffer = s.clearStencilBuffer),
                  (this.cullFaces = s.cullFaces),
                  (this.disablePostEffectsLayer = s.disablePostEffectsLayer),
                  (this.farClip = s.farClip),
                  (this.flipFaces = s.flipFaces),
                  (this.fov = s.fov),
                  (this.frustumCulling = s.frustumCulling),
                  (this.horizontalFov = s.horizontalFov),
                  (this.layers = s.layers),
                  (this.nearClip = s.nearClip),
                  (this.orthoHeight = s.orthoHeight),
                  (this.priority = s.priority),
                  (this.projection = s.projection),
                  (this.rect = s.rect),
                  (this.renderTarget = s.renderTarget),
                  (this.scissorRect = s.scissorRect),
                  (this.sensitivity = s.sensitivity),
                  (this.shutter = s.shutter);
              }
            }
          },
          2205: (xe, V, a) => {
            "use strict";
            a.d(V, { T: () => h });
            var A = a(1630),
              x = a(9061),
              y = a(1208),
              c = a(9391);
            class d {
              constructor(s, l) {
                (this.effect = s),
                  (this.inputTarget = l),
                  (this.outputTarget = null),
                  (this.name = s.constructor.name);
              }
            }
            class h {
              constructor(s, l) {
                (this.app = s),
                  (this.camera = l),
                  (this.destinationRenderTarget = null),
                  (this.effects = []),
                  (this.enabled = !1),
                  (this.depthTarget = null),
                  l.on("set:rect", this.onCameraRectChanged, this);
              }
              _allocateColorBuffer(s, l) {
                var n, o, i, e;
                const t = this.camera.rect,
                  r = Math.floor(
                    t.z *
                      ((n =
                        (o = this.camera.renderTarget) == null
                          ? void 0
                          : o.width) != null
                        ? n
                        : this.app.graphicsDevice.width)
                  ),
                  u = Math.floor(
                    t.w *
                      ((i =
                        (e = this.camera.renderTarget) == null
                          ? void 0
                          : e.height) != null
                        ? i
                        : this.app.graphicsDevice.height)
                  );
                return new y.g(this.app.graphicsDevice, {
                  name: l,
                  format: s,
                  width: r,
                  height: u,
                  mipmaps: !1,
                  minFilter: A.uhC,
                  magFilter: A.uhC,
                  addressU: A.vq6,
                  addressV: A.vq6,
                });
              }
              _createOffscreenTarget(s, l) {
                const n = this.app.graphicsDevice,
                  o = (l && n.getHdrFormat(!1, !0, !1, !1)) || A.Lxj,
                  i =
                    this.camera.entity.name +
                    "-posteffect-" +
                    this.effects.length,
                  e = this._allocateColorBuffer(o, i);
                return new x.O({
                  colorBuffer: e,
                  depth: s,
                  stencil: s && this.app.graphicsDevice.supportsStencil,
                  samples: s ? n.samples : 1,
                });
              }
              _resizeOffscreenTarget(s) {
                const l = s.colorBuffer.format,
                  n = s.colorBuffer.name;
                s.destroyFrameBuffers(),
                  s.destroyTextureBuffers(),
                  (s._colorBuffer = this._allocateColorBuffer(l, n)),
                  (s._colorBuffers = [s._colorBuffer]);
              }
              _destroyOffscreenTarget(s) {
                s.destroyTextureBuffers(), s.destroy();
              }
              addEffect(s) {
                const l = this.effects,
                  n = l.length === 0,
                  o = this._createOffscreenTarget(n, s.hdr),
                  i = new d(s, o);
                l.push(i),
                  (this._sourceTarget = i.inputTarget),
                  l.length > 1 &&
                    (l[l.length - 2].outputTarget = i.inputTarget),
                  (this._newPostEffect = s),
                  s.needsDepthBuffer && this._requestDepthMap(),
                  this.enable(),
                  (this._newPostEffect = void 0);
              }
              removeEffect(s) {
                let l = -1;
                for (let n = 0, o = this.effects.length; n < o; n++)
                  if (this.effects[n].effect === s) {
                    l = n;
                    break;
                  }
                l >= 0 &&
                  (l > 0
                    ? (this.effects[l - 1].outputTarget =
                        l + 1 < this.effects.length
                          ? this.effects[l + 1].inputTarget
                          : null)
                    : this.effects.length > 1 &&
                      (this.effects[1].inputTarget._depth ||
                        (this._destroyOffscreenTarget(
                          this.effects[1].inputTarget
                        ),
                        (this.effects[1].inputTarget =
                          this._createOffscreenTarget(!0, this.effects[1].hdr)),
                        (this._sourceTarget = this.effects[1].inputTarget)),
                      (this.camera.renderTarget = this.effects[1].inputTarget)),
                  this._destroyOffscreenTarget(this.effects[l].inputTarget),
                  this.effects.splice(l, 1)),
                  this.enabled && s.needsDepthBuffer && this._releaseDepthMap(),
                  this.effects.length === 0 && this.disable();
              }
              _requestDepthMaps() {
                for (let s = 0, l = this.effects.length; s < l; s++) {
                  const n = this.effects[s].effect;
                  this._newPostEffect !== n &&
                    n.needsDepthBuffer &&
                    this._requestDepthMap();
                }
              }
              _releaseDepthMaps() {
                for (let s = 0, l = this.effects.length; s < l; s++)
                  this.effects[s].effect.needsDepthBuffer &&
                    this._releaseDepthMap();
              }
              _requestDepthMap() {
                const s = this.app.scene.layers.getLayerById(c.$9);
                s &&
                  (s.incrementCounter(), this.camera.requestSceneDepthMap(!0));
              }
              _releaseDepthMap() {
                const s = this.app.scene.layers.getLayerById(c.$9);
                s &&
                  (s.decrementCounter(), this.camera.requestSceneDepthMap(!1));
              }
              destroy() {
                for (let s = 0, l = this.effects.length; s < l; s++)
                  this.effects[s].inputTarget.destroy();
                (this.effects.length = 0), this.disable();
              }
              enable() {
                !this.enabled &&
                  this.effects.length &&
                  ((this.enabled = !0),
                  this._requestDepthMaps(),
                  this.app.graphicsDevice.on(
                    "resizecanvas",
                    this._onCanvasResized,
                    this
                  ),
                  (this.destinationRenderTarget = this.camera.renderTarget),
                  (this.camera.renderTarget = this.effects[0].inputTarget),
                  (this.camera.onPostprocessing = () => {
                    if (this.enabled) {
                      let s = null;
                      const l = this.effects.length;
                      if (l)
                        for (let n = 0; n < l; n++) {
                          const o = this.effects[n];
                          let i = o.outputTarget;
                          n === l - 1 &&
                            ((s = this.camera.rect),
                            this.destinationRenderTarget &&
                              (i = this.destinationRenderTarget)),
                            o.effect.render(o.inputTarget, i, s);
                        }
                    }
                  }));
              }
              disable() {
                this.enabled &&
                  ((this.enabled = !1),
                  this.app.graphicsDevice.off(
                    "resizecanvas",
                    this._onCanvasResized,
                    this
                  ),
                  this._releaseDepthMaps(),
                  this._destroyOffscreenTarget(this._sourceTarget),
                  (this.camera.renderTarget = null),
                  (this.camera.onPostprocessing = null));
              }
              _onCanvasResized(s, l) {
                const n = this.camera.rect,
                  o = this.app.graphicsDevice;
                (this.camera.camera.aspectRatio =
                  (o.width * n.z) / (o.height * n.w)),
                  this.resizeRenderTargets();
              }
              resizeRenderTargets() {
                const s = this.camera.rect,
                  l = Math.floor(s.z * this.app.graphicsDevice.width),
                  n = Math.floor(s.w * this.app.graphicsDevice.height),
                  o = this.effects;
                for (let i = 0, e = o.length; i < e; i++) {
                  const t = o[i];
                  (t.inputTarget.width !== l || t.inputTarget.height !== n) &&
                    this._resizeOffscreenTarget(t.inputTarget);
                }
              }
              onCameraRectChanged(s, l, n) {
                this.enabled && this.resizeRenderTargets();
              }
            }
          },
          9619: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => l });
            var A = a(1014),
              x = a(5227),
              y = a(5596),
              c = a(4124),
              d = a(2930),
              h = a(2364);
            class f {
              constructor() {
                this.enabled = !0;
              }
            }
            const s = ["enabled"];
            class l extends d.r {
              constructor(o) {
                super(o),
                  (this.cameras = []),
                  (this.id = "camera"),
                  (this.ComponentType = h.n),
                  (this.DataType = f),
                  (this.schema = s),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.on("prerender", this.onAppPrerender, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(o, i, e) {
                e = [
                  "aspectRatio",
                  "aspectRatioMode",
                  "calculateProjection",
                  "calculateTransform",
                  "clearColor",
                  "clearColorBuffer",
                  "clearDepthBuffer",
                  "clearStencilBuffer",
                  "renderSceneColorMap",
                  "renderSceneDepthMap",
                  "cullFaces",
                  "farClip",
                  "flipFaces",
                  "fov",
                  "frustumCulling",
                  "horizontalFov",
                  "layers",
                  "renderTarget",
                  "nearClip",
                  "orthoHeight",
                  "projection",
                  "priority",
                  "rect",
                  "scissorRect",
                  "aperture",
                  "shutter",
                  "sensitivity",
                ];
                for (let t = 0; t < e.length; t++) {
                  const r = e[t];
                  if (i.hasOwnProperty(r)) {
                    const u = i[r];
                    switch (r) {
                      case "rect":
                      case "scissorRect":
                        Array.isArray(u)
                          ? (o[r] = new y.Z(u[0], u[1], u[2], u[3]))
                          : (o[r] = u);
                        break;
                      case "clearColor":
                        Array.isArray(u)
                          ? (o[r] = new x.Q(u[0], u[1], u[2], u[3]))
                          : (o[r] = u);
                        break;
                      default:
                        o[r] = u;
                        break;
                    }
                  }
                }
                super.initializeComponentData(o, i, ["enabled"]);
              }
              cloneComponent(o, i) {
                const e = o.camera;
                return this.addComponent(i, {
                  aspectRatio: e.aspectRatio,
                  aspectRatioMode: e.aspectRatioMode,
                  calculateProjection: e.calculateProjection,
                  calculateTransform: e.calculateTransform,
                  clearColor: e.clearColor,
                  clearColorBuffer: e.clearColorBuffer,
                  clearDepthBuffer: e.clearDepthBuffer,
                  clearStencilBuffer: e.clearStencilBuffer,
                  renderSceneDepthMap: e.renderSceneDepthMap,
                  renderSceneColorMap: e.renderSceneColorMap,
                  cullFaces: e.cullFaces,
                  enabled: e.enabled,
                  farClip: e.farClip,
                  flipFaces: e.flipFaces,
                  fov: e.fov,
                  frustumCulling: e.frustumCulling,
                  horizontalFov: e.horizontalFov,
                  layers: e.layers,
                  renderTarget: e.renderTarget,
                  nearClip: e.nearClip,
                  orthoHeight: e.orthoHeight,
                  projection: e.projection,
                  priority: e.priority,
                  rect: e.rect,
                  scissorRect: e.scissorRect,
                  aperture: e.aperture,
                  sensitivity: e.sensitivity,
                  shutter: e.shutter,
                });
              }
              onBeforeRemove(o, i) {
                this.removeCamera(i);
              }
              onUpdate(o) {}
              onAppPrerender() {
                for (let o = 0, i = this.cameras.length; o < i; o++)
                  this.cameras[o].onAppPrerender();
              }
              addCamera(o) {
                this.cameras.push(o), (0, A.Z)(this.cameras);
              }
              removeCamera(o) {
                const i = this.cameras.indexOf(o);
                i >= 0 && (this.cameras.splice(i, 1), (0, A.Z)(this.cameras));
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            c.u._buildAccessors(h.n.prototype, s);
          },
          8751: (xe, V, a) => {
            "use strict";
            a.d(V, { I: () => f });
            var A = a(3021),
              x = a(7481),
              y = a(3953),
              c = a(4124);
            const d = new x.e(),
              h = new A.k();
            class f extends c.u {
              constructor(l, n) {
                super(l, n),
                  (this._compoundParent = null),
                  (this._hasOffset = !1),
                  this.entity.on("insert", this._onInsert, this),
                  this.on("set_type", this.onSetType, this),
                  this.on("set_halfExtents", this.onSetHalfExtents, this),
                  this.on("set_linearOffset", this.onSetOffset, this),
                  this.on("set_angularOffset", this.onSetOffset, this),
                  this.on("set_radius", this.onSetRadius, this),
                  this.on("set_height", this.onSetHeight, this),
                  this.on("set_axis", this.onSetAxis, this),
                  this.on("set_asset", this.onSetAsset, this),
                  this.on("set_renderAsset", this.onSetRenderAsset, this),
                  this.on("set_model", this.onSetModel, this),
                  this.on("set_render", this.onSetRender, this);
              }
              onSetType(l, n, o) {
                n !== o && this.system.changeType(this, n, o);
              }
              onSetHalfExtents(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  i === "box" &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetOffset(l, n, o) {
                (this._hasOffset =
                  !this.data.linearOffset.equals(x.e.ZERO) ||
                  !this.data.angularOffset.equals(A.k.IDENTITY)),
                  this.data.initialized &&
                    this.system.recreatePhysicalShapes(this);
              }
              onSetRadius(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  (i === "sphere" ||
                    i === "capsule" ||
                    i === "cylinder" ||
                    i === "cone") &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetHeight(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  (i === "capsule" || i === "cylinder" || i === "cone") &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetAxis(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  (i === "capsule" || i === "cylinder" || i === "cone") &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetAsset(l, n, o) {
                const i = this.system.app.assets;
                if (n) {
                  const e = i.get(n);
                  e && e.off("remove", this.onAssetRemoved, this);
                }
                if (o) {
                  o instanceof y.V && (this.data.asset = o.id);
                  const e = i.get(this.data.asset);
                  e &&
                    (e.off("remove", this.onAssetRemoved, this),
                    e.on("remove", this.onAssetRemoved, this));
                }
                this.data.initialized &&
                  this.data.type === "mesh" &&
                  (o || (this.data.model = null),
                  this.system.recreatePhysicalShapes(this));
              }
              onSetRenderAsset(l, n, o) {
                const i = this.system.app.assets;
                if (n) {
                  const e = i.get(n);
                  e && e.off("remove", this.onRenderAssetRemoved, this);
                }
                if (o) {
                  o instanceof y.V && (this.data.renderAsset = o.id);
                  const e = i.get(this.data.renderAsset);
                  e &&
                    (e.off("remove", this.onRenderAssetRemoved, this),
                    e.on("remove", this.onRenderAssetRemoved, this));
                }
                this.data.initialized &&
                  this.data.type === "mesh" &&
                  (o || (this.data.render = null),
                  this.system.recreatePhysicalShapes(this));
              }
              onSetModel(l, n, o) {
                this.data.initialized &&
                  this.data.type === "mesh" &&
                  this.system.implementations.mesh.doRecreatePhysicalShape(
                    this
                  );
              }
              onSetRender(l, n, o) {
                this.onSetModel(l, n, o);
              }
              onAssetRemoved(l) {
                l.off("remove", this.onAssetRemoved, this),
                  this.data.asset === l.id && (this.asset = null);
              }
              onRenderAssetRemoved(l) {
                l.off("remove", this.onRenderAssetRemoved, this),
                  this.data.renderAsset === l.id && (this.renderAsset = null);
              }
              _getCompoundChildShapeIndex(l) {
                const n = this.data.shape,
                  o = n.getNumChildShapes();
                for (let i = 0; i < o; i++)
                  if (n.getChildShape(i).ptr === l.ptr) return i;
                return null;
              }
              _onInsert(l) {
                if (typeof Ammo != "undefined") {
                  if (this._compoundParent)
                    this.system.recreatePhysicalShapes(this);
                  else if (!this.entity.rigidbody) {
                    let n = this.entity.parent;
                    for (; n; ) {
                      if (n.collision && n.collision.type === "compound") {
                        n.collision.shape.getNumChildShapes() === 0
                          ? this.system.recreatePhysicalShapes(n.collision)
                          : this.system.recreatePhysicalShapes(this);
                        break;
                      }
                      n = n.parent;
                    }
                  }
                }
              }
              _updateCompound() {
                const l = this.entity;
                if (l._dirtyWorld) {
                  let n = l._dirtyLocal,
                    o = l;
                  for (
                    ;
                    o &&
                    !n &&
                    !(o.collision && o.collision === this._compoundParent);

                  )
                    o._dirtyLocal && (n = !0), (o = o.parent);
                  if (n) {
                    l.forEach(
                      this.system.implementations.compound
                        ._updateEachDescendantTransform,
                      l
                    );
                    const i = this._compoundParent.entity.rigidbody;
                    i && i.activate();
                  }
                }
              }
              getShapePosition() {
                const l = this.entity.getPosition();
                if (this._hasOffset) {
                  const n = this.entity.getRotation(),
                    o = this.data.linearOffset;
                  return h.copy(n).transformVector(o, d), d.add(l);
                }
                return l;
              }
              getShapeRotation() {
                const l = this.entity.getRotation();
                return this._hasOffset
                  ? h.copy(l).mul(this.data.angularOffset)
                  : l;
              }
              onEnable() {
                if (
                  this.data.type === "mesh" &&
                  (this.data.asset || this.data.renderAsset) &&
                  this.data.initialized
                ) {
                  const l = this.system.app.assets.get(
                    this.data.asset || this.data.renderAsset
                  );
                  if (l && (!l.resource || !this.data.shape)) {
                    this.system.recreatePhysicalShapes(this);
                    return;
                  }
                }
                if (this.entity.rigidbody)
                  this.entity.rigidbody.enabled &&
                    this.entity.rigidbody.enableSimulation();
                else if (this._compoundParent && this !== this._compoundParent)
                  if (this._compoundParent.shape.getNumChildShapes() === 0)
                    this.system.recreatePhysicalShapes(this._compoundParent);
                  else {
                    const l = this.system._getNodeTransform(
                      this.entity,
                      this._compoundParent.entity
                    );
                    this._compoundParent.shape.addChildShape(
                      l,
                      this.data.shape
                    ),
                      Ammo.destroy(l),
                      this._compoundParent.entity.rigidbody &&
                        this._compoundParent.entity.rigidbody.activate();
                  }
                else this.entity.trigger && this.entity.trigger.enable();
              }
              onDisable() {
                this.entity.rigidbody
                  ? this.entity.rigidbody.disableSimulation()
                  : this._compoundParent && this !== this._compoundParent
                  ? this._compoundParent.entity._destroying ||
                    (this.system._removeCompoundChild(
                      this._compoundParent,
                      this.data.shape
                    ),
                    this._compoundParent.entity.rigidbody &&
                      this._compoundParent.entity.rigidbody.activate())
                  : this.entity.trigger && this.entity.trigger.disable();
              }
              onBeforeRemove() {
                this.asset && (this.asset = null),
                  this.renderAsset && (this.renderAsset = null),
                  this.entity.off("insert", this._onInsert, this),
                  this.off();
              }
            }
          },
          6686: (xe, V, a) => {
            "use strict";
            a.d(V, { v: () => X });
            var A = a(8484),
              x = a(3021),
              y = a(7481),
              c = a(1630),
              d = a(3035),
              h = a(9611),
              f = a(4124),
              s = a(2930),
              l = a(8751);
            class n {
              constructor() {
                (this.enabled = !0),
                  (this.type = "box"),
                  (this.halfExtents = new y.e(0.5, 0.5, 0.5)),
                  (this.linearOffset = new y.e()),
                  (this.angularOffset = new x.k()),
                  (this.radius = 0.5),
                  (this.axis = 1),
                  (this.height = 2),
                  (this.asset = null),
                  (this.renderAsset = null),
                  (this.shape = null),
                  (this.model = null),
                  (this.render = null),
                  (this.initialized = !1);
              }
            }
            var o = a(8379);
            let i, e, t;
            class r {
              constructor(Q, te, ae) {
                (this.entity = te.entity),
                  (this.component = te),
                  (this.app = Q),
                  typeof Ammo != "undefined" &&
                    !i &&
                    ((i = new Ammo.btVector3()),
                    (e = new Ammo.btQuaternion()),
                    (t = new Ammo.btTransform())),
                  this.initialize(ae);
              }
              initialize(Q) {
                const te = this.entity,
                  ae = Q.shape;
                if (ae && typeof Ammo != "undefined") {
                  te.trigger && te.trigger.destroy();
                  const Z = 1,
                    J = this.component;
                  if (J) {
                    const _e = J.getShapePosition(),
                      L = J.getShapeRotation();
                    i.setValue(_e.x, _e.y, _e.z),
                      e.setValue(L.x, L.y, L.z, L.w);
                  } else {
                    const _e = te.getPosition(),
                      L = te.getRotation();
                    i.setValue(_e.x, _e.y, _e.z),
                      e.setValue(L.x, L.y, L.z, L.w);
                  }
                  t.setOrigin(i), t.setRotation(e);
                  const ve = this.app.systems.rigidbody.createBody(Z, ae, t);
                  ve.setRestitution(0),
                    ve.setFriction(0),
                    ve.setDamping(0, 0),
                    i.setValue(0, 0, 0),
                    ve.setLinearFactor(i),
                    ve.setAngularFactor(i),
                    ve.setCollisionFlags(ve.getCollisionFlags() | o.ce),
                    (ve.entity = te),
                    (this.body = ve),
                    this.component.enabled && te.enabled && this.enable();
                }
              }
              destroy() {
                const Q = this.body;
                Q &&
                  (this.disable(), this.app.systems.rigidbody.destroyBody(Q));
              }
              _getEntityTransform(Q) {
                const te = this.component;
                if (te) {
                  const ae = te.getShapePosition(),
                    Z = te.getShapeRotation();
                  i.setValue(ae.x, ae.y, ae.z), e.setValue(Z.x, Z.y, Z.z, Z.w);
                } else {
                  const ae = this.entity.getPosition(),
                    Z = this.entity.getRotation();
                  i.setValue(ae.x, ae.y, ae.z), e.setValue(Z.x, Z.y, Z.z, Z.w);
                }
                Q.setOrigin(i), Q.setRotation(e);
              }
              updateTransform() {
                this._getEntityTransform(t);
                const Q = this.body;
                Q.setWorldTransform(t), Q.activate();
              }
              enable() {
                const Q = this.body;
                if (!Q) return;
                const te = this.app.systems;
                te.rigidbody.addBody(Q, o.lB, o.EE ^ o.lB),
                  te.rigidbody._triggers.push(this),
                  Q.forceActivationState(o.UQ),
                  this.updateTransform();
              }
              disable() {
                const Q = this.body;
                if (!Q) return;
                const te = this.app.systems,
                  ae = te.rigidbody._triggers.indexOf(this);
                ae > -1 && te.rigidbody._triggers.splice(ae, 1),
                  te.rigidbody.removeBody(Q),
                  Q.forceActivationState(o.$5);
              }
            }
            const u = new A.$(),
              v = new y.e(),
              _ = new y.e(),
              m = new x.k(),
              g = new d.t(),
              T = [
                "enabled",
                "type",
                "halfExtents",
                "linearOffset",
                "angularOffset",
                "radius",
                "axis",
                "height",
                "asset",
                "renderAsset",
                "shape",
                "model",
                "render",
              ];
            class E {
              constructor(Q) {
                this.system = Q;
              }
              beforeInitialize(Q, te) {
                (te.shape = null),
                  (te.model = new h.K()),
                  (te.model.graph = new d.t());
              }
              afterInitialize(Q, te) {
                this.recreatePhysicalShapes(Q), (Q.data.initialized = !0);
              }
              reset(Q, te) {
                this.beforeInitialize(Q, te), this.afterInitialize(Q, te);
              }
              recreatePhysicalShapes(Q) {
                const te = Q.entity,
                  ae = Q.data;
                if (typeof Ammo != "undefined") {
                  te.trigger && (te.trigger.destroy(), delete te.trigger),
                    ae.shape &&
                      (Q._compoundParent &&
                        (this.system._removeCompoundChild(
                          Q._compoundParent,
                          ae.shape
                        ),
                        Q._compoundParent.entity.rigidbody &&
                          Q._compoundParent.entity.rigidbody.activate()),
                      this.destroyShape(ae)),
                    (ae.shape = this.createPhysicalShape(Q.entity, ae));
                  const Z = !Q._compoundParent;
                  if (
                    ae.type === "compound" &&
                    (!Q._compoundParent || Q === Q._compoundParent)
                  )
                    (Q._compoundParent = Q),
                      te.forEach(this._addEachDescendant, Q);
                  else if (
                    ae.type !== "compound" &&
                    (Q._compoundParent &&
                      Q === Q._compoundParent &&
                      te.forEach(
                        this.system.implementations.compound
                          ._updateEachDescendant,
                        Q
                      ),
                    !Q.rigidbody)
                  ) {
                    Q._compoundParent = null;
                    let J = te.parent;
                    for (; J; ) {
                      if (J.collision && J.collision.type === "compound") {
                        Q._compoundParent = J.collision;
                        break;
                      }
                      J = J.parent;
                    }
                  }
                  Q._compoundParent &&
                    Q !== Q._compoundParent &&
                    (Z && Q._compoundParent.shape.getNumChildShapes() === 0
                      ? this.system.recreatePhysicalShapes(Q._compoundParent)
                      : (this.system.updateCompoundChildTransform(te),
                        Q._compoundParent.entity.rigidbody &&
                          Q._compoundParent.entity.rigidbody.activate())),
                    te.rigidbody
                      ? (te.rigidbody.disableSimulation(),
                        te.rigidbody.createBody(),
                        te.enabled &&
                          te.rigidbody.enabled &&
                          te.rigidbody.enableSimulation())
                      : Q._compoundParent ||
                        (te.trigger
                          ? te.trigger.initialize(ae)
                          : (te.trigger = new r(this.system.app, Q, ae)));
                }
              }
              createPhysicalShape(Q, te) {}
              updateTransform(Q, te, ae, Z) {
                Q.entity.trigger && Q.entity.trigger.updateTransform();
              }
              destroyShape(Q) {
                Q.shape && (Ammo.destroy(Q.shape), (Q.shape = null));
              }
              beforeRemove(Q, te) {
                te.data.shape &&
                  (te._compoundParent &&
                    !te._compoundParent.entity._destroying &&
                    (this.system._removeCompoundChild(
                      te._compoundParent,
                      te.data.shape
                    ),
                    te._compoundParent.entity.rigidbody &&
                      te._compoundParent.entity.rigidbody.activate()),
                  (te._compoundParent = null),
                  this.destroyShape(te.data));
              }
              remove(Q, te) {
                Q.rigidbody &&
                  Q.rigidbody.body &&
                  Q.rigidbody.disableSimulation(),
                  Q.trigger && (Q.trigger.destroy(), delete Q.trigger);
              }
              clone(Q, te) {
                const ae = this.system.store[Q.getGuid()],
                  Z = {
                    enabled: ae.data.enabled,
                    type: ae.data.type,
                    halfExtents: [
                      ae.data.halfExtents.x,
                      ae.data.halfExtents.y,
                      ae.data.halfExtents.z,
                    ],
                    linearOffset: [
                      ae.data.linearOffset.x,
                      ae.data.linearOffset.y,
                      ae.data.linearOffset.z,
                    ],
                    angularOffset: [
                      ae.data.angularOffset.x,
                      ae.data.angularOffset.y,
                      ae.data.angularOffset.z,
                      ae.data.angularOffset.w,
                    ],
                    radius: ae.data.radius,
                    axis: ae.data.axis,
                    height: ae.data.height,
                    asset: ae.data.asset,
                    renderAsset: ae.data.renderAsset,
                    model: ae.data.model,
                    render: ae.data.render,
                  };
                return this.system.addComponent(te, Z);
              }
            }
            class M extends E {
              createPhysicalShape(Q, te) {
                if (typeof Ammo != "undefined") {
                  const ae = te.halfExtents,
                    Z = new Ammo.btVector3(
                      ae ? ae.x : 0.5,
                      ae ? ae.y : 0.5,
                      ae ? ae.z : 0.5
                    ),
                    J = new Ammo.btBoxShape(Z);
                  return Ammo.destroy(Z), J;
                }
              }
            }
            class R extends E {
              createPhysicalShape(Q, te) {
                if (typeof Ammo != "undefined")
                  return new Ammo.btSphereShape(te.radius);
              }
            }
            class P extends E {
              createPhysicalShape(Q, te) {
                var ae, Z, J;
                const ve = (ae = te.axis) != null ? ae : 1,
                  _e = (Z = te.radius) != null ? Z : 0.5,
                  L = Math.max(((J = te.height) != null ? J : 2) - 2 * _e, 0);
                let ge = null;
                if (typeof Ammo != "undefined")
                  switch (ve) {
                    case 0:
                      ge = new Ammo.btCapsuleShapeX(_e, L);
                      break;
                    case 1:
                      ge = new Ammo.btCapsuleShape(_e, L);
                      break;
                    case 2:
                      ge = new Ammo.btCapsuleShapeZ(_e, L);
                      break;
                  }
                return ge;
              }
            }
            class F extends E {
              createPhysicalShape(Q, te) {
                var ae, Z, J;
                const ve = (ae = te.axis) != null ? ae : 1,
                  _e = (Z = te.radius) != null ? Z : 0.5,
                  L = (J = te.height) != null ? J : 1;
                let ge = null,
                  k = null;
                if (typeof Ammo != "undefined")
                  switch (ve) {
                    case 0:
                      (ge = new Ammo.btVector3(L * 0.5, _e, _e)),
                        (k = new Ammo.btCylinderShapeX(ge));
                      break;
                    case 1:
                      (ge = new Ammo.btVector3(_e, L * 0.5, _e)),
                        (k = new Ammo.btCylinderShape(ge));
                      break;
                    case 2:
                      (ge = new Ammo.btVector3(_e, _e, L * 0.5)),
                        (k = new Ammo.btCylinderShapeZ(ge));
                      break;
                  }
                return ge && Ammo.destroy(ge), k;
              }
            }
            class b extends E {
              createPhysicalShape(Q, te) {
                var ae, Z, J;
                const ve = (ae = te.axis) != null ? ae : 1,
                  _e = (Z = te.radius) != null ? Z : 0.5,
                  L = (J = te.height) != null ? J : 1;
                let ge = null;
                if (typeof Ammo != "undefined")
                  switch (ve) {
                    case 0:
                      ge = new Ammo.btConeShapeX(_e, L);
                      break;
                    case 1:
                      ge = new Ammo.btConeShape(_e, L);
                      break;
                    case 2:
                      ge = new Ammo.btConeShapeZ(_e, L);
                      break;
                  }
                return ge;
              }
            }
            class D extends E {
              beforeInitialize(Q, te) {}
              createAmmoMesh(Q, te, ae) {
                let Z;
                if (this.system._triMeshCache[Q.id])
                  Z = this.system._triMeshCache[Q.id];
                else {
                  const ge = Q.vertexBuffer,
                    k = ge.getFormat();
                  let j, B;
                  for (let N = 0; N < k.elements.length; N++) {
                    const W = k.elements[N];
                    if (W.name === c.JYe) {
                      (B = new Float32Array(ge.lock(), W.offset)),
                        (j = W.stride / 4);
                      break;
                    }
                  }
                  const $ = [];
                  Q.getIndices($);
                  const le = Q.primitive[0].count / 3,
                    O = new Ammo.btVector3(),
                    Y = new Ammo.btVector3(),
                    ne = new Ammo.btVector3();
                  let de, re, I;
                  const w = Q.primitive[0].base;
                  (Z = new Ammo.btTriangleMesh()),
                    (this.system._triMeshCache[Q.id] = Z);
                  for (let N = 0; N < le; N++)
                    (de = $[w + N * 3] * j),
                      (re = $[w + N * 3 + 1] * j),
                      (I = $[w + N * 3 + 2] * j),
                      O.setValue(B[de], B[de + 1], B[de + 2]),
                      Y.setValue(B[re], B[re + 1], B[re + 2]),
                      ne.setValue(B[I], B[I + 1], B[I + 2]),
                      Z.addTriangle(O, Y, ne, !0);
                  Ammo.destroy(O), Ammo.destroy(Y), Ammo.destroy(ne);
                }
                const J = !0,
                  ve = new Ammo.btBvhTriangleMeshShape(Z, J),
                  _e = this.system._getNodeScaling(te);
                ve.setLocalScaling(_e), Ammo.destroy(_e);
                const L = this.system._getNodeTransform(te);
                ae.addChildShape(L, ve), Ammo.destroy(L);
              }
              createPhysicalShape(Q, te) {
                if (typeof Ammo != "undefined" && (te.model || te.render)) {
                  const ae = new Ammo.btCompoundShape();
                  if (te.model) {
                    const _e = te.model.meshInstances;
                    for (let L = 0; L < _e.length; L++)
                      this.createAmmoMesh(_e[L].mesh, _e[L].node, ae);
                  } else if (te.render) {
                    const _e = te.render.meshes;
                    for (let L = 0; L < _e.length; L++)
                      this.createAmmoMesh(_e[L], g, ae);
                  }
                  const J = Q.getWorldTransform().getScale(),
                    ve = new Ammo.btVector3(J.x, J.y, J.z);
                  return ae.setLocalScaling(ve), Ammo.destroy(ve), ae;
                }
              }
              recreatePhysicalShapes(Q) {
                const te = Q.data;
                if (
                  (te.renderAsset || te.asset) &&
                  Q.enabled &&
                  Q.entity.enabled
                ) {
                  this.loadAsset(
                    Q,
                    te.renderAsset || te.asset,
                    te.renderAsset ? "render" : "model"
                  );
                  return;
                }
                this.doRecreatePhysicalShape(Q);
              }
              loadAsset(Q, te, ae) {
                const Z = Q.data,
                  J = this.system.app.assets,
                  ve = J.get(te);
                ve
                  ? (ve.ready((_e) => {
                      (Z[ae] = _e.resource), this.doRecreatePhysicalShape(Q);
                    }),
                    J.load(ve))
                  : J.once("add:" + te, (_e) => {
                      _e.ready((L) => {
                        (Z[ae] = L.resource), this.doRecreatePhysicalShape(Q);
                      }),
                        J.load(_e);
                    });
              }
              doRecreatePhysicalShape(Q) {
                const te = Q.entity,
                  ae = Q.data;
                ae.model || ae.render
                  ? (this.destroyShape(ae),
                    (ae.shape = this.createPhysicalShape(te, ae)),
                    te.rigidbody
                      ? (te.rigidbody.disableSimulation(),
                        te.rigidbody.createBody(),
                        te.enabled &&
                          te.rigidbody.enabled &&
                          te.rigidbody.enableSimulation())
                      : te.trigger
                      ? te.trigger.initialize(ae)
                      : (te.trigger = new r(this.system.app, Q, ae)))
                  : (this.beforeRemove(te, Q), this.remove(te, ae));
              }
              updateTransform(Q, te, ae, Z) {
                if (Q.shape) {
                  const ve = Q.entity.getWorldTransform().getScale(),
                    _e = Q.shape.getLocalScaling();
                  (ve.x !== _e.x() || ve.y !== _e.y() || ve.z !== _e.z()) &&
                    this.doRecreatePhysicalShape(Q);
                }
                super.updateTransform(Q, te, ae, Z);
              }
              destroyShape(Q) {
                if (!Q.shape) return;
                const te = Q.shape.getNumChildShapes();
                for (let ae = 0; ae < te; ae++) {
                  const Z = Q.shape.getChildShape(ae);
                  Ammo.destroy(Z);
                }
                Ammo.destroy(Q.shape), (Q.shape = null);
              }
            }
            class G extends E {
              createPhysicalShape(Q, te) {
                if (typeof Ammo != "undefined")
                  return new Ammo.btCompoundShape();
              }
              _addEachDescendant(Q) {
                !Q.collision ||
                  Q.rigidbody ||
                  ((Q.collision._compoundParent = this),
                  Q !== this.entity &&
                    Q.collision.system.recreatePhysicalShapes(Q.collision));
              }
              _updateEachDescendant(Q) {
                Q.collision &&
                  Q.collision._compoundParent === this &&
                  ((Q.collision._compoundParent = null),
                  Q !== this.entity &&
                    !Q.rigidbody &&
                    Q.collision.system.recreatePhysicalShapes(Q.collision));
              }
              _updateEachDescendantTransform(Q) {
                !Q.collision ||
                  Q.collision._compoundParent !==
                    this.collision._compoundParent ||
                  this.collision.system.updateCompoundChildTransform(Q);
              }
            }
            class X extends s.r {
              constructor(Q) {
                super(Q),
                  (this.id = "collision"),
                  (this.ComponentType = l.I),
                  (this.DataType = n),
                  (this.schema = T),
                  (this.implementations = {}),
                  (this._triMeshCache = {}),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.on("remove", this.onRemove, this);
              }
              initializeComponentData(Q, te, ae) {
                ae = [
                  "type",
                  "halfExtents",
                  "radius",
                  "axis",
                  "height",
                  "shape",
                  "model",
                  "asset",
                  "render",
                  "renderAsset",
                  "enabled",
                  "linearOffset",
                  "angularOffset",
                ];
                const Z = {};
                for (let _e = 0, L = ae.length; _e < L; _e++) {
                  const ge = ae[_e];
                  Z[ge] = te[ge];
                }
                let J;
                if (
                  (te.hasOwnProperty("asset")
                    ? ((J = ae.indexOf("model")),
                      J !== -1 && ae.splice(J, 1),
                      (J = ae.indexOf("render")),
                      J !== -1 && ae.splice(J, 1))
                    : te.hasOwnProperty("model") &&
                      ((J = ae.indexOf("asset")), J !== -1 && ae.splice(J, 1)),
                  Z.type || (Z.type = Q.data.type),
                  (Q.data.type = Z.type),
                  Array.isArray(Z.halfExtents) &&
                    (Z.halfExtents = new y.e(Z.halfExtents)),
                  Array.isArray(Z.linearOffset) &&
                    (Z.linearOffset = new y.e(Z.linearOffset)),
                  Array.isArray(Z.angularOffset))
                ) {
                  const _e = Z.angularOffset;
                  _e.length === 3
                    ? (Z.angularOffset = new x.k().setFromEulerAngles(
                        _e[0],
                        _e[1],
                        _e[2]
                      ))
                    : (Z.angularOffset = new x.k(Z.angularOffset));
                }
                const ve = this._createImplementation(Z.type);
                ve.beforeInitialize(Q, Z),
                  super.initializeComponentData(Q, Z, ae),
                  ve.afterInitialize(Q, Z);
              }
              _createImplementation(Q) {
                if (this.implementations[Q] === void 0) {
                  let te;
                  switch (Q) {
                    case "box":
                      te = new M(this);
                      break;
                    case "sphere":
                      te = new R(this);
                      break;
                    case "capsule":
                      te = new P(this);
                      break;
                    case "cylinder":
                      te = new F(this);
                      break;
                    case "cone":
                      te = new b(this);
                      break;
                    case "mesh":
                      te = new D(this);
                      break;
                    case "compound":
                      te = new G(this);
                      break;
                  }
                  this.implementations[Q] = te;
                }
                return this.implementations[Q];
              }
              _getImplementation(Q) {
                return this.implementations[Q.collision.data.type];
              }
              cloneComponent(Q, te) {
                return this._getImplementation(Q).clone(Q, te);
              }
              onBeforeRemove(Q, te) {
                this.implementations[te.data.type].beforeRemove(Q, te),
                  te.onBeforeRemove();
              }
              onRemove(Q, te) {
                this.implementations[te.type].remove(Q, te);
              }
              updateCompoundChildTransform(Q) {
                if (
                  (this._removeCompoundChild(
                    Q.collision._compoundParent,
                    Q.collision.data.shape
                  ),
                  Q.enabled && Q.collision.enabled)
                ) {
                  const te = this._getNodeTransform(
                    Q,
                    Q.collision._compoundParent.entity
                  );
                  Q.collision._compoundParent.shape.addChildShape(
                    te,
                    Q.collision.data.shape
                  ),
                    Ammo.destroy(te);
                }
              }
              _removeCompoundChild(Q, te) {
                if (Q.shape.removeChildShape) Q.shape.removeChildShape(te);
                else {
                  const ae = Q._getCompoundChildShapeIndex(te);
                  ae !== null && Q.shape.removeChildShapeByIndex(ae);
                }
              }
              onTransformChanged(Q, te, ae, Z) {
                this.implementations[Q.data.type].updateTransform(Q, te, ae, Z);
              }
              changeType(Q, te, ae) {
                this.implementations[te].beforeRemove(Q.entity, Q),
                  this.implementations[te].remove(Q.entity, Q.data),
                  this._createImplementation(ae).reset(Q, Q.data);
              }
              recreatePhysicalShapes(Q) {
                this.implementations[Q.data.type].recreatePhysicalShapes(Q);
              }
              _calculateNodeRelativeTransform(Q, te) {
                if (Q === te) {
                  const ae = Q.getWorldTransform().getScale();
                  u.setScale(ae.x, ae.y, ae.z);
                } else
                  this._calculateNodeRelativeTransform(Q.parent, te),
                    u.mul(Q.getLocalTransform());
              }
              _getNodeScaling(Q) {
                const ae = Q.getWorldTransform().getScale();
                return new Ammo.btVector3(ae.x, ae.y, ae.z);
              }
              _getNodeTransform(Q, te) {
                let ae, Z;
                te
                  ? (this._calculateNodeRelativeTransform(Q, te),
                    (ae = v),
                    (Z = m),
                    u.getTranslation(ae),
                    Z.setFromMat4(u))
                  : ((ae = Q.getPosition()), (Z = Q.getRotation()));
                const J = new Ammo.btQuaternion(),
                  ve = new Ammo.btTransform();
                ve.setIdentity();
                const _e = ve.getOrigin(),
                  L = Q.collision;
                if (L && L._hasOffset) {
                  const ge = L.data.linearOffset,
                    k = L.data.angularOffset,
                    j = _;
                  m.copy(Z).transformVector(ge, j),
                    j.add(ae),
                    m.copy(Z).mul(k),
                    _e.setValue(j.x, j.y, j.z),
                    J.setValue(m.x, m.y, m.z, m.w);
                } else
                  _e.setValue(ae.x, ae.y, ae.z), J.setValue(Z.x, Z.y, Z.z, Z.w);
                return ve.setRotation(J), Ammo.destroy(J), Ammo.destroy(_e), ve;
              }
              destroy() {
                for (const Q in this._triMeshCache)
                  Ammo.destroy(this._triMeshCache[Q]);
                (this._triMeshCache = null), super.destroy();
              }
            }
            f.u._buildAccessors(l.I.prototype, T);
          },
          4124: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => x });
            var A = a(8976);
            class x extends A.J {
              constructor(c, d) {
                super(),
                  (this.system = void 0),
                  (this.entity = void 0),
                  (this.system = c),
                  (this.entity = d),
                  this.system.schema &&
                    !this._accessorsBuilt &&
                    this.buildAccessors(this.system.schema),
                  this.on("set", function (h, f, s) {
                    this.fire("set_" + h, h, f, s);
                  }),
                  this.on("set_enabled", this.onSetEnabled, this);
              }
              static _buildAccessors(c, d) {
                d.forEach(function (h) {
                  const f = typeof h == "object" ? h.name : h;
                  Object.defineProperty(c, f, {
                    get: function () {
                      return this.data[f];
                    },
                    set: function (s) {
                      const l = this.data,
                        n = l[f];
                      (l[f] = s), this.fire("set", f, n, s);
                    },
                    configurable: !0,
                  });
                }),
                  (c._accessorsBuilt = !0);
              }
              buildAccessors(c) {
                x._buildAccessors(this, c);
              }
              onSetEnabled(c, d, h) {
                d !== h &&
                  this.entity.enabled &&
                  (h ? this.onEnable() : this.onDisable());
              }
              onEnable() {}
              onDisable() {}
              onPostStateChange() {}
              get data() {
                const c = this.system.store[this.entity.getGuid()];
                return c ? c.data : null;
              }
            }
          },
          6543: (xe, V, a) => {
            "use strict";
            a.d(V, { _: () => E });
            var A = a(8484),
              x = a(7994),
              y = a(7481),
              c = a(5596),
              d = a(1630),
              h = a(9391),
              f = a(5041),
              s = a(2640),
              l = a(371),
              n = a(4124),
              o = a(9189),
              i = a(8596),
              e = a(4885);
            const t = new y.e(),
              r = new A.$(),
              u = new y.e(),
              v = new y.e(),
              _ = new A.$(),
              m = new A.$(),
              g = new A.$(),
              T = new A.$();
            class E extends n.u {
              constructor(P, F) {
                super(P, F),
                  (this._beingInitialized = !1),
                  (this._anchor = new c.Z()),
                  (this._localAnchor = new c.Z()),
                  (this._pivot = new x.Z()),
                  (this._width = this._calculatedWidth = 32),
                  (this._height = this._calculatedHeight = 32),
                  (this._margin = new c.Z(0, 0, -32, -32)),
                  (this._modelTransform = new A.$()),
                  (this._screenToWorld = new A.$()),
                  (this._anchorTransform = new A.$()),
                  (this._anchorDirty = !0),
                  (this._parentWorldTransform = new A.$()),
                  (this._screenTransform = new A.$()),
                  (this._screenCorners = [
                    new y.e(),
                    new y.e(),
                    new y.e(),
                    new y.e(),
                  ]),
                  (this._canvasCorners = [
                    new x.Z(),
                    new x.Z(),
                    new x.Z(),
                    new x.Z(),
                  ]),
                  (this._worldCorners = [
                    new y.e(),
                    new y.e(),
                    new y.e(),
                    new y.e(),
                  ]),
                  (this._cornersDirty = !0),
                  (this._canvasCornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this.entity.on("insert", this._onInsert, this),
                  this._patch(),
                  (this.screen = null),
                  (this._type = o.Dk),
                  (this._image = null),
                  (this._text = null),
                  (this._group = null),
                  (this._drawOrder = 0),
                  (this._fitMode = o.$B),
                  (this._useInput = !1),
                  (this._layers = [h.Qe]),
                  (this._addedModels = []),
                  (this._batchGroupId = -1),
                  (this._offsetReadAt = 0),
                  (this._maskOffset = 0.5),
                  (this._maskedBy = null);
              }
              get _absLeft() {
                return this._localAnchor.x + this._margin.x;
              }
              get _absRight() {
                return this._localAnchor.z - this._margin.z;
              }
              get _absTop() {
                return this._localAnchor.w - this._margin.w;
              }
              get _absBottom() {
                return this._localAnchor.y + this._margin.y;
              }
              get _hasSplitAnchorsX() {
                return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
              }
              get _hasSplitAnchorsY() {
                return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
              }
              get aabb() {
                return this._image
                  ? this._image.aabb
                  : this._text
                  ? this._text.aabb
                  : null;
              }
              set anchor(P) {
                P instanceof c.Z
                  ? this._anchor.copy(P)
                  : this._anchor.set(...P),
                  !this.entity._parent && !this.screen
                    ? this._calculateLocalAnchors()
                    : this._calculateSize(
                        this._hasSplitAnchorsX,
                        this._hasSplitAnchorsY
                      ),
                  (this._anchorDirty = !0),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:anchor", this._anchor);
              }
              get anchor() {
                return this._anchor;
              }
              set batchGroupId(P) {
                if (this._batchGroupId !== P) {
                  if (this.entity.enabled && this._batchGroupId >= 0) {
                    var F;
                    (F = this.system.app.batcher) == null ||
                      F.remove(f.w.ELEMENT, this.batchGroupId, this.entity);
                  }
                  if (this.entity.enabled && P >= 0) {
                    var b;
                    (b = this.system.app.batcher) == null ||
                      b.insert(f.w.ELEMENT, P, this.entity);
                  }
                  P < 0 &&
                    this._batchGroupId >= 0 &&
                    this.enabled &&
                    this.entity.enabled &&
                    (this._image && this._image._renderable.model
                      ? this.addModelToLayers(this._image._renderable.model)
                      : this._text &&
                        this._text._model &&
                        this.addModelToLayers(this._text._model)),
                    (this._batchGroupId = P);
                }
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set bottom(P) {
                this._margin.y = P;
                const F = this.entity.getLocalPosition(),
                  b = this._absTop,
                  D = this._localAnchor.y + P;
                this._setHeight(b - D),
                  (F.y = P + this._calculatedHeight * this._pivot.y),
                  this.entity.setLocalPosition(F);
              }
              get bottom() {
                return this._margin.y;
              }
              set calculatedWidth(P) {
                this._setCalculatedWidth(P, !0);
              }
              get calculatedWidth() {
                return this._calculatedWidth;
              }
              set calculatedHeight(P) {
                this._setCalculatedHeight(P, !0);
              }
              get calculatedHeight() {
                return this._calculatedHeight;
              }
              get canvasCorners() {
                if (
                  !this._canvasCornersDirty ||
                  !this.screen ||
                  !this.screen.screen.screenSpace
                )
                  return this._canvasCorners;
                const P = this.system.app.graphicsDevice,
                  F = this.screenCorners,
                  b = P.canvas.clientWidth / P.width,
                  D = P.canvas.clientHeight / P.height;
                for (let G = 0; G < 4; G++)
                  this._canvasCorners[G].set(
                    F[G].x * b,
                    (P.height - F[G].y) * D
                  );
                return (this._canvasCornersDirty = !1), this._canvasCorners;
              }
              set drawOrder(P) {
                let F = 0;
                this.screen && (F = this.screen.screen.priority),
                  P > 16777215 && (P = 16777215),
                  (this._drawOrder = (F << 24) + P),
                  this.fire("set:draworder", this._drawOrder);
              }
              get drawOrder() {
                return this._drawOrder;
              }
              set height(P) {
                (this._height = P),
                  this._hasSplitAnchorsY || this._setCalculatedHeight(P, !0),
                  this.fire("set:height", this._height);
              }
              get height() {
                return this._height;
              }
              set layers(P) {
                if (this._addedModels.length)
                  for (let F = 0; F < this._layers.length; F++) {
                    const b = this.system.app.scene.layers.getLayerById(
                      this._layers[F]
                    );
                    if (b)
                      for (let D = 0; D < this._addedModels.length; D++)
                        b.removeMeshInstances(
                          this._addedModels[D].meshInstances
                        );
                  }
                if (
                  ((this._layers = P),
                  !(
                    !this.enabled ||
                    !this.entity.enabled ||
                    !this._addedModels.length
                  ))
                )
                  for (let F = 0; F < this._layers.length; F++) {
                    const b = this.system.app.scene.layers.getLayerById(
                      this._layers[F]
                    );
                    if (b)
                      for (let D = 0; D < this._addedModels.length; D++)
                        b.addMeshInstances(this._addedModels[D].meshInstances);
                  }
              }
              get layers() {
                return this._layers;
              }
              set left(P) {
                this._margin.x = P;
                const F = this.entity.getLocalPosition(),
                  b = this._absRight,
                  D = this._localAnchor.x + P;
                this._setWidth(b - D),
                  (F.x = P + this._calculatedWidth * this._pivot.x),
                  this.entity.setLocalPosition(F);
              }
              get left() {
                return this._margin.x;
              }
              set margin(P) {
                this._margin.copy(P),
                  this._calculateSize(!0, !0),
                  this.fire("set:margin", this._margin);
              }
              get margin() {
                return this._margin;
              }
              get maskedBy() {
                return this._maskedBy;
              }
              set pivot(P) {
                const { pivot: F, margin: b } = this,
                  D = F.x,
                  G = F.y;
                P instanceof x.Z ? F.copy(P) : F.set(...P);
                const X = b.x + b.z,
                  ie = F.x - D;
                (b.x += X * ie), (b.z -= X * ie);
                const Q = b.y + b.w,
                  te = F.y - G;
                (b.y += Q * te),
                  (b.w -= Q * te),
                  (this._anchorDirty = !0),
                  (this._cornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this._calculateSize(!1, !1),
                  this._flagChildrenAsDirty(),
                  this.fire("set:pivot", F);
              }
              get pivot() {
                return this._pivot;
              }
              set right(P) {
                this._margin.z = P;
                const F = this.entity.getLocalPosition(),
                  b = this._absLeft,
                  D = this._localAnchor.z - P;
                this._setWidth(D - b),
                  (F.x =
                    this._localAnchor.z -
                    this._localAnchor.x -
                    P -
                    this._calculatedWidth * (1 - this._pivot.x)),
                  this.entity.setLocalPosition(F);
              }
              get right() {
                return this._margin.z;
              }
              get screenCorners() {
                if (!this._cornersDirty || !this.screen)
                  return this._screenCorners;
                const P =
                  this.entity.parent &&
                  this.entity.parent.element &&
                  this.entity.parent.element.screenCorners[0];
                this._screenCorners[0].set(this._absLeft, this._absBottom, 0),
                  this._screenCorners[1].set(
                    this._absRight,
                    this._absBottom,
                    0
                  ),
                  this._screenCorners[2].set(this._absRight, this._absTop, 0),
                  this._screenCorners[3].set(this._absLeft, this._absTop, 0);
                const F = this.screen.screen.screenSpace;
                for (let b = 0; b < 4; b++)
                  this._screenTransform.transformPoint(
                    this._screenCorners[b],
                    this._screenCorners[b]
                  ),
                    F &&
                      this._screenCorners[b].mulScalar(
                        this.screen.screen.scale
                      ),
                    P && this._screenCorners[b].add(P);
                return (
                  (this._cornersDirty = !1),
                  (this._canvasCornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this._screenCorners
                );
              }
              get textWidth() {
                return this._text ? this._text.width : 0;
              }
              get textHeight() {
                return this._text ? this._text.height : 0;
              }
              set top(P) {
                this._margin.w = P;
                const F = this.entity.getLocalPosition(),
                  b = this._absBottom,
                  D = this._localAnchor.w - P;
                this._setHeight(D - b),
                  (F.y =
                    this._localAnchor.w -
                    this._localAnchor.y -
                    P -
                    this._calculatedHeight * (1 - this._pivot.y)),
                  this.entity.setLocalPosition(F);
              }
              get top() {
                return this._margin.w;
              }
              set type(P) {
                P !== this._type &&
                  ((this._type = P),
                  this._image && (this._image.destroy(), (this._image = null)),
                  this._text && (this._text.destroy(), (this._text = null)),
                  P === o.b5
                    ? (this._image = new i.C(this))
                    : P === o.l$ && (this._text = new e.S(this)));
              }
              get type() {
                return this._type;
              }
              set useInput(P) {
                this._useInput !== P &&
                  ((this._useInput = P),
                  this.system.app.elementInput
                    ? P
                      ? this.enabled &&
                        this.entity.enabled &&
                        this.system.app.elementInput.addElement(this)
                      : this.system.app.elementInput.removeElement(this)
                    : this._useInput,
                  this.fire("set:useInput", P));
              }
              get useInput() {
                return this._useInput;
              }
              set fitMode(P) {
                (this._fitMode = P),
                  this._calculateSize(!0, !0),
                  this._image && this._image.refreshMesh();
              }
              get fitMode() {
                return this._fitMode;
              }
              set width(P) {
                (this._width = P),
                  this._hasSplitAnchorsX || this._setCalculatedWidth(P, !0),
                  this.fire("set:width", this._width);
              }
              get width() {
                return this._width;
              }
              get worldCorners() {
                if (!this._worldCornersDirty) return this._worldCorners;
                if (this.screen) {
                  const P = this.screenCorners;
                  if (!this.screen.screen.screenSpace) {
                    _.copy(this.screen.screen._screenMatrix),
                      (_.data[13] = -_.data[13]),
                      _.mul2(this.screen.getWorldTransform(), _);
                    for (let F = 0; F < 4; F++)
                      _.transformPoint(P[F], this._worldCorners[F]);
                  }
                } else {
                  const P = this.entity.getLocalPosition();
                  _.setTranslate(-P.x, -P.y, -P.z),
                    m.setTRS(
                      y.e.ZERO,
                      this.entity.getLocalRotation(),
                      this.entity.getLocalScale()
                    ),
                    g.setTranslate(P.x, P.y, P.z);
                  const F = this.entity.parent
                    ? this.entity.parent
                    : this.entity;
                  T.copy(F.getWorldTransform()),
                    T.mul(g).mul(m).mul(_),
                    u.set(
                      P.x - this.pivot.x * this.calculatedWidth,
                      P.y - this.pivot.y * this.calculatedHeight,
                      P.z
                    ),
                    T.transformPoint(u, this._worldCorners[0]),
                    u.set(
                      P.x + (1 - this.pivot.x) * this.calculatedWidth,
                      P.y - this.pivot.y * this.calculatedHeight,
                      P.z
                    ),
                    T.transformPoint(u, this._worldCorners[1]),
                    u.set(
                      P.x + (1 - this.pivot.x) * this.calculatedWidth,
                      P.y + (1 - this.pivot.y) * this.calculatedHeight,
                      P.z
                    ),
                    T.transformPoint(u, this._worldCorners[2]),
                    u.set(
                      P.x - this.pivot.x * this.calculatedWidth,
                      P.y + (1 - this.pivot.y) * this.calculatedHeight,
                      P.z
                    ),
                    T.transformPoint(u, this._worldCorners[3]);
                }
                return (this._worldCornersDirty = !1), this._worldCorners;
              }
              _patch() {
                (this.entity._sync = this._sync),
                  (this.entity.setPosition = this._setPosition),
                  (this.entity.setLocalPosition = this._setLocalPosition);
              }
              _unpatch() {
                (this.entity._sync = l.w.prototype._sync),
                  (this.entity.setPosition = l.w.prototype.setPosition),
                  (this.entity.setLocalPosition =
                    l.w.prototype.setLocalPosition);
              }
              _setPosition(P, F, b) {
                if (!this.element.screen) {
                  l.w.prototype.setPosition.call(this, P, F, b);
                  return;
                }
                P instanceof y.e ? t.copy(P) : t.set(P, F, b),
                  this.getWorldTransform(),
                  r.copy(this.element._screenToWorld).invert(),
                  r.transformPoint(t, this.localPosition),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              _setLocalPosition(P, F, b) {
                P instanceof y.e
                  ? this.localPosition.copy(P)
                  : this.localPosition.set(P, F, b);
                const D = this.element,
                  G = this.localPosition,
                  X = D._pivot;
                (D._margin.x = G.x - D._calculatedWidth * X.x),
                  (D._margin.z =
                    D._localAnchor.z -
                    D._localAnchor.x -
                    D._calculatedWidth -
                    D._margin.x),
                  (D._margin.y = G.y - D._calculatedHeight * X.y),
                  (D._margin.w =
                    D._localAnchor.w -
                    D._localAnchor.y -
                    D._calculatedHeight -
                    D._margin.y),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              _sync() {
                const P = this.element,
                  F = P.screen;
                if (F) {
                  if (P._anchorDirty) {
                    let b = 0,
                      D = 0,
                      G = 0,
                      X = 1;
                    if (this._parent && this._parent.element)
                      (b = this._parent.element.calculatedWidth),
                        (D = this._parent.element.calculatedHeight),
                        (G = this._parent.element.pivot.x),
                        (X = this._parent.element.pivot.y);
                    else {
                      const ie = F.screen.resolution;
                      (b = ie.x / F.screen.scale), (D = ie.y / F.screen.scale);
                    }
                    P._anchorTransform.setTranslate(
                      b * (P.anchor.x - G),
                      -(D * (X - P.anchor.y)),
                      0
                    ),
                      (P._anchorDirty = !1),
                      P._calculateLocalAnchors();
                  }
                  P._sizeDirty && P._calculateSize(!1, !1);
                }
                if (this._dirtyLocal) {
                  this.localTransform.setTRS(
                    this.localPosition,
                    this.localRotation,
                    this.localScale
                  );
                  const b = this.localPosition,
                    D = P._pivot;
                  (P._margin.x = b.x - P._calculatedWidth * D.x),
                    (P._margin.z =
                      P._localAnchor.z -
                      P._localAnchor.x -
                      P._calculatedWidth -
                      P._margin.x),
                    (P._margin.y = b.y - P._calculatedHeight * D.y),
                    (P._margin.w =
                      P._localAnchor.w -
                      P._localAnchor.y -
                      P._calculatedHeight -
                      P._margin.y),
                    (this._dirtyLocal = !1);
                }
                if (!F)
                  return (
                    this._dirtyWorld &&
                      ((P._cornersDirty = !0),
                      (P._canvasCornersDirty = !0),
                      (P._worldCornersDirty = !0)),
                    l.w.prototype._sync.call(this)
                  );
                if (this._dirtyWorld) {
                  if (this._parent === null)
                    this.worldTransform.copy(this.localTransform);
                  else if (
                    (this._parent.element
                      ? P._screenToWorld.mul2(
                          this._parent.element._modelTransform,
                          P._anchorTransform
                        )
                      : P._screenToWorld.copy(P._anchorTransform),
                    P._modelTransform.mul2(
                      P._screenToWorld,
                      this.localTransform
                    ),
                    F)
                  ) {
                    P._screenToWorld.mul2(
                      F.screen._screenMatrix,
                      P._screenToWorld
                    ),
                      F.screen.screenSpace ||
                        P._screenToWorld.mul2(
                          F.worldTransform,
                          P._screenToWorld
                        ),
                      this.worldTransform.mul2(
                        P._screenToWorld,
                        this.localTransform
                      );
                    const b = P._parentWorldTransform;
                    b.setIdentity();
                    const D = this._parent;
                    D &&
                      D.element &&
                      D !== F &&
                      (_.setTRS(
                        y.e.ZERO,
                        D.getLocalRotation(),
                        D.getLocalScale()
                      ),
                      b.mul2(D.element._parentWorldTransform, _));
                    const G = u;
                    G.set(0, 0, this.localPosition.z);
                    const X = v;
                    X.set(
                      P._absLeft + P._pivot.x * P.calculatedWidth,
                      P._absBottom + P._pivot.y * P.calculatedHeight,
                      0
                    ),
                      _.setTranslate(-X.x, -X.y, -X.z),
                      m.setTRS(
                        G,
                        this.getLocalRotation(),
                        this.getLocalScale()
                      ),
                      g.setTranslate(X.x, X.y, X.z),
                      P._screenTransform
                        .mul2(P._parentWorldTransform, g)
                        .mul(m)
                        .mul(_),
                      (P._cornersDirty = !0),
                      (P._canvasCornersDirty = !0),
                      (P._worldCornersDirty = !0);
                  } else this.worldTransform.copy(P._modelTransform);
                  this._dirtyWorld = !1;
                }
              }
              _onInsert(P) {
                const F = this._parseUpToScreen();
                this.entity._dirtifyWorld(),
                  this._updateScreen(F.screen),
                  this._dirtifyMask();
              }
              _dirtifyMask() {
                let P = this.entity;
                for (; P; ) {
                  const F = P.parent;
                  if ((F === null || F.screen) && P.element) {
                    (!this.system._prerender ||
                      !this.system._prerender.length) &&
                      ((this.system._prerender = []),
                      this.system.app.once(
                        "prerender",
                        this._onPrerender,
                        this
                      ));
                    const b = this.system._prerender.indexOf(this.entity);
                    b >= 0 && this.system._prerender.splice(b, 1),
                      this.system._prerender.indexOf(P) < 0 &&
                        this.system._prerender.push(P);
                  }
                  P = F;
                }
              }
              _onPrerender() {
                for (let P = 0; P < this.system._prerender.length; P++) {
                  const F = this.system._prerender[P];
                  F.element && F.element.syncMask(1);
                }
                this.system._prerender.length = 0;
              }
              _bindScreen(P) {
                P._bindElement(this);
              }
              _unbindScreen(P) {
                P._unbindElement(this);
              }
              _updateScreen(P) {
                this.screen &&
                  this.screen !== P &&
                  this._unbindScreen(this.screen.screen);
                const F = this.screen;
                (this.screen = P),
                  this.screen && this._bindScreen(this.screen.screen),
                  this._calculateSize(
                    this._hasSplitAnchorsX,
                    this._hasSplitAnchorsY
                  ),
                  this.fire("set:screen", this.screen, F),
                  (this._anchorDirty = !0);
                const b = this.entity.children;
                for (let D = 0, G = b.length; D < G; D++)
                  b[D].element && b[D].element._updateScreen(P);
                this.screen && this.screen.screen.syncDrawOrder();
              }
              syncMask(P) {
                const F = this._parseUpToScreen();
                this._updateMask(F.mask, P);
              }
              _setMaskedBy(P) {
                const F = this._image || this._text;
                if (P) {
                  const b = P.element._image._maskRef;
                  F == null || F._setStencil(new s.n({ ref: b, func: d.sTv })),
                    (this._maskedBy = P);
                } else
                  F == null || F._setStencil(null), (this._maskedBy = null);
              }
              _updateMask(P, F) {
                if (P) {
                  if ((this._setMaskedBy(P), this.mask)) {
                    const X = P.element._image._maskRef,
                      ie = new s.n({ ref: X, func: d.sTv, zpass: d.G1V });
                    this._image._setStencil(ie),
                      (this._image._maskRef = F),
                      F++,
                      (P = this.entity);
                  }
                  const G = this.entity.children;
                  for (let X = 0, ie = G.length; X < ie; X++) {
                    var b;
                    (b = G[X].element) == null || b._updateMask(P, F);
                  }
                  this.mask && F--;
                } else {
                  if ((this._setMaskedBy(null), this.mask)) {
                    const X = new s.n({ ref: F, func: d.vpx, zpass: d.L4b });
                    this._image._setStencil(X),
                      (this._image._maskRef = F),
                      F++,
                      (P = this.entity);
                  }
                  const G = this.entity.children;
                  for (let X = 0, ie = G.length; X < ie; X++) {
                    var D;
                    (D = G[X].element) == null || D._updateMask(P, F);
                  }
                  this.mask && F--;
                }
              }
              _parseUpToScreen() {
                const P = { screen: null, mask: null };
                let F = this.entity._parent;
                for (; F && !F.screen; )
                  F.element && F.element.mask && (P.mask || (P.mask = F)),
                    (F = F.parent);
                return F && F.screen && (P.screen = F), P;
              }
              _onScreenResize(P) {
                (this._anchorDirty = !0),
                  (this._cornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this._calculateSize(
                    this._hasSplitAnchorsX,
                    this._hasSplitAnchorsY
                  ),
                  this.fire("screen:set:resolution", P);
              }
              _onScreenSpaceChange() {
                this.fire(
                  "screen:set:screenspace",
                  this.screen.screen.screenSpace
                );
              }
              _onScreenRemove() {
                this.screen &&
                  (this.screen._destroying
                    ? (this.screen = null)
                    : this._updateScreen(null));
              }
              _calculateLocalAnchors() {
                let P = 1e3,
                  F = 1e3;
                const b = this.entity._parent;
                if (b && b.element)
                  (P = b.element.calculatedWidth),
                    (F = b.element.calculatedHeight);
                else if (this.screen) {
                  const D = this.screen.screen.resolution,
                    G = this.screen.screen.scale;
                  (P = D.x / G), (F = D.y / G);
                }
                this._localAnchor.set(
                  this._anchor.x * P,
                  this._anchor.y * F,
                  this._anchor.z * P,
                  this._anchor.w * F
                );
              }
              getOffsetPosition(P, F) {
                const b = this.entity.getLocalPosition().clone();
                return (
                  (b.x += P),
                  (b.y += F),
                  this._screenToWorld.transformPoint(b, b),
                  b
                );
              }
              onLayersChanged(P, F) {
                this.addModelToLayers(
                  this._image
                    ? this._image._renderable.model
                    : this._text._model
                ),
                  P.off("add", this.onLayerAdded, this),
                  P.off("remove", this.onLayerRemoved, this),
                  F.on("add", this.onLayerAdded, this),
                  F.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(P) {
                this.layers.indexOf(P.id) < 0 ||
                  (this._image
                    ? P.addMeshInstances(
                        this._image._renderable.model.meshInstances
                      )
                    : this._text &&
                      P.addMeshInstances(this._text._model.meshInstances));
              }
              onLayerRemoved(P) {
                this.layers.indexOf(P.id) < 0 ||
                  (this._image
                    ? P.removeMeshInstances(
                        this._image._renderable.model.meshInstances
                      )
                    : this._text &&
                      P.removeMeshInstances(this._text._model.meshInstances));
              }
              onEnable() {
                if (
                  (this._image && this._image.onEnable(),
                  this._text && this._text.onEnable(),
                  this._group && this._group.onEnable(),
                  this.useInput &&
                    this.system.app.elementInput &&
                    this.system.app.elementInput.addElement(this),
                  this.system.app.scene.on(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.on(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.on(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this._batchGroupId >= 0)
                ) {
                  var P;
                  (P = this.system.app.batcher) == null ||
                    P.insert(f.w.ELEMENT, this.batchGroupId, this.entity);
                }
                this.fire("enableelement");
              }
              onDisable() {
                if (
                  (this.system.app.scene.off(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.off(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.off(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this._image && this._image.onDisable(),
                  this._text && this._text.onDisable(),
                  this._group && this._group.onDisable(),
                  this.system.app.elementInput &&
                    this.useInput &&
                    this.system.app.elementInput.removeElement(this),
                  this._batchGroupId >= 0)
                ) {
                  var P;
                  (P = this.system.app.batcher) == null ||
                    P.remove(f.w.ELEMENT, this.batchGroupId, this.entity);
                }
                this.fire("disableelement");
              }
              onRemove() {
                this.entity.off("insert", this._onInsert, this),
                  this._unpatch(),
                  this._image && this._image.destroy(),
                  this._text && this._text.destroy(),
                  this.system.app.elementInput &&
                    this.useInput &&
                    this.system.app.elementInput.removeElement(this),
                  this.screen &&
                    this.screen.screen &&
                    (this._unbindScreen(this.screen.screen),
                    this.screen.screen.syncDrawOrder()),
                  this.off();
              }
              _calculateSize(P, F) {
                if (!this.entity._parent && !this.screen) return;
                this._calculateLocalAnchors();
                const b = this._absRight - this._absLeft,
                  D = this._absTop - this._absBottom;
                P ? this._setWidth(b) : this._setCalculatedWidth(b, !1),
                  F ? this._setHeight(D) : this._setCalculatedHeight(D, !1);
                const G = this.entity.getLocalPosition();
                (G.x = this._margin.x + this._calculatedWidth * this._pivot.x),
                  (G.y =
                    this._margin.y + this._calculatedHeight * this._pivot.y),
                  this.entity.setLocalPosition(G),
                  (this._sizeDirty = !1);
              }
              _setWidth(P) {
                (this._width = P),
                  this._setCalculatedWidth(P, !1),
                  this.fire("set:width", this._width);
              }
              _setHeight(P) {
                (this._height = P),
                  this._setCalculatedHeight(P, !1),
                  this.fire("set:height", this._height);
              }
              _setCalculatedWidth(P, F) {
                if (!(Math.abs(P - this._calculatedWidth) <= 1e-4)) {
                  if (
                    ((this._calculatedWidth = P),
                    this.entity._dirtifyLocal(),
                    F)
                  ) {
                    const b = this.entity.getLocalPosition(),
                      D = this._pivot;
                    (this._margin.x = b.x - this._calculatedWidth * D.x),
                      (this._margin.z =
                        this._localAnchor.z -
                        this._localAnchor.x -
                        this._calculatedWidth -
                        this._margin.x);
                  }
                  this._flagChildrenAsDirty(),
                    this.fire("set:calculatedWidth", this._calculatedWidth),
                    this.fire(
                      "resize",
                      this._calculatedWidth,
                      this._calculatedHeight
                    );
                }
              }
              _setCalculatedHeight(P, F) {
                if (!(Math.abs(P - this._calculatedHeight) <= 1e-4)) {
                  if (
                    ((this._calculatedHeight = P),
                    this.entity._dirtifyLocal(),
                    F)
                  ) {
                    const b = this.entity.getLocalPosition(),
                      D = this._pivot;
                    (this._margin.y = b.y - this._calculatedHeight * D.y),
                      (this._margin.w =
                        this._localAnchor.w -
                        this._localAnchor.y -
                        this._calculatedHeight -
                        this._margin.y);
                  }
                  this._flagChildrenAsDirty(),
                    this.fire("set:calculatedHeight", this._calculatedHeight),
                    this.fire(
                      "resize",
                      this._calculatedWidth,
                      this._calculatedHeight
                    );
                }
              }
              _flagChildrenAsDirty() {
                const P = this.entity._children;
                for (let F = 0, b = P.length; F < b; F++)
                  P[F].element &&
                    ((P[F].element._anchorDirty = !0),
                    (P[F].element._sizeDirty = !0));
              }
              addModelToLayers(P) {
                this._addedModels.push(P);
                for (let F = 0; F < this.layers.length; F++) {
                  const b = this.system.app.scene.layers.getLayerById(
                    this.layers[F]
                  );
                  b && b.addMeshInstances(P.meshInstances);
                }
              }
              removeModelFromLayers(P) {
                const F = this._addedModels.indexOf(P);
                F >= 0 && this._addedModels.splice(F, 1);
                for (let b = 0; b < this.layers.length; b++) {
                  const D = this.system.app.scene.layers.getLayerById(
                    this.layers[b]
                  );
                  D && D.removeMeshInstances(P.meshInstances);
                }
              }
              getMaskOffset() {
                const P = this.system.app.frame;
                this._offsetReadAt !== P &&
                  ((this._maskOffset = 0.5), (this._offsetReadAt = P));
                const F = this._maskOffset;
                return (this._maskOffset -= 0.001), F;
              }
              isVisibleForCamera(P) {
                let F, b, D, G;
                if (this.maskedBy) {
                  const Z = this.maskedBy.element.screenCorners;
                  (F = Math.min(
                    Math.min(Z[0].x, Z[1].x),
                    Math.min(Z[2].x, Z[3].x)
                  )),
                    (b = Math.max(
                      Math.max(Z[0].x, Z[1].x),
                      Math.max(Z[2].x, Z[3].x)
                    )),
                    (G = Math.min(
                      Math.min(Z[0].y, Z[1].y),
                      Math.min(Z[2].y, Z[3].y)
                    )),
                    (D = Math.max(
                      Math.max(Z[0].y, Z[1].y),
                      Math.max(Z[2].y, Z[3].y)
                    ));
                } else {
                  const Z = this.system.app.graphicsDevice.width,
                    J = this.system.app.graphicsDevice.height,
                    ve = P._rect.z * Z,
                    _e = P._rect.w * J;
                  (F = P._rect.x * Z),
                    (b = F + ve),
                    (D = (1 - P._rect.y) * J),
                    (G = D - _e);
                }
                const X = this.screenCorners,
                  ie = Math.min(
                    Math.min(X[0].x, X[1].x),
                    Math.min(X[2].x, X[3].x)
                  ),
                  Q = Math.max(
                    Math.max(X[0].x, X[1].x),
                    Math.max(X[2].x, X[3].x)
                  ),
                  te = Math.min(
                    Math.min(X[0].y, X[1].y),
                    Math.min(X[2].y, X[3].y)
                  ),
                  ae = Math.max(
                    Math.max(X[0].y, X[1].y),
                    Math.max(X[2].y, X[3].y)
                  );
                return !(Q < F || ie > b || te > D || ae < G);
              }
              _isScreenSpace() {
                return this.screen && this.screen.screen
                  ? this.screen.screen.screenSpace
                  : !1;
              }
              _isScreenCulled() {
                return this.screen && this.screen.screen
                  ? this.screen.screen.cull
                  : !1;
              }
              _dirtyBatch() {
                if (this.batchGroupId !== -1) {
                  var P;
                  (P = this.system.app.batcher) == null ||
                    P.markGroupDirty(this.batchGroupId);
                }
              }
            }
            function M(R) {
              Object.defineProperty(E.prototype, R, {
                get: function () {
                  return this._text
                    ? this._text[R]
                    : this._image
                    ? this._image[R]
                    : null;
                },
                set: function (P) {
                  this._text
                    ? (this._text[R] !== P && this._dirtyBatch(),
                      (this._text[R] = P))
                    : this._image &&
                      (this._image[R] !== P && this._dirtyBatch(),
                      (this._image[R] = P));
                },
              });
            }
            M("fontSize"),
              M("minFontSize"),
              M("maxFontSize"),
              M("maxLines"),
              M("autoFitWidth"),
              M("autoFitHeight"),
              M("color"),
              M("font"),
              M("fontAsset"),
              M("spacing"),
              M("lineHeight"),
              M("wrapLines"),
              M("lines"),
              M("alignment"),
              M("autoWidth"),
              M("autoHeight"),
              M("rtlReorder"),
              M("unicodeConverter"),
              M("text"),
              M("key"),
              M("texture"),
              M("textureAsset"),
              M("material"),
              M("materialAsset"),
              M("sprite"),
              M("spriteAsset"),
              M("spriteFrame"),
              M("pixelsPerUnit"),
              M("opacity"),
              M("rect"),
              M("mask"),
              M("outlineColor"),
              M("outlineThickness"),
              M("shadowColor"),
              M("shadowOffset"),
              M("enableMarkup"),
              M("rangeStart"),
              M("rangeEnd");
          },
          9189: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $B: () => c,
              Dk: () => A,
              Do: () => h,
              b5: () => x,
              l$: () => y,
              qW: () => d,
            });
            const A = "group",
              x = "image",
              y = "text",
              c = "stretch",
              d = "contain",
              h = "cover";
          },
          8219: (xe, V, a) => {
            "use strict";
            a.d(V, { h: () => v });
            var A = a(9222),
              x = a(8976),
              y = a(3021),
              c = a(7994),
              d = a(7481),
              h = a(6543),
              f = a(9663),
              s = a(7337);
            const l = new c.Z(),
              n = new d.e(),
              o = new f.R(),
              i = new s.Z(),
              e = new d.e(),
              t = new d.e(),
              r = new y.k(),
              u = { x: "y", y: "x" };
            class v extends x.J {
              constructor(m, g) {
                if ((super(), !m || !(m instanceof h._)))
                  throw new Error(
                    "Element was null or not an ElementComponent"
                  );
                if (g && g !== "x" && g !== "y")
                  throw new Error("Unrecognized axis: " + g);
                (this._element = m),
                  (this._app = m.system.app),
                  (this._axis = g || null),
                  (this._enabled = !0),
                  (this._dragScale = new d.e()),
                  (this._dragStartMousePosition = new d.e()),
                  (this._dragStartHandlePosition = new d.e()),
                  (this._deltaMousePosition = new d.e()),
                  (this._deltaHandlePosition = new d.e()),
                  (this._isDragging = !1),
                  this._toggleLifecycleListeners("on");
              }
              _toggleLifecycleListeners(m) {
                this._element[m](
                  "mousedown",
                  this._onMouseDownOrTouchStart,
                  this
                ),
                  this._element[m](
                    "touchstart",
                    this._onMouseDownOrTouchStart,
                    this
                  ),
                  this._element[m](
                    "selectstart",
                    this._onMouseDownOrTouchStart,
                    this
                  );
              }
              _toggleDragListeners(m) {
                const g = m === "on";
                (this._hasDragListeners && g) ||
                  (this._app.mouse &&
                    (this._element[m]("mousemove", this._onMove, this),
                    this._element[m](
                      "mouseup",
                      this._onMouseUpOrTouchEnd,
                      this
                    )),
                  A.i.touch &&
                    (this._element[m]("touchmove", this._onMove, this),
                    this._element[m](
                      "touchend",
                      this._onMouseUpOrTouchEnd,
                      this
                    ),
                    this._element[m](
                      "touchcancel",
                      this._onMouseUpOrTouchEnd,
                      this
                    )),
                  this._element[m]("selectmove", this._onMove, this),
                  this._element[m](
                    "selectend",
                    this._onMouseUpOrTouchEnd,
                    this
                  ),
                  (this._hasDragListeners = g));
              }
              _onMouseDownOrTouchStart(m) {
                if (this._element && !this._isDragging && this.enabled) {
                  (this._dragCamera = m.camera), this._calculateDragScale();
                  const g = this._screenToLocal(m);
                  g &&
                    (this._toggleDragListeners("on"),
                    (this._isDragging = !0),
                    this._dragStartMousePosition.copy(g),
                    this._dragStartHandlePosition.copy(
                      this._element.entity.getLocalPosition()
                    ),
                    this.fire("drag:start"));
                }
              }
              _onMouseUpOrTouchEnd() {
                this._isDragging &&
                  ((this._isDragging = !1),
                  this._toggleDragListeners("off"),
                  this.fire("drag:end"));
              }
              _screenToLocal(m) {
                return (
                  m.inputSource
                    ? o.set(
                        m.inputSource.getOrigin(),
                        m.inputSource.getDirection()
                      )
                    : (this._determineInputPosition(m),
                      this._chooseRayOriginAndDirection()),
                  e.copy(this._element.entity.forward).mulScalar(-1),
                  i.setFromPointNormal(this._element.entity.getPosition(), e),
                  i.intersectsRay(o, t)
                    ? (r
                        .copy(this._element.entity.getRotation())
                        .invert()
                        .transformVector(t, t),
                      t.mul(this._dragScale),
                      t)
                    : null
                );
              }
              _determineInputPosition(m) {
                const g = this._app.graphicsDevice.maxPixelRatio;
                typeof m.x != "undefined" && typeof m.y != "undefined"
                  ? ((l.x = m.x * g), (l.y = m.y * g))
                  : m.changedTouches
                  ? ((l.x = m.changedTouches[0].x * g),
                    (l.y = m.changedTouches[0].y * g))
                  : console.warn(
                      "Could not determine position from input event"
                    );
              }
              _chooseRayOriginAndDirection() {
                this._element.screen && this._element.screen.screen.screenSpace
                  ? (o.origin.set(l.x, -l.y, 0), o.direction.copy(d.e.FORWARD))
                  : (n.copy(this._dragCamera.screenToWorld(l.x, l.y, 1)),
                    o.origin.copy(this._dragCamera.entity.getPosition()),
                    o.direction.copy(n).sub(o.origin).normalize());
              }
              _calculateDragScale() {
                let m = this._element.entity.parent;
                const g = this._element.screen && this._element.screen.screen,
                  T = g && g.screenSpace,
                  E = T ? g.scale : 1,
                  M = this._dragScale;
                for (
                  M.set(E, E, E);
                  m &&
                  (M.mul(m.getLocalScale()), (m = m.parent), !(T && m.screen));

                );
                (M.x = 1 / M.x), (M.y = 1 / M.y), (M.z = 0);
              }
              _onMove(m) {
                const {
                  _element: g,
                  _deltaMousePosition: T,
                  _deltaHandlePosition: E,
                  _axis: M,
                } = this;
                if (
                  g &&
                  this._isDragging &&
                  this.enabled &&
                  g.enabled &&
                  g.entity.enabled
                ) {
                  const R = this._screenToLocal(m);
                  if (R) {
                    if (
                      (T.sub2(R, this._dragStartMousePosition),
                      E.add2(this._dragStartHandlePosition, T),
                      M)
                    ) {
                      const P = g.entity.getLocalPosition(),
                        F = u[M];
                      E[F] = P[F];
                    }
                    g.entity.setLocalPosition(E), this.fire("drag:move", E);
                  }
                }
              }
              destroy() {
                this._toggleLifecycleListeners("off"),
                  this._toggleDragListeners("off");
              }
              set enabled(m) {
                this._enabled = m;
              }
              get enabled() {
                return this._enabled;
              }
              get isDragging() {
                return this._isDragging;
              }
            }
          },
          8596: (xe, V, a) => {
            "use strict";
            a.d(V, { C: () => g });
            var A = a(8656),
              x = a(5227),
              y = a(7994),
              c = a(7481),
              d = a(5596),
              h = a(1630),
              f = a(5860),
              s = a(6089),
              l = a(5950),
              n = a(9391),
              o = a(3035),
              i = a(7197),
              e = a(3637),
              t = a(9611),
              r = a(2640),
              u = a(9189),
              v = a(3953);
            const _ = new l.N();
            class m {
              constructor(E, M, R) {
                (this._entity = E),
                  (this._element = E.element),
                  (this.model = new t.K()),
                  (this.node = new o.t()),
                  (this.model.graph = this.node),
                  (this.mesh = M),
                  (this.meshInstance = new e.F(this.mesh, R, this.node)),
                  (this.meshInstance.name = "ImageElement: " + E.name),
                  (this.meshInstance.castShadow = !1),
                  (this.meshInstance.receiveShadow = !1),
                  (this._meshDirty = !1),
                  this.model.meshInstances.push(this.meshInstance),
                  this._entity.addChild(this.model.graph),
                  (this.model._entity = this._entity),
                  (this.unmaskMeshInstance = null);
              }
              destroy() {
                this.setMaterial(null),
                  this._element.removeModelFromLayers(this.model),
                  this.model.destroy(),
                  (this.model = null),
                  (this.node = null),
                  (this.mesh = null),
                  (this.meshInstance = null),
                  (this._entity = null),
                  (this._element = null);
              }
              setMesh(E) {
                this.meshInstance &&
                  ((this.mesh = E),
                  (this.meshInstance.mesh = E),
                  (this.meshInstance.visible = !!E),
                  this.unmaskMeshInstance && (this.unmaskMeshInstance.mesh = E),
                  this.forceUpdateAabb());
              }
              setMask(E) {
                if (this.meshInstance) {
                  if (E) {
                    (this.unmaskMeshInstance = new e.F(
                      this.mesh,
                      this.meshInstance.material,
                      this.node
                    )),
                      (this.unmaskMeshInstance.name =
                        "Unmask: " + this._entity.name),
                      (this.unmaskMeshInstance.castShadow = !1),
                      (this.unmaskMeshInstance.receiveShadow = !1),
                      (this.unmaskMeshInstance.pick = !1),
                      this.model.meshInstances.push(this.unmaskMeshInstance);
                    for (const M in this.meshInstance.parameters)
                      this.unmaskMeshInstance.setParameter(
                        M,
                        this.meshInstance.parameters[M].data
                      );
                  } else {
                    const M = this.model.meshInstances.indexOf(
                      this.unmaskMeshInstance
                    );
                    M >= 0 && this.model.meshInstances.splice(M, 1),
                      (this.unmaskMeshInstance = null);
                  }
                  this._entity.enabled &&
                    this._element.enabled &&
                    (this._element.removeModelFromLayers(this.model),
                    this._element.addModelToLayers(this.model));
                }
              }
              setMaterial(E) {
                this.meshInstance &&
                  ((this.meshInstance.material = E),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance.material = E));
              }
              setParameter(E, M) {
                this.meshInstance &&
                  (this.meshInstance.setParameter(E, M),
                  this.unmaskMeshInstance &&
                    this.unmaskMeshInstance.setParameter(E, M));
              }
              deleteParameter(E) {
                this.meshInstance &&
                  (this.meshInstance.deleteParameter(E),
                  this.unmaskMeshInstance &&
                    this.unmaskMeshInstance.deleteParameter(E));
              }
              setUnmaskDrawOrder() {
                if (!this.meshInstance) return;
                const E = function M(R) {
                  let P;
                  const F = R.children,
                    b = F.length;
                  if (b) {
                    for (let G = 0; G < b; G++) F[G].element && (P = F[G]);
                    if (!P) return null;
                    const D = M(P);
                    return D || P;
                  }
                  return null;
                };
                if (this.unmaskMeshInstance) {
                  const M = E(this._entity);
                  M && M.element
                    ? (this.unmaskMeshInstance.drawOrder =
                        M.element.drawOrder + M.element.getMaskOffset())
                    : (this.unmaskMeshInstance.drawOrder =
                        this.meshInstance.drawOrder +
                        this._element.getMaskOffset());
                }
              }
              setDrawOrder(E) {
                this.meshInstance && (this.meshInstance.drawOrder = E);
              }
              setCull(E) {
                if (!this.meshInstance) return;
                const M = this._element;
                let R = null;
                E &&
                  M._isScreenSpace() &&
                  (R = function (P) {
                    return M.isVisibleForCamera(P);
                  }),
                  (this.meshInstance.cull = E),
                  (this.meshInstance.isVisibleFunc = R),
                  this.unmaskMeshInstance &&
                    ((this.unmaskMeshInstance.cull = E),
                    (this.unmaskMeshInstance.isVisibleFunc = R));
              }
              setScreenSpace(E) {
                this.meshInstance &&
                  ((this.meshInstance.screenSpace = E),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance.screenSpace = E));
              }
              setLayer(E) {
                this.meshInstance &&
                  ((this.meshInstance.layer = E),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance.layer = E));
              }
              forceUpdateAabb(E) {
                this.meshInstance &&
                  ((this.meshInstance._aabbVer = -1),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance._aabbVer = -1));
              }
              setAabbFunc(E) {
                this.meshInstance &&
                  ((this.meshInstance._updateAabbFunc = E),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance._updateAabbFunc = E));
              }
            }
            class g {
              constructor(E) {
                (this._element = E),
                  (this._entity = E.entity),
                  (this._system = E.system),
                  (this._textureAsset = null),
                  (this._texture = null),
                  (this._materialAsset = null),
                  (this._material = null),
                  (this._spriteAsset = null),
                  (this._sprite = null),
                  (this._spriteFrame = 0),
                  (this._pixelsPerUnit = null),
                  (this._targetAspectRatio = -1),
                  (this._rect = new d.Z(0, 0, 1, 1)),
                  (this._mask = !1),
                  (this._maskRef = 0),
                  (this._outerScale = new y.Z()),
                  (this._outerScaleUniform = new Float32Array(2)),
                  (this._innerOffset = new d.Z()),
                  (this._innerOffsetUniform = new Float32Array(4)),
                  (this._atlasRect = new d.Z()),
                  (this._atlasRectUniform = new Float32Array(4)),
                  (this._defaultMesh = this._createMesh()),
                  (this._renderable = new m(
                    this._entity,
                    this._defaultMesh,
                    this._material
                  )),
                  (this._color = new x.Q(1, 1, 1, 1)),
                  (this._colorUniform = new Float32Array([1, 1, 1])),
                  this._renderable.setParameter(
                    "material_emissive",
                    this._colorUniform
                  ),
                  this._renderable.setParameter("material_opacity", 1),
                  (this._updateAabbFunc = this._updateAabb.bind(this)),
                  this._onScreenChange(this._element.screen),
                  this._element.on(
                    "resize",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.on(
                    "set:pivot",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.on(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  this._element.on("set:screen", this._onScreenChange, this),
                  this._element.on(
                    "set:draworder",
                    this._onDrawOrderChange,
                    this
                  ),
                  this._element.on(
                    "screen:set:resolution",
                    this._onResolutionChange,
                    this
                  );
              }
              destroy() {
                (this.textureAsset = null),
                  (this.spriteAsset = null),
                  (this.materialAsset = null),
                  this._renderable.setMesh(this._defaultMesh),
                  this._renderable.destroy(),
                  (this._defaultMesh = null),
                  this._element.off(
                    "resize",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.off(
                    "set:pivot",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.off(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  this._element.off("set:screen", this._onScreenChange, this),
                  this._element.off(
                    "set:draworder",
                    this._onDrawOrderChange,
                    this
                  ),
                  this._element.off(
                    "screen:set:resolution",
                    this._onResolutionChange,
                    this
                  );
              }
              _onResolutionChange(E) {}
              _onParentResizeOrPivotChange() {
                this._renderable.mesh &&
                  this._updateMesh(this._renderable.mesh);
              }
              _onScreenSpaceChange(E) {
                this._updateMaterial(E);
              }
              _onScreenChange(E, M) {
                E
                  ? this._updateMaterial(E.screen.screenSpace)
                  : this._updateMaterial(!1);
              }
              _onDrawOrderChange(E) {
                this._renderable.setDrawOrder(E),
                  this.mask &&
                    this._element.screen &&
                    this._element.screen.screen.once(
                      "syncdraworder",
                      function () {
                        this._renderable.setUnmaskDrawOrder();
                      },
                      this
                    );
              }
              _hasUserMaterial() {
                return (
                  !!this._materialAsset ||
                  (!!this._material &&
                    this._system.defaultImageMaterials.indexOf(
                      this._material
                    ) === -1)
                );
              }
              _use9Slicing() {
                return (
                  this.sprite &&
                  (this.sprite.renderMode === n.FC ||
                    this.sprite.renderMode === n.jZ)
                );
              }
              _updateMaterial(E) {
                const M = !!this._mask,
                  R = !!(this.sprite && this.sprite.renderMode === n.FC),
                  P = !!(this.sprite && this.sprite.renderMode === n.jZ);
                this._hasUserMaterial() ||
                  (this._material = this._system.getImageElementMaterial(
                    E,
                    M,
                    R,
                    P
                  )),
                  this._renderable &&
                    (this._renderable.setCull(
                      !this._element._isScreenSpace() ||
                        this._element._isScreenCulled()
                    ),
                    this._renderable.setMaterial(this._material),
                    this._renderable.setScreenSpace(E),
                    this._renderable.setLayer(E ? n.m2 : n.$1));
              }
              _createMesh() {
                const E = this._element,
                  M = E.calculatedWidth,
                  R = E.calculatedHeight,
                  P = this._rect,
                  F = this._system.app.graphicsDevice,
                  b = new Float32Array([
                    M,
                    0,
                    0,
                    0,
                    0,
                    1,
                    P.x + P.z,
                    1 - P.y,
                    M,
                    R,
                    0,
                    0,
                    0,
                    1,
                    P.x + P.z,
                    1 - (P.y + P.w),
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    P.x,
                    1 - P.y,
                    0,
                    R,
                    0,
                    0,
                    0,
                    1,
                    P.x,
                    1 - (P.y + P.w),
                  ]),
                  D = _.get(
                    F,
                    () =>
                      new s.y(F, [
                        { semantic: h.JYe, components: 3, type: h.n$B },
                        { semantic: h.XF6, components: 3, type: h.n$B },
                        { semantic: h.slc, components: 2, type: h.n$B },
                      ])
                  ),
                  G = new f.R(F, D, 4, h.y1K, b.buffer),
                  X = new i.e(F);
                return (
                  (X.vertexBuffer = G),
                  (X.primitive[0].type = h.SF$),
                  (X.primitive[0].base = 0),
                  (X.primitive[0].count = 4),
                  (X.primitive[0].indexed = !1),
                  X.aabb.setMinMax(c.e.ZERO, new c.e(M, R, 0)),
                  this._updateMesh(X),
                  X
                );
              }
              _updateMesh(E) {
                const M = this._element;
                let R = M.calculatedWidth,
                  P = M.calculatedHeight;
                if (M.fitMode !== u.$B && this._targetAspectRatio > 0) {
                  const b = M.calculatedWidth / M.calculatedHeight;
                  (M.fitMode === u.qW && b > this._targetAspectRatio) ||
                  (M.fitMode === u.Do && b < this._targetAspectRatio)
                    ? (R = M.calculatedHeight * this._targetAspectRatio)
                    : (P = M.calculatedWidth / this._targetAspectRatio);
                }
                const F = M._isScreenSpace();
                if (
                  (this._updateMaterial(F),
                  this._renderable && this._renderable.forceUpdateAabb(),
                  this.sprite &&
                    (this.sprite.renderMode === n.FC ||
                      this.sprite.renderMode === n.jZ))
                ) {
                  const b =
                      this._sprite.atlas.frames[
                        this._sprite.frameKeys[this._spriteFrame]
                      ],
                    D = 2 / b.rect.z,
                    G = 2 / b.rect.w;
                  this._innerOffset.set(
                    b.border.x * D,
                    b.border.y * G,
                    b.border.z * D,
                    b.border.w * G
                  );
                  const X = this.sprite.atlas.texture;
                  this._atlasRect.set(
                    b.rect.x / X.width,
                    b.rect.y / X.height,
                    b.rect.z / X.width,
                    b.rect.w / X.height
                  );
                  const ie =
                      this._pixelsPerUnit !== null
                        ? this._pixelsPerUnit
                        : this.sprite.pixelsPerUnit,
                    Q = b.rect.z / ie,
                    te = b.rect.w / ie;
                  this._outerScale.set(
                    Math.max(R, this._innerOffset.x * Q),
                    Math.max(P, this._innerOffset.y * te)
                  );
                  let ae = Q,
                    Z = te;
                  (this._outerScale.x /= Q),
                    (this._outerScale.y /= te),
                    (ae *= A.D.clamp(R / (this._innerOffset.x * Q), 1e-4, 1)),
                    (Z *= A.D.clamp(P / (this._innerOffset.y * te), 1e-4, 1)),
                    this._renderable &&
                      ((this._innerOffsetUniform[0] = this._innerOffset.x),
                      (this._innerOffsetUniform[1] = this._innerOffset.y),
                      (this._innerOffsetUniform[2] = this._innerOffset.z),
                      (this._innerOffsetUniform[3] = this._innerOffset.w),
                      this._renderable.setParameter(
                        "innerOffset",
                        this._innerOffsetUniform
                      ),
                      (this._atlasRectUniform[0] = this._atlasRect.x),
                      (this._atlasRectUniform[1] = this._atlasRect.y),
                      (this._atlasRectUniform[2] = this._atlasRect.z),
                      (this._atlasRectUniform[3] = this._atlasRect.w),
                      this._renderable.setParameter(
                        "atlasRect",
                        this._atlasRectUniform
                      ),
                      (this._outerScaleUniform[0] = this._outerScale.x),
                      (this._outerScaleUniform[1] = this._outerScale.y),
                      this._renderable.setParameter(
                        "outerScale",
                        this._outerScaleUniform
                      ),
                      this._renderable.setAabbFunc(this._updateAabbFunc),
                      this._renderable.node.setLocalScale(ae, Z, 1),
                      this._renderable.node.setLocalPosition(
                        (0.5 - M.pivot.x) * R,
                        (0.5 - M.pivot.y) * P,
                        0
                      ));
                } else {
                  const b = E.vertexBuffer,
                    D = new Float32Array(b.lock()),
                    G = M.pivot.x,
                    X = M.pivot.y;
                  (D[0] = R - G * R),
                    (D[1] = 0 - X * P),
                    (D[8] = R - G * R),
                    (D[9] = P - X * P),
                    (D[16] = 0 - G * R),
                    (D[17] = 0 - X * P),
                    (D[24] = 0 - G * R),
                    (D[25] = P - X * P);
                  let ie = 1,
                    Q = 1,
                    te = this._rect;
                  if (
                    this._sprite &&
                    this._sprite.frameKeys[this._spriteFrame] &&
                    this._sprite.atlas
                  ) {
                    const J =
                      this._sprite.atlas.frames[
                        this._sprite.frameKeys[this._spriteFrame]
                      ];
                    J &&
                      ((te = J.rect),
                      (ie = this._sprite.atlas.texture.width),
                      (Q = this._sprite.atlas.texture.height));
                  }
                  (D[6] = (te.x + te.z) / ie),
                    (D[7] = 1 - te.y / Q),
                    (D[14] = (te.x + te.z) / ie),
                    (D[15] = 1 - (te.y + te.w) / Q),
                    (D[22] = te.x / ie),
                    (D[23] = 1 - te.y / Q),
                    (D[30] = te.x / ie),
                    (D[31] = 1 - (te.y + te.w) / Q),
                    b.unlock();
                  const ae = new c.e(0 - G * R, 0 - X * P, 0),
                    Z = new c.e(R - G * R, P - X * P, 0);
                  E.aabb.setMinMax(ae, Z),
                    this._renderable &&
                      (this._renderable.node.setLocalScale(1, 1, 1),
                      this._renderable.node.setLocalPosition(0, 0, 0),
                      this._renderable.setAabbFunc(null));
                }
                this._meshDirty = !1;
              }
              _updateSprite() {
                let E = !1,
                  M = null;
                if (
                  ((this._targetAspectRatio = -1),
                  this._sprite && this._sprite.atlas)
                ) {
                  (M = this._sprite.meshes[this.spriteFrame]),
                    (E =
                      this._sprite.renderMode === n.FC ||
                      this._sprite.renderMode === n.jZ);
                  const R =
                    this._sprite.atlas.frames[
                      this._sprite.frameKeys[this._spriteFrame]
                    ];
                  (R == null ? void 0 : R.rect.w) > 0 &&
                    (this._targetAspectRatio = R.rect.z / R.rect.w);
                }
                (this.mesh = E ? M : this._defaultMesh), this.refreshMesh();
              }
              refreshMesh() {
                this.mesh &&
                  (this._element._beingInitialized
                    ? (this._meshDirty = !0)
                    : this._updateMesh(this.mesh));
              }
              _updateAabb(E) {
                return (
                  E.center.set(0, 0, 0),
                  E.halfExtents.set(
                    this._outerScale.x * 0.5,
                    this._outerScale.y * 0.5,
                    0.001
                  ),
                  E.setFromTransformedAabb(
                    E,
                    this._renderable.node.getWorldTransform()
                  ),
                  E
                );
              }
              _toggleMask() {
                this._element._dirtifyMask();
                const E = this._element._isScreenSpace();
                this._updateMaterial(E), this._renderable.setMask(!!this._mask);
              }
              _onMaterialLoad(E) {
                this.material = E.resource;
              }
              _onMaterialAdded(E) {
                this._system.app.assets.off(
                  "add:" + E.id,
                  this._onMaterialAdded,
                  this
                ),
                  this._materialAsset === E.id && this._bindMaterialAsset(E);
              }
              _bindMaterialAsset(E) {
                this._entity.enabled &&
                  (E.on("load", this._onMaterialLoad, this),
                  E.on("change", this._onMaterialChange, this),
                  E.on("remove", this._onMaterialRemove, this),
                  E.resource
                    ? this._onMaterialLoad(E)
                    : this._system.app.assets.load(E));
              }
              _unbindMaterialAsset(E) {
                E.off("load", this._onMaterialLoad, this),
                  E.off("change", this._onMaterialChange, this),
                  E.off("remove", this._onMaterialRemove, this);
              }
              _onMaterialChange() {}
              _onMaterialRemove() {}
              _onTextureAdded(E) {
                this._system.app.assets.off(
                  "add:" + E.id,
                  this._onTextureAdded,
                  this
                ),
                  this._textureAsset === E.id && this._bindTextureAsset(E);
              }
              _bindTextureAsset(E) {
                this._entity.enabled &&
                  (E.on("load", this._onTextureLoad, this),
                  E.on("change", this._onTextureChange, this),
                  E.on("remove", this._onTextureRemove, this),
                  E.resource
                    ? this._onTextureLoad(E)
                    : this._system.app.assets.load(E));
              }
              _unbindTextureAsset(E) {
                E.off("load", this._onTextureLoad, this),
                  E.off("change", this._onTextureChange, this),
                  E.off("remove", this._onTextureRemove, this);
              }
              _onTextureLoad(E) {
                this.texture = E.resource;
              }
              _onTextureChange(E) {}
              _onTextureRemove(E) {}
              _onSpriteAssetAdded(E) {
                this._system.app.assets.off(
                  "add:" + E.id,
                  this._onSpriteAssetAdded,
                  this
                ),
                  this._spriteAsset === E.id && this._bindSpriteAsset(E);
              }
              _bindSpriteAsset(E) {
                this._entity.enabled &&
                  (E.on("load", this._onSpriteAssetLoad, this),
                  E.on("change", this._onSpriteAssetChange, this),
                  E.on("remove", this._onSpriteAssetRemove, this),
                  E.resource
                    ? this._onSpriteAssetLoad(E)
                    : this._system.app.assets.load(E));
              }
              _unbindSpriteAsset(E) {
                E.off("load", this._onSpriteAssetLoad, this),
                  E.off("change", this._onSpriteAssetChange, this),
                  E.off("remove", this._onSpriteAssetRemove, this),
                  E.data.textureAtlasAsset &&
                    this._system.app.assets.off(
                      "load:" + E.data.textureAtlasAsset,
                      this._onTextureAtlasLoad,
                      this
                    );
              }
              _onSpriteAssetLoad(E) {
                if (!E || !E.resource) this.sprite = null;
                else if (E.resource.atlas) this.sprite = E.resource;
                else {
                  const M = E.data.textureAtlasAsset;
                  if (M) {
                    const R = this._system.app.assets;
                    R.off("load:" + M, this._onTextureAtlasLoad, this),
                      R.once("load:" + M, this._onTextureAtlasLoad, this);
                  }
                }
              }
              _onSpriteAssetChange(E) {
                this._onSpriteAssetLoad(E);
              }
              _onSpriteAssetRemove(E) {}
              _bindSprite(E) {
                E.on("set:meshes", this._onSpriteMeshesChange, this),
                  E.on("set:pixelsPerUnit", this._onSpritePpuChange, this),
                  E.on("set:atlas", this._onAtlasTextureChange, this),
                  E.atlas &&
                    E.atlas.on("set:texture", this._onAtlasTextureChange, this);
              }
              _unbindSprite(E) {
                E.off("set:meshes", this._onSpriteMeshesChange, this),
                  E.off("set:pixelsPerUnit", this._onSpritePpuChange, this),
                  E.off("set:atlas", this._onAtlasTextureChange, this),
                  E.atlas &&
                    E.atlas.off(
                      "set:texture",
                      this._onAtlasTextureChange,
                      this
                    );
              }
              _onSpriteMeshesChange() {
                this._sprite &&
                  (this._spriteFrame = A.D.clamp(
                    this._spriteFrame,
                    0,
                    this._sprite.frameKeys.length - 1
                  )),
                  this._updateSprite();
              }
              _onSpritePpuChange() {
                this.sprite.renderMode !== n.hA &&
                  this._pixelsPerUnit === null &&
                  this._updateSprite();
              }
              _onAtlasTextureChange() {
                this.sprite && this.sprite.atlas && this.sprite.atlas.texture
                  ? (this._renderable.setParameter(
                      "texture_emissiveMap",
                      this._sprite.atlas.texture
                    ),
                    this._renderable.setParameter(
                      "texture_opacityMap",
                      this._sprite.atlas.texture
                    ))
                  : (this._renderable.deleteParameter("texture_emissiveMap"),
                    this._renderable.deleteParameter("texture_opacityMap"));
              }
              _onTextureAtlasLoad(E) {
                const M = this._spriteAsset;
                M instanceof v.V
                  ? this._onSpriteAssetLoad(M)
                  : this._onSpriteAssetLoad(this._system.app.assets.get(M));
              }
              onEnable() {
                if (this._materialAsset) {
                  const E = this._system.app.assets.get(this._materialAsset);
                  E &&
                    E.resource !== this._material &&
                    this._bindMaterialAsset(E);
                }
                if (this._textureAsset) {
                  const E = this._system.app.assets.get(this._textureAsset);
                  E &&
                    E.resource !== this._texture &&
                    this._bindTextureAsset(E);
                }
                if (this._spriteAsset) {
                  const E = this._system.app.assets.get(this._spriteAsset);
                  E && E.resource !== this._sprite && this._bindSpriteAsset(E);
                }
                this._element.addModelToLayers(this._renderable.model);
              }
              onDisable() {
                this._element.removeModelFromLayers(this._renderable.model);
              }
              _setStencil(E) {
                (this._renderable.meshInstance.stencilFront = E),
                  (this._renderable.meshInstance.stencilBack = E);
                let M = 0;
                if (
                  (this._element.maskedBy &&
                    (M = this._element.maskedBy.element._image._maskRef),
                  this._renderable.unmaskMeshInstance)
                ) {
                  const R = new r.n({ ref: M + 1, func: h.sTv, zpass: h.Srv });
                  (this._renderable.unmaskMeshInstance.stencilFront = R),
                    (this._renderable.unmaskMeshInstance.stencilBack = R);
                }
              }
              set color(E) {
                const M = E.r,
                  R = E.g,
                  P = E.b;
                (this._color.r !== M ||
                  this._color.g !== R ||
                  this._color.b !== P) &&
                  ((this._color.r = M),
                  (this._color.g = R),
                  (this._color.b = P),
                  (this._colorUniform[0] = M),
                  (this._colorUniform[1] = R),
                  (this._colorUniform[2] = P),
                  this._renderable.setParameter(
                    "material_emissive",
                    this._colorUniform
                  )),
                  this._element && this._element.fire("set:color", this._color);
              }
              get color() {
                return this._color;
              }
              set opacity(E) {
                E !== this._color.a &&
                  ((this._color.a = E),
                  this._renderable.setParameter("material_opacity", E)),
                  this._element && this._element.fire("set:opacity", E);
              }
              get opacity() {
                return this._color.a;
              }
              set rect(E) {
                let M, R, P, F;
                E instanceof d.Z
                  ? ((M = E.x), (R = E.y), (P = E.z), (F = E.w))
                  : ((M = E[0]), (R = E[1]), (P = E[2]), (F = E[3])),
                  !(
                    M === this._rect.x &&
                    R === this._rect.y &&
                    P === this._rect.z &&
                    F === this._rect.w
                  ) &&
                    (this._rect.set(M, R, P, F),
                    this._renderable.mesh &&
                      (this._element._beingInitialized
                        ? (this._meshDirty = !0)
                        : this._updateMesh(this._renderable.mesh)));
              }
              get rect() {
                return this._rect;
              }
              _removeMaterialAssetEvents() {
                if (this._materialAsset) {
                  const E = this._system.app.assets;
                  E.off(
                    "add:" + this._materialAsset,
                    this._onMaterialAdded,
                    this
                  );
                  const M = E.get(this._materialAsset);
                  M &&
                    (M.off("load", this._onMaterialLoad, this),
                    M.off("change", this._onMaterialChange, this),
                    M.off("remove", this._onMaterialRemove, this));
                }
              }
              set material(E) {
                if (this._material !== E) {
                  if (!E) {
                    const M = this._element._isScreenSpace();
                    this.mask
                      ? (E = M
                          ? this._system.defaultScreenSpaceImageMaskMaterial
                          : this._system.defaultImageMaskMaterial)
                      : (E = M
                          ? this._system.defaultScreenSpaceImageMaterial
                          : this._system.defaultImageMaterial);
                  }
                  if (((this._material = E), this._materialAsset)) {
                    const M = this._system.app.assets.get(this._materialAsset);
                    (!M || M.resource !== E) &&
                      (this._removeMaterialAssetEvents(),
                      (this._materialAsset = null));
                  }
                  E &&
                    (this._renderable.setMaterial(E),
                    this._hasUserMaterial()
                      ? (this._renderable.deleteParameter("material_opacity"),
                        this._renderable.deleteParameter("material_emissive"))
                      : ((this._colorUniform[0] = this._color.r),
                        (this._colorUniform[1] = this._color.g),
                        (this._colorUniform[2] = this._color.b),
                        this._renderable.setParameter(
                          "material_emissive",
                          this._colorUniform
                        ),
                        this._renderable.setParameter(
                          "material_opacity",
                          this._color.a
                        )));
                }
              }
              get material() {
                return this._material;
              }
              set materialAsset(E) {
                const M = this._system.app.assets;
                let R = E;
                if ((E instanceof v.V && (R = E.id), this._materialAsset !== R))
                  if (
                    (this._removeMaterialAssetEvents(),
                    (this._materialAsset = R),
                    this._materialAsset)
                  ) {
                    const P = M.get(this._materialAsset);
                    P
                      ? this._bindMaterialAsset(P)
                      : ((this._materialAsset = null),
                        (this.material = null),
                        (this._materialAsset = R),
                        M.on(
                          "add:" + this._materialAsset,
                          this._onMaterialAdded,
                          this
                        ));
                  } else
                    (this._materialAsset = null),
                      (this.material = null),
                      (this._materialAsset = R);
              }
              get materialAsset() {
                return this._materialAsset;
              }
              set texture(E) {
                if (this._texture !== E) {
                  if (this._textureAsset) {
                    const M = this._system.app.assets.get(this._textureAsset);
                    M && M.resource !== E && (this.textureAsset = null);
                  }
                  if (((this._texture = E), E)) {
                    this._spriteAsset && (this.spriteAsset = null),
                      this._renderable.setParameter(
                        "texture_emissiveMap",
                        this._texture
                      ),
                      this._renderable.setParameter(
                        "texture_opacityMap",
                        this._texture
                      ),
                      (this._colorUniform[0] = this._color.r),
                      (this._colorUniform[1] = this._color.g),
                      (this._colorUniform[2] = this._color.b),
                      this._renderable.setParameter(
                        "material_emissive",
                        this._colorUniform
                      ),
                      this._renderable.setParameter(
                        "material_opacity",
                        this._color.a
                      );
                    const M = this._texture.width / this._texture.height;
                    M !== this._targetAspectRatio &&
                      ((this._targetAspectRatio = M),
                      this._element.fitMode !== u.$B && this.refreshMesh());
                  } else
                    this._renderable.deleteParameter("texture_emissiveMap"),
                      this._renderable.deleteParameter("texture_opacityMap"),
                      (this._targetAspectRatio = -1),
                      this._element.fitMode !== u.$B && this.refreshMesh();
                }
              }
              get texture() {
                return this._texture;
              }
              set textureAsset(E) {
                const M = this._system.app.assets;
                let R = E;
                if (
                  (E instanceof v.V && (R = E.id), this._textureAsset !== R)
                ) {
                  if (this._textureAsset) {
                    M.off(
                      "add:" + this._textureAsset,
                      this._onTextureAdded,
                      this
                    );
                    const P = M.get(this._textureAsset);
                    P &&
                      (P.off("load", this._onTextureLoad, this),
                      P.off("change", this._onTextureChange, this),
                      P.off("remove", this._onTextureRemove, this));
                  }
                  if (((this._textureAsset = R), this._textureAsset)) {
                    const P = M.get(this._textureAsset);
                    P
                      ? this._bindTextureAsset(P)
                      : ((this.texture = null),
                        M.on(
                          "add:" + this._textureAsset,
                          this._onTextureAdded,
                          this
                        ));
                  } else this.texture = null;
                }
              }
              get textureAsset() {
                return this._textureAsset;
              }
              set spriteAsset(E) {
                const M = this._system.app.assets;
                let R = E;
                if ((E instanceof v.V && (R = E.id), this._spriteAsset !== R)) {
                  if (this._spriteAsset) {
                    M.off(
                      "add:" + this._spriteAsset,
                      this._onSpriteAssetAdded,
                      this
                    );
                    const P = M.get(this._spriteAsset);
                    P && this._unbindSpriteAsset(P);
                  }
                  if (((this._spriteAsset = R), this._spriteAsset)) {
                    const P = M.get(this._spriteAsset);
                    P
                      ? this._bindSpriteAsset(P)
                      : ((this.sprite = null),
                        M.on(
                          "add:" + this._spriteAsset,
                          this._onSpriteAssetAdded,
                          this
                        ));
                  } else this.sprite = null;
                }
                this._element && this._element.fire("set:spriteAsset", R);
              }
              get spriteAsset() {
                return this._spriteAsset;
              }
              set sprite(E) {
                if (this._sprite !== E) {
                  if (
                    (this._sprite && this._unbindSprite(this._sprite),
                    this._spriteAsset)
                  ) {
                    const M = this._system.app.assets.get(this._spriteAsset);
                    M && M.resource !== E && (this.spriteAsset = null);
                  }
                  (this._sprite = E),
                    this._sprite &&
                      (this._bindSprite(this._sprite),
                      this._textureAsset && (this.textureAsset = null)),
                    this._sprite &&
                    this._sprite.atlas &&
                    this._sprite.atlas.texture
                      ? (this._renderable.setParameter(
                          "texture_emissiveMap",
                          this._sprite.atlas.texture
                        ),
                        this._renderable.setParameter(
                          "texture_opacityMap",
                          this._sprite.atlas.texture
                        ))
                      : (this._renderable.deleteParameter(
                          "texture_emissiveMap"
                        ),
                        this._renderable.deleteParameter("texture_opacityMap")),
                    this._sprite &&
                      (this._spriteFrame = A.D.clamp(
                        this._spriteFrame,
                        0,
                        this._sprite.frameKeys.length - 1
                      )),
                    this._updateSprite();
                }
              }
              get sprite() {
                return this._sprite;
              }
              set spriteFrame(E) {
                const M = this._spriteFrame;
                this._sprite
                  ? (this._spriteFrame = A.D.clamp(
                      E,
                      0,
                      this._sprite.frameKeys.length - 1
                    ))
                  : (this._spriteFrame = E),
                  this._spriteFrame !== M && this._updateSprite(),
                  this._element && this._element.fire("set:spriteFrame", E);
              }
              get spriteFrame() {
                return this._spriteFrame;
              }
              set mesh(E) {
                this._renderable.setMesh(E),
                  this._defaultMesh === E
                    ? this._renderable.setAabbFunc(null)
                    : this._renderable.setAabbFunc(this._updateAabbFunc);
              }
              get mesh() {
                return this._renderable.mesh;
              }
              set mask(E) {
                this._mask !== E && ((this._mask = E), this._toggleMask());
              }
              get mask() {
                return this._mask;
              }
              set pixelsPerUnit(E) {
                this._pixelsPerUnit !== E &&
                  ((this._pixelsPerUnit = E),
                  this._sprite &&
                    (this._sprite.renderMode === n.FC ||
                      this._sprite.renderMode === n.jZ) &&
                    this._updateSprite());
              }
              get pixelsPerUnit() {
                return this._pixelsPerUnit;
              }
              get aabb() {
                return this._renderable.meshInstance
                  ? this._renderable.meshInstance.aabb
                  : null;
              }
            }
          },
          6528: (xe, V, a) => {
            "use strict";
            a.d(V, { B: () => t });
            var A = a(5227),
              x = a(7994),
              y = a(5596),
              c = a(1630),
              d = a(1208),
              h = a(9391),
              f = a(1369),
              s = a(4124),
              l = a(2930),
              n = a(9189),
              o = a(6543);
            class i {
              constructor() {
                this.enabled = !0;
              }
            }
            const e = ["enabled"];
            class t extends l.r {
              constructor(u) {
                super(u),
                  (this.id = "element"),
                  (this.ComponentType = o._),
                  (this.DataType = i),
                  (this.schema = e),
                  (this._unicodeConverter = null),
                  (this._rtlReorder = null),
                  (this._defaultTexture = new d.g(u.graphicsDevice, {
                    width: 1,
                    height: 1,
                    format: c.Lxj,
                    name: "element-system",
                  }));
                const v = this._defaultTexture.lock(),
                  _ = new Uint8Array(4);
                (_[0] = 255),
                  (_[1] = 255),
                  (_[2] = 255),
                  (_[3] = 255),
                  v.set(_),
                  this._defaultTexture.unlock(),
                  (this.defaultImageMaterial = null),
                  (this.defaultImage9SlicedMaterial = null),
                  (this.defaultImage9TiledMaterial = null),
                  (this.defaultImageMaskMaterial = null),
                  (this.defaultImage9SlicedMaskMaterial = null),
                  (this.defaultImage9TiledMaskMaterial = null),
                  (this.defaultScreenSpaceImageMaterial = null),
                  (this.defaultScreenSpaceImage9SlicedMaterial = null),
                  (this.defaultScreenSpaceImage9TiledMaterial = null),
                  (this.defaultScreenSpaceImageMask9SlicedMaterial = null),
                  (this.defaultScreenSpaceImageMask9TiledMaterial = null),
                  (this.defaultScreenSpaceImageMaskMaterial = null),
                  (this._defaultTextMaterials = {}),
                  (this.defaultImageMaterials = []),
                  this.on("beforeremove", this.onRemoveComponent, this);
              }
              destroy() {
                super.destroy(), this._defaultTexture.destroy();
              }
              initializeComponentData(u, v, _) {
                (u._beingInitialized = !0),
                  v.anchor !== void 0 &&
                    (v.anchor instanceof y.Z
                      ? u.anchor.copy(v.anchor)
                      : u.anchor.set(
                          v.anchor[0],
                          v.anchor[1],
                          v.anchor[2],
                          v.anchor[3]
                        )),
                  v.pivot !== void 0 &&
                    (v.pivot instanceof x.Z
                      ? u.pivot.copy(v.pivot)
                      : u.pivot.set(v.pivot[0], v.pivot[1]));
                const m = Math.abs(u.anchor.x - u.anchor.z) > 0.001,
                  g = Math.abs(u.anchor.y - u.anchor.w) > 0.001;
                let T = !1,
                  E;
                v.margin !== void 0 &&
                  (v.margin instanceof y.Z
                    ? u.margin.copy(v.margin)
                    : u._margin.set(
                        v.margin[0],
                        v.margin[1],
                        v.margin[2],
                        v.margin[3]
                      ),
                  (T = !0)),
                  v.left !== void 0 && ((u._margin.x = v.left), (T = !0)),
                  v.bottom !== void 0 && ((u._margin.y = v.bottom), (T = !0)),
                  v.right !== void 0 && ((u._margin.z = v.right), (T = !0)),
                  v.top !== void 0 && ((u._margin.w = v.top), (T = !0)),
                  T && (u.margin = u._margin);
                let M = !1;
                v.width !== void 0 && !m ? (u.width = v.width) : m && (M = !0),
                  v.height !== void 0 && !g
                    ? (u.height = v.height)
                    : g && (M = !0),
                  M && (u.anchor = u.anchor),
                  v.enabled !== void 0 && (u.enabled = v.enabled),
                  v.useInput !== void 0 && (u.useInput = v.useInput),
                  v.fitMode !== void 0 && (u.fitMode = v.fitMode),
                  (u.batchGroupId =
                    v.batchGroupId === void 0 || v.batchGroupId === null
                      ? -1
                      : v.batchGroupId),
                  v.layers &&
                    Array.isArray(v.layers) &&
                    (u.layers = v.layers.slice(0)),
                  v.type !== void 0 && (u.type = v.type),
                  u.type === n.b5
                    ? (v.rect !== void 0 && (u.rect = v.rect),
                      v.color !== void 0 &&
                        ((E = v.color),
                        E instanceof A.Q ||
                          (E = new A.Q(v.color[0], v.color[1], v.color[2])),
                        (u.color = E)),
                      v.opacity !== void 0 && (u.opacity = v.opacity),
                      v.textureAsset !== void 0 &&
                        (u.textureAsset = v.textureAsset),
                      v.texture && (u.texture = v.texture),
                      v.spriteAsset !== void 0 &&
                        (u.spriteAsset = v.spriteAsset),
                      v.sprite && (u.sprite = v.sprite),
                      v.spriteFrame !== void 0 &&
                        (u.spriteFrame = v.spriteFrame),
                      v.pixelsPerUnit !== void 0 &&
                        v.pixelsPerUnit !== null &&
                        (u.pixelsPerUnit = v.pixelsPerUnit),
                      v.materialAsset !== void 0 &&
                        (u.materialAsset = v.materialAsset),
                      v.material && (u.material = v.material),
                      v.mask !== void 0 && (u.mask = v.mask))
                    : u.type === n.l$ &&
                      (v.autoWidth !== void 0 && (u.autoWidth = v.autoWidth),
                      v.autoHeight !== void 0 && (u.autoHeight = v.autoHeight),
                      v.rtlReorder !== void 0 && (u.rtlReorder = v.rtlReorder),
                      v.unicodeConverter !== void 0 &&
                        (u.unicodeConverter = v.unicodeConverter),
                      v.text !== null && v.text !== void 0
                        ? (u.text = v.text)
                        : v.key !== null && v.key !== void 0 && (u.key = v.key),
                      v.color !== void 0 &&
                        ((E = v.color),
                        E instanceof A.Q || (E = new A.Q(E[0], E[1], E[2])),
                        (u.color = E)),
                      v.opacity !== void 0 && (u.opacity = v.opacity),
                      v.spacing !== void 0 && (u.spacing = v.spacing),
                      v.fontSize !== void 0 &&
                        ((u.fontSize = v.fontSize),
                        v.lineHeight || (u.lineHeight = v.fontSize)),
                      v.lineHeight !== void 0 && (u.lineHeight = v.lineHeight),
                      v.maxLines !== void 0 && (u.maxLines = v.maxLines),
                      v.wrapLines !== void 0 && (u.wrapLines = v.wrapLines),
                      v.minFontSize !== void 0 &&
                        (u.minFontSize = v.minFontSize),
                      v.maxFontSize !== void 0 &&
                        (u.maxFontSize = v.maxFontSize),
                      v.autoFitWidth && (u.autoFitWidth = v.autoFitWidth),
                      v.autoFitHeight && (u.autoFitHeight = v.autoFitHeight),
                      v.fontAsset !== void 0 && (u.fontAsset = v.fontAsset),
                      v.font !== void 0 && (u.font = v.font),
                      v.alignment !== void 0 && (u.alignment = v.alignment),
                      v.outlineColor !== void 0 &&
                        (u.outlineColor = v.outlineColor),
                      v.outlineThickness !== void 0 &&
                        (u.outlineThickness = v.outlineThickness),
                      v.shadowColor !== void 0 &&
                        (u.shadowColor = v.shadowColor),
                      v.shadowOffset !== void 0 &&
                        (u.shadowOffset = v.shadowOffset),
                      v.enableMarkup !== void 0 &&
                        (u.enableMarkup = v.enableMarkup));
                const R = u._parseUpToScreen();
                R.screen && u._updateScreen(R.screen),
                  super.initializeComponentData(u, v, _),
                  (u._beingInitialized = !1),
                  u.type === n.b5 &&
                    u._image._meshDirty &&
                    u._image._updateMesh(u._image.mesh);
              }
              onRemoveComponent(u, v) {
                v.onRemove();
              }
              cloneComponent(u, v) {
                const _ = u.element,
                  m = {
                    enabled: _.enabled,
                    width: _.width,
                    height: _.height,
                    anchor: _.anchor.clone(),
                    pivot: _.pivot.clone(),
                    margin: _.margin.clone(),
                    alignment:
                      (_.alignment && _.alignment.clone()) || _.alignment,
                    autoWidth: _.autoWidth,
                    autoHeight: _.autoHeight,
                    type: _.type,
                    rect: (_.rect && _.rect.clone()) || _.rect,
                    rtlReorder: _.rtlReorder,
                    unicodeConverter: _.unicodeConverter,
                    materialAsset: _.materialAsset,
                    material: _.material,
                    color: (_.color && _.color.clone()) || _.color,
                    opacity: _.opacity,
                    textureAsset: _.textureAsset,
                    texture: _.texture,
                    spriteAsset: _.spriteAsset,
                    sprite: _.sprite,
                    spriteFrame: _.spriteFrame,
                    pixelsPerUnit: _.pixelsPerUnit,
                    spacing: _.spacing,
                    lineHeight: _.lineHeight,
                    wrapLines: _.wrapLines,
                    layers: _.layers,
                    fontSize: _.fontSize,
                    minFontSize: _.minFontSize,
                    maxFontSize: _.maxFontSize,
                    autoFitWidth: _.autoFitWidth,
                    autoFitHeight: _.autoFitHeight,
                    maxLines: _.maxLines,
                    fontAsset: _.fontAsset,
                    font: _.font,
                    useInput: _.useInput,
                    fitMode: _.fitMode,
                    batchGroupId: _.batchGroupId,
                    mask: _.mask,
                    outlineColor:
                      (_.outlineColor && _.outlineColor.clone()) ||
                      _.outlineColor,
                    outlineThickness: _.outlineThickness,
                    shadowColor:
                      (_.shadowColor && _.shadowColor.clone()) || _.shadowColor,
                    shadowOffset:
                      (_.shadowOffset && _.shadowOffset.clone()) ||
                      _.shadowOffset,
                    enableMarkup: _.enableMarkup,
                  };
                return (
                  _.key !== void 0 && _.key !== null
                    ? (m.key = _.key)
                    : (m.text = _.text),
                  this.addComponent(v, m)
                );
              }
              getTextElementMaterial(u, v, _) {
                const m = (u && 1) | (v && 2) | (_ && 4);
                let g = this._defaultTextMaterials[m];
                if (g) return g;
                let T = "TextMaterial";
                return (
                  (g = new f.F()),
                  v
                    ? ((g.msdfMap = this._defaultTexture),
                      (g.msdfTextAttribute = _),
                      g.emissive.set(1, 1, 1))
                    : ((T = "Bitmap" + T),
                      g.emissive.set(0.5, 0.5, 0.5),
                      (g.emissiveMap = this._defaultTexture),
                      (g.emissiveTint = !0),
                      (g.opacityMap = this._defaultTexture),
                      (g.opacityMapChannel = "a")),
                  u && ((T = "ScreenSpace" + T), (g.depthTest = !1)),
                  (g.name = "default" + T),
                  (g.useLighting = !1),
                  (g.useGammaTonemap = !1),
                  (g.useFog = !1),
                  (g.useSkybox = !1),
                  g.diffuse.set(0, 0, 0),
                  (g.opacity = 0.5),
                  (g.blendType = h.bY),
                  (g.depthWrite = !1),
                  (g.emissiveVertexColor = !0),
                  g.update(),
                  (this._defaultTextMaterials[m] = g),
                  g
                );
              }
              _createBaseImageMaterial() {
                const u = new f.F();
                return (
                  u.diffuse.set(0, 0, 0),
                  u.emissive.set(0.5, 0.5, 0.5),
                  (u.emissiveMap = this._defaultTexture),
                  (u.emissiveTint = !0),
                  (u.opacityMap = this._defaultTexture),
                  (u.opacityMapChannel = "a"),
                  (u.opacityTint = !0),
                  (u.opacity = 0),
                  (u.useLighting = !1),
                  (u.useGammaTonemap = !1),
                  (u.useFog = !1),
                  (u.useSkybox = !1),
                  (u.blendType = h.bY),
                  (u.depthWrite = !1),
                  u
                );
              }
              getImageElementMaterial(u, v, _, m) {
                return u
                  ? v
                    ? _
                      ? (this.defaultScreenSpaceImageMask9SlicedMaterial ||
                          ((this.defaultScreenSpaceImageMask9SlicedMaterial =
                            this._createBaseImageMaterial()),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.name =
                            "defaultScreenSpaceImageMask9SlicedMaterial"),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode =
                            h.FC),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite =
                            !1),
                          this.defaultScreenSpaceImageMask9SlicedMaterial.update(),
                          this.defaultImageMaterials.push(
                            this.defaultScreenSpaceImageMask9SlicedMaterial
                          )),
                        this.defaultScreenSpaceImageMask9SlicedMaterial)
                      : m
                      ? (this.defaultScreenSpaceImageMask9TiledMaterial ||
                          ((this.defaultScreenSpaceImageMask9TiledMaterial =
                            this.defaultScreenSpaceImage9TiledMaterial.clone()),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.name =
                            "defaultScreenSpaceImageMask9TiledMaterial"),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode =
                            h.jZ),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.depthTest =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.redWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite =
                            !1),
                          this.defaultScreenSpaceImageMask9TiledMaterial.update(),
                          this.defaultImageMaterials.push(
                            this.defaultScreenSpaceImageMask9TiledMaterial
                          )),
                        this.defaultScreenSpaceImageMask9TiledMaterial)
                      : (this.defaultScreenSpaceImageMaskMaterial ||
                          ((this.defaultScreenSpaceImageMaskMaterial =
                            this._createBaseImageMaterial()),
                          (this.defaultScreenSpaceImageMaskMaterial.name =
                            "defaultScreenSpaceImageMaskMaterial"),
                          (this.defaultScreenSpaceImageMaskMaterial.depthTest =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1),
                          (this.defaultScreenSpaceImageMaskMaterial.redWrite =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.greenWrite =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.blueWrite =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.alphaWrite =
                            !1),
                          this.defaultScreenSpaceImageMaskMaterial.update(),
                          this.defaultImageMaterials.push(
                            this.defaultScreenSpaceImageMaskMaterial
                          )),
                        this.defaultScreenSpaceImageMaskMaterial)
                    : _
                    ? (this.defaultScreenSpaceImage9SlicedMaterial ||
                        ((this.defaultScreenSpaceImage9SlicedMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultScreenSpaceImage9SlicedMaterial.name =
                          "defaultScreenSpaceImage9SlicedMaterial"),
                        (this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode =
                          h.FC),
                        (this.defaultScreenSpaceImage9SlicedMaterial.depthTest =
                          !1),
                        this.defaultScreenSpaceImage9SlicedMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultScreenSpaceImage9SlicedMaterial
                        )),
                      this.defaultScreenSpaceImage9SlicedMaterial)
                    : m
                    ? (this.defaultScreenSpaceImage9TiledMaterial ||
                        ((this.defaultScreenSpaceImage9TiledMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultScreenSpaceImage9TiledMaterial.name =
                          "defaultScreenSpaceImage9TiledMaterial"),
                        (this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode =
                          h.jZ),
                        (this.defaultScreenSpaceImage9TiledMaterial.depthTest =
                          !1),
                        this.defaultScreenSpaceImage9TiledMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultScreenSpaceImage9TiledMaterial
                        )),
                      this.defaultScreenSpaceImage9TiledMaterial)
                    : (this.defaultScreenSpaceImageMaterial ||
                        ((this.defaultScreenSpaceImageMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultScreenSpaceImageMaterial.name =
                          "defaultScreenSpaceImageMaterial"),
                        (this.defaultScreenSpaceImageMaterial.depthTest = !1),
                        this.defaultScreenSpaceImageMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultScreenSpaceImageMaterial
                        )),
                      this.defaultScreenSpaceImageMaterial)
                  : v
                  ? _
                    ? (this.defaultImage9SlicedMaskMaterial ||
                        ((this.defaultImage9SlicedMaskMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultImage9SlicedMaskMaterial.name =
                          "defaultImage9SlicedMaskMaterial"),
                        (this.defaultImage9SlicedMaskMaterial.nineSlicedMode =
                          h.FC),
                        (this.defaultImage9SlicedMaskMaterial.alphaTest = 1),
                        (this.defaultImage9SlicedMaskMaterial.redWrite = !1),
                        (this.defaultImage9SlicedMaskMaterial.greenWrite = !1),
                        (this.defaultImage9SlicedMaskMaterial.blueWrite = !1),
                        (this.defaultImage9SlicedMaskMaterial.alphaWrite = !1),
                        this.defaultImage9SlicedMaskMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultImage9SlicedMaskMaterial
                        )),
                      this.defaultImage9SlicedMaskMaterial)
                    : m
                    ? (this.defaultImage9TiledMaskMaterial ||
                        ((this.defaultImage9TiledMaskMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultImage9TiledMaskMaterial.name =
                          "defaultImage9TiledMaskMaterial"),
                        (this.defaultImage9TiledMaskMaterial.nineSlicedMode =
                          h.jZ),
                        (this.defaultImage9TiledMaskMaterial.alphaTest = 1),
                        (this.defaultImage9TiledMaskMaterial.redWrite = !1),
                        (this.defaultImage9TiledMaskMaterial.greenWrite = !1),
                        (this.defaultImage9TiledMaskMaterial.blueWrite = !1),
                        (this.defaultImage9TiledMaskMaterial.alphaWrite = !1),
                        this.defaultImage9TiledMaskMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultImage9TiledMaskMaterial
                        )),
                      this.defaultImage9TiledMaskMaterial)
                    : (this.defaultImageMaskMaterial ||
                        ((this.defaultImageMaskMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultImageMaskMaterial.name =
                          "defaultImageMaskMaterial"),
                        (this.defaultImageMaskMaterial.alphaTest = 1),
                        (this.defaultImageMaskMaterial.redWrite = !1),
                        (this.defaultImageMaskMaterial.greenWrite = !1),
                        (this.defaultImageMaskMaterial.blueWrite = !1),
                        (this.defaultImageMaskMaterial.alphaWrite = !1),
                        this.defaultImageMaskMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultImageMaskMaterial
                        )),
                      this.defaultImageMaskMaterial)
                  : _
                  ? (this.defaultImage9SlicedMaterial ||
                      ((this.defaultImage9SlicedMaterial =
                        this._createBaseImageMaterial()),
                      (this.defaultImage9SlicedMaterial.name =
                        "defaultImage9SlicedMaterial"),
                      (this.defaultImage9SlicedMaterial.nineSlicedMode = h.FC),
                      this.defaultImage9SlicedMaterial.update(),
                      this.defaultImageMaterials.push(
                        this.defaultImage9SlicedMaterial
                      )),
                    this.defaultImage9SlicedMaterial)
                  : m
                  ? (this.defaultImage9TiledMaterial ||
                      ((this.defaultImage9TiledMaterial =
                        this._createBaseImageMaterial()),
                      (this.defaultImage9TiledMaterial.name =
                        "defaultImage9TiledMaterial"),
                      (this.defaultImage9TiledMaterial.nineSlicedMode = h.jZ),
                      this.defaultImage9TiledMaterial.update(),
                      this.defaultImageMaterials.push(
                        this.defaultImage9TiledMaterial
                      )),
                    this.defaultImage9TiledMaterial)
                  : (this.defaultImageMaterial ||
                      ((this.defaultImageMaterial =
                        this._createBaseImageMaterial()),
                      (this.defaultImageMaterial.name = "defaultImageMaterial"),
                      this.defaultImageMaterial.update(),
                      this.defaultImageMaterials.push(
                        this.defaultImageMaterial
                      )),
                    this.defaultImageMaterial);
              }
              registerUnicodeConverter(u) {
                this._unicodeConverter = u;
              }
              registerRtlReorder(u) {
                this._rtlReorder = u;
              }
              getUnicodeConverter() {
                return this._unicodeConverter;
              }
              getRtlReorder() {
                return this._rtlReorder;
              }
            }
            s.u._buildAccessors(o._.prototype, e);
          },
          4885: (xe, V, a) => {
            "use strict";
            a.d(V, { S: () => $ });
            var A = a(8772),
              x = a(8656),
              y = a(5227),
              c = a(7994),
              d = a(7915),
              h = a(1630),
              f = a(1984),
              s = a(3035),
              l = a(3637),
              n = a(9611),
              o = a(7197),
              i = a(5853),
              e = a(2471);
            const t = 0,
              r = 1,
              u = 2,
              v = 3,
              _ = 4,
              m = 5,
              g = 6,
              T = 7,
              E = 8,
              M = ` 	
\r\v\f`,
              R = /[A-Z|a-z|0-9|_|-|/]/;
            class P {
              constructor(O) {
                (this._symbols = O),
                  (this._index = 0),
                  (this._last = 0),
                  (this._cur =
                    this._symbols.length > 0 ? this._symbols[0] : null),
                  (this._buf = []),
                  (this._mode = "text"),
                  (this._error = null);
              }
              read() {
                let O = this._read();
                for (; O === E; ) O = this._read();
                return O !== t && O !== r && (this._last = this._index), O;
              }
              buf() {
                return this._buf;
              }
              last() {
                return this._last;
              }
              error() {
                return this._error;
              }
              debugPrint() {
                const O = [
                  "EOF",
                  "ERROR",
                  "TEXT",
                  "OPEN_BRACKET",
                  "CLOSE_BRACKET",
                  "EQUALS",
                  "STRING",
                  "IDENTIFIER",
                  "WHITESPACE",
                ];
                let Y = this.read(),
                  ne = "";
                for (
                  ;
                  (ne +=
                    (ne.length > 0
                      ? `
`
                      : "") +
                    O[Y] +
                    " '" +
                    this.buf().join("") +
                    "'"),
                    !(Y === t || Y === r);

                )
                  Y = this.read();
                return ne;
              }
              _read() {
                return (
                  (this._buf = []),
                  this._eof()
                    ? t
                    : this._mode === "text"
                    ? this._text()
                    : this._tag()
                );
              }
              _text() {
                for (;;)
                  switch (this._cur) {
                    case null:
                      return this._buf.length > 0 ? u : t;
                    case "[":
                      return (
                        (this._mode = "tag"),
                        this._buf.length > 0 ? u : this._tag()
                      );
                    case "\\":
                      switch ((this._next(), this._cur)) {
                        case "[":
                          this._store();
                          break;
                        default:
                          this._output("\\");
                          break;
                      }
                      break;
                    default:
                      this._store();
                      break;
                  }
              }
              _tag() {
                switch (this._cur) {
                  case null:
                    return (
                      (this._error = "unexpected end of input reading tag"), r
                    );
                  case "[":
                    return this._store(), v;
                  case "]":
                    return this._store(), (this._mode = "text"), _;
                  case "=":
                    return this._store(), m;
                  case " ":
                  case "	":
                  case `
`:
                  case "\r":
                  case "\v":
                  case "\f":
                    return this._whitespace();
                  case '"':
                    return this._string();
                  default:
                    return this._isIdentifierSymbol(this._cur)
                      ? this._identifier()
                      : ((this._error = "unrecognized character"), r);
                }
              }
              _whitespace() {
                for (this._store(); M.indexOf(this._cur) !== -1; )
                  this._store();
                return E;
              }
              _string() {
                for (this._next(); ; )
                  switch (this._cur) {
                    case null:
                      return (
                        (this._error =
                          "unexpected end of input reading string"),
                        r
                      );
                    case '"':
                      return this._next(), g;
                    default:
                      this._store();
                      break;
                  }
              }
              _identifier() {
                for (
                  this._store();
                  this._cur !== null && this._isIdentifierSymbol(this._cur);

                )
                  this._store();
                return T;
              }
              _isIdentifierSymbol(O) {
                return O.length === 1 && O.match(R) !== null;
              }
              _eof() {
                return this._cur === null;
              }
              _next() {
                return (
                  this._eof() ||
                    (this._index++,
                    (this._cur =
                      this._index < this._symbols.length
                        ? this._symbols[this._index]
                        : null)),
                  this._cur
                );
              }
              _store() {
                return this._buf.push(this._cur), this._next();
              }
              _output(O) {
                this._buf.push(O);
              }
            }
            class F {
              constructor(O) {
                (this._scanner = new P(O)), (this._error = null);
              }
              parse(O, Y) {
                for (;;)
                  switch (this._scanner.read()) {
                    case t:
                      return !0;
                    case r:
                      return !1;
                    case u:
                      Array.prototype.push.apply(O, this._scanner.buf());
                      break;
                    case v:
                      if (!this._parseTag(O, Y)) return !1;
                      break;
                    default:
                      return !1;
                  }
              }
              error() {
                return (
                  "Error evaluating markup at #" +
                  this._scanner.last().toString() +
                  " (" +
                  (this._scanner.error() || this._error) +
                  ")"
                );
              }
              _parseTag(O, Y) {
                let ne = this._scanner.read();
                if (ne !== T) return (this._error = "expected identifier"), !1;
                const de = this._scanner.buf().join("");
                if (de[0] === "/") {
                  for (let I = Y.length - 1; I >= 0; --I)
                    if (de === "/" + Y[I].name && Y[I].end === null)
                      return (
                        (Y[I].end = O.length),
                        (ne = this._scanner.read()),
                        ne !== _
                          ? ((this._error = "expected close bracket"), !1)
                          : !0
                      );
                  return (this._error = "failed to find matching tag"), !1;
                }
                const re = {
                  name: de,
                  value: null,
                  attributes: {},
                  start: O.length,
                  end: null,
                };
                if (((ne = this._scanner.read()), ne === m)) {
                  if (((ne = this._scanner.read()), ne !== g))
                    return (this._error = "expected string"), !1;
                  (re.value = this._scanner.buf().join("")),
                    (ne = this._scanner.read());
                }
                for (;;) {
                  switch (ne) {
                    case _:
                      return Y.push(re), !0;
                    case T: {
                      const I = this._scanner.buf().join("");
                      if (((ne = this._scanner.read()), ne !== m))
                        return (this._error = "expected equals"), !1;
                      if (((ne = this._scanner.read()), ne !== g))
                        return (this._error = "expected string"), !1;
                      const w = this._scanner.buf().join("");
                      re.attributes[I] = w;
                      break;
                    }
                    default:
                      return (
                        (this._error = "expected close bracket or identifier"),
                        !1
                      );
                  }
                  ne = this._scanner.read();
                }
              }
            }
            function b(le, O) {
              for (const Y in O) {
                if (!O.hasOwnProperty(Y)) continue;
                const ne = O[Y];
                ne instanceof Object
                  ? (le.hasOwnProperty(Y) || (le[Y] = {}), b(le[Y], O[Y]))
                  : (le[Y] = ne);
              }
            }
            function D(le) {
              if (le.length === 0) return null;
              const O = {};
              for (let Y = 0; Y < le.length; ++Y) {
                const ne = le[Y],
                  de = {};
                (de[ne.name] = { value: ne.value, attributes: ne.attributes }),
                  b(O, de);
              }
              return O;
            }
            function G(le, O) {
              if (le.length === 0) return null;
              const Y = {};
              for (let he = 0; he < le.length; ++he) {
                const ue = le[he];
                Y.hasOwnProperty(ue.start)
                  ? Y[ue.start].open === null
                    ? (Y[ue.start].open = [ue])
                    : Y[ue.start].open.push(ue)
                  : (Y[ue.start] = { open: [ue], close: null }),
                  Y.hasOwnProperty(ue.end)
                    ? Y[ue.end].close === null
                      ? (Y[ue.end].close = [ue])
                      : Y[ue.end].close.push(ue)
                    : (Y[ue.end] = { open: null, close: [ue] });
              }
              let ne = [];
              function de(he) {
                ne = ne.filter(function (ue) {
                  return (
                    he.find(function (ye) {
                      return ye === ue;
                    }) === void 0
                  );
                });
              }
              function re(he) {
                for (let ue = 0; ue < he.length; ++ue) ne.push(he[ue]);
              }
              const I = Object.keys(Y).sort(function (he, ue) {
                  return he - ue;
                }),
                w = [];
              for (let he = 0; he < I.length; ++he) {
                const ue = Y[I[he]];
                ue.close !== null && de(ue.close),
                  ue.open !== null && re(ue.open),
                  w.push({ start: I[he], tags: D(ne) });
              }
              const N = [];
              let W = null;
              for (let he = 0; he < w.length; ++he) {
                const ue = w[he];
                for (; N.length < ue.start; ) N.push(W ? W.tags : null);
                W = ue;
              }
              for (; N.length < O; ) N.push(null);
              return N;
            }
            function X(le) {
              const O = new F(le),
                Y = [],
                ne = [];
              if (!O.parse(Y, ne))
                return console.warn(O.error()), { symbols: le, tags: null };
              const de = ne.find(function (I) {
                return I.end === null;
              });
              if (de)
                return (
                  console.warn(`Markup error: found unclosed tag='${de.name}'`),
                  { symbols: le, tags: null }
                );
              const re = G(ne, Y.length);
              return { symbols: Y, tags: re };
            }
            class ie {
              static evaluate(O) {
                return X(O);
              }
            }
            class Q {
              constructor() {
                (this.count = 0),
                  (this.quad = 0),
                  (this.lines = {}),
                  (this.positions = []),
                  (this.normals = []),
                  (this.uvs = []),
                  (this.colors = []),
                  (this.indices = []),
                  (this.outlines = []),
                  (this.shadows = []),
                  (this.meshInstance = null);
              }
            }
            function te(le, O) {
              const Y = new o.e(le);
              return (
                Y.setPositions(O.positions),
                Y.setNormals(O.normals),
                Y.setColors32(O.colors),
                Y.setUvs(0, O.uvs),
                Y.setIndices(O.indices),
                Y.setVertexStream(h.$_V, O.outlines, 3, void 0, h.n$B, !1),
                Y.setVertexStream(h.URU, O.shadows, 3, void 0, h.n$B, !1),
                Y.update(),
                Y
              );
            }
            const ae = /^[\r\n]$/,
              Z = /^[ \t]$/,
              J = /^[ \t\-]|[\u200b]$/,
              ve = /^[a-z0-9]$/i,
              _e =
                /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/,
              L =
                /^[〕〉》」』】〙〗〟ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻]$/,
              ge = [
                "\u200B",
                "\u061C",
                "\u200E",
                "\u200F",
                "\u202A",
                "\u202B",
                "\u202C",
                "\u202D",
                "\u202E",
                "\u2066",
                "\u2067",
                "\u2068",
                "\u2069",
              ],
              k = { width: 0, height: 0, xadvance: 0, xoffset: 0, yoffset: 0 },
              j = new y.Q(),
              B = new c.Z();
            class $ {
              constructor(O) {
                (this._element = O),
                  (this._system = O.system),
                  (this._entity = O.entity),
                  (this._text = ""),
                  (this._symbols = []),
                  (this._colorPalette = []),
                  (this._outlinePalette = []),
                  (this._shadowPalette = []),
                  (this._symbolColors = null),
                  (this._symbolOutlineParams = null),
                  (this._symbolShadowParams = null),
                  (this._i18nKey = null),
                  (this._fontAsset = new i.w(this._system.app)),
                  (this._fontAsset.disableLocalization = !0),
                  this._fontAsset.on("load", this._onFontLoad, this),
                  this._fontAsset.on("change", this._onFontChange, this),
                  this._fontAsset.on("remove", this._onFontRemove, this),
                  (this._font = null),
                  (this._color = new y.Q(1, 1, 1, 1)),
                  (this._colorUniform = new Float32Array(3)),
                  (this._spacing = 1),
                  (this._fontSize = 32),
                  (this._fontMinY = 0),
                  (this._fontMaxY = 0),
                  (this._originalFontSize = 32),
                  (this._maxFontSize = 32),
                  (this._minFontSize = 8),
                  (this._autoFitWidth = !1),
                  (this._autoFitHeight = !1),
                  (this._maxLines = -1),
                  (this._lineHeight = 32),
                  (this._scaledLineHeight = 32),
                  (this._wrapLines = !1),
                  (this._drawOrder = 0),
                  (this._alignment = new c.Z(0.5, 0.5)),
                  (this._autoWidth = !0),
                  (this._autoHeight = !0),
                  (this.width = 0),
                  (this.height = 0),
                  (this._node = new s.t()),
                  (this._model = new n.K()),
                  (this._model.graph = this._node),
                  this._entity.addChild(this._node),
                  (this._meshInfo = []),
                  (this._material = null),
                  (this._aabbDirty = !0),
                  (this._aabb = new d.I()),
                  (this._noResize = !1),
                  (this._currentMaterialType = null),
                  (this._maskedMaterialSrc = null),
                  (this._rtlReorder = !1),
                  (this._unicodeConverter = !1),
                  (this._rtl = !1),
                  (this._outlineColor = new y.Q(0, 0, 0, 1)),
                  (this._outlineColorUniform = new Float32Array(4)),
                  (this._outlineThicknessScale = 0.2),
                  (this._outlineThickness = 0),
                  (this._shadowColor = new y.Q(0, 0, 0, 1)),
                  (this._shadowColorUniform = new Float32Array(4)),
                  (this._shadowOffsetScale = 0.005),
                  (this._shadowOffset = new c.Z(0, 0)),
                  (this._shadowOffsetUniform = new Float32Array(2)),
                  (this._enableMarkup = !1),
                  this._onScreenChange(this._element.screen),
                  O.on("resize", this._onParentResize, this),
                  O.on("set:screen", this._onScreenChange, this),
                  O.on(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  O.on("set:draworder", this._onDrawOrderChange, this),
                  O.on("set:pivot", this._onPivotChange, this),
                  this._system.app.i18n.on(
                    "set:locale",
                    this._onLocaleSet,
                    this
                  ),
                  this._system.app.i18n.on(
                    "data:add",
                    this._onLocalizationData,
                    this
                  ),
                  this._system.app.i18n.on(
                    "data:remove",
                    this._onLocalizationData,
                    this
                  ),
                  (this._rangeStart = 0),
                  (this._rangeEnd = 0);
              }
              destroy() {
                this._setMaterial(null),
                  this._model &&
                    (this._element.removeModelFromLayers(this._model),
                    this._model.destroy(),
                    (this._model = null)),
                  this._fontAsset.destroy(),
                  (this.font = null),
                  this._element.off("resize", this._onParentResize, this),
                  this._element.off("set:screen", this._onScreenChange, this),
                  this._element.off(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  this._element.off(
                    "set:draworder",
                    this._onDrawOrderChange,
                    this
                  ),
                  this._element.off("set:pivot", this._onPivotChange, this),
                  this._system.app.i18n.off(
                    "set:locale",
                    this._onLocaleSet,
                    this
                  ),
                  this._system.app.i18n.off(
                    "data:add",
                    this._onLocalizationData,
                    this
                  ),
                  this._system.app.i18n.off(
                    "data:remove",
                    this._onLocalizationData,
                    this
                  );
              }
              _onParentResize(O, Y) {
                this._noResize || (this._font && this._updateText());
              }
              _onScreenChange(O) {
                O
                  ? this._updateMaterial(O.screen.screenSpace)
                  : this._updateMaterial(!1);
              }
              _onScreenSpaceChange(O) {
                this._updateMaterial(O);
              }
              _onDrawOrderChange(O) {
                if (((this._drawOrder = O), this._model))
                  for (
                    let Y = 0, ne = this._model.meshInstances.length;
                    Y < ne;
                    Y++
                  )
                    this._model.meshInstances[Y].drawOrder = O;
              }
              _onPivotChange(O) {
                this._font && this._updateText();
              }
              _onLocaleSet(O) {
                if (this._i18nKey) {
                  if (this.fontAsset) {
                    const Y = this._system.app.assets.get(this.fontAsset);
                    (!Y || !Y.resource || Y.resource !== this._font) &&
                      (this.font = null);
                  }
                  this._resetLocalizedText();
                }
              }
              _onLocalizationData(O, Y) {
                this._i18nKey && Y[this._i18nKey] && this._resetLocalizedText();
              }
              _resetLocalizedText() {
                this._setText(this._system.app.i18n.getText(this._i18nKey));
              }
              _setText(O) {
                if (this.unicodeConverter) {
                  const Y = this._system.getUnicodeConverter();
                  Y
                    ? (O = Y(O))
                    : console.warn(
                        "Element created with unicodeConverter option but no unicodeConverter function registered"
                      );
                }
                this._text !== O &&
                  (this._font && this._updateText(O), (this._text = O));
              }
              _updateText(O) {
                let Y;
                if (
                  (O === void 0 && (O = this._text),
                  (this._symbols = A.Y.getSymbols(
                    O.normalize ? O.normalize("NFC") : O
                  )),
                  this._symbols.length === 0 && (this._symbols = [" "]),
                  this._enableMarkup)
                ) {
                  const ue = ie.evaluate(this._symbols);
                  (this._symbols = ue.symbols), (Y = ue.tags || []);
                }
                if (this._rtlReorder) {
                  const ue = this._system.app.systems.element.getRtlReorder();
                  if (ue) {
                    const ye = ue(this._symbols);
                    (this._rtl = ye.rtl),
                      (this._symbols = ye.mapping.map(function (Oe) {
                        return this._symbols[Oe];
                      }, this)),
                      Y &&
                        (Y = ye.mapping.map(function (Oe) {
                          return Y[Oe];
                        }));
                  } else
                    console.warn(
                      "Element created with rtlReorder option but no rtlReorder function registered"
                    );
                } else this._rtl = !1;
                const ne = (ue, ye) =>
                    `${ue.toString(!0).toLowerCase()}:${ye.toFixed(2)}`,
                  de = (ue, ye) =>
                    `${ue.toString(!0).toLowerCase()}:${ye.x.toFixed(
                      2
                    )}:${ye.y.toFixed(2)}`;
                if (Y) {
                  const ue = {},
                    ye = {},
                    Oe = {};
                  (this._colorPalette = [
                    Math.round(this._color.r * 255),
                    Math.round(this._color.g * 255),
                    Math.round(this._color.b * 255),
                  ]),
                    (this._outlinePalette = [
                      Math.round(this._outlineColor.r * 255),
                      Math.round(this._outlineColor.g * 255),
                      Math.round(this._outlineColor.b * 255),
                      Math.round(this._outlineColor.a * 255),
                      Math.round(this._outlineThickness * 255),
                    ]),
                    (this._shadowPalette = [
                      Math.round(this._shadowColor.r * 255),
                      Math.round(this._shadowColor.g * 255),
                      Math.round(this._shadowColor.b * 255),
                      Math.round(this._shadowColor.a * 255),
                      Math.round(this._shadowOffset.x * 127),
                      Math.round(this._shadowOffset.y * 127),
                    ]),
                    (this._symbolColors = []),
                    (this._symbolOutlineParams = []),
                    (this._symbolShadowParams = []),
                    (ue[this._color.toString(!1).toLowerCase()] = 0),
                    (ye[ne(this._outlineColor, this._outlineThickness)] = 0),
                    (Oe[de(this._shadowColor, this._shadowOffset)] = 0);
                  for (let Ae = 0, ke = this._symbols.length; Ae < ke; ++Ae) {
                    const Ue = Y[Ae];
                    let Ge = 0;
                    if (Ue && Ue.color && Ue.color.value) {
                      const z = Ue.color.value;
                      if (z.length === 7 && z[0] === "#") {
                        const K = z.substring(1).toLowerCase();
                        ue.hasOwnProperty(K)
                          ? (Ge = ue[K])
                          : /^([0-9a-f]{2}){3}$/.test(K) &&
                            ((Ge = this._colorPalette.length / 3),
                            (ue[K] = Ge),
                            this._colorPalette.push(
                              parseInt(K.substring(0, 2), 16)
                            ),
                            this._colorPalette.push(
                              parseInt(K.substring(2, 4), 16)
                            ),
                            this._colorPalette.push(
                              parseInt(K.substring(4, 6), 16)
                            ));
                      }
                    }
                    this._symbolColors.push(Ge);
                    let ht = 0;
                    if (
                      Ue &&
                      Ue.outline &&
                      (Ue.outline.attributes.color ||
                        Ue.outline.attributes.thickness)
                    ) {
                      let z = Ue.outline.attributes.color
                          ? j.fromString(Ue.outline.attributes.color)
                          : this._outlineColor,
                        K = Number(Ue.outline.attributes.thickness);
                      (Number.isNaN(z.r) ||
                        Number.isNaN(z.g) ||
                        Number.isNaN(z.b) ||
                        Number.isNaN(z.a)) &&
                        (z = this._outlineColor),
                        Number.isNaN(K) && (K = this._outlineThickness);
                      const Te = ne(z, K);
                      ye.hasOwnProperty(Te)
                        ? (ht = ye[Te])
                        : ((ht = this._outlinePalette.length / 5),
                          (ye[Te] = ht),
                          this._outlinePalette.push(
                            Math.round(z.r * 255),
                            Math.round(z.g * 255),
                            Math.round(z.b * 255),
                            Math.round(z.a * 255),
                            Math.round(K * 255)
                          ));
                    }
                    this._symbolOutlineParams.push(ht);
                    let me = 0;
                    if (
                      Ue &&
                      Ue.shadow &&
                      (Ue.shadow.attributes.color ||
                        Ue.shadow.attributes.offset ||
                        Ue.shadow.attributes.offsetX ||
                        Ue.shadow.attributes.offsetY)
                    ) {
                      let z = Ue.shadow.attributes.color
                        ? j.fromString(Ue.shadow.attributes.color)
                        : this._shadowColor;
                      const K = Number(Ue.shadow.attributes.offset),
                        Te = Number(Ue.shadow.attributes.offsetX),
                        H = Number(Ue.shadow.attributes.offsetY);
                      (Number.isNaN(z.r) ||
                        Number.isNaN(z.g) ||
                        Number.isNaN(z.b) ||
                        Number.isNaN(z.a)) &&
                        (z = this._shadowColor);
                      const q = B.set(
                          Number.isNaN(Te)
                            ? Number.isNaN(K)
                              ? this._shadowOffset.x
                              : K
                            : Te,
                          Number.isNaN(H)
                            ? Number.isNaN(K)
                              ? this._shadowOffset.y
                              : K
                            : H
                        ),
                        se = de(z, q);
                      Oe.hasOwnProperty(se)
                        ? (me = Oe[se])
                        : ((me = this._shadowPalette.length / 6),
                          (Oe[se] = me),
                          this._shadowPalette.push(
                            Math.round(z.r * 255),
                            Math.round(z.g * 255),
                            Math.round(z.b * 255),
                            Math.round(z.a * 255),
                            Math.round(q.x * 127),
                            Math.round(q.y * 127)
                          ));
                    }
                    this._symbolShadowParams.push(me);
                  }
                } else
                  (this._colorPalette = []),
                    (this._symbolColors = null),
                    (this._symbolOutlineParams = null),
                    (this._symbolShadowParams = null);
                this._updateMaterialEmissive(),
                  this._updateMaterialOutline(),
                  this._updateMaterialShadow();
                const re = this._calculateCharsPerTexture();
                let I = !1;
                const w = this._element,
                  N = w._isScreenSpace(),
                  W = w._isScreenCulled(),
                  he = function (ye) {
                    return w.isVisibleForCamera(ye);
                  };
                for (let ue = 0, ye = this._meshInfo.length; ue < ye; ue++) {
                  const Oe = re[ue] || 0,
                    Ae = this._meshInfo[ue];
                  if (Ae.count !== Oe) {
                    if (
                      (I || (w.removeModelFromLayers(this._model), (I = !0)),
                      (Ae.count = Oe),
                      (Ae.positions.length = Ae.normals.length = Oe * 3 * 4),
                      (Ae.indices.length = Oe * 3 * 2),
                      (Ae.uvs.length = Oe * 2 * 4),
                      (Ae.colors.length = Oe * 4 * 4),
                      (Ae.outlines.length = Oe * 4 * 3),
                      (Ae.shadows.length = Oe * 4 * 3),
                      Ae.meshInstance &&
                        this._removeMeshInstance(Ae.meshInstance),
                      Oe === 0)
                    ) {
                      Ae.meshInstance = null;
                      continue;
                    }
                    for (let Ge = 0; Ge < Oe; Ge++)
                      (Ae.indices[Ge * 3 * 2 + 0] = Ge * 4),
                        (Ae.indices[Ge * 3 * 2 + 1] = Ge * 4 + 1),
                        (Ae.indices[Ge * 3 * 2 + 2] = Ge * 4 + 3),
                        (Ae.indices[Ge * 3 * 2 + 3] = Ge * 4 + 2),
                        (Ae.indices[Ge * 3 * 2 + 4] = Ge * 4 + 3),
                        (Ae.indices[Ge * 3 * 2 + 5] = Ge * 4 + 1),
                        (Ae.normals[Ge * 4 * 3 + 0] = 0),
                        (Ae.normals[Ge * 4 * 3 + 1] = 0),
                        (Ae.normals[Ge * 4 * 3 + 2] = -1),
                        (Ae.normals[Ge * 4 * 3 + 3] = 0),
                        (Ae.normals[Ge * 4 * 3 + 4] = 0),
                        (Ae.normals[Ge * 4 * 3 + 5] = -1),
                        (Ae.normals[Ge * 4 * 3 + 6] = 0),
                        (Ae.normals[Ge * 4 * 3 + 7] = 0),
                        (Ae.normals[Ge * 4 * 3 + 8] = -1),
                        (Ae.normals[Ge * 4 * 3 + 9] = 0),
                        (Ae.normals[Ge * 4 * 3 + 10] = 0),
                        (Ae.normals[Ge * 4 * 3 + 11] = -1);
                    const ke = te(this._system.app.graphicsDevice, Ae),
                      Ue = new l.F(ke, this._material, this._node);
                    if (
                      ((Ue.name = "Text Element: " + this._entity.name),
                      (Ue.castShadow = !1),
                      (Ue.receiveShadow = !1),
                      (Ue.cull = !N),
                      (Ue.screenSpace = N),
                      (Ue.drawOrder = this._drawOrder),
                      W && ((Ue.cull = !0), (Ue.isVisibleFunc = he)),
                      this._setTextureParams(Ue, this._font.textures[ue]),
                      Ue.setParameter("material_emissive", this._colorUniform),
                      Ue.setParameter("material_opacity", this._color.a),
                      Ue.setParameter(
                        "font_sdfIntensity",
                        this._font.intensity
                      ),
                      Ue.setParameter(
                        "font_pxrange",
                        this._getPxRange(this._font)
                      ),
                      Ue.setParameter(
                        "font_textureWidth",
                        this._font.data.info.maps[ue].width
                      ),
                      Ue.setParameter(
                        "outline_color",
                        this._outlineColorUniform
                      ),
                      Ue.setParameter(
                        "outline_thickness",
                        this._outlineThicknessScale * this._outlineThickness
                      ),
                      Ue.setParameter("shadow_color", this._shadowColorUniform),
                      this._symbolShadowParams)
                    )
                      (this._shadowOffsetUniform[0] = 0),
                        (this._shadowOffsetUniform[1] = 0);
                    else {
                      const Ge =
                        -this._font.data.info.maps[ue].width /
                        this._font.data.info.maps[ue].height;
                      (this._shadowOffsetUniform[0] =
                        this._shadowOffsetScale * this._shadowOffset.x),
                        (this._shadowOffsetUniform[1] =
                          Ge * this._shadowOffsetScale * this._shadowOffset.y);
                    }
                    Ue.setParameter("shadow_offset", this._shadowOffsetUniform),
                      (Ae.meshInstance = Ue),
                      this._model.meshInstances.push(Ue);
                  }
                }
                this._element.maskedBy &&
                  this._element._setMaskedBy(this._element.maskedBy),
                  I &&
                    this._element.enabled &&
                    this._entity.enabled &&
                    this._element.addModelToLayers(this._model),
                  this._updateMeshes(),
                  (this._rangeStart = 0),
                  (this._rangeEnd = this._symbols.length),
                  this._updateRenderRange();
              }
              _removeMeshInstance(O) {
                O.destroy();
                const Y = this._model.meshInstances.indexOf(O);
                Y !== -1 && this._model.meshInstances.splice(Y, 1);
              }
              _setMaterial(O) {
                if (((this._material = O), this._model))
                  for (
                    let Y = 0, ne = this._model.meshInstances.length;
                    Y < ne;
                    Y++
                  ) {
                    const de = this._model.meshInstances[Y];
                    de.material = O;
                  }
              }
              _updateMaterial(O) {
                const Y = this._element,
                  ne = Y._isScreenCulled(),
                  de = function (w) {
                    return Y.isVisibleForCamera(w);
                  },
                  re = this._font && this._font.type === e.P;
                if (
                  ((this._material = this._system.getTextElementMaterial(
                    O,
                    re,
                    this._enableMarkup
                  )),
                  this._model)
                )
                  for (
                    let I = 0, w = this._model.meshInstances.length;
                    I < w;
                    I++
                  ) {
                    const N = this._model.meshInstances[I];
                    (N.cull = !O),
                      (N.material = this._material),
                      (N.screenSpace = O),
                      ne
                        ? ((N.cull = !0), (N.isVisibleFunc = de))
                        : (N.isVisibleFunc = null);
                  }
              }
              _updateMaterialEmissive() {
                this._symbolColors
                  ? ((this._colorUniform[0] = 1),
                    (this._colorUniform[1] = 1),
                    (this._colorUniform[2] = 1))
                  : ((this._colorUniform[0] = this._color.r),
                    (this._colorUniform[1] = this._color.g),
                    (this._colorUniform[2] = this._color.b));
              }
              _updateMaterialOutline() {
                this._symbolOutlineParams
                  ? ((this._outlineColorUniform[0] = 0),
                    (this._outlineColorUniform[1] = 0),
                    (this._outlineColorUniform[2] = 0),
                    (this._outlineColorUniform[3] = 1))
                  : ((this._outlineColorUniform[0] = this._outlineColor.r),
                    (this._outlineColorUniform[1] = this._outlineColor.g),
                    (this._outlineColorUniform[2] = this._outlineColor.b),
                    (this._outlineColorUniform[3] = this._outlineColor.a));
              }
              _updateMaterialShadow() {
                this._symbolOutlineParams
                  ? ((this._shadowColorUniform[0] = 0),
                    (this._shadowColorUniform[1] = 0),
                    (this._shadowColorUniform[2] = 0),
                    (this._shadowColorUniform[3] = 0))
                  : ((this._shadowColorUniform[0] = this._shadowColor.r),
                    (this._shadowColorUniform[1] = this._shadowColor.g),
                    (this._shadowColorUniform[2] = this._shadowColor.b),
                    (this._shadowColorUniform[3] = this._shadowColor.a));
              }
              _isWordBoundary(O) {
                return J.test(O);
              }
              _isValidNextChar(O) {
                return O !== null && !L.test(O);
              }
              _isNextCJKBoundary(O, Y) {
                return _e.test(O) && (J.test(Y) || ve.test(Y));
              }
              _isNextCJKWholeWord(O) {
                return _e.test(O);
              }
              _updateMeshes() {
                const O = this._font.data,
                  Y = this,
                  ne = Math.min(this._minFontSize, this._maxFontSize),
                  de = this._maxFontSize,
                  re = this._shouldAutoFit();
                re && (this._fontSize = this._maxFontSize);
                const I = 32,
                  w = this._symbols.length;
                let N = 0,
                  W = 0,
                  he = 0,
                  ue = 0,
                  ye = 1,
                  Oe = 0,
                  Ae = 0,
                  ke = 0,
                  Ue = 0,
                  Ge = 0,
                  ht = 0;
                const me =
                  Math.abs(this._element.anchor.x - this._element.anchor.z) >=
                  1e-4;
                let z = this._element.calculatedWidth;
                ((this.autoWidth && !me) || !this._wrapLines) &&
                  (z = Number.POSITIVE_INFINITY);
                let K = 0,
                  Te = 0,
                  H,
                  q,
                  se,
                  Ce;
                function we(it, At, Rt) {
                  Y._lineWidths.push(Math.abs(Rt));
                  const Ft = ke > At ? At + 1 : ke,
                    ut = ke > At ? ke + 1 : At,
                    Pt = it.slice(Ft, ut);
                  if (ht) {
                    let bt = Pt.length;
                    for (; bt-- && ht > 0; )
                      ae.test(Pt[bt]) && (Pt.splice(bt, 1), ht--);
                  }
                  Y._lineContents.push(Pt.join("")),
                    (N = 0),
                    (W -= Y._scaledLineHeight),
                    ye++,
                    (Ue = 0),
                    (Ge = 0),
                    (ht = 0),
                    (Oe = 0),
                    (ke = At);
                }
                let Me = !0;
                for (; Me; ) {
                  (Me = !1),
                    re
                      ? (this._scaledLineHeight =
                          (this._lineHeight * this._fontSize) /
                          (this._maxFontSize || 1e-4))
                      : (this._scaledLineHeight = this._lineHeight),
                    (this.width = 0),
                    (this.height = 0),
                    (this._lineWidths = []),
                    (this._lineContents = []),
                    (N = 0),
                    (W = 0),
                    (he = 0),
                    (ue = 0),
                    (ye = 1),
                    (Oe = 0),
                    (Ae = 0),
                    (ke = 0),
                    (Ue = 0),
                    (Ge = 0),
                    (ht = 0);
                  const it = this._fontSize / I;
                  (K = this._fontMinY * it), (Te = this._fontMaxY * it);
                  for (let Pe = 0; Pe < this._meshInfo.length; Pe++)
                    (this._meshInfo[Pe].quad = 0),
                      (this._meshInfo[Pe].lines = {});
                  let At = 255,
                    Rt = 255,
                    Ft = 255,
                    ut = 255 + 255 * 256,
                    Pt = 255 + 255 * 256,
                    bt = 0,
                    Zt = 255 + 255 * 256,
                    Xt = 255 + 255 * 256,
                    yt = 127 + 127 * 256;
                  for (let Pe = 0; Pe < w; Pe++) {
                    if (
                      ((H = this._symbols[Pe]),
                      (Ce = Pe + 1 >= w ? null : this._symbols[Pe + 1]),
                      ae.test(H))
                    ) {
                      ht++,
                        (!this._wrapLines ||
                          this._maxLines < 0 ||
                          ye < this._maxLines) &&
                          (we(this._symbols, Pe, ue),
                          (Ae = Pe + 1),
                          (ke = Pe + 1));
                      continue;
                    }
                    let Je = 0,
                      rt = 0,
                      ct = 0,
                      Ve = 1,
                      wt,
                      at;
                    if (((q = O.chars[H]), !q))
                      if (ge.indexOf(H) !== -1) q = k;
                      else if (O.chars[" "]) q = O.chars[" "];
                      else
                        for (const et in O.chars) {
                          q = O.chars[et];
                          break;
                        }
                    if (q) {
                      let et = 0;
                      if (Ge > 0) {
                        const _t = this._font.data.kerning;
                        if (_t) {
                          const Qe =
                            _t[A.Y.getCodePoint(this._symbols[Pe - 1]) || 0];
                          Qe &&
                            (et =
                              Qe[A.Y.getCodePoint(this._symbols[Pe]) || 0] ||
                              0);
                        }
                      }
                      (wt = q.scale || 1),
                        (at = (q.width + q.height) / 2),
                        (Ve = (it * at) / wt),
                        (ct = (q.xadvance + et) * it),
                        (Je = (q.xoffset - et) * it),
                        (rt = q.yoffset * it);
                    } else
                      console.error(
                        `Couldn't substitute missing character: '${H}'`
                      );
                    const ce = Z.test(H),
                      pe = (q && q.map) || 0,
                      De =
                        -this._font.data.info.maps[pe].width /
                        this._font.data.info.maps[pe].height,
                      fe = this._meshInfo[pe],
                      Ze = N + this._spacing * ct;
                    if (
                      Ze > z &&
                      Ge > 0 &&
                      !ce &&
                      (this._maxLines < 0 || ye < this._maxLines)
                    )
                      if (Ue === 0) (Ae = Pe), we(this._symbols, Pe, ue);
                      else {
                        const et = Math.max(Pe - Ae, 0);
                        if (this._meshInfo.length <= 1)
                          (fe.lines[ye - 1] -= et), (fe.quad -= et);
                        else {
                          const _t = Ae,
                            Qe = Pe;
                          for (let lt = _t; lt < Qe; lt++) {
                            const xt = this._symbols[lt],
                              Tt = O.chars[xt],
                              ft = this._meshInfo[(Tt && Tt.map) || 0];
                            (ft.lines[ye - 1] -= 1), (ft.quad -= 1);
                          }
                        }
                        (Pe -= et + 1), we(this._symbols, Ae, Oe);
                        continue;
                      }
                    (se = fe.quad), (fe.lines[ye - 1] = se);
                    let Ne = N - Je,
                      Ye = Ne + Ve;
                    const Ke = W - rt,
                      nt = Ke + Ve;
                    if (this._rtl) {
                      const et = Ve - Je - this._spacing * ct - Je;
                      (Ne -= et), (Ye -= et);
                    }
                    (fe.positions[se * 4 * 3 + 0] = Ne),
                      (fe.positions[se * 4 * 3 + 1] = Ke),
                      (fe.positions[se * 4 * 3 + 2] = he),
                      (fe.positions[se * 4 * 3 + 3] = Ye),
                      (fe.positions[se * 4 * 3 + 4] = Ke),
                      (fe.positions[se * 4 * 3 + 5] = he),
                      (fe.positions[se * 4 * 3 + 6] = Ye),
                      (fe.positions[se * 4 * 3 + 7] = nt),
                      (fe.positions[se * 4 * 3 + 8] = he),
                      (fe.positions[se * 4 * 3 + 9] = Ne),
                      (fe.positions[se * 4 * 3 + 10] = nt),
                      (fe.positions[se * 4 * 3 + 11] = he),
                      (this.width = Math.max(this.width, Ze));
                    let ot;
                    if (
                      this._shouldAutoFitWidth() &&
                      this.width > this._element.calculatedWidth &&
                      ((ot = Math.floor(
                        (this._element.fontSize *
                          this._element.calculatedWidth) /
                          (this.width || 1e-4)
                      )),
                      (ot = x.D.clamp(ot, ne, de)),
                      ot !== this._element.fontSize)
                    ) {
                      (this._fontSize = ot), (Me = !0);
                      break;
                    }
                    if (
                      ((this.height = Math.max(this.height, Te - (W + K))),
                      this._shouldAutoFitHeight() &&
                        this.height > this._element.calculatedHeight &&
                        ((ot = x.D.clamp(this._fontSize - 1, ne, de)),
                        ot !== this._element.fontSize))
                    ) {
                      (this._fontSize = ot), (Me = !0);
                      break;
                    }
                    (N += this._spacing * ct),
                      ce || (ue = N),
                      (this._isWordBoundary(H) ||
                        (this._isValidNextChar(Ce) &&
                          (this._isNextCJKBoundary(H, Ce) ||
                            this._isNextCJKWholeWord(Ce)))) &&
                        (Ue++, (Oe = ue), (Ae = Pe + 1)),
                      Ge++;
                    const ze = this._getUv(H);
                    if (
                      ((fe.uvs[se * 4 * 2 + 0] = ze[0]),
                      (fe.uvs[se * 4 * 2 + 1] = 1 - ze[1]),
                      (fe.uvs[se * 4 * 2 + 2] = ze[2]),
                      (fe.uvs[se * 4 * 2 + 3] = 1 - ze[1]),
                      (fe.uvs[se * 4 * 2 + 4] = ze[2]),
                      (fe.uvs[se * 4 * 2 + 5] = 1 - ze[3]),
                      (fe.uvs[se * 4 * 2 + 6] = ze[0]),
                      (fe.uvs[se * 4 * 2 + 7] = 1 - ze[3]),
                      this._symbolColors)
                    ) {
                      const et = this._symbolColors[Pe] * 3;
                      (At = this._colorPalette[et]),
                        (Rt = this._colorPalette[et + 1]),
                        (Ft = this._colorPalette[et + 2]);
                    }
                    if (
                      ((fe.colors[se * 4 * 4 + 0] = At),
                      (fe.colors[se * 4 * 4 + 1] = Rt),
                      (fe.colors[se * 4 * 4 + 2] = Ft),
                      (fe.colors[se * 4 * 4 + 3] = 255),
                      (fe.colors[se * 4 * 4 + 4] = At),
                      (fe.colors[se * 4 * 4 + 5] = Rt),
                      (fe.colors[se * 4 * 4 + 6] = Ft),
                      (fe.colors[se * 4 * 4 + 7] = 255),
                      (fe.colors[se * 4 * 4 + 8] = At),
                      (fe.colors[se * 4 * 4 + 9] = Rt),
                      (fe.colors[se * 4 * 4 + 10] = Ft),
                      (fe.colors[se * 4 * 4 + 11] = 255),
                      (fe.colors[se * 4 * 4 + 12] = At),
                      (fe.colors[se * 4 * 4 + 13] = Rt),
                      (fe.colors[se * 4 * 4 + 14] = Ft),
                      (fe.colors[se * 4 * 4 + 15] = 255),
                      this._symbolOutlineParams)
                    ) {
                      const et = this._symbolOutlineParams[Pe] * 5;
                      (ut =
                        this._outlinePalette[et] +
                        this._outlinePalette[et + 1] * 256),
                        (Pt =
                          this._outlinePalette[et + 2] +
                          this._outlinePalette[et + 3] * 256),
                        (bt = this._outlinePalette[et + 4]);
                    }
                    if (
                      ((fe.outlines[se * 4 * 3 + 0] = ut),
                      (fe.outlines[se * 4 * 3 + 1] = Pt),
                      (fe.outlines[se * 4 * 3 + 2] = bt),
                      (fe.outlines[se * 4 * 3 + 3] = ut),
                      (fe.outlines[se * 4 * 3 + 4] = Pt),
                      (fe.outlines[se * 4 * 3 + 5] = bt),
                      (fe.outlines[se * 4 * 3 + 6] = ut),
                      (fe.outlines[se * 4 * 3 + 7] = Pt),
                      (fe.outlines[se * 4 * 3 + 8] = bt),
                      (fe.outlines[se * 4 * 3 + 9] = ut),
                      (fe.outlines[se * 4 * 3 + 10] = Pt),
                      (fe.outlines[se * 4 * 3 + 11] = bt),
                      this._symbolShadowParams)
                    ) {
                      const et = this._symbolShadowParams[Pe] * 6;
                      (Zt =
                        this._shadowPalette[et] +
                        this._shadowPalette[et + 1] * 256),
                        (Xt =
                          this._shadowPalette[et + 2] +
                          this._shadowPalette[et + 3] * 256),
                        (yt =
                          this._shadowPalette[et + 4] +
                          127 +
                          Math.round(De * this._shadowPalette[et + 5] + 127) *
                            256);
                    }
                    (fe.shadows[se * 4 * 3 + 0] = Zt),
                      (fe.shadows[se * 4 * 3 + 1] = Xt),
                      (fe.shadows[se * 4 * 3 + 2] = yt),
                      (fe.shadows[se * 4 * 3 + 3] = Zt),
                      (fe.shadows[se * 4 * 3 + 4] = Xt),
                      (fe.shadows[se * 4 * 3 + 5] = yt),
                      (fe.shadows[se * 4 * 3 + 6] = Zt),
                      (fe.shadows[se * 4 * 3 + 7] = Xt),
                      (fe.shadows[se * 4 * 3 + 8] = yt),
                      (fe.shadows[se * 4 * 3 + 9] = Zt),
                      (fe.shadows[se * 4 * 3 + 10] = Xt),
                      (fe.shadows[se * 4 * 3 + 11] = yt),
                      fe.quad++;
                  }
                  Me || (ke < w && we(this._symbols, w, N));
                }
                (this._noResize = !0),
                  (this.autoWidth = this._autoWidth),
                  (this.autoHeight = this._autoHeight),
                  (this._noResize = !1);
                const Ie = this._element.pivot.x,
                  Le = this._element.pivot.y,
                  tt = this._alignment.x,
                  vt = this._alignment.y;
                for (let it = 0; it < this._meshInfo.length; it++) {
                  if (this._meshInfo[it].count === 0) continue;
                  let At = 0;
                  for (const Pt in this._meshInfo[it].lines) {
                    const bt = this._meshInfo[it].lines[Pt],
                      Zt = this._lineWidths[parseInt(Pt, 10)],
                      Xt =
                        -Ie * this._element.calculatedWidth +
                        tt *
                          (this._element.calculatedWidth - Zt) *
                          (this._rtl ? -1 : 1),
                      yt =
                        (1 - Le) * this._element.calculatedHeight -
                        Te -
                        (1 - vt) *
                          (this._element.calculatedHeight - this.height);
                    for (let Pe = At; Pe <= bt; Pe++)
                      (this._meshInfo[it].positions[Pe * 4 * 3] += Xt),
                        (this._meshInfo[it].positions[Pe * 4 * 3 + 3] += Xt),
                        (this._meshInfo[it].positions[Pe * 4 * 3 + 6] += Xt),
                        (this._meshInfo[it].positions[Pe * 4 * 3 + 9] += Xt),
                        (this._meshInfo[it].positions[Pe * 4 * 3 + 1] += yt),
                        (this._meshInfo[it].positions[Pe * 4 * 3 + 4] += yt),
                        (this._meshInfo[it].positions[Pe * 4 * 3 + 7] += yt),
                        (this._meshInfo[it].positions[Pe * 4 * 3 + 10] += yt);
                    if (this._rtl)
                      for (let Pe = At; Pe <= bt; Pe++) {
                        const $e = Pe * 4 * 3;
                        for (let ct = 0; ct < 4; ++ct)
                          this._meshInfo[it].positions[$e + ct * 3] =
                            this._element.calculatedWidth -
                            this._meshInfo[it].positions[$e + ct * 3] +
                            Xt * 2;
                        const Je = this._meshInfo[it].positions[$e + 3],
                          rt = this._meshInfo[it].positions[$e + 6];
                        (this._meshInfo[it].positions[$e + 3] =
                          this._meshInfo[it].positions[$e + 0]),
                          (this._meshInfo[it].positions[$e + 6] =
                            this._meshInfo[it].positions[$e + 9]),
                          (this._meshInfo[it].positions[$e + 0] = Je),
                          (this._meshInfo[it].positions[$e + 9] = rt);
                      }
                    At = bt + 1;
                  }
                  const Rt = this._meshInfo[it].count * 4,
                    Ft = this._meshInfo[it].quad * 4,
                    ut = new f.P(
                      this._meshInfo[it].meshInstance.mesh.vertexBuffer
                    );
                  for (let Pt = 0; Pt < Rt; Pt++)
                    Pt >= Ft
                      ? (ut.element[h.JYe].set(0, 0, 0),
                        ut.element[h.slc].set(0, 0),
                        ut.element[h.F8$].set(0, 0, 0, 0),
                        ut.element[h.$_V].set(0, 0, 0, 0),
                        ut.element[h.URU].set(0, 0, 0, 0))
                      : (ut.element[h.JYe].set(
                          this._meshInfo[it].positions[Pt * 3 + 0],
                          this._meshInfo[it].positions[Pt * 3 + 1],
                          this._meshInfo[it].positions[Pt * 3 + 2]
                        ),
                        ut.element[h.slc].set(
                          this._meshInfo[it].uvs[Pt * 2 + 0],
                          this._meshInfo[it].uvs[Pt * 2 + 1]
                        ),
                        ut.element[h.F8$].set(
                          this._meshInfo[it].colors[Pt * 4 + 0],
                          this._meshInfo[it].colors[Pt * 4 + 1],
                          this._meshInfo[it].colors[Pt * 4 + 2],
                          this._meshInfo[it].colors[Pt * 4 + 3]
                        ),
                        ut.element[h.$_V].set(
                          this._meshInfo[it].outlines[Pt * 3 + 0],
                          this._meshInfo[it].outlines[Pt * 3 + 1],
                          this._meshInfo[it].outlines[Pt * 3 + 2]
                        ),
                        ut.element[h.URU].set(
                          this._meshInfo[it].shadows[Pt * 3 + 0],
                          this._meshInfo[it].shadows[Pt * 3 + 1],
                          this._meshInfo[it].shadows[Pt * 3 + 2]
                        )),
                      ut.next();
                  ut.end(),
                    this._meshInfo[it].meshInstance.mesh.aabb.compute(
                      this._meshInfo[it].positions
                    ),
                    (this._meshInfo[it].meshInstance._aabbVer = -1);
                }
                this._aabbDirty = !0;
              }
              _onFontRender() {
                this.font = this._font;
              }
              _onFontLoad(O) {
                this.font !== O.resource && (this.font = O.resource);
              }
              _onFontChange(O, Y, ne, de) {
                if (Y === "data") {
                  this._font.data = ne;
                  const re = this._font.data.info.maps.length;
                  for (let I = 0; I < re; I++) {
                    if (!this._meshInfo[I]) continue;
                    const w = this._meshInfo[I].meshInstance;
                    w &&
                      (w.setParameter(
                        "font_sdfIntensity",
                        this._font.intensity
                      ),
                      w.setParameter(
                        "font_pxrange",
                        this._getPxRange(this._font)
                      ),
                      w.setParameter(
                        "font_textureWidth",
                        this._font.data.info.maps[I].width
                      ));
                  }
                }
              }
              _onFontRemove(O) {}
              _setTextureParams(O, Y) {
                this._font &&
                  (this._font.type === e.P
                    ? (O.deleteParameter("texture_emissiveMap"),
                      O.deleteParameter("texture_opacityMap"),
                      O.setParameter("texture_msdfMap", Y))
                    : this._font.type === e.M &&
                      (O.deleteParameter("texture_msdfMap"),
                      O.setParameter("texture_emissiveMap", Y),
                      O.setParameter("texture_opacityMap", Y)));
              }
              _getPxRange(O) {
                const Y = Object.keys(this._font.data.chars);
                for (let ne = 0; ne < Y.length; ne++) {
                  const de = this._font.data.chars[Y[ne]];
                  if (de.range) return (de.scale || 1) * de.range;
                }
                return 2;
              }
              _getUv(O) {
                const Y = this._font.data;
                if (!Y.chars[O]) {
                  const Oe = " ";
                  return Y.chars[Oe] ? this._getUv(Oe) : [0, 0, 0, 0];
                }
                const ne = Y.chars[O].map,
                  de = Y.info.maps[ne].width,
                  re = Y.info.maps[ne].height,
                  I = Y.chars[O].x,
                  w = Y.chars[O].y,
                  N = I,
                  W = w,
                  he = I + Y.chars[O].width,
                  ue = w - Y.chars[O].height,
                  ye = 1 - Y.chars[O].height / re;
                return [N / de, ye - W / re, he / de, ye - ue / re];
              }
              onEnable() {
                (this._fontAsset.autoLoad = !0),
                  this._model && this._element.addModelToLayers(this._model);
              }
              onDisable() {
                (this._fontAsset.autoLoad = !1),
                  this._model &&
                    this._element.removeModelFromLayers(this._model);
              }
              _setStencil(O) {
                if (this._model) {
                  const Y = this._model.meshInstances;
                  for (let ne = 0; ne < Y.length; ne++)
                    (Y[ne].stencilFront = O), (Y[ne].stencilBack = O);
                }
              }
              _shouldAutoFitWidth() {
                return this._autoFitWidth && !this._autoWidth;
              }
              _shouldAutoFitHeight() {
                return this._autoFitHeight && !this._autoHeight;
              }
              _shouldAutoFit() {
                return (
                  (this._autoFitWidth && !this._autoWidth) ||
                  (this._autoFitHeight && !this._autoHeight)
                );
              }
              _calculateCharsPerTexture(O) {
                const Y = {};
                O === void 0 && (O = this._symbols.length);
                for (let ne = 0, de = O; ne < de; ne++) {
                  const re = this._symbols[ne];
                  let I = this._font.data.chars[re];
                  I ||
                    ((I = this._font.data.chars[" "]),
                    I ||
                      (I =
                        this._font.data.chars[
                          Object.keys(this._font.data.chars)[0]
                        ]));
                  const w = I.map;
                  Y[w] ? Y[w]++ : (Y[w] = 1);
                }
                return Y;
              }
              _updateRenderRange() {
                const O =
                    this._rangeStart === 0
                      ? 0
                      : this._calculateCharsPerTexture(this._rangeStart),
                  Y =
                    this._rangeEnd === 0
                      ? 0
                      : this._calculateCharsPerTexture(this._rangeEnd);
                for (let ne = 0, de = this._meshInfo.length; ne < de; ne++) {
                  const re = O[ne] || 0,
                    I = Y[ne] || 0,
                    w = this._meshInfo[ne].meshInstance;
                  if (w) {
                    const N = w.mesh;
                    N &&
                      ((N.primitive[0].base = re * 3 * 2),
                      (N.primitive[0].count = (I - re) * 3 * 2));
                  }
                }
              }
              set text(O) {
                this._i18nKey = null;
                const Y = (O != null && O.toString()) || "";
                this._setText(Y);
              }
              get text() {
                return this._text;
              }
              set key(O) {
                const Y = O !== null ? O.toString() : null;
                this._i18nKey !== Y &&
                  ((this._i18nKey = Y),
                  Y
                    ? ((this._fontAsset.disableLocalization = !1),
                      this._resetLocalizedText())
                    : (this._fontAsset.disableLocalization = !0));
              }
              get key() {
                return this._i18nKey;
              }
              set color(O) {
                const Y = O.r,
                  ne = O.g,
                  de = O.b;
                if (
                  !(
                    this._color.r === Y &&
                    this._color.g === ne &&
                    this._color.b === de
                  ) &&
                  ((this._color.r = Y),
                  (this._color.g = ne),
                  (this._color.b = de),
                  !!this._model)
                ) {
                  if (this._symbolColors) this._font && this._updateText();
                  else {
                    (this._colorUniform[0] = this._color.r),
                      (this._colorUniform[1] = this._color.g),
                      (this._colorUniform[2] = this._color.b);
                    for (
                      let re = 0, I = this._model.meshInstances.length;
                      re < I;
                      re++
                    )
                      this._model.meshInstances[re].setParameter(
                        "material_emissive",
                        this._colorUniform
                      );
                  }
                  this._element && this._element.fire("set:color", this._color);
                }
              }
              get color() {
                return this._color;
              }
              set opacity(O) {
                if (this._color.a !== O && ((this._color.a = O), this._model))
                  for (
                    let Y = 0, ne = this._model.meshInstances.length;
                    Y < ne;
                    Y++
                  )
                    this._model.meshInstances[Y].setParameter(
                      "material_opacity",
                      O
                    );
                this._element && this._element.fire("set:opacity", O);
              }
              get opacity() {
                return this._color.a;
              }
              set lineHeight(O) {
                const Y = this._lineHeight;
                (this._lineHeight = O),
                  (this._scaledLineHeight = O),
                  Y !== O && this._font && this._updateText();
              }
              get lineHeight() {
                return this._lineHeight;
              }
              set wrapLines(O) {
                const Y = this._wrapLines;
                (this._wrapLines = O),
                  Y !== O && this._font && this._updateText();
              }
              get wrapLines() {
                return this._wrapLines;
              }
              get lines() {
                return this._lineContents;
              }
              set spacing(O) {
                const Y = this._spacing;
                (this._spacing = O),
                  Y !== O && this._font && this._updateText();
              }
              get spacing() {
                return this._spacing;
              }
              set fontSize(O) {
                const Y = this._fontSize;
                (this._fontSize = O),
                  (this._originalFontSize = O),
                  Y !== O && this._font && this._updateText();
              }
              get fontSize() {
                return this._fontSize;
              }
              set fontAsset(O) {
                this._fontAsset.defaultAsset = O;
              }
              get fontAsset() {
                return this._fontAsset.localizedAsset;
              }
              set font(O) {
                let Y;
                if (
                  (this._font &&
                    ((Y = this._font.type),
                    this._font.off &&
                      this._font.off("render", this._onFontRender, this)),
                  (this._font = O),
                  (this._fontMinY = 0),
                  (this._fontMaxY = 0),
                  !O)
                )
                  return;
                const ne = this._font.data;
                for (const re in ne.chars) {
                  const I = ne.chars[re];
                  I.bounds &&
                    ((this._fontMinY = Math.min(this._fontMinY, I.bounds[1])),
                    (this._fontMaxY = Math.max(this._fontMaxY, I.bounds[3])));
                }
                if (
                  (this._font.on &&
                    this._font.on("render", this._onFontRender, this),
                  this._fontAsset.localizedAsset &&
                    this._system.app.assets.get(this._fontAsset.localizedAsset)
                      .resource !== this._font &&
                    (this._fontAsset.defaultAsset = null),
                  O.type !== Y)
                ) {
                  const re = this._element._isScreenSpace();
                  this._updateMaterial(re);
                }
                for (let re = 0, I = this._font.textures.length; re < I; re++)
                  if (!this._meshInfo[re]) this._meshInfo[re] = new Q();
                  else {
                    const w = this._meshInfo[re].meshInstance;
                    w &&
                      (w.setParameter(
                        "font_sdfIntensity",
                        this._font.intensity
                      ),
                      w.setParameter(
                        "font_pxrange",
                        this._getPxRange(this._font)
                      ),
                      w.setParameter(
                        "font_textureWidth",
                        this._font.data.info.maps[re].width
                      ),
                      this._setTextureParams(w, this._font.textures[re]));
                  }
                let de = !1;
                for (
                  let re = this._font.textures.length;
                  re < this._meshInfo.length;
                  re++
                )
                  this._meshInfo[re].meshInstance &&
                    (de ||
                      (this._element.removeModelFromLayers(this._model),
                      (de = !0)),
                    this._removeMeshInstance(this._meshInfo[re].meshInstance));
                this._meshInfo.length > this._font.textures.length &&
                  (this._meshInfo.length = this._font.textures.length),
                  this._updateText();
              }
              get font() {
                return this._font;
              }
              set alignment(O) {
                O instanceof c.Z
                  ? this._alignment.set(O.x, O.y)
                  : this._alignment.set(O[0], O[1]),
                  this._font && this._updateText();
              }
              get alignment() {
                return this._alignment;
              }
              set autoWidth(O) {
                const Y = this._autoWidth;
                if (
                  ((this._autoWidth = O),
                  O &&
                    Math.abs(this._element.anchor.x - this._element.anchor.z) <
                      1e-4 &&
                    (this._element.width = this.width),
                  Y !== O)
                ) {
                  const ne = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize;
                  ne !== this._fontSize &&
                    ((this._fontSize = ne), this._font && this._updateText());
                }
              }
              get autoWidth() {
                return this._autoWidth;
              }
              set autoHeight(O) {
                const Y = this._autoHeight;
                if (
                  ((this._autoHeight = O),
                  O &&
                    Math.abs(this._element.anchor.y - this._element.anchor.w) <
                      1e-4 &&
                    (this._element.height = this.height),
                  Y !== O)
                ) {
                  const ne = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize;
                  ne !== this._fontSize &&
                    ((this._fontSize = ne), this._font && this._updateText());
                }
              }
              get autoHeight() {
                return this._autoHeight;
              }
              set rtlReorder(O) {
                this._rtlReorder !== O &&
                  ((this._rtlReorder = O), this._font && this._updateText());
              }
              get rtlReorder() {
                return this._rtlReorder;
              }
              set unicodeConverter(O) {
                this._unicodeConverter !== O &&
                  ((this._unicodeConverter = O), this._setText(this._text));
              }
              get unicodeConverter() {
                return this._unicodeConverter;
              }
              get aabb() {
                if (this._aabbDirty) {
                  let O = !1;
                  for (let Y = 0; Y < this._meshInfo.length; Y++)
                    this._meshInfo[Y].meshInstance &&
                      (O
                        ? this._aabb.add(this._meshInfo[Y].meshInstance.aabb)
                        : (this._aabb.copy(this._meshInfo[Y].meshInstance.aabb),
                          (O = !0)));
                  this._aabbDirty = !1;
                }
                return this._aabb;
              }
              set outlineColor(O) {
                const Y = O instanceof y.Q ? O.r : O[0],
                  ne = O instanceof y.Q ? O.g : O[1],
                  de = O instanceof y.Q ? O.b : O[2],
                  re = O instanceof y.Q ? O.a : O[3];
                if (
                  !(
                    this._outlineColor.r === Y &&
                    this._outlineColor.g === ne &&
                    this._outlineColor.b === de &&
                    this._outlineColor.a === re
                  ) &&
                  ((this._outlineColor.r = Y),
                  (this._outlineColor.g = ne),
                  (this._outlineColor.b = de),
                  (this._outlineColor.a = re),
                  !!this._model)
                ) {
                  if (this._symbolOutlineParams)
                    this._font && this._updateText();
                  else {
                    (this._outlineColorUniform[0] = this._outlineColor.r),
                      (this._outlineColorUniform[1] = this._outlineColor.g),
                      (this._outlineColorUniform[2] = this._outlineColor.b),
                      (this._outlineColorUniform[3] = this._outlineColor.a);
                    for (
                      let I = 0, w = this._model.meshInstances.length;
                      I < w;
                      I++
                    )
                      this._model.meshInstances[I].setParameter(
                        "outline_color",
                        this._outlineColorUniform
                      );
                  }
                  this._element &&
                    this._element.fire("set:outline", this._color);
                }
              }
              get outlineColor() {
                return this._outlineColor;
              }
              set outlineThickness(O) {
                const Y = this._outlineThickness;
                if (((this._outlineThickness = O), Y !== O && this._font)) {
                  if (!this._model) return;
                  if (this._symbolOutlineParams)
                    this._font && this._updateText();
                  else
                    for (
                      let ne = 0, de = this._model.meshInstances.length;
                      ne < de;
                      ne++
                    )
                      this._model.meshInstances[ne].setParameter(
                        "outline_thickness",
                        this._outlineThicknessScale * this._outlineThickness
                      );
                }
              }
              get outlineThickness() {
                return this._outlineThickness;
              }
              set shadowColor(O) {
                const Y = O instanceof y.Q ? O.r : O[0],
                  ne = O instanceof y.Q ? O.g : O[1],
                  de = O instanceof y.Q ? O.b : O[2],
                  re = O instanceof y.Q ? O.a : O[3];
                if (
                  !(
                    this._shadowColor.r === Y &&
                    this._shadowColor.g === ne &&
                    this._shadowColor.b === de &&
                    this._shadowColor.a === re
                  ) &&
                  ((this._shadowColor.r = Y),
                  (this._shadowColor.g = ne),
                  (this._shadowColor.b = de),
                  (this._shadowColor.a = re),
                  !!this._model)
                )
                  if (this._symbolShadowParams)
                    this._font && this._updateText();
                  else {
                    (this._shadowColorUniform[0] = this._shadowColor.r),
                      (this._shadowColorUniform[1] = this._shadowColor.g),
                      (this._shadowColorUniform[2] = this._shadowColor.b),
                      (this._shadowColorUniform[3] = this._shadowColor.a);
                    for (
                      let I = 0, w = this._model.meshInstances.length;
                      I < w;
                      I++
                    )
                      this._model.meshInstances[I].setParameter(
                        "shadow_color",
                        this._shadowColorUniform
                      );
                  }
              }
              get shadowColor() {
                return this._shadowColor;
              }
              set shadowOffset(O) {
                const Y = O instanceof c.Z ? O.x : O[0],
                  ne = O instanceof c.Z ? O.y : O[1];
                if (
                  !(
                    this._shadowOffset.x === Y && this._shadowOffset.y === ne
                  ) &&
                  (this._shadowOffset.set(Y, ne), this._font && this._model)
                )
                  if (this._symbolShadowParams) this._updateText();
                  else
                    for (
                      let de = 0, re = this._model.meshInstances.length;
                      de < re;
                      de++
                    ) {
                      const I =
                        -this._font.data.info.maps[de].width /
                        this._font.data.info.maps[de].height;
                      (this._shadowOffsetUniform[0] =
                        this._shadowOffsetScale * this._shadowOffset.x),
                        (this._shadowOffsetUniform[1] =
                          I * this._shadowOffsetScale * this._shadowOffset.y),
                        this._model.meshInstances[de].setParameter(
                          "shadow_offset",
                          this._shadowOffsetUniform
                        );
                    }
              }
              get shadowOffset() {
                return this._shadowOffset;
              }
              set minFontSize(O) {
                this._minFontSize !== O &&
                  ((this._minFontSize = O),
                  this.font && this._shouldAutoFit() && this._updateText());
              }
              get minFontSize() {
                return this._minFontSize;
              }
              set maxFontSize(O) {
                this._maxFontSize !== O &&
                  ((this._maxFontSize = O),
                  this.font && this._shouldAutoFit() && this._updateText());
              }
              get maxFontSize() {
                return this._maxFontSize;
              }
              set autoFitWidth(O) {
                this._autoFitWidth !== O &&
                  ((this._autoFitWidth = O),
                  (this._fontSize = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize),
                  this.font && this._updateText());
              }
              get autoFitWidth() {
                return this._autoFitWidth;
              }
              set autoFitHeight(O) {
                this._autoFitHeight !== O &&
                  ((this._autoFitHeight = O),
                  (this._fontSize = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize),
                  this.font && this._updateText());
              }
              get autoFitHeight() {
                return this._autoFitHeight;
              }
              set maxLines(O) {
                this._maxLines !== O &&
                  ((O === null && this._maxLines === -1) ||
                    ((this._maxLines = O === null ? -1 : O),
                    this.font && this._wrapLines && this._updateText()));
              }
              get maxLines() {
                return this._maxLines;
              }
              set enableMarkup(O) {
                if (((O = !!O), this._enableMarkup === O)) return;
                (this._enableMarkup = O), this.font && this._updateText();
                const Y = this._element._isScreenSpace();
                this._updateMaterial(Y);
              }
              get enableMarkup() {
                return this._enableMarkup;
              }
              get symbols() {
                return this._symbols;
              }
              get symbolColors() {
                return this._symbolColors === null
                  ? null
                  : this._symbolColors.map(function (O) {
                      return this._colorPalette.slice(O * 3, O * 3 + 3);
                    }, this);
              }
              get symbolOutlineParams() {
                return this._symbolOutlineParams === null
                  ? null
                  : this._symbolOutlineParams.map(function (O) {
                      return this._outlinePalette.slice(O * 5, O * 5 + 5);
                    }, this);
              }
              get symbolShadowParams() {
                return this._symbolShadowParams === null
                  ? null
                  : this._symbolShadowParams.map(function (O) {
                      return this._shadowPalette.slice(O * 6, O * 6 + 6);
                    }, this);
              }
              get rtl() {
                return this._rtl;
              }
              set rangeStart(O) {
                (O = Math.max(0, Math.min(O, this._symbols.length))),
                  O !== this._rangeStart &&
                    ((this._rangeStart = O), this._updateRenderRange());
              }
              get rangeStart() {
                return this._rangeStart;
              }
              set rangeEnd(O) {
                (O = Math.max(
                  this._rangeStart,
                  Math.min(O, this._symbols.length)
                )),
                  O !== this._rangeEnd &&
                    ((this._rangeEnd = O), this._updateRenderRange());
              }
              get rangeEnd() {
                return this._rangeEnd;
              }
            }
          },
          3371: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => s });
            var A = a(8656),
              x = a(8484),
              y = a(3021),
              c = a(7994),
              d = a(4124),
              h = a(5777);
            const f = [
              "angularDampingX",
              "angularDampingY",
              "angularDampingZ",
              "angularEquilibriumX",
              "angularEquilibriumY",
              "angularEquilibriumZ",
              "angularLimitsX",
              "angularLimitsY",
              "angularLimitsZ",
              "angularMotionX",
              "angularMotionY",
              "angularMotionZ",
              "angularSpringX",
              "angularSpringY",
              "angularSpringZ",
              "angularStiffnessX",
              "angularStiffnessY",
              "angularStiffnessZ",
              "breakForce",
              "enableCollision",
              "enabled",
              "entityA",
              "entityB",
              "linearDampingX",
              "linearDampingY",
              "linearDampingZ",
              "linearEquilibriumX",
              "linearEquilibriumY",
              "linearEquilibriumZ",
              "linearLimitsX",
              "linearLimitsY",
              "linearLimitsZ",
              "linearMotionX",
              "linearMotionY",
              "linearMotionZ",
              "linearSpringX",
              "linearSpringY",
              "linearSpringZ",
              "linearStiffnessX",
              "linearStiffnessY",
              "linearStiffnessZ",
            ];
            class s extends d.u {
              constructor(o, i) {
                super(o, i),
                  (this._constraint = null),
                  (this._entityA = null),
                  (this._entityB = null),
                  (this._breakForce = 34e37),
                  (this._enableCollision = !0),
                  (this._linearMotionX = h.it),
                  (this._linearLimitsX = new c.Z(0, 0)),
                  (this._linearSpringX = !1),
                  (this._linearStiffnessX = 0),
                  (this._linearDampingX = 1),
                  (this._linearEquilibriumX = 0),
                  (this._linearMotionY = h.it),
                  (this._linearLimitsY = new c.Z(0, 0)),
                  (this._linearSpringY = !1),
                  (this._linearStiffnessY = 0),
                  (this._linearDampingY = 1),
                  (this._linearEquilibriumY = 0),
                  (this._linearMotionZ = h.it),
                  (this._linearLimitsZ = new c.Z(0, 0)),
                  (this._linearSpringZ = !1),
                  (this._linearStiffnessZ = 0),
                  (this._linearDampingZ = 1),
                  (this._linearEquilibriumZ = 0),
                  (this._angularMotionX = h.it),
                  (this._angularLimitsX = new c.Z(0, 0)),
                  (this._angularSpringX = !1),
                  (this._angularStiffnessX = 0),
                  (this._angularDampingX = 1),
                  (this._angularEquilibriumX = 0),
                  (this._angularMotionY = h.it),
                  (this._angularLimitsY = new c.Z(0, 0)),
                  (this._angularSpringY = !1),
                  (this._angularStiffnessY = 0),
                  (this._angularDampingY = 1),
                  (this._angularEquilibriumY = 0),
                  (this._angularMotionZ = h.it),
                  (this._angularLimitsZ = new c.Z(0, 0)),
                  (this._angularSpringZ = !1),
                  (this._angularEquilibriumZ = 0),
                  (this._angularDampingZ = 1),
                  (this._angularStiffnessZ = 0),
                  this.on("set_enabled", this._onSetEnabled, this);
              }
              set entityA(o) {
                this._destroyConstraint(),
                  (this._entityA = o),
                  this._createConstraint();
              }
              get entityA() {
                return this._entityA;
              }
              set entityB(o) {
                this._destroyConstraint(),
                  (this._entityB = o),
                  this._createConstraint();
              }
              get entityB() {
                return this._entityB;
              }
              set breakForce(o) {
                this._constraint &&
                  this._breakForce !== o &&
                  (this._constraint.setBreakingImpulseThreshold(o),
                  (this._breakForce = o));
              }
              get breakForce() {
                return this._breakForce;
              }
              set enableCollision(o) {
                this._destroyConstraint(),
                  (this._enableCollision = o),
                  this._createConstraint();
              }
              get enableCollision() {
                return this._enableCollision;
              }
              set angularLimitsX(o) {
                this._angularLimitsX.equals(o) ||
                  (this._angularLimitsX.copy(o), this._updateAngularLimits());
              }
              get angularLimitsX() {
                return this._angularLimitsX;
              }
              set angularMotionX(o) {
                this._angularMotionX !== o &&
                  ((this._angularMotionX = o), this._updateAngularLimits());
              }
              get angularMotionX() {
                return this._angularMotionX;
              }
              set angularLimitsY(o) {
                this._angularLimitsY.equals(o) ||
                  (this._angularLimitsY.copy(o), this._updateAngularLimits());
              }
              get angularLimitsY() {
                return this._angularLimitsY;
              }
              set angularMotionY(o) {
                this._angularMotionY !== o &&
                  ((this._angularMotionY = o), this._updateAngularLimits());
              }
              get angularMotionY() {
                return this._angularMotionY;
              }
              set angularLimitsZ(o) {
                this._angularLimitsZ.equals(o) ||
                  (this._angularLimitsZ.copy(o), this._updateAngularLimits());
              }
              get angularLimitsZ() {
                return this._angularLimitsZ;
              }
              set angularMotionZ(o) {
                this._angularMotionZ !== o &&
                  ((this._angularMotionZ = o), this._updateAngularLimits());
              }
              get angularMotionZ() {
                return this._angularMotionZ;
              }
              set linearLimitsX(o) {
                this._linearLimitsX.equals(o) ||
                  (this._linearLimitsX.copy(o), this._updateLinearLimits());
              }
              get linearLimitsX() {
                return this._linearLimitsX;
              }
              set linearMotionX(o) {
                this._linearMotionX !== o &&
                  ((this._linearMotionX = o), this._updateLinearLimits());
              }
              get linearMotionX() {
                return this._linearMotionX;
              }
              set linearLimitsY(o) {
                this._linearLimitsY.equals(o) ||
                  (this._linearLimitsY.copy(o), this._updateLinearLimits());
              }
              get linearLimitsY() {
                return this._linearLimitsY;
              }
              set linearMotionY(o) {
                this._linearMotionY !== o &&
                  ((this._linearMotionY = o), this._updateLinearLimits());
              }
              get linearMotionY() {
                return this._linearMotionY;
              }
              set linearLimitsZ(o) {
                this._linearLimitsZ.equals(o) ||
                  (this._linearLimitsZ.copy(o), this._updateLinearLimits());
              }
              get linearLimitsZ() {
                return this._linearLimitsZ;
              }
              set linearMotionZ(o) {
                this._linearMotionZ !== o &&
                  ((this._linearMotionZ = o), this._updateLinearLimits());
              }
              get linearMotionZ() {
                return this._linearMotionZ;
              }
              _convertTransform(o, i) {
                const e = o.getTranslation(),
                  t = new y.k();
                t.setFromMat4(o);
                const r = new Ammo.btVector3(e.x, e.y, e.z),
                  u = new Ammo.btQuaternion(t.x, t.y, t.z, t.w);
                i.setOrigin(r),
                  i.setRotation(u),
                  Ammo.destroy(r),
                  Ammo.destroy(u);
              }
              _updateAngularLimits() {
                const o = this._constraint;
                if (o) {
                  let i, e, t, r, u, v;
                  this._angularMotionX === h.ko
                    ? ((i = this._angularLimitsX.x * A.D.DEG_TO_RAD),
                      (r = this._angularLimitsX.y * A.D.DEG_TO_RAD))
                    : this._angularMotionX === h.CH
                    ? ((i = 1), (r = 0))
                    : (i = r = 0),
                    this._angularMotionY === h.ko
                      ? ((e = this._angularLimitsY.x * A.D.DEG_TO_RAD),
                        (u = this._angularLimitsY.y * A.D.DEG_TO_RAD))
                      : this._angularMotionY === h.CH
                      ? ((e = 1), (u = 0))
                      : (e = u = 0),
                    this._angularMotionZ === h.ko
                      ? ((t = this._angularLimitsZ.x * A.D.DEG_TO_RAD),
                        (v = this._angularLimitsZ.y * A.D.DEG_TO_RAD))
                      : this._angularMotionZ === h.CH
                      ? ((t = 1), (v = 0))
                      : (t = v = 0);
                  const _ = new Ammo.btVector3(i, e, t);
                  o.setAngularLowerLimit(_),
                    _.setValue(r, u, v),
                    o.setAngularUpperLimit(_),
                    Ammo.destroy(_);
                }
              }
              _updateLinearLimits() {
                const o = this._constraint;
                if (o) {
                  let i, e, t, r, u, v;
                  this._linearMotionX === h.ko
                    ? ((i = this._linearLimitsX.x), (r = this._linearLimitsX.y))
                    : this._linearMotionX === h.CH
                    ? ((i = 1), (r = 0))
                    : (i = r = 0),
                    this._linearMotionY === h.ko
                      ? ((e = this._linearLimitsY.x),
                        (u = this._linearLimitsY.y))
                      : this._linearMotionY === h.CH
                      ? ((e = 1), (u = 0))
                      : (e = u = 0),
                    this._linearMotionZ === h.ko
                      ? ((t = this._linearLimitsZ.x),
                        (v = this._linearLimitsZ.y))
                      : this._linearMotionZ === h.CH
                      ? ((t = 1), (v = 0))
                      : (t = v = 0);
                  const _ = new Ammo.btVector3(i, e, t);
                  o.setLinearLowerLimit(_),
                    _.setValue(r, u, v),
                    o.setLinearUpperLimit(_),
                    Ammo.destroy(_);
                }
              }
              _createConstraint() {
                if (this._entityA && this._entityA.rigidbody) {
                  this._destroyConstraint();
                  const o = new x.$(),
                    i = this._entityA.rigidbody.body;
                  i.activate();
                  const e = this.entity.getWorldTransform(),
                    r = this._entityA.getWorldTransform().clone().invert();
                  o.mul2(r, e);
                  const u = new Ammo.btTransform();
                  if (
                    (this._convertTransform(o, u),
                    this._entityB && this._entityB.rigidbody)
                  ) {
                    const g = this._entityB.rigidbody.body;
                    g.activate();
                    const E = this._entityB
                      .getWorldTransform()
                      .clone()
                      .invert();
                    o.mul2(E, e);
                    const M = new Ammo.btTransform();
                    this._convertTransform(o, M),
                      (this._constraint =
                        new Ammo.btGeneric6DofSpringConstraint(
                          i,
                          g,
                          u,
                          M,
                          !this._enableCollision
                        )),
                      Ammo.destroy(M);
                  } else
                    this._constraint = new Ammo.btGeneric6DofSpringConstraint(
                      i,
                      u,
                      !this._enableCollision
                    );
                  Ammo.destroy(u);
                  const v = ["X", "Y", "Z", "X", "Y", "Z"];
                  for (let g = 0; g < 6; g++) {
                    const T = g < 3 ? "_linear" : "_angular";
                    this._constraint.enableSpring(g, this[T + "Spring" + v[g]]),
                      this._constraint.setDamping(
                        g,
                        this[T + "Damping" + v[g]]
                      ),
                      this._constraint.setEquilibriumPoint(
                        g,
                        this[T + "Equilibrium" + v[g]]
                      ),
                      this._constraint.setStiffness(
                        g,
                        this[T + "Stiffness" + v[g]]
                      );
                  }
                  this._constraint.setBreakingImpulseThreshold(
                    this._breakForce
                  ),
                    this._updateLinearLimits(),
                    this._updateAngularLimits(),
                    this.system.app.systems.rigidbody.dynamicsWorld.addConstraint(
                      this._constraint,
                      !this._enableCollision
                    );
                }
              }
              _destroyConstraint() {
                this._constraint &&
                  (this.system.app.systems.rigidbody.dynamicsWorld.removeConstraint(
                    this._constraint
                  ),
                  Ammo.destroy(this._constraint),
                  (this._constraint = null));
              }
              initFromData(o) {
                for (const i of f)
                  o.hasOwnProperty(i) &&
                    (o[i] instanceof c.Z
                      ? this["_" + i].copy(o[i])
                      : (this["_" + i] = o[i]));
                this._createConstraint();
              }
              onEnable() {
                this._createConstraint();
              }
              onDisable() {
                this._destroyConstraint();
              }
              _onSetEnabled(o, i, e) {}
              _onBeforeRemove() {
                this.fire("remove");
              }
            }
            const l = {
              Damping: "setDamping",
              Equilibrium: "setEquilibriumPoint",
              Spring: "enableSpring",
              Stiffness: "setStiffness",
            };
            ["linear", "angular"].forEach((n) => {
              ["Damping", "Equilibrium", "Spring", "Stiffness"].forEach((o) => {
                ["X", "Y", "Z"].forEach((i) => {
                  const e = n + o + i,
                    t = "_" + e;
                  let r = n === "linear" ? 0 : 3;
                  i === "Y" && (r += 1),
                    i === "Z" && (r += 2),
                    Object.defineProperty(s.prototype, e, {
                      get: function () {
                        return this[t];
                      },
                      set: function (u) {
                        this[t] !== u &&
                          ((this[t] = u), this._constraint[l[o]](r, u));
                      },
                    });
                });
              });
            });
          },
          5777: (xe, V, a) => {
            "use strict";
            a.d(V, { CH: () => A, it: () => y, ko: () => x });
            const A = "free",
              x = "limited",
              y = "locked";
          },
          7436: (xe, V, a) => {
            "use strict";
            a.d(V, { X: () => h });
            var A = a(4124),
              x = a(2930),
              y = a(3371);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends x.r {
              constructor(s) {
                super(s),
                  (this.id = "joint"),
                  (this.app = s),
                  (this.ComponentType = y.K),
                  (this.DataType = c),
                  (this.schema = d);
              }
              initializeComponentData(s, l, n) {
                s.initFromData(l);
              }
            }
            A.u._buildAccessors(y.K.prototype, d);
          },
          906: (xe, V, a) => {
            "use strict";
            a.d(V, { Y: () => x });
            var A = a(4124);
            class x extends A.u {
              constructor(c, d) {
                super(c, d),
                  (this._minWidth = 0),
                  (this._minHeight = 0),
                  (this._maxWidth = null),
                  (this._maxHeight = null),
                  (this._fitWidthProportion = 0),
                  (this._fitHeightProportion = 0),
                  (this._excludeFromLayout = !1);
              }
              set minWidth(c) {
                c !== this._minWidth &&
                  ((this._minWidth = c), this.fire("resize"));
              }
              get minWidth() {
                return this._minWidth;
              }
              set minHeight(c) {
                c !== this._minHeight &&
                  ((this._minHeight = c), this.fire("resize"));
              }
              get minHeight() {
                return this._minHeight;
              }
              set maxWidth(c) {
                c !== this._maxWidth &&
                  ((this._maxWidth = c), this.fire("resize"));
              }
              get maxWidth() {
                return this._maxWidth;
              }
              set maxHeight(c) {
                c !== this._maxHeight &&
                  ((this._maxHeight = c), this.fire("resize"));
              }
              get maxHeight() {
                return this._maxHeight;
              }
              set fitWidthProportion(c) {
                c !== this._fitWidthProportion &&
                  ((this._fitWidthProportion = c), this.fire("resize"));
              }
              get fitWidthProportion() {
                return this._fitWidthProportion;
              }
              set fitHeightProportion(c) {
                c !== this._fitHeightProportion &&
                  ((this._fitHeightProportion = c), this.fire("resize"));
              }
              get fitHeightProportion() {
                return this._fitHeightProportion;
              }
              set excludeFromLayout(c) {
                c !== this._excludeFromLayout &&
                  ((this._excludeFromLayout = c), this.fire("resize"));
              }
              get excludeFromLayout() {
                return this._excludeFromLayout;
              }
            }
          },
          1341: (xe, V, a) => {
            "use strict";
            a.d(V, { h: () => h });
            var A = a(4124),
              x = a(2930),
              y = a(906);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends x.r {
              constructor(s) {
                super(s),
                  (this.id = "layoutchild"),
                  (this.ComponentType = y.Y),
                  (this.DataType = c),
                  (this.schema = d);
              }
              initializeComponentData(s, l, n) {
                l.enabled !== void 0 && (s.enabled = l.enabled),
                  l.minWidth !== void 0 && (s.minWidth = l.minWidth),
                  l.minHeight !== void 0 && (s.minHeight = l.minHeight),
                  l.maxWidth !== void 0 && (s.maxWidth = l.maxWidth),
                  l.maxHeight !== void 0 && (s.maxHeight = l.maxHeight),
                  l.fitWidthProportion !== void 0 &&
                    (s.fitWidthProportion = l.fitWidthProportion),
                  l.fitHeightProportion !== void 0 &&
                    (s.fitHeightProportion = l.fitHeightProportion),
                  l.excludeFromLayout !== void 0 &&
                    (s.excludeFromLayout = l.excludeFromLayout),
                  super.initializeComponentData(s, l, n);
              }
              cloneComponent(s, l) {
                const n = s.layoutchild;
                return this.addComponent(l, {
                  enabled: n.enabled,
                  minWidth: n.minWidth,
                  minHeight: n.minHeight,
                  maxWidth: n.maxWidth,
                  maxHeight: n.maxHeight,
                  fitWidthProportion: n.fitWidthProportion,
                  fitHeightProportion: n.fitHeightProportion,
                  excludeFromLayout: n.excludeFromLayout,
                });
              }
            }
            A.u._buildAccessors(y.Y.prototype, d);
          },
          7503: (xe, V, a) => {
            "use strict";
            a.d(V, { b: () => l });
            var A = a(7994),
              x = a(5596),
              y = a(9391),
              c = a(9733),
              d = a(4124),
              h = a(1993);
            function f(n) {
              return n.element;
            }
            function s(n) {
              return n.enabled && n.element && n.element.enabled;
            }
            class l extends d.u {
              constructor(o, i) {
                super(o, i),
                  (this._orientation = y.Sz),
                  (this._reverseX = !1),
                  (this._reverseY = !0),
                  (this._alignment = new A.Z(0, 1)),
                  (this._padding = new x.Z()),
                  (this._spacing = new A.Z()),
                  (this._widthFitting = c.Jb),
                  (this._heightFitting = c.Jb),
                  (this._wrap = !1),
                  (this._layoutCalculator = new h.b()),
                  this._listenForReflowEvents(this.entity, "on"),
                  this.entity.children.forEach((e) => {
                    this._listenForReflowEvents(e, "on");
                  }),
                  this.entity.on("childinsert", this._onChildInsert, this),
                  this.entity.on("childremove", this._onChildRemove, this),
                  o.app.systems.element.on(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  o.app.systems.element.on(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  ),
                  o.app.systems.layoutchild.on(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  o.app.systems.layoutchild.on(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  );
              }
              set orientation(o) {
                o !== this._orientation &&
                  ((this._orientation = o), this._scheduleReflow());
              }
              get orientation() {
                return this._orientation;
              }
              set reverseX(o) {
                o !== this._reverseX &&
                  ((this._reverseX = o), this._scheduleReflow());
              }
              get reverseX() {
                return this._reverseX;
              }
              set reverseY(o) {
                o !== this._reverseY &&
                  ((this._reverseY = o), this._scheduleReflow());
              }
              get reverseY() {
                return this._reverseY;
              }
              set alignment(o) {
                o.equals(this._alignment) ||
                  (this._alignment.copy(o), this._scheduleReflow());
              }
              get alignment() {
                return this._alignment;
              }
              set padding(o) {
                o.equals(this._padding) ||
                  (this._padding.copy(o), this._scheduleReflow());
              }
              get padding() {
                return this._padding;
              }
              set spacing(o) {
                o.equals(this._spacing) ||
                  (this._spacing.copy(o), this._scheduleReflow());
              }
              get spacing() {
                return this._spacing;
              }
              set widthFitting(o) {
                o !== this._widthFitting &&
                  ((this._widthFitting = o), this._scheduleReflow());
              }
              get widthFitting() {
                return this._widthFitting;
              }
              set heightFitting(o) {
                o !== this._heightFitting &&
                  ((this._heightFitting = o), this._scheduleReflow());
              }
              get heightFitting() {
                return this._heightFitting;
              }
              set wrap(o) {
                o !== this._wrap && ((this._wrap = o), this._scheduleReflow());
              }
              get wrap() {
                return this._wrap;
              }
              _isSelfOrChild(o) {
                return (
                  o === this.entity || this.entity.children.indexOf(o) !== -1
                );
              }
              _listenForReflowEvents(o, i) {
                o.element &&
                  (o.element[i]("enableelement", this._scheduleReflow, this),
                  o.element[i]("disableelement", this._scheduleReflow, this),
                  o.element[i]("resize", this._scheduleReflow, this),
                  o.element[i]("set:pivot", this._scheduleReflow, this)),
                  o.layoutchild &&
                    (o.layoutchild[i](
                      "set_enabled",
                      this._scheduleReflow,
                      this
                    ),
                    o.layoutchild[i]("resize", this._scheduleReflow, this));
              }
              _onElementOrLayoutComponentAdd(o) {
                this._isSelfOrChild(o) &&
                  (this._listenForReflowEvents(o, "on"),
                  this._scheduleReflow());
              }
              _onElementOrLayoutComponentRemove(o) {
                this._isSelfOrChild(o) &&
                  (this._listenForReflowEvents(o, "off"),
                  this._scheduleReflow());
              }
              _onChildInsert(o) {
                this._listenForReflowEvents(o, "on"), this._scheduleReflow();
              }
              _onChildRemove(o) {
                this._listenForReflowEvents(o, "off"), this._scheduleReflow();
              }
              _scheduleReflow() {
                this.enabled &&
                  this.entity &&
                  this.entity.enabled &&
                  !this._isPerformingReflow &&
                  this.system.scheduleReflow(this);
              }
              reflow() {
                const o = f(this.entity),
                  i = this.entity.children.filter(s).map(f);
                if (!o || i.length === 0) return;
                const e = Math.max(o.calculatedWidth, 0),
                  t = Math.max(o.calculatedHeight, 0),
                  r = {
                    orientation: this._orientation,
                    reverseX: this._reverseX,
                    reverseY: this._reverseY,
                    alignment: this._alignment,
                    padding: this._padding,
                    spacing: this._spacing,
                    widthFitting: this._widthFitting,
                    heightFitting: this._heightFitting,
                    wrap: this._wrap,
                    containerSize: new A.Z(e, t),
                  };
                this._isPerformingReflow = !0;
                const u = this._layoutCalculator.calculateLayout(i, r);
                (this._isPerformingReflow = !1), this.fire("reflow", u);
              }
              onEnable() {
                this._scheduleReflow();
              }
              onRemove() {
                this.entity.off("childinsert", this._onChildInsert, this),
                  this.entity.off("childremove", this._onChildRemove, this),
                  this._listenForReflowEvents(this.entity, "off"),
                  this.entity.children.forEach((o) => {
                    this._listenForReflowEvents(o, "off");
                  }),
                  this.system.app.systems.element.off(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  this.system.app.systems.element.off(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  ),
                  this.system.app.systems.layoutchild.off(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  this.system.app.systems.layoutchild.off(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  );
              }
            }
          },
          9733: (xe, V, a) => {
            "use strict";
            a.d(V, { Jb: () => A, S3: () => x, eF: () => c, g7: () => y });
            const A = 0,
              x = 1,
              y = 2,
              c = 3;
          },
          1993: (xe, V, a) => {
            "use strict";
            a.d(V, { b: () => i });
            var A = a(7994),
              x = a(5596),
              y = a(9391),
              c = a(9733);
            const d = {};
            (d[y.Sz] = {
              axis: "x",
              size: "width",
              calculatedSize: "calculatedWidth",
              minSize: "minWidth",
              maxSize: "maxWidth",
              fitting: "widthFitting",
              fittingProportion: "fitWidthProportion",
            }),
              (d[y.Yn] = {
                axis: "y",
                size: "height",
                calculatedSize: "calculatedHeight",
                minSize: "minHeight",
                maxSize: "maxHeight",
                fitting: "heightFitting",
                fittingProportion: "fitHeightProportion",
              });
            const h = {};
            (h[y.Sz] = y.Yn), (h[y.Yn] = y.Sz);
            const f = {
                minWidth: 0,
                minHeight: 0,
                maxWidth: Number.POSITIVE_INFINITY,
                maxHeight: Number.POSITIVE_INFINITY,
                width: null,
                height: null,
                fitWidthProportion: 0,
                fitHeightProportion: 0,
              },
              s = {
                NONE: "NONE",
                APPLY_STRETCHING: "APPLY_STRETCHING",
                APPLY_SHRINKING: "APPLY_SHRINKING",
              },
              l = new A.Z();
            function n(e) {
              let t;
              const r = d[e],
                u = d[h[e]];
              function v(O, Y) {
                return -Y[r.size] * O.pivot[r.axis];
              }
              function _(O, Y) {
                return -Y[u.size] * O.pivot[u.axis];
              }
              function m(O, Y) {
                return Y[r.size] * (1 - O.pivot[r.axis]);
              }
              function g(O, Y) {
                (O = O.filter(T)),
                  (t = Y),
                  (l.x = t.containerSize.x - t.padding.x - t.padding.z),
                  (l.y = t.containerSize.y - t.padding.y - t.padding.w),
                  E(O);
                const ne = R(M(O)),
                  de = F(ne, P(ne)),
                  re = Q(ne, de);
                return te(ne, de, re), ae(ne, de, re), Z(ne);
              }
              function T(O) {
                const Y = O.entity.layoutchild;
                return !Y || !Y.enabled || !Y.excludeFromLayout;
              }
              function E(O) {
                for (let Y = 0; Y < O.length; ++Y) {
                  const ne = O[Y],
                    de = ne.anchor;
                  (de.x !== 0 || de.y !== 0 || de.z !== 0 || de.w !== 0) &&
                    (ne.anchor = x.Z.ZERO);
                }
              }
              function M(O) {
                if (!t.wrap) return [O];
                const Y = [[]],
                  ne = J(O);
                let de = 0;
                const re = t[r.fitting] === c.g7;
                for (let I = 0; I < O.length; ++I) {
                  Y[Y.length - 1].length > 0 && (de += t.spacing[r.axis]);
                  const w = ne[I][r.size];
                  (de += w),
                    !re &&
                      de > l[r.axis] &&
                      Y[Y.length - 1].length !== 0 &&
                      ((de = w), Y.push([])),
                    Y[Y.length - 1].push(O[I]),
                    re &&
                      de > l[r.axis] &&
                      I !== O.length - 1 &&
                      ((de = 0), Y.push([]));
                }
                return Y;
              }
              function R(O) {
                const Y =
                    (t.orientation === y.Sz && t.reverseX) ||
                    (t.orientation === y.Yn && t.reverseY),
                  ne =
                    (t.orientation === y.Sz && t.reverseY) ||
                    (t.orientation === y.Yn && t.reverseX);
                if (Y)
                  for (let de = 0; de < O.length; ++de) Y && O[de].reverse();
                return ne && O.reverse(), O;
              }
              function P(O) {
                const Y = [];
                for (let ne = 0; ne < O.length; ++ne) {
                  const de = O[ne],
                    re = J(de),
                    I = D(re, r),
                    w = b(t[r.fitting], I, l[r.axis]);
                  w === s.APPLY_STRETCHING
                    ? G(re, I, r)
                    : w === s.APPLY_SHRINKING && X(re, I, r),
                    Y.push(re);
                }
                return Y;
              }
              function F(O, Y) {
                const ne = [],
                  de = [];
                for (let w = 0; w < O.length; ++w) {
                  const N = O[w];
                  (N.largestElement = null),
                    (N.largestSize = {
                      width: Number.NEGATIVE_INFINITY,
                      height: Number.NEGATIVE_INFINITY,
                    });
                  for (let W = 0; W < N.length; ++W) {
                    const he = Y[w][W];
                    he[u.size] > N.largestSize[u.size] &&
                      ((N.largestElement = N[W]), (N.largestSize = he));
                  }
                  ne.push(N.largestElement), de.push(N.largestSize);
                }
                const re = D(de, u),
                  I = b(t[u.fitting], re, l[u.axis]);
                I === s.APPLY_STRETCHING
                  ? G(de, re, u)
                  : I === s.APPLY_SHRINKING && X(de, re, u);
                for (let w = 0; w < O.length; ++w) {
                  const N = O[w];
                  for (let W = 0; W < N.length; ++W) {
                    const he = Y[w][W],
                      ue = he[u.size],
                      ye = O.length === 1 ? l[u.axis] : N.largestSize[u.size],
                      Oe = b(t[u.fitting], ue, ye);
                    Oe === s.APPLY_STRETCHING
                      ? (he[u.size] = Math.min(ye, he[u.maxSize]))
                      : Oe === s.APPLY_SHRINKING &&
                        (he[u.size] = Math.max(ye, he[u.minSize]));
                  }
                }
                return Y;
              }
              function b(O, Y, ne) {
                switch (O) {
                  case c.Jb:
                    return s.NONE;
                  case c.S3:
                    return Y < ne ? s.APPLY_STRETCHING : s.NONE;
                  case c.g7:
                    return Y >= ne ? s.APPLY_SHRINKING : s.NONE;
                  case c.eF:
                    return Y < ne ? s.APPLY_STRETCHING : s.APPLY_SHRINKING;
                  default:
                    throw new Error(`Unrecognized fitting mode: ${O}`);
                }
              }
              function D(O, Y) {
                const ne = L(O, Y.size),
                  de = (O.length - 1) * t.spacing[Y.axis];
                return ne + de;
              }
              function G(O, Y, ne) {
                const de = j(O, ne.maxSize),
                  re = ge(O, ne.fittingProportion),
                  I = le(re, de);
                let w = l[ne.axis] - Y;
                for (let N = 0; N < O.length; ++N) {
                  const W = de[N],
                    he = ie(W, w, re, I),
                    ue = O[W][ne.size] + he,
                    ye = O[W][ne.maxSize],
                    Oe = Math.min(ue, ye);
                  O[W][ne.size] = Oe;
                  const Ae = Math.max(ue - Oe, 0),
                    ke = he - Ae;
                  w -= ke;
                }
              }
              function X(O, Y, ne) {
                const de = j(O, ne.minSize, !0),
                  re = ge(O, ne.fittingProportion),
                  I = k(re),
                  w = le(I, de);
                let N = Y - l[ne.axis];
                for (let W = 0; W < O.length; ++W) {
                  const he = de[W],
                    ue = ie(he, N, I, w),
                    ye = O[he][ne.size] - ue,
                    Oe = O[he][ne.minSize],
                    Ae = Math.max(ye, Oe);
                  O[he][ne.size] = Ae;
                  const ke = Math.max(Ae - ye, 0),
                    Ue = ue - ke;
                  N -= Ue;
                }
              }
              function ie(O, Y, ne, de) {
                const re = ne[O],
                  I = de[O];
                return Math.abs(re) < 1e-5 && Math.abs(I) < 1e-5
                  ? Y
                  : (Y * re) / I;
              }
              function Q(O, Y) {
                const ne = {};
                (ne[r.axis] = 0),
                  (ne[u.axis] = 0),
                  (O[r.size] = Number.NEGATIVE_INFINITY);
                const de = [];
                for (let re = 0; re < O.length; ++re) {
                  const I = O[re];
                  if (I.length === 0) {
                    de.push([]);
                    continue;
                  }
                  const w = [],
                    N = Y[re];
                  for (let W = 0; W < I.length; ++W) {
                    const he = I[W],
                      ue = N[W];
                    (ne[u.axis] -= _(he, ue)),
                      (ne[r.axis] -= v(he, ue)),
                      (w[W] = {}),
                      (w[W][r.axis] = ne[r.axis]),
                      (w[W][u.axis] = ne[u.axis]),
                      (ne[u.axis] += _(he, ue)),
                      (ne[r.axis] += m(he, ue) + t.spacing[r.axis]);
                  }
                  (I[r.size] = ne[r.axis] - t.spacing[r.axis]),
                    (I[u.size] = I.largestSize[u.size]),
                    (O[r.size] = Math.max(O[r.size], I[r.size])),
                    (ne[r.axis] = 0),
                    (ne[u.axis] += I[u.size] + t.spacing[u.axis]),
                    de.push(w);
                }
                return (O[u.size] = ne[u.axis] - t.spacing[u.axis]), de;
              }
              function te(O, Y, ne) {
                const de = t.alignment[r.axis],
                  re = t.alignment[u.axis],
                  I = t.padding[r.axis],
                  w = t.padding[u.axis];
                for (let N = 0; N < O.length; ++N) {
                  const W = O[N],
                    he = Y[N],
                    ue = ne[N],
                    ye = (l[r.axis] - W[r.size]) * de + I,
                    Oe = (l[u.axis] - O[u.size]) * re + w;
                  for (let Ae = 0; Ae < W.length; ++Ae) {
                    const ke =
                      (W[u.size] - he[Ae][u.size]) * t.alignment[u.axis];
                    (ue[Ae][r.axis] += ye), (ue[Ae][u.axis] += Oe + ke);
                  }
                }
              }
              function ae(O, Y, ne) {
                for (let de = 0; de < O.length; ++de) {
                  const re = O[de],
                    I = Y[de],
                    w = ne[de];
                  for (let N = 0; N < re.length; ++N) {
                    const W = re[N];
                    (W[r.calculatedSize] = I[N][r.size]),
                      (W[u.calculatedSize] = I[N][u.size]),
                      t.orientation === y.Sz
                        ? W.entity.setLocalPosition(
                            w[N][r.axis],
                            w[N][u.axis],
                            W.entity.getLocalPosition().z
                          )
                        : W.entity.setLocalPosition(
                            w[N][u.axis],
                            w[N][r.axis],
                            W.entity.getLocalPosition().z
                          );
                  }
                }
              }
              function Z(O) {
                const Y = O.width,
                  ne = O.height,
                  de = (l.x - Y) * t.alignment.x + t.padding.x,
                  re = (l.y - ne) * t.alignment.y + t.padding.y;
                return { bounds: new x.Z(de, re, Y, ne) };
              }
              function J(O) {
                const Y = [];
                for (let ne = 0; ne < O.length; ++ne) {
                  const de = O[ne],
                    re = Math.max(ve(de, "minWidth"), 0),
                    I = Math.max(ve(de, "minHeight"), 0),
                    w = Math.max(ve(de, "maxWidth"), re),
                    N = Math.max(ve(de, "maxHeight"), I),
                    W = _e(ve(de, "width"), re, w),
                    he = _e(ve(de, "height"), I, N),
                    ue = ve(de, "fitWidthProportion"),
                    ye = ve(de, "fitHeightProportion");
                  Y.push({
                    minWidth: re,
                    minHeight: I,
                    maxWidth: w,
                    maxHeight: N,
                    width: W,
                    height: he,
                    fitWidthProportion: ue,
                    fitHeightProportion: ye,
                  });
                }
                return Y;
              }
              function ve(O, Y) {
                const ne = O.entity.layoutchild;
                return ne && ne.enabled && ne[Y] !== void 0 && ne[Y] !== null
                  ? ne[Y]
                  : O[Y] !== void 0
                  ? O[Y]
                  : f[Y];
              }
              function _e(O, Y, ne) {
                return Math.min(Math.max(O, Y), ne);
              }
              function L(O, Y) {
                return O.reduce(function (ne, de) {
                  return ne + de[Y];
                }, 0);
              }
              function ge(O, Y) {
                const ne = L(O, Y),
                  de = [],
                  re = O.length;
                if (ne === 0) for (let I = 0; I < re; ++I) de.push(1 / re);
                else for (let I = 0; I < re; ++I) de.push(O[I][Y] / ne);
                return de;
              }
              function k(O) {
                if (O.length === 1) return [1];
                const Y = [],
                  ne = O.length;
                for (let de = 0; de < ne; ++de) Y.push((1 - O[de]) / (ne - 1));
                return Y;
              }
              function j(O, Y, ne) {
                return (
                  O.forEach(B),
                  O.slice()
                    .sort(function (de, re) {
                      return ne ? re[Y] - de[Y] : de[Y] - re[Y];
                    })
                    .map($)
                );
              }
              function B(O, Y) {
                O.index = Y;
              }
              function $(O) {
                return O.index;
              }
              function le(O, Y) {
                const ne = [];
                ne[Y[O.length - 1]] = O[Y[O.length - 1]];
                for (let de = O.length - 2; de >= 0; --de)
                  ne[Y[de]] = ne[Y[de + 1]] + O[Y[de]];
                return ne;
              }
              return g;
            }
            const o = {};
            (o[y.Sz] = n(y.Sz)), (o[y.Yn] = n(y.Yn));
            class i {
              calculateLayout(t, r) {
                const u = o[r.orientation];
                if (u) return u(t, r);
                throw new Error(
                  "Unrecognized orientation value: " + r.orientation
                );
              }
            }
          },
          5680: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => l });
            var A = a(7994),
              x = a(5596),
              y = a(4124),
              c = a(2930),
              d = a(7503);
            class h {
              constructor() {
                this.enabled = !0;
              }
            }
            const f = ["enabled"],
              s = 100;
            class l extends c.r {
              constructor(o) {
                super(o),
                  (this.id = "layoutgroup"),
                  (this.ComponentType = d.b),
                  (this.DataType = h),
                  (this.schema = f),
                  (this._reflowQueue = []),
                  this.on("beforeremove", this._onRemoveComponent, this),
                  this.app.systems.on("postUpdate", this._onPostUpdate, this);
              }
              initializeComponentData(o, i, e) {
                i.enabled !== void 0 && (o.enabled = i.enabled),
                  i.orientation !== void 0 && (o.orientation = i.orientation),
                  i.reverseX !== void 0 && (o.reverseX = i.reverseX),
                  i.reverseY !== void 0 && (o.reverseY = i.reverseY),
                  i.alignment !== void 0 &&
                    (o.alignment = Array.isArray(i.alignment)
                      ? new A.Z(i.alignment)
                      : i.alignment),
                  i.padding !== void 0 &&
                    (o.padding = Array.isArray(i.padding)
                      ? new x.Z(i.padding)
                      : i.padding),
                  i.spacing !== void 0 &&
                    (o.spacing = Array.isArray(i.spacing)
                      ? new A.Z(i.spacing)
                      : i.spacing),
                  i.widthFitting !== void 0 &&
                    (o.widthFitting = i.widthFitting),
                  i.heightFitting !== void 0 &&
                    (o.heightFitting = i.heightFitting),
                  i.wrap !== void 0 && (o.wrap = i.wrap),
                  super.initializeComponentData(o, i, e);
              }
              cloneComponent(o, i) {
                const e = o.layoutgroup;
                return this.addComponent(i, {
                  enabled: e.enabled,
                  orientation: e.orientation,
                  reverseX: e.reverseX,
                  reverseY: e.reverseY,
                  alignment: e.alignment,
                  padding: e.padding,
                  spacing: e.spacing,
                  widthFitting: e.widthFitting,
                  heightFitting: e.heightFitting,
                  wrap: e.wrap,
                });
              }
              scheduleReflow(o) {
                this._reflowQueue.indexOf(o) === -1 &&
                  this._reflowQueue.push(o);
              }
              _onPostUpdate() {
                this._processReflowQueue();
              }
              _processReflowQueue() {
                if (this._reflowQueue.length === 0) return;
                let o = 0;
                for (; this._reflowQueue.length > 0; ) {
                  const i = this._reflowQueue.slice();
                  (this._reflowQueue.length = 0),
                    i.sort(function (e, t) {
                      return e.entity.graphDepth - t.entity.graphDepth;
                    });
                  for (let e = 0; e < i.length; ++e) i[e].reflow();
                  if (++o >= s) {
                    console.warn(
                      "Max reflow iterations limit reached, bailing."
                    );
                    break;
                  }
                }
              }
              _onRemoveComponent(o, i) {
                i.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("postUpdate", this._onPostUpdate, this);
              }
            }
            y.u._buildAccessors(d.b.prototype, f);
          },
          9763: (xe, V, a) => {
            "use strict";
            a.d(V, { Mm: () => l, qm: () => f, vF: () => s });
            var A = a(8656),
              x = a(5227),
              y = a(5596),
              c = a(9391),
              d = a(3953),
              h = a(4124);
            const f = [],
              s = [];
            class l extends h.u {
              constructor(e, t) {
                super(e, t),
                  (this._cookieAsset = null),
                  (this._cookieAssetId = null),
                  (this._cookieAssetAdd = !1),
                  (this._cookieMatrix = null);
              }
              addLightToLayers() {
                for (let e = 0; e < this.layers.length; e++) {
                  const t = this.system.app.scene.layers.getLayerById(
                    this.layers[e]
                  );
                  t && t.addLight(this);
                }
              }
              removeLightFromLayers() {
                for (let e = 0; e < this.layers.length; e++) {
                  const t = this.system.app.scene.layers.getLayerById(
                    this.layers[e]
                  );
                  t && t.removeLight(this);
                }
              }
              onLayersChanged(e, t) {
                this.enabled && this.entity.enabled && this.addLightToLayers(),
                  e.off("add", this.onLayerAdded, this),
                  e.off("remove", this.onLayerRemoved, this),
                  t.on("add", this.onLayerAdded, this),
                  t.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(e) {
                this.layers.indexOf(e.id) >= 0 &&
                  this.enabled &&
                  this.entity.enabled &&
                  e.addLight(this);
              }
              onLayerRemoved(e) {
                this.layers.indexOf(e.id) >= 0 && e.removeLight(this);
              }
              refreshProperties() {
                for (let e = 0; e < f.length; e++) {
                  const t = f[e];
                  this[t] = this[t];
                }
                this.enabled && this.entity.enabled && this.onEnable();
              }
              onCookieAssetSet() {
                let e = !1;
                this._cookieAsset.type === "cubemap" &&
                  !this._cookieAsset.loadFaces &&
                  ((this._cookieAsset.loadFaces = !0), (e = !0)),
                  (!this._cookieAsset.resource || e) &&
                    this.system.app.assets.load(this._cookieAsset),
                  this._cookieAsset.resource && this.onCookieAssetLoad();
              }
              onCookieAssetAdd(e) {
                this._cookieAssetId === e.id &&
                  ((this._cookieAsset = e),
                  this.light.enabled && this.onCookieAssetSet(),
                  this._cookieAsset.on("load", this.onCookieAssetLoad, this),
                  this._cookieAsset.on(
                    "remove",
                    this.onCookieAssetRemove,
                    this
                  ));
              }
              onCookieAssetLoad() {
                !this._cookieAsset ||
                  !this._cookieAsset.resource ||
                  (this.cookie = this._cookieAsset.resource);
              }
              onCookieAssetRemove() {
                this._cookieAssetId &&
                  (this._cookieAssetAdd &&
                    (this.system.app.assets.off(
                      "add:" + this._cookieAssetId,
                      this.onCookieAssetAdd,
                      this
                    ),
                    (this._cookieAssetAdd = !1)),
                  this._cookieAsset &&
                    (this._cookieAsset.off(
                      "load",
                      this.onCookieAssetLoad,
                      this
                    ),
                    this._cookieAsset.off(
                      "remove",
                      this.onCookieAssetRemove,
                      this
                    ),
                    (this._cookieAsset = null)),
                  (this.cookie = null));
              }
              onEnable() {
                (this.light.enabled = !0),
                  this.system.app.scene.on(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.on(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.on(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this.enabled &&
                    this.entity.enabled &&
                    this.addLightToLayers(),
                  this._cookieAsset && !this.cookie && this.onCookieAssetSet();
              }
              onDisable() {
                (this.light.enabled = !1),
                  this.system.app.scene.off(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.off(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.off(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this.removeLightFromLayers();
              }
              onRemove() {
                this.onDisable(),
                  this.light.destroy(),
                  (this.cookieAsset = null);
              }
              set shadowUpdateOverrides(e) {
                this.light.shadowUpdateOverrides = e;
              }
              get shadowUpdateOverrides() {
                return this.light.shadowUpdateOverrides;
              }
              set penumbraSize(e) {
                this.light.penumbraSize = e;
              }
              get penumbraSize() {
                return this.light.penumbraSize;
              }
            }
            function n(i, e, t, r) {
              const u = l.prototype;
              f.push(i),
                s.push(e),
                Object.defineProperty(u, i, {
                  get: function () {
                    return this.data[i];
                  },
                  set: function (v) {
                    const _ = this.data,
                      m = _[i];
                    (!r && m === v) || ((_[i] = v), t && t.call(this, v, m));
                  },
                  configurable: !0,
                });
            }
            function o() {
              n("enabled", !0, function (i, e) {
                this.onSetEnabled(null, e, i);
              }),
                n("light", null),
                n("type", "directional", function (i, e) {
                  this.system.changeType(this, e, i), this.refreshProperties();
                }),
                n(
                  "color",
                  new x.Q(1, 1, 1),
                  function (i, e) {
                    this.light.setColor(i);
                  },
                  !0
                ),
                n("intensity", 1, function (i, e) {
                  this.light.intensity = i;
                }),
                n("luminance", 0, function (i, e) {
                  this.light.luminance = i;
                }),
                n("shape", c.j0, function (i, e) {
                  this.light.shape = i;
                }),
                n("affectSpecularity", !0, function (i, e) {
                  this.light.affectSpecularity = i;
                }),
                n("castShadows", !1, function (i, e) {
                  this.light.castShadows = i;
                }),
                n("shadowDistance", 40, function (i, e) {
                  this.light.shadowDistance = i;
                }),
                n("shadowIntensity", 1, function (i, e) {
                  this.light.shadowIntensity = i;
                }),
                n("shadowResolution", 1024, function (i, e) {
                  this.light.shadowResolution = i;
                }),
                n("shadowBias", 0.05, function (i, e) {
                  this.light.shadowBias = -0.01 * A.D.clamp(i, 0, 1);
                }),
                n("numCascades", 1, function (i, e) {
                  this.light.numCascades = A.D.clamp(Math.floor(i), 1, 4);
                }),
                n("bakeNumSamples", 1, function (i, e) {
                  this.light.bakeNumSamples = A.D.clamp(Math.floor(i), 1, 255);
                }),
                n("bakeArea", 0, function (i, e) {
                  this.light.bakeArea = A.D.clamp(i, 0, 180);
                }),
                n("cascadeDistribution", 0.5, function (i, e) {
                  this.light.cascadeDistribution = A.D.clamp(i, 0, 1);
                }),
                n("normalOffsetBias", 0, function (i, e) {
                  this.light.normalOffsetBias = A.D.clamp(i, 0, 1);
                }),
                n("range", 10, function (i, e) {
                  this.light.attenuationEnd = i;
                }),
                n("innerConeAngle", 40, function (i, e) {
                  this.light.innerConeAngle = i;
                }),
                n("outerConeAngle", 45, function (i, e) {
                  this.light.outerConeAngle = i;
                }),
                n("falloffMode", c.$7, function (i, e) {
                  this.light.falloffMode = i;
                }),
                n("shadowType", c.MF, function (i, e) {
                  this.light.shadowType = i;
                }),
                n("vsmBlurSize", 11, function (i, e) {
                  this.light.vsmBlurSize = i;
                }),
                n("vsmBlurMode", c.wA, function (i, e) {
                  this.light.vsmBlurMode = i;
                }),
                n("vsmBias", 0.0025, function (i, e) {
                  this.light.vsmBias = A.D.clamp(i, 0, 1);
                }),
                n("cookieAsset", null, function (i, e) {
                  if (
                    !(
                      this._cookieAssetId &&
                      ((i instanceof d.V && i.id === this._cookieAssetId) ||
                        i === this._cookieAssetId)
                    )
                  ) {
                    if (
                      (this.onCookieAssetRemove(),
                      (this._cookieAssetId = null),
                      i instanceof d.V)
                    )
                      (this.data.cookieAsset = i.id),
                        (this._cookieAssetId = i.id),
                        this.onCookieAssetAdd(i);
                    else if (typeof i == "number") {
                      this._cookieAssetId = i;
                      const t = this.system.app.assets.get(i);
                      t
                        ? this.onCookieAssetAdd(t)
                        : ((this._cookieAssetAdd = !0),
                          this.system.app.assets.on(
                            "add:" + this._cookieAssetId,
                            this.onCookieAssetAdd,
                            this
                          ));
                    }
                  }
                }),
                n("cookie", null, function (i, e) {
                  this.light.cookie = i;
                }),
                n("cookieIntensity", 1, function (i, e) {
                  this.light.cookieIntensity = A.D.clamp(i, 0, 1);
                }),
                n("cookieFalloff", !0, function (i, e) {
                  this.light.cookieFalloff = i;
                }),
                n("cookieChannel", "rgb", function (i, e) {
                  this.light.cookieChannel = i;
                }),
                n("cookieAngle", 0, function (i, e) {
                  if (i !== 0 || this.cookieScale !== null) {
                    this._cookieMatrix || (this._cookieMatrix = new y.Z());
                    let t = 1,
                      r = 1;
                    this.cookieScale &&
                      ((t = this.cookieScale.x), (r = this.cookieScale.y));
                    const u = Math.cos(i * A.D.DEG_TO_RAD),
                      v = Math.sin(i * A.D.DEG_TO_RAD);
                    this._cookieMatrix.set(u / t, -v / t, v / r, u / r),
                      (this.light.cookieTransform = this._cookieMatrix);
                  } else this.light.cookieTransform = null;
                }),
                n(
                  "cookieScale",
                  null,
                  function (i, e) {
                    if (i !== null || this.cookieAngle !== 0) {
                      this._cookieMatrix || (this._cookieMatrix = new y.Z());
                      const t = i.x,
                        r = i.y,
                        u = Math.cos(this.cookieAngle * A.D.DEG_TO_RAD),
                        v = Math.sin(this.cookieAngle * A.D.DEG_TO_RAD);
                      this._cookieMatrix.set(u / t, -v / t, v / r, u / r),
                        (this.light.cookieTransform = this._cookieMatrix);
                    } else this.light.cookieTransform = null;
                  },
                  !0
                ),
                n(
                  "cookieOffset",
                  null,
                  function (i, e) {
                    this.light.cookieOffset = i;
                  },
                  !0
                ),
                n(
                  "shadowUpdateMode",
                  c.M5,
                  function (i, e) {
                    this.light.shadowUpdateMode = i;
                  },
                  !0
                ),
                n("mask", 1, function (i, e) {
                  this.light.mask = i;
                }),
                n("affectDynamic", !0, function (i, e) {
                  i ? (this.light.mask |= c.Xj) : (this.light.mask &= ~c.Xj),
                    this.light.layersDirty();
                }),
                n("affectLightmapped", !1, function (i, e) {
                  i
                    ? ((this.light.mask |= c.be),
                      this.bake && (this.light.mask &= ~c.XE))
                    : ((this.light.mask &= ~c.be),
                      this.bake && (this.light.mask |= c.XE));
                }),
                n("bake", !1, function (i, e) {
                  i
                    ? ((this.light.mask |= c.XE),
                      this.affectLightmapped && (this.light.mask &= ~c.be))
                    : ((this.light.mask &= ~c.XE),
                      this.affectLightmapped && (this.light.mask |= c.be)),
                    this.light.layersDirty();
                }),
                n("bakeDir", !0, function (i, e) {
                  this.light.bakeDir = i;
                }),
                n("isStatic", !1, function (i, e) {
                  this.light.isStatic = i;
                }),
                n("layers", [c.uE], function (i, e) {
                  for (let t = 0; t < e.length; t++) {
                    const r = this.system.app.scene.layers.getLayerById(e[t]);
                    r && r.removeLight(this);
                  }
                  for (let t = 0; t < i.length; t++) {
                    const r = this.system.app.scene.layers.getLayerById(i[t]);
                    r &&
                      this.enabled &&
                      this.entity.enabled &&
                      r.addLight(this);
                  }
                }),
                f.push("penumbraSize"),
                s.push(1);
            }
            o();
          },
          3188: (xe, V, a) => {
            "use strict";
            a.d(V, { t: () => s });
            var A = a(5227),
              x = a(7994),
              y = a(9391),
              c = a(8026),
              d = a(2930),
              h = a(9763);
            class f {
              constructor() {
                const n = h.qm,
                  o = h.vF;
                for (let i = 0; i < n.length; i++) {
                  const e = o[i];
                  e && e.clone ? (this[n[i]] = e.clone()) : (this[n[i]] = e);
                }
              }
            }
            class s extends d.r {
              constructor(n) {
                super(n),
                  (this.id = "light"),
                  (this.ComponentType = h.Mm),
                  (this.DataType = f),
                  this.on("beforeremove", this._onRemoveComponent, this);
              }
              initializeComponentData(n, o) {
                const i = h.qm,
                  e = {};
                for (let r = 0, u = i.length; r < u; r++) {
                  const v = i[r];
                  e[v] = o[v];
                }
                e.type || (e.type = n.data.type),
                  (n.data.type = e.type),
                  e.layers &&
                    Array.isArray(e.layers) &&
                    (e.layers = e.layers.slice(0)),
                  e.color &&
                    Array.isArray(e.color) &&
                    (e.color = new A.Q(e.color[0], e.color[1], e.color[2])),
                  e.cookieOffset &&
                    e.cookieOffset instanceof Array &&
                    (e.cookieOffset = new x.Z(
                      e.cookieOffset[0],
                      e.cookieOffset[1]
                    )),
                  e.cookieScale &&
                    e.cookieScale instanceof Array &&
                    (e.cookieScale = new x.Z(
                      e.cookieScale[0],
                      e.cookieScale[1]
                    )),
                  e.enable &&
                    (console.warn(
                      "WARNING: enable: Property is deprecated. Set enabled property instead."
                    ),
                    (e.enabled = e.enable)),
                  e.shape || (e.shape = y.j0);
                const t = new c.v(this.app.graphicsDevice);
                (t.type = c.A[e.type]),
                  (t._node = n.entity),
                  (t._scene = this.app.scene),
                  (n.data.light = t),
                  super.initializeComponentData(n, e, i);
              }
              _onRemoveComponent(n, o) {
                o.onRemove();
              }
              cloneComponent(n, o) {
                const i = n.light,
                  e = [];
                let t;
                const r = h.qm;
                for (let u = 0; u < r.length; u++)
                  (t = r[u]),
                    t !== "light" &&
                      (i[t] && i[t].clone
                        ? (e[t] = i[t].clone())
                        : (e[t] = i[t]));
                return this.addComponent(o, e);
              }
              changeType(n, o, i) {
                o !== i && (n.light.type = c.A[i]);
              }
            }
          },
          7654: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => l });
            var A = a(9391),
              x = a(5041),
              y = a(3035),
              c = a(3637),
              d = a(9611),
              h = a(8531),
              f = a(3953),
              s = a(4124);
            class l extends s.u {
              constructor(o, i) {
                super(o, i),
                  (this._type = "asset"),
                  (this._asset = null),
                  (this._model = null),
                  (this._mapping = {}),
                  (this._castShadows = !0),
                  (this._receiveShadows = !0),
                  (this._materialAsset = null),
                  (this._material = void 0),
                  (this._castShadowsLightmap = !0),
                  (this._lightmapped = !1),
                  (this._lightmapSizeMultiplier = 1),
                  (this.isStatic = !1),
                  (this._layers = [A.uE]),
                  (this._batchGroupId = -1),
                  (this._customAabb = null),
                  (this._area = null),
                  (this._materialEvents = null),
                  (this._clonedModel = !1),
                  (this._material = o.defaultMaterial),
                  i.on("remove", this.onRemoveChild, this),
                  i.on("removehierarchy", this.onRemoveChild, this),
                  i.on("insert", this.onInsertChild, this),
                  i.on("inserthierarchy", this.onInsertChild, this);
              }
              set meshInstances(o) {
                this._model && (this._model.meshInstances = o);
              }
              get meshInstances() {
                return this._model ? this._model.meshInstances : null;
              }
              set customAabb(o) {
                if (((this._customAabb = o), this._model)) {
                  const i = this._model.meshInstances;
                  if (i)
                    for (let e = 0; e < i.length; e++)
                      i[e].setCustomAabb(this._customAabb);
                }
              }
              get customAabb() {
                return this._customAabb;
              }
              set type(o) {
                if (this._type !== o)
                  if (((this._area = null), (this._type = o), o === "asset"))
                    this._asset !== null
                      ? this._bindModelAsset(this._asset)
                      : (this.model = null);
                  else {
                    const i = (0, h.LT)(this.system.app.graphicsDevice, o);
                    this._area = i.area;
                    const e = i.mesh,
                      t = new y.t(),
                      r = new d.K();
                    (r.graph = t),
                      (r.meshInstances = [new c.F(e, this._material, t)]),
                      (this.model = r),
                      (this._asset = null);
                  }
              }
              get type() {
                return this._type;
              }
              set asset(o) {
                const i = this.system.app.assets;
                let e = o;
                if ((o instanceof f.V && (e = o.id), this._asset !== e)) {
                  if (this._asset) {
                    i.off("add:" + this._asset, this._onModelAssetAdded, this);
                    const t = i.get(this._asset);
                    t && this._unbindModelAsset(t);
                  }
                  if (((this._asset = e), this._asset)) {
                    const t = i.get(this._asset);
                    t
                      ? this._bindModelAsset(t)
                      : ((this.model = null),
                        i.on(
                          "add:" + this._asset,
                          this._onModelAssetAdded,
                          this
                        ));
                  } else this.model = null;
                }
              }
              get asset() {
                return this._asset;
              }
              set model(o) {
                if (
                  this._model !== o &&
                  !(o && o._immutable) &&
                  (this._model &&
                    ((this._model._immutable = !1),
                    this.removeModelFromLayers(),
                    this._model.getGraph().destroy(),
                    delete this._model._entity,
                    this._clonedModel &&
                      (this._model.destroy(), (this._clonedModel = !1))),
                  (this._model = o),
                  this._model)
                ) {
                  this._model._immutable = !0;
                  const i = this._model.meshInstances;
                  for (let e = 0; e < i.length; e++)
                    (i[e].castShadow = this._castShadows),
                      (i[e].receiveShadow = this._receiveShadows),
                      i[e].setCustomAabb(this._customAabb);
                  (this.lightmapped = this._lightmapped),
                    this.entity.addChild(this._model.graph),
                    this.enabled &&
                      this.entity.enabled &&
                      this.addModelToLayers(),
                    (this._model._entity = this.entity),
                    this.entity.animation &&
                      this.entity.animation.setModel(this._model),
                    this.entity.anim && this.entity.anim.rebind(),
                    this.type === "asset"
                      ? (this.mapping = this._mapping)
                      : this._unsetMaterialEvents();
                }
              }
              get model() {
                return this._model;
              }
              set lightmapped(o) {
                if (
                  o !== this._lightmapped &&
                  ((this._lightmapped = o), this._model)
                ) {
                  const i = this._model.meshInstances;
                  for (let e = 0; e < i.length; e++) i[e].setLightmapped(o);
                }
              }
              get lightmapped() {
                return this._lightmapped;
              }
              set castShadows(o) {
                if (this._castShadows === o) return;
                const i = this._model;
                if (i) {
                  const e = this.layers,
                    t = this.system.app.scene;
                  if (this._castShadows && !o)
                    for (let u = 0; u < e.length; u++) {
                      const v = this.system.app.scene.layers.getLayerById(
                        this.layers[u]
                      );
                      v && v.removeShadowCasters(i.meshInstances);
                    }
                  const r = i.meshInstances;
                  for (let u = 0; u < r.length; u++) r[u].castShadow = o;
                  if (!this._castShadows && o)
                    for (let u = 0; u < e.length; u++) {
                      const v = t.layers.getLayerById(e[u]);
                      v && v.addShadowCasters(i.meshInstances);
                    }
                }
                this._castShadows = o;
              }
              get castShadows() {
                return this._castShadows;
              }
              set receiveShadows(o) {
                if (
                  this._receiveShadows !== o &&
                  ((this._receiveShadows = o), this._model)
                ) {
                  const i = this._model.meshInstances;
                  for (let e = 0, t = i.length; e < t; e++)
                    i[e].receiveShadow = o;
                }
              }
              get receiveShadows() {
                return this._receiveShadows;
              }
              set castShadowsLightmap(o) {
                this._castShadowsLightmap = o;
              }
              get castShadowsLightmap() {
                return this._castShadowsLightmap;
              }
              set lightmapSizeMultiplier(o) {
                this._lightmapSizeMultiplier = o;
              }
              get lightmapSizeMultiplier() {
                return this._lightmapSizeMultiplier;
              }
              set layers(o) {
                const i = this.system.app.scene.layers;
                if (this.meshInstances)
                  for (let e = 0; e < this._layers.length; e++) {
                    const t = i.getLayerById(this._layers[e]);
                    t && t.removeMeshInstances(this.meshInstances);
                  }
                this._layers.length = 0;
                for (let e = 0; e < o.length; e++) this._layers[e] = o[e];
                if (
                  !(
                    !this.enabled ||
                    !this.entity.enabled ||
                    !this.meshInstances
                  )
                )
                  for (let e = 0; e < this._layers.length; e++) {
                    const t = i.getLayerById(this._layers[e]);
                    t && t.addMeshInstances(this.meshInstances);
                  }
              }
              get layers() {
                return this._layers;
              }
              set batchGroupId(o) {
                if (this._batchGroupId !== o) {
                  if (this.entity.enabled && this._batchGroupId >= 0) {
                    var i;
                    (i = this.system.app.batcher) == null ||
                      i.remove(x.w.MODEL, this.batchGroupId, this.entity);
                  }
                  if (this.entity.enabled && o >= 0) {
                    var e;
                    (e = this.system.app.batcher) == null ||
                      e.insert(x.w.MODEL, o, this.entity);
                  }
                  o < 0 &&
                    this._batchGroupId >= 0 &&
                    this.enabled &&
                    this.entity.enabled &&
                    this.addModelToLayers(),
                    (this._batchGroupId = o);
                }
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set materialAsset(o) {
                let i = o;
                o instanceof f.V && (i = o.id);
                const e = this.system.app.assets;
                if (i !== this._materialAsset) {
                  if (this._materialAsset) {
                    e.off(
                      "add:" + this._materialAsset,
                      this._onMaterialAssetAdd,
                      this
                    );
                    const t = e.get(this._materialAsset);
                    t && this._unbindMaterialAsset(t);
                  }
                  if (((this._materialAsset = i), this._materialAsset)) {
                    const t = e.get(this._materialAsset);
                    t
                      ? this._bindMaterialAsset(t)
                      : (this._setMaterial(this.system.defaultMaterial),
                        e.on(
                          "add:" + this._materialAsset,
                          this._onMaterialAssetAdd,
                          this
                        ));
                  } else this._setMaterial(this.system.defaultMaterial);
                }
              }
              get materialAsset() {
                return this._materialAsset;
              }
              set material(o) {
                this._material !== o &&
                  ((this.materialAsset = null), this._setMaterial(o));
              }
              get material() {
                return this._material;
              }
              set mapping(o) {
                if (
                  this._type !== "asset" ||
                  (this._unsetMaterialEvents(),
                  o || (o = {}),
                  (this._mapping = o),
                  !this._model)
                )
                  return;
                const i = this._model.meshInstances,
                  e = this.asset
                    ? this.system.app.assets.get(this.asset)
                    : null,
                  t = e ? e.data.mapping : null;
                let r = null;
                for (let u = 0, v = i.length; u < v; u++)
                  if (o[u] !== void 0)
                    o[u]
                      ? ((r = this.system.app.assets.get(o[u])),
                        this._loadAndSetMeshInstanceMaterial(r, i[u], u))
                      : (i[u].material = this.system.defaultMaterial);
                  else if (t)
                    if (t[u] && (t[u].material || t[u].path)) {
                      if (t[u].material !== void 0)
                        r = this.system.app.assets.get(t[u].material);
                      else if (t[u].path !== void 0) {
                        const _ = this._getMaterialAssetUrl(t[u].path);
                        _ && (r = this.system.app.assets.getByUrl(_));
                      }
                      this._loadAndSetMeshInstanceMaterial(r, i[u], u);
                    } else i[u].material = this.system.defaultMaterial;
              }
              get mapping() {
                return this._mapping;
              }
              addModelToLayers() {
                const o = this.system.app.scene.layers;
                for (let i = 0; i < this._layers.length; i++) {
                  const e = o.getLayerById(this._layers[i]);
                  e && e.addMeshInstances(this.meshInstances);
                }
              }
              removeModelFromLayers() {
                const o = this.system.app.scene.layers;
                for (let i = 0; i < this._layers.length; i++) {
                  const e = o.getLayerById(this._layers[i]);
                  e && e.removeMeshInstances(this.meshInstances);
                }
              }
              onRemoveChild() {
                this._model && this.removeModelFromLayers();
              }
              onInsertChild() {
                this._model &&
                  this.enabled &&
                  this.entity.enabled &&
                  this.addModelToLayers();
              }
              onRemove() {
                (this.asset = null),
                  (this.model = null),
                  (this.materialAsset = null),
                  this._unsetMaterialEvents(),
                  this.entity.off("remove", this.onRemoveChild, this),
                  this.entity.off("insert", this.onInsertChild, this);
              }
              onLayersChanged(o, i) {
                this.addModelToLayers(),
                  o.off("add", this.onLayerAdded, this),
                  o.off("remove", this.onLayerRemoved, this),
                  i.on("add", this.onLayerAdded, this),
                  i.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(o) {
                this.layers.indexOf(o.id) < 0 ||
                  o.addMeshInstances(this.meshInstances);
              }
              onLayerRemoved(o) {
                this.layers.indexOf(o.id) < 0 ||
                  o.removeMeshInstances(this.meshInstances);
              }
              _setMaterialEvent(o, i, e, t) {
                const r = i + ":" + e;
                this.system.app.assets.on(r, t, this),
                  this._materialEvents || (this._materialEvents = []),
                  this._materialEvents[o] || (this._materialEvents[o] = {}),
                  (this._materialEvents[o][r] = { id: e, handler: t });
              }
              _unsetMaterialEvents() {
                const o = this.system.app.assets,
                  i = this._materialEvents;
                if (i) {
                  for (let e = 0, t = i.length; e < t; e++) {
                    if (!i[e]) continue;
                    const r = i[e];
                    for (const u in r) o.off(u, r[u].handler, this);
                  }
                  this._materialEvents = null;
                }
              }
              _getAssetByIdOrPath(o) {
                let i = null;
                if (!isNaN(parseInt(o, 10))) i = this.system.app.assets.get(o);
                else if (this.asset) {
                  const t = this._getMaterialAssetUrl(o);
                  t && (i = this.system.app.assets.getByUrl(t));
                }
                return i;
              }
              _getMaterialAssetUrl(o) {
                if (!this.asset) return null;
                const i = this.system.app.assets.get(this.asset);
                return i ? i.getAbsoluteUrl(o) : null;
              }
              _loadAndSetMeshInstanceMaterial(o, i, e) {
                const t = this.system.app.assets;
                o &&
                  (o.resource
                    ? ((i.material = o.resource),
                      this._setMaterialEvent(e, "remove", o.id, function () {
                        i.material = this.system.defaultMaterial;
                      }))
                    : (this._setMaterialEvent(e, "load", o.id, function (r) {
                        (i.material = r.resource),
                          this._setMaterialEvent(
                            e,
                            "remove",
                            o.id,
                            function () {
                              i.material = this.system.defaultMaterial;
                            }
                          );
                      }),
                      this.enabled && this.entity.enabled && t.load(o)));
              }
              onEnable() {
                const o = this.system.app,
                  i = o.scene;
                i.on("set:layers", this.onLayersChanged, this),
                  i.layers &&
                    (i.layers.on("add", this.onLayerAdded, this),
                    i.layers.on("remove", this.onLayerRemoved, this));
                const e = this._type === "asset";
                let t;
                if (
                  (this._model
                    ? this.addModelToLayers()
                    : e &&
                      this._asset &&
                      ((t = o.assets.get(this._asset)),
                      t &&
                        t.resource !== this._model &&
                        this._bindModelAsset(t)),
                  this._materialAsset &&
                    ((t = o.assets.get(this._materialAsset)),
                    t &&
                      t.resource !== this._material &&
                      this._bindMaterialAsset(t)),
                  e && this._mapping)
                )
                  for (const u in this._mapping)
                    this._mapping[u] &&
                      ((t = this._getAssetByIdOrPath(this._mapping[u])),
                      t && !t.resource && o.assets.load(t));
                if (this._batchGroupId >= 0) {
                  var r;
                  (r = o.batcher) == null ||
                    r.insert(x.w.MODEL, this.batchGroupId, this.entity);
                }
              }
              onDisable() {
                const o = this.system.app,
                  i = o.scene;
                if (
                  (i.off("set:layers", this.onLayersChanged, this),
                  i.layers &&
                    (i.layers.off("add", this.onLayerAdded, this),
                    i.layers.off("remove", this.onLayerRemoved, this)),
                  this._batchGroupId >= 0)
                ) {
                  var e;
                  (e = o.batcher) == null ||
                    e.remove(x.w.MODEL, this.batchGroupId, this.entity);
                }
                this._model && this.removeModelFromLayers();
              }
              hide() {
                if (this._model) {
                  const o = this._model.meshInstances;
                  for (let i = 0, e = o.length; i < e; i++) o[i].visible = !1;
                }
              }
              show() {
                if (this._model) {
                  const o = this._model.meshInstances;
                  for (let i = 0, e = o.length; i < e; i++) o[i].visible = !0;
                }
              }
              _bindMaterialAsset(o) {
                if (
                  (o.on("load", this._onMaterialAssetLoad, this),
                  o.on("unload", this._onMaterialAssetUnload, this),
                  o.on("remove", this._onMaterialAssetRemove, this),
                  o.on("change", this._onMaterialAssetChange, this),
                  o.resource)
                )
                  this._onMaterialAssetLoad(o);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(o);
                }
              }
              _unbindMaterialAsset(o) {
                o.off("load", this._onMaterialAssetLoad, this),
                  o.off("unload", this._onMaterialAssetUnload, this),
                  o.off("remove", this._onMaterialAssetRemove, this),
                  o.off("change", this._onMaterialAssetChange, this);
              }
              _onMaterialAssetAdd(o) {
                this.system.app.assets.off(
                  "add:" + o.id,
                  this._onMaterialAssetAdd,
                  this
                ),
                  this._materialAsset === o.id && this._bindMaterialAsset(o);
              }
              _onMaterialAssetLoad(o) {
                this._setMaterial(o.resource);
              }
              _onMaterialAssetUnload(o) {
                this._setMaterial(this.system.defaultMaterial);
              }
              _onMaterialAssetRemove(o) {
                this._onMaterialAssetUnload(o);
              }
              _onMaterialAssetChange(o) {}
              _bindModelAsset(o) {
                if (
                  (this._unbindModelAsset(o),
                  o.on("load", this._onModelAssetLoad, this),
                  o.on("unload", this._onModelAssetUnload, this),
                  o.on("change", this._onModelAssetChange, this),
                  o.on("remove", this._onModelAssetRemove, this),
                  o.resource)
                )
                  this._onModelAssetLoad(o);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(o);
                }
              }
              _unbindModelAsset(o) {
                o.off("load", this._onModelAssetLoad, this),
                  o.off("unload", this._onModelAssetUnload, this),
                  o.off("change", this._onModelAssetChange, this),
                  o.off("remove", this._onModelAssetRemove, this);
              }
              _onModelAssetAdded(o) {
                this.system.app.assets.off(
                  "add:" + o.id,
                  this._onModelAssetAdded,
                  this
                ),
                  o.id === this._asset && this._bindModelAsset(o);
              }
              _onModelAssetLoad(o) {
                (this.model = o.resource.clone()), (this._clonedModel = !0);
              }
              _onModelAssetUnload(o) {
                this.model = null;
              }
              _onModelAssetChange(o, i, e, t) {
                i === "data" && (this.mapping = this._mapping);
              }
              _onModelAssetRemove(o) {
                this.model = null;
              }
              _setMaterial(o) {
                if (this._material === o) return;
                this._material = o;
                const i = this._model;
                if (i && this._type !== "asset") {
                  const e = i.meshInstances;
                  for (let t = 0, r = e.length; t < r; t++) e[t].material = o;
                }
              }
            }
          },
          8441: (xe, V, a) => {
            "use strict";
            a.d(V, { a: () => o });
            var A = a(8506),
              x = a(7481),
              y = a(7915),
              c = a(1594),
              d = a(3953),
              h = a(4124),
              f = a(2930),
              s = a(7654);
            class l {
              constructor() {
                this.enabled = !0;
              }
            }
            const n = ["enabled"];
            class o extends f.r {
              constructor(e) {
                super(e),
                  (this.id = "model"),
                  (this.ComponentType = s.D),
                  (this.DataType = l),
                  (this.schema = n),
                  (this.defaultMaterial = (0, c.h)(e.graphicsDevice)),
                  this.on("beforeremove", this.onRemove, this);
              }
              initializeComponentData(e, t, r) {
                (r = [
                  "material",
                  "materialAsset",
                  "asset",
                  "castShadows",
                  "receiveShadows",
                  "castShadowsLightmap",
                  "lightmapped",
                  "lightmapSizeMultiplier",
                  "type",
                  "mapping",
                  "layers",
                  "isStatic",
                  "batchGroupId",
                ]),
                  (t.batchGroupId === null || t.batchGroupId === void 0) &&
                    (t.batchGroupId = -1),
                  t.layers && t.layers.length && (t.layers = t.layers.slice(0));
                for (let u = 0; u < r.length; u++)
                  t.hasOwnProperty(r[u]) && (e[r[u]] = t[r[u]]);
                t.aabbCenter &&
                  t.aabbHalfExtents &&
                  (e.customAabb = new y.I(
                    new x.e(t.aabbCenter),
                    new x.e(t.aabbHalfExtents)
                  )),
                  super.initializeComponentData(e, t, ["enabled"]);
              }
              cloneComponent(e, t) {
                const r = {
                  type: e.model.type,
                  asset: e.model.asset,
                  castShadows: e.model.castShadows,
                  receiveShadows: e.model.receiveShadows,
                  castShadowsLightmap: e.model.castShadowsLightmap,
                  lightmapped: e.model.lightmapped,
                  lightmapSizeMultiplier: e.model.lightmapSizeMultiplier,
                  isStatic: e.model.isStatic,
                  enabled: e.model.enabled,
                  layers: e.model.layers,
                  batchGroupId: e.model.batchGroupId,
                  mapping: (0, A.X$)({}, e.model.mapping),
                };
                let u = e.model.materialAsset;
                !(u instanceof d.V) &&
                  u != null &&
                  (u = this.app.assets.get(u));
                const v = e.model.material;
                (!v || v === this.defaultMaterial || !u || v === u.resource) &&
                  (r.materialAsset = u);
                const _ = this.addComponent(t, r);
                if (
                  (e.model.model &&
                    e.model.type === "asset" &&
                    !e.model.asset &&
                    ((_.model = e.model.model.clone()), (_._clonedModel = !0)),
                  r.materialAsset || (_.material = v),
                  e.model.model)
                ) {
                  const m = e.model.model.meshInstances,
                    g = _.model.meshInstances;
                  for (let T = 0; T < m.length; T++)
                    (g[T].mask = m[T].mask),
                      (g[T].material = m[T].material),
                      (g[T].layer = m[T].layer),
                      (g[T].receiveShadow = m[T].receiveShadow);
                }
                return (
                  e.model.customAabb &&
                    (_.customAabb = e.model.customAabb.clone()),
                  _
                );
              }
              onRemove(e, t) {
                t.onRemove();
              }
            }
            h.u._buildAccessors(s.D.prototype, n);
          },
          9803: (xe, V, a) => {
            "use strict";
            a.d(V, { r: () => o });
            var A = a(9391),
              x = a(7197),
              y = a(2863),
              c = a(3953),
              d = a(4124);
            const h = [
                "emitterExtents",
                "emitterRadius",
                "emitterExtentsInner",
                "emitterRadiusInner",
                "loop",
                "initialVelocity",
                "animSpeed",
                "normalMap",
                "particleNormal",
              ],
              f = [
                "numParticles",
                "lifetime",
                "rate",
                "rate2",
                "startAngle",
                "startAngle2",
                "lighting",
                "halfLambert",
                "intensity",
                "wrap",
                "wrapBounds",
                "depthWrite",
                "noFog",
                "sort",
                "stretch",
                "alignToMotion",
                "preWarm",
                "emitterShape",
                "animTilesX",
                "animTilesY",
                "animStartFrame",
                "animNumFrames",
                "animNumAnimations",
                "animIndex",
                "randomizeAnimIndex",
                "animLoop",
                "colorMap",
                "localSpace",
                "screenSpace",
                "orientation",
              ],
              s = [
                "scaleGraph",
                "scaleGraph2",
                "colorGraph",
                "colorGraph2",
                "alphaGraph",
                "alphaGraph2",
                "velocityGraph",
                "velocityGraph2",
                "localVelocityGraph",
                "localVelocityGraph2",
                "rotationSpeedGraph",
                "rotationSpeedGraph2",
                "radialSpeedGraph",
                "radialSpeedGraph2",
              ],
              l = [
                "colorMapAsset",
                "normalMapAsset",
                "meshAsset",
                "renderAsset",
              ];
            let n;
            class o extends d.u {
              constructor(e, t) {
                super(e, t),
                  (this._requestedDepth = !1),
                  (this._drawOrder = 0),
                  this.on("set_colorMapAsset", this.onSetColorMapAsset, this),
                  this.on("set_normalMapAsset", this.onSetNormalMapAsset, this),
                  this.on("set_meshAsset", this.onSetMeshAsset, this),
                  this.on("set_mesh", this.onSetMesh, this),
                  this.on("set_renderAsset", this.onSetRenderAsset, this),
                  this.on("set_loop", this.onSetLoop, this),
                  this.on("set_blendType", this.onSetBlendType, this),
                  this.on("set_depthSoftening", this.onSetDepthSoftening, this),
                  this.on("set_layers", this.onSetLayers, this),
                  h.forEach((r) => {
                    this.on(`set_${r}`, this.onSetSimpleProperty, this);
                  }),
                  f.forEach((r) => {
                    this.on(`set_${r}`, this.onSetComplexProperty, this);
                  }),
                  s.forEach((r) => {
                    this.on(`set_${r}`, this.onSetGraphProperty, this);
                  });
              }
              set drawOrder(e) {
                (this._drawOrder = e),
                  this.emitter && (this.emitter.drawOrder = e);
              }
              get drawOrder() {
                return this._drawOrder;
              }
              addMeshInstanceToLayers() {
                if (this.emitter)
                  for (let e = 0; e < this.layers.length; e++) {
                    const t = this.system.app.scene.layers.getLayerById(
                      this.layers[e]
                    );
                    t &&
                      (t.addMeshInstances([this.emitter.meshInstance]),
                      (this.emitter._layer = t));
                  }
              }
              removeMeshInstanceFromLayers() {
                if (this.emitter)
                  for (let e = 0; e < this.layers.length; e++) {
                    const t = this.system.app.scene.layers.getLayerById(
                      this.layers[e]
                    );
                    t && t.removeMeshInstances([this.emitter.meshInstance]);
                  }
              }
              onSetLayers(e, t, r) {
                if (this.emitter) {
                  for (let u = 0; u < t.length; u++) {
                    const v = this.system.app.scene.layers.getLayerById(t[u]);
                    v && v.removeMeshInstances([this.emitter.meshInstance]);
                  }
                  if (!(!this.enabled || !this.entity.enabled))
                    for (let u = 0; u < r.length; u++) {
                      const v = this.system.app.scene.layers.getLayerById(r[u]);
                      v && v.addMeshInstances([this.emitter.meshInstance]);
                    }
                }
              }
              onLayersChanged(e, t) {
                this.addMeshInstanceToLayers(),
                  e.off("add", this.onLayerAdded, this),
                  e.off("remove", this.onLayerRemoved, this),
                  t.on("add", this.onLayerAdded, this),
                  t.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(e) {
                !this.emitter ||
                  this.layers.indexOf(e.id) < 0 ||
                  e.addMeshInstances([this.emitter.meshInstance]);
              }
              onLayerRemoved(e) {
                !this.emitter ||
                  this.layers.indexOf(e.id) < 0 ||
                  e.removeMeshInstances([this.emitter.meshInstance]);
              }
              _bindColorMapAsset(e) {
                if (
                  (e.on("load", this._onColorMapAssetLoad, this),
                  e.on("unload", this._onColorMapAssetUnload, this),
                  e.on("remove", this._onColorMapAssetRemove, this),
                  e.on("change", this._onColorMapAssetChange, this),
                  e.resource)
                )
                  this._onColorMapAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindColorMapAsset(e) {
                e.off("load", this._onColorMapAssetLoad, this),
                  e.off("unload", this._onColorMapAssetUnload, this),
                  e.off("remove", this._onColorMapAssetRemove, this),
                  e.off("change", this._onColorMapAssetChange, this);
              }
              _onColorMapAssetLoad(e) {
                this.colorMap = e.resource;
              }
              _onColorMapAssetUnload(e) {
                this.colorMap = null;
              }
              _onColorMapAssetRemove(e) {
                this._onColorMapAssetUnload(e);
              }
              _onColorMapAssetChange(e) {}
              onSetColorMapAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const v = u.get(t);
                  v && this._unbindColorMapAsset(v);
                }
                if (r) {
                  r instanceof c.V &&
                    ((this.data.colorMapAsset = r.id), (r = r.id));
                  const v = u.get(r);
                  v
                    ? this._bindColorMapAsset(v)
                    : u.once("add:" + r, (_) => {
                        this._bindColorMapAsset(_);
                      });
                } else this.colorMap = null;
              }
              _bindNormalMapAsset(e) {
                if (
                  (e.on("load", this._onNormalMapAssetLoad, this),
                  e.on("unload", this._onNormalMapAssetUnload, this),
                  e.on("remove", this._onNormalMapAssetRemove, this),
                  e.on("change", this._onNormalMapAssetChange, this),
                  e.resource)
                )
                  this._onNormalMapAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindNormalMapAsset(e) {
                e.off("load", this._onNormalMapAssetLoad, this),
                  e.off("unload", this._onNormalMapAssetUnload, this),
                  e.off("remove", this._onNormalMapAssetRemove, this),
                  e.off("change", this._onNormalMapAssetChange, this);
              }
              _onNormalMapAssetLoad(e) {
                this.normalMap = e.resource;
              }
              _onNormalMapAssetUnload(e) {
                this.normalMap = null;
              }
              _onNormalMapAssetRemove(e) {
                this._onNormalMapAssetUnload(e);
              }
              _onNormalMapAssetChange(e) {}
              onSetNormalMapAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const v = u.get(t);
                  v && this._unbindNormalMapAsset(v);
                }
                if (r) {
                  r instanceof c.V &&
                    ((this.data.normalMapAsset = r.id), (r = r.id));
                  const v = u.get(r);
                  v
                    ? this._bindNormalMapAsset(v)
                    : u.once("add:" + r, (_) => {
                        this._bindNormalMapAsset(_);
                      });
                } else this.normalMap = null;
              }
              _bindMeshAsset(e) {
                if (
                  (e.on("load", this._onMeshAssetLoad, this),
                  e.on("unload", this._onMeshAssetUnload, this),
                  e.on("remove", this._onMeshAssetRemove, this),
                  e.on("change", this._onMeshAssetChange, this),
                  e.resource)
                )
                  this._onMeshAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindMeshAsset(e) {
                e.off("load", this._onMeshAssetLoad, this),
                  e.off("unload", this._onMeshAssetUnload, this),
                  e.off("remove", this._onMeshAssetRemove, this),
                  e.off("change", this._onMeshAssetChange, this);
              }
              _onMeshAssetLoad(e) {
                this._onMeshChanged(e.resource);
              }
              _onMeshAssetUnload(e) {
                this.mesh = null;
              }
              _onMeshAssetRemove(e) {
                this._onMeshAssetUnload(e);
              }
              _onMeshAssetChange(e) {}
              onSetMeshAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const v = u.get(t);
                  v && this._unbindMeshAsset(v);
                }
                if (r) {
                  r instanceof c.V &&
                    ((this.data.meshAsset = r.id), (r = r.id));
                  const v = u.get(r);
                  v && this._bindMeshAsset(v);
                } else this._onMeshChanged(null);
              }
              onSetMesh(e, t, r) {
                !r || r instanceof c.V || typeof r == "number"
                  ? (this.meshAsset = r)
                  : this._onMeshChanged(r);
              }
              _onMeshChanged(e) {
                e &&
                  !(e instanceof x.e) &&
                  (e.meshInstances[0]
                    ? (e = e.meshInstances[0].mesh)
                    : (e = null)),
                  (this.data.mesh = e),
                  this.emitter &&
                    ((this.emitter.mesh = e),
                    this.emitter.resetMaterial(),
                    this.rebuild());
              }
              onSetRenderAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const v = u.get(t);
                  v && this._unbindRenderAsset(v);
                }
                if (r) {
                  r instanceof c.V &&
                    ((this.data.renderAsset = r.id), (r = r.id));
                  const v = u.get(r);
                  v && this._bindRenderAsset(v);
                } else this._onRenderChanged(null);
              }
              _bindRenderAsset(e) {
                if (
                  (e.on("load", this._onRenderAssetLoad, this),
                  e.on("unload", this._onRenderAssetUnload, this),
                  e.on("remove", this._onRenderAssetRemove, this),
                  e.resource)
                )
                  this._onRenderAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindRenderAsset(e) {
                e.off("load", this._onRenderAssetLoad, this),
                  e.off("unload", this._onRenderAssetUnload, this),
                  e.off("remove", this._onRenderAssetRemove, this),
                  e.resource &&
                    e.resource.off("set:meshes", this._onRenderSetMeshes, this);
              }
              _onRenderAssetLoad(e) {
                this._onRenderChanged(e.resource);
              }
              _onRenderAssetUnload(e) {
                this._onRenderChanged(null);
              }
              _onRenderAssetRemove(e) {
                this._onRenderAssetUnload(e);
              }
              _onRenderChanged(e) {
                if (!e) {
                  this._onMeshChanged(null);
                  return;
                }
                e.off("set:meshes", this._onRenderSetMeshes, this),
                  e.on("set:meshes", this._onRenderSetMeshes, this),
                  e.meshes && this._onRenderSetMeshes(e.meshes);
              }
              _onRenderSetMeshes(e) {
                this._onMeshChanged(e && e[0]);
              }
              onSetLoop(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r), this.emitter.resetTime());
              }
              onSetBlendType(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r),
                  (this.emitter.material.blendType = r),
                  this.emitter.resetMaterial(),
                  this.rebuild());
              }
              _requestDepth() {
                this._requestedDepth ||
                  (n || (n = this.system.app.scene.layers.getLayerById(A.$9)),
                  n && (n.incrementCounter(), (this._requestedDepth = !0)));
              }
              _releaseDepth() {
                this._requestedDepth &&
                  n &&
                  (n.decrementCounter(), (this._requestedDepth = !1));
              }
              onSetDepthSoftening(e, t, r) {
                t !== r &&
                  (r
                    ? (this.enabled &&
                        this.entity.enabled &&
                        this._requestDepth(),
                      this.emitter && (this.emitter[e] = r))
                    : (this.enabled &&
                        this.entity.enabled &&
                        this._releaseDepth(),
                      this.emitter && (this.emitter[e] = r)),
                  this.emitter &&
                    (this.reset(),
                    this.emitter.resetMaterial(),
                    this.rebuild()));
              }
              onSetSimpleProperty(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r), this.emitter.resetMaterial());
              }
              onSetComplexProperty(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r),
                  this.emitter.resetMaterial(),
                  this.rebuild(),
                  this.reset());
              }
              onSetGraphProperty(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r),
                  this.emitter.rebuildGraphs(),
                  this.emitter.resetMaterial());
              }
              onEnable() {
                const e = this.data;
                for (let t = 0, r = l.length; t < r; t++) {
                  let u = e[l[t]];
                  if (u) {
                    if (!(u instanceof c.V))
                      if (parseInt(u, 10) >= 0)
                        u = this.system.app.assets.get(u);
                      else continue;
                    u && !u.resource && this.system.app.assets.load(u);
                  }
                }
                if (!this.system.app.graphicsDevice.disableParticleSystem) {
                  if (!this.emitter) {
                    let t = e.mesh;
                    t instanceof x.e || (t = null),
                      (this.emitter = new y.v(this.system.app.graphicsDevice, {
                        numParticles: e.numParticles,
                        emitterExtents: e.emitterExtents,
                        emitterExtentsInner: e.emitterExtentsInner,
                        emitterRadius: e.emitterRadius,
                        emitterRadiusInner: e.emitterRadiusInner,
                        emitterShape: e.emitterShape,
                        initialVelocity: e.initialVelocity,
                        wrap: e.wrap,
                        localSpace: e.localSpace,
                        screenSpace: e.screenSpace,
                        wrapBounds: e.wrapBounds,
                        lifetime: e.lifetime,
                        rate: e.rate,
                        rate2: e.rate2,
                        orientation: e.orientation,
                        particleNormal: e.particleNormal,
                        animTilesX: e.animTilesX,
                        animTilesY: e.animTilesY,
                        animStartFrame: e.animStartFrame,
                        animNumFrames: e.animNumFrames,
                        animNumAnimations: e.animNumAnimations,
                        animIndex: e.animIndex,
                        randomizeAnimIndex: e.randomizeAnimIndex,
                        animSpeed: e.animSpeed,
                        animLoop: e.animLoop,
                        startAngle: e.startAngle,
                        startAngle2: e.startAngle2,
                        scaleGraph: e.scaleGraph,
                        scaleGraph2: e.scaleGraph2,
                        colorGraph: e.colorGraph,
                        colorGraph2: e.colorGraph2,
                        alphaGraph: e.alphaGraph,
                        alphaGraph2: e.alphaGraph2,
                        localVelocityGraph: e.localVelocityGraph,
                        localVelocityGraph2: e.localVelocityGraph2,
                        velocityGraph: e.velocityGraph,
                        velocityGraph2: e.velocityGraph2,
                        rotationSpeedGraph: e.rotationSpeedGraph,
                        rotationSpeedGraph2: e.rotationSpeedGraph2,
                        radialSpeedGraph: e.radialSpeedGraph,
                        radialSpeedGraph2: e.radialSpeedGraph2,
                        colorMap: e.colorMap,
                        normalMap: e.normalMap,
                        loop: e.loop,
                        preWarm: e.preWarm,
                        sort: e.sort,
                        stretch: e.stretch,
                        alignToMotion: e.alignToMotion,
                        lighting: e.lighting,
                        halfLambert: e.halfLambert,
                        intensity: e.intensity,
                        depthSoftening: e.depthSoftening,
                        scene: this.system.app.scene,
                        mesh: t,
                        depthWrite: e.depthWrite,
                        noFog: e.noFog,
                        node: this.entity,
                        blendType: e.blendType,
                      })),
                      (this.emitter.meshInstance.node = this.entity),
                      (this.emitter.drawOrder = this.drawOrder),
                      e.autoPlay ||
                        (this.pause(),
                        (this.emitter.meshInstance.visible = !1));
                  }
                  this.emitter.colorMap && this.addMeshInstanceToLayers(),
                    this.system.app.scene.on(
                      "set:layers",
                      this.onLayersChanged,
                      this
                    ),
                    this.system.app.scene.layers &&
                      (this.system.app.scene.layers.on(
                        "add",
                        this.onLayerAdded,
                        this
                      ),
                      this.system.app.scene.layers.on(
                        "remove",
                        this.onLayerRemoved,
                        this
                      )),
                    this.enabled &&
                      this.entity.enabled &&
                      e.depthSoftening &&
                      this._requestDepth();
                }
              }
              onDisable() {
                this.system.app.scene.off(
                  "set:layers",
                  this.onLayersChanged,
                  this
                ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.off(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.off(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this.emitter &&
                    (this.removeMeshInstanceFromLayers(),
                    this.data.depthSoftening && this._releaseDepth(),
                    (this.emitter.camera = null));
              }
              onBeforeRemove() {
                this.enabled && (this.enabled = !1),
                  this.emitter &&
                    (this.emitter.destroy(), (this.emitter = null));
                for (let e = 0; e < l.length; e++) {
                  const t = l[e];
                  this.data[t] && (this[t] = null);
                }
                this.off();
              }
              reset() {
                this.emitter && this.emitter.reset();
              }
              stop() {
                this.emitter &&
                  ((this.emitter.loop = !1),
                  this.emitter.resetTime(),
                  this.emitter.addTime(0, !0));
              }
              pause() {
                this.data.paused = !0;
              }
              unpause() {
                this.data.paused = !1;
              }
              play() {
                (this.data.paused = !1),
                  this.emitter &&
                    ((this.emitter.meshInstance.visible = !0),
                    (this.emitter.loop = this.data.loop),
                    this.emitter.resetTime());
              }
              isPlaying() {
                return this.data.paused
                  ? !1
                  : this.emitter && this.emitter.loop
                  ? !0
                  : Date.now() <= this.emitter.endTime;
              }
              rebuild() {
                const e = this.enabled;
                (this.enabled = !1),
                  this.emitter &&
                    (this.emitter.rebuild(),
                    (this.emitter.meshInstance.node = this.entity)),
                  (this.enabled = e);
              }
            }
          },
          5580: (xe, V, a) => {
            "use strict";
            a.d(V, { s: () => o });
            var A = a(5567),
              x = a(2358),
              y = a(7481),
              c = a(9391),
              d = a(3953),
              h = a(4124),
              f = a(2930),
              s = a(9803);
            class l {
              constructor() {
                (this.numParticles = 1),
                  (this.rate = 1),
                  (this.rate2 = null),
                  (this.startAngle = 0),
                  (this.startAngle2 = null),
                  (this.lifetime = 50),
                  (this.emitterExtents = new y.e()),
                  (this.emitterExtentsInner = new y.e()),
                  (this.emitterRadius = 0),
                  (this.emitterRadiusInner = 0),
                  (this.emitterShape = c.Ql),
                  (this.initialVelocity = 0),
                  (this.wrapBounds = new y.e()),
                  (this.localSpace = !1),
                  (this.screenSpace = !1),
                  (this.colorMap = null),
                  (this.colorMapAsset = null),
                  (this.normalMap = null),
                  (this.normalMapAsset = null),
                  (this.loop = !0),
                  (this.preWarm = !1),
                  (this.sort = 0),
                  (this.mode = c.JQ),
                  (this.scene = null),
                  (this.lighting = !1),
                  (this.halfLambert = !1),
                  (this.intensity = 1),
                  (this.stretch = 0),
                  (this.alignToMotion = !1),
                  (this.depthSoftening = 0),
                  (this.meshAsset = null),
                  (this.mesh = null),
                  (this.depthWrite = !1),
                  (this.noFog = !1),
                  (this.orientation = c.gp),
                  (this.particleNormal = new y.e(0, 1, 0)),
                  (this.animTilesX = 1),
                  (this.animTilesY = 1),
                  (this.animStartFrame = 0),
                  (this.animNumFrames = 1),
                  (this.animNumAnimations = 1),
                  (this.animIndex = 0),
                  (this.randomizeAnimIndex = !1),
                  (this.animSpeed = 1),
                  (this.animLoop = !0),
                  (this.scaleGraph = null),
                  (this.scaleGraph2 = null),
                  (this.colorGraph = null),
                  (this.colorGraph2 = null),
                  (this.alphaGraph = null),
                  (this.alphaGraph2 = null),
                  (this.localVelocityGraph = null),
                  (this.localVelocityGraph2 = null),
                  (this.velocityGraph = null),
                  (this.velocityGraph2 = null),
                  (this.rotationSpeedGraph = null),
                  (this.rotationSpeedGraph2 = null),
                  (this.radialSpeedGraph = null),
                  (this.radialSpeedGraph2 = null),
                  (this.blendType = c.i9),
                  (this.enabled = !0),
                  (this.paused = !1),
                  (this.autoPlay = !0),
                  (this.layers = [c.uE]);
              }
            }
            const n = [
              "enabled",
              "autoPlay",
              "numParticles",
              "lifetime",
              "rate",
              "rate2",
              "startAngle",
              "startAngle2",
              "loop",
              "preWarm",
              "lighting",
              "halfLambert",
              "intensity",
              "depthWrite",
              "noFog",
              "depthSoftening",
              "sort",
              "blendType",
              "stretch",
              "alignToMotion",
              "emitterShape",
              "emitterExtents",
              "emitterExtentsInner",
              "emitterRadius",
              "emitterRadiusInner",
              "initialVelocity",
              "wrap",
              "wrapBounds",
              "localSpace",
              "screenSpace",
              "colorMapAsset",
              "normalMapAsset",
              "mesh",
              "meshAsset",
              "renderAsset",
              "orientation",
              "particleNormal",
              "localVelocityGraph",
              "localVelocityGraph2",
              "velocityGraph",
              "velocityGraph2",
              "rotationSpeedGraph",
              "rotationSpeedGraph2",
              "radialSpeedGraph",
              "radialSpeedGraph2",
              "scaleGraph",
              "scaleGraph2",
              "colorGraph",
              "colorGraph2",
              "alphaGraph",
              "alphaGraph2",
              "colorMap",
              "normalMap",
              "animTilesX",
              "animTilesY",
              "animStartFrame",
              "animNumFrames",
              "animNumAnimations",
              "animIndex",
              "randomizeAnimIndex",
              "animSpeed",
              "animLoop",
              "layers",
            ];
            class o extends f.r {
              constructor(e) {
                super(e),
                  (this.id = "particlesystem"),
                  (this.ComponentType = s.r),
                  (this.DataType = l),
                  (this.schema = n),
                  (this.propertyTypes = {
                    emitterExtents: "vec3",
                    emitterExtentsInner: "vec3",
                    particleNormal: "vec3",
                    wrapBounds: "vec3",
                    localVelocityGraph: "curveset",
                    localVelocityGraph2: "curveset",
                    velocityGraph: "curveset",
                    velocityGraph2: "curveset",
                    colorGraph: "curveset",
                    colorGraph2: "curveset",
                    alphaGraph: "curve",
                    alphaGraph2: "curve",
                    rotationSpeedGraph: "curve",
                    rotationSpeedGraph2: "curve",
                    radialSpeedGraph: "curve",
                    radialSpeedGraph2: "curve",
                    scaleGraph: "curve",
                    scaleGraph2: "curve",
                  }),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(e, t, r) {
                const u = {};
                r = [];
                const v = this.propertyTypes;
                (t.mesh instanceof d.V || typeof t.mesh == "number") &&
                  ((t.meshAsset = t.mesh), delete t.mesh);
                for (const _ in t) {
                  if (
                    (t.hasOwnProperty(_) && (r.push(_), (u[_] = t[_])),
                    v[_] === "vec3")
                  )
                    Array.isArray(u[_]) &&
                      (u[_] = new y.e(u[_][0], u[_][1], u[_][2]));
                  else if (v[_] === "curve") {
                    if (!(u[_] instanceof A.I)) {
                      const m = u[_].type;
                      (u[_] = new A.I(u[_].keys)), (u[_].type = m);
                    }
                  } else if (v[_] === "curveset" && !(u[_] instanceof x.K)) {
                    const m = u[_].type;
                    (u[_] = new x.K(u[_].keys)), (u[_].type = m);
                  }
                  u.layers &&
                    Array.isArray(u.layers) &&
                    (u.layers = u.layers.slice(0));
                }
                super.initializeComponentData(e, u, r);
              }
              cloneComponent(e, t) {
                const r = e.particlesystem.data,
                  u = this.schema,
                  v = {};
                for (let _ = 0, m = u.length; _ < m; _++) {
                  const g = u[_];
                  let T = r[g];
                  T instanceof y.e || T instanceof A.I || T instanceof x.K
                    ? ((T = T.clone()), (v[g] = T))
                    : g === "layers"
                    ? (v.layers = r.layers.slice(0))
                    : T != null && (v[g] = T);
                }
                return this.addComponent(t, v);
              }
              onUpdate(e) {
                const t = this.store;
                let r;
                const u = this.app.stats.particles;
                for (const v in t)
                  if (t.hasOwnProperty(v)) {
                    const _ = t[v],
                      m = _.entity,
                      g = _.data;
                    if (g.enabled && m.enabled) {
                      const T = m.particlesystem.emitter;
                      if (!(T != null && T.meshInstance.visible)) continue;
                      if (T.lighting) {
                        const E = g.layers;
                        let M;
                        for (let R = 0; R < E.length; R++) {
                          const P = this.app.scene.layers.getLayerById(E[R]);
                          if (!P) continue;
                          P._lightCube || (P._lightCube = new Float32Array(18)),
                            (M = P._lightCube);
                          for (let b = 0; b < 6; b++)
                            (M[b * 3] = this.app.scene.ambientLight.r),
                              (M[b * 3 + 1] = this.app.scene.ambientLight.g),
                              (M[b * 3 + 2] = this.app.scene.ambientLight.b);
                          const F = P._splitLights[c.kx];
                          for (let b = 0; b < F.length; b++)
                            for (let D = 0; D < 6; D++) {
                              const G =
                                Math.max(
                                  T.lightCubeDir[D].dot(F[b]._direction),
                                  0
                                ) * F[b]._intensity;
                              (M[D * 3] += F[b]._color.r * G),
                                (M[D * 3 + 1] += F[b]._color.g * G),
                                (M[D * 3 + 2] += F[b]._color.b * G);
                            }
                        }
                        T.constantLightCube.setValue(M);
                      }
                      if (!g.paused) {
                        if (
                          ((T.simTime += e),
                          T.simTime > T.fixedTimeStep &&
                            ((r = Math.floor(T.simTime / T.fixedTimeStep)),
                            (T.simTime -= r * T.fixedTimeStep)),
                          r)
                        ) {
                          r = Math.min(r, T.maxSubSteps);
                          for (let E = 0; E < r; E++)
                            T.addTime(T.fixedTimeStep, !1);
                          (u._updatesPerFrame += r),
                            (u._frameTime += T._addTimeTime),
                            (T._addTimeTime = 0);
                        }
                        T.finishFrame();
                      }
                    }
                  }
              }
              onBeforeRemove(e, t) {
                t.onBeforeRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            h.u._buildAccessors(s.r.prototype, n);
          },
          972: (xe, V, a) => {
            "use strict";
            a.d(V, { S: () => x });
            var A = a(8976);
            class x extends A.J {
              constructor() {
                super(),
                  (this.anim = void 0),
                  (this.animation = void 0),
                  (this.audiolistener = void 0),
                  (this.audiosource = void 0),
                  (this.button = void 0),
                  (this.camera = void 0),
                  (this.collision = void 0),
                  (this.element = void 0),
                  (this.joint = void 0),
                  (this.layoutchild = void 0),
                  (this.layoutgroup = void 0),
                  (this.light = void 0),
                  (this.model = void 0),
                  (this.particlesystem = void 0),
                  (this.render = void 0),
                  (this.rigidbody = void 0),
                  (this.screen = void 0),
                  (this.script = void 0),
                  (this.scrollbar = void 0),
                  (this.scrollview = void 0),
                  (this.sound = void 0),
                  (this.sprite = void 0),
                  (this.zone = void 0),
                  (this.list = []);
              }
              add(c) {
                const d = c.id;
                if (this[d])
                  throw new Error(
                    `ComponentSystem name '${d}' already registered or not allowed`
                  );
                (this[d] = c), this.list.push(c);
              }
              remove(c) {
                const d = c.id;
                if (!this[d])
                  throw new Error(`No ComponentSystem named '${d}' registered`);
                delete this[d];
                const h = this.list.indexOf(this[d]);
                h !== -1 && this.list.splice(h, 1);
              }
              destroy() {
                this.off();
                for (let c = 0; c < this.list.length; c++)
                  this.list[c].destroy();
              }
            }
          },
          8103: (xe, V, a) => {
            "use strict";
            a.d(V, { y: () => i });
            var A = a(9391),
              x = a(5041),
              y = a(3637),
              c = a(6414),
              d = a(8531),
              h = a(3035),
              f = a(5506),
              s = a(3953),
              l = a(3029),
              n = a(4124),
              o = a(1657);
            class i extends n.u {
              constructor(t, r) {
                super(t, r),
                  (this._type = "asset"),
                  (this._castShadows = !0),
                  (this._receiveShadows = !0),
                  (this._castShadowsLightmap = !0),
                  (this._lightmapped = !1),
                  (this._lightmapSizeMultiplier = 1),
                  (this.isStatic = !1),
                  (this._batchGroupId = -1),
                  (this._layers = [A.uE]),
                  (this._renderStyle = A.OZ),
                  (this._meshInstances = []),
                  (this._customAabb = null),
                  (this._area = null),
                  (this._assetReference = []),
                  (this._materialReferences = []),
                  (this._material = void 0),
                  (this._rootBone = void 0),
                  (this._rootBone = new o.D(this, "rootBone")),
                  this._rootBone.on("set:entity", this._onSetRootBone, this),
                  (this._assetReference = new l.Y(
                    "asset",
                    this,
                    t.app.assets,
                    {
                      add: this._onRenderAssetAdded,
                      load: this._onRenderAssetLoad,
                      remove: this._onRenderAssetRemove,
                      unload: this._onRenderAssetUnload,
                    },
                    this
                  )),
                  (this._material = t.defaultMaterial),
                  r.on("remove", this.onRemoveChild, this),
                  r.on("removehierarchy", this.onRemoveChild, this),
                  r.on("insert", this.onInsertChild, this),
                  r.on("inserthierarchy", this.onInsertChild, this);
              }
              set renderStyle(t) {
                this._renderStyle !== t &&
                  ((this._renderStyle = t),
                  y.F._prepareRenderStyleForArray(this._meshInstances, t));
              }
              get renderStyle() {
                return this._renderStyle;
              }
              set customAabb(t) {
                this._customAabb = t;
                const r = this._meshInstances;
                if (r)
                  for (let u = 0; u < r.length; u++)
                    r[u].setCustomAabb(this._customAabb);
              }
              get customAabb() {
                return this._customAabb;
              }
              set type(t) {
                if (
                  this._type !== t &&
                  ((this._area = null),
                  (this._type = t),
                  this.destroyMeshInstances(),
                  t !== "asset")
                ) {
                  let r = this._material;
                  (!r || r === this.system.defaultMaterial) &&
                    (r =
                      this._materialReferences[0] &&
                      this._materialReferences[0].asset &&
                      this._materialReferences[0].asset.resource);
                  const u = (0, d.LT)(this.system.app.graphicsDevice, t);
                  (this._area = u.area),
                    (this.meshInstances = [
                      new y.F(
                        u.mesh,
                        r || this.system.defaultMaterial,
                        this.entity
                      ),
                    ]);
                }
              }
              get type() {
                return this._type;
              }
              set meshInstances(t) {
                if (
                  (this.destroyMeshInstances(),
                  (this._meshInstances = t),
                  this._meshInstances)
                ) {
                  const r = this._meshInstances;
                  for (let u = 0; u < r.length; u++)
                    r[u].node || (r[u].node = this.entity),
                      (r[u].castShadow = this._castShadows),
                      (r[u].receiveShadow = this._receiveShadows),
                      (r[u].renderStyle = this._renderStyle),
                      r[u].setLightmapped(this._lightmapped),
                      r[u].setCustomAabb(this._customAabb);
                  this.enabled && this.entity.enabled && this.addToLayers();
                }
              }
              get meshInstances() {
                return this._meshInstances;
              }
              set lightmapped(t) {
                if (t !== this._lightmapped) {
                  this._lightmapped = t;
                  const r = this._meshInstances;
                  if (r)
                    for (let u = 0; u < r.length; u++) r[u].setLightmapped(t);
                }
              }
              get lightmapped() {
                return this._lightmapped;
              }
              set castShadows(t) {
                if (this._castShadows !== t) {
                  const r = this._meshInstances;
                  if (r) {
                    const u = this.layers,
                      v = this.system.app.scene;
                    if (this._castShadows && !t)
                      for (let _ = 0; _ < u.length; _++) {
                        const m = v.layers.getLayerById(this.layers[_]);
                        m && m.removeShadowCasters(r);
                      }
                    for (let _ = 0; _ < r.length; _++) r[_].castShadow = t;
                    if (!this._castShadows && t)
                      for (let _ = 0; _ < u.length; _++) {
                        const m = v.layers.getLayerById(u[_]);
                        m && m.addShadowCasters(r);
                      }
                  }
                  this._castShadows = t;
                }
              }
              get castShadows() {
                return this._castShadows;
              }
              set receiveShadows(t) {
                if (this._receiveShadows !== t) {
                  this._receiveShadows = t;
                  const r = this._meshInstances;
                  if (r)
                    for (let u = 0; u < r.length; u++) r[u].receiveShadow = t;
                }
              }
              get receiveShadows() {
                return this._receiveShadows;
              }
              set castShadowsLightmap(t) {
                this._castShadowsLightmap = t;
              }
              get castShadowsLightmap() {
                return this._castShadowsLightmap;
              }
              set lightmapSizeMultiplier(t) {
                this._lightmapSizeMultiplier = t;
              }
              get lightmapSizeMultiplier() {
                return this._lightmapSizeMultiplier;
              }
              set layers(t) {
                const r = this.system.app.scene.layers;
                let u;
                if (this._meshInstances)
                  for (let v = 0; v < this._layers.length; v++)
                    (u = r.getLayerById(this._layers[v])),
                      u && u.removeMeshInstances(this._meshInstances);
                this._layers.length = 0;
                for (let v = 0; v < t.length; v++) this._layers[v] = t[v];
                if (
                  !(
                    !this.enabled ||
                    !this.entity.enabled ||
                    !this._meshInstances
                  )
                )
                  for (let v = 0; v < this._layers.length; v++)
                    (u = r.getLayerById(this._layers[v])),
                      u && u.addMeshInstances(this._meshInstances);
              }
              get layers() {
                return this._layers;
              }
              set batchGroupId(t) {
                if (this._batchGroupId !== t) {
                  if (this.entity.enabled && this._batchGroupId >= 0) {
                    var r;
                    (r = this.system.app.batcher) == null ||
                      r.remove(x.w.RENDER, this.batchGroupId, this.entity);
                  }
                  if (this.entity.enabled && t >= 0) {
                    var u;
                    (u = this.system.app.batcher) == null ||
                      u.insert(x.w.RENDER, t, this.entity);
                  }
                  t < 0 &&
                    this._batchGroupId >= 0 &&
                    this.enabled &&
                    this.entity.enabled &&
                    this.addToLayers(),
                    (this._batchGroupId = t);
                }
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set material(t) {
                if (
                  this._material !== t &&
                  ((this._material = t),
                  this._meshInstances && this._type !== "asset")
                )
                  for (let r = 0; r < this._meshInstances.length; r++)
                    this._meshInstances[r].material = t;
              }
              get material() {
                return this._material;
              }
              set materialAssets(t = []) {
                if (this._materialReferences.length > t.length) {
                  for (
                    let r = t.length;
                    r < this._materialReferences.length;
                    r++
                  )
                    this._materialReferences[r].id = null;
                  this._materialReferences.length = t.length;
                }
                for (let r = 0; r < t.length; r++)
                  if (
                    (this._materialReferences[r] ||
                      this._materialReferences.push(
                        new l.Y(
                          r,
                          this,
                          this.system.app.assets,
                          {
                            add: this._onMaterialAdded,
                            load: this._onMaterialLoad,
                            remove: this._onMaterialRemove,
                            unload: this._onMaterialUnload,
                          },
                          this
                        )
                      ),
                    t[r])
                  ) {
                    const u = t[r] instanceof s.V ? t[r].id : t[r];
                    this._materialReferences[r].id !== u &&
                      (this._materialReferences[r].id = u),
                      this._materialReferences[r].asset &&
                        this._onMaterialAdded(
                          r,
                          this,
                          this._materialReferences[r].asset
                        );
                  } else
                    (this._materialReferences[r].id = null),
                      this._meshInstances[r] &&
                        (this._meshInstances[r].material =
                          this.system.defaultMaterial);
              }
              get materialAssets() {
                return this._materialReferences.map(function (t) {
                  return t.id;
                });
              }
              set asset(t) {
                const r = t instanceof s.V ? t.id : t;
                this._assetReference.id !== r &&
                  (this._assetReference.asset &&
                    this._assetReference.asset.resource &&
                    this._onRenderAssetRemove(),
                  (this._assetReference.id = r),
                  this._assetReference.asset && this._onRenderAssetAdded());
              }
              get asset() {
                return this._assetReference.id;
              }
              assignAsset(t) {
                const r = t instanceof s.V ? t.id : t;
                this._assetReference.id = r;
              }
              _onSetRootBone(t) {
                t && this._onRootBoneChanged();
              }
              _onRootBoneChanged() {
                this._clearSkinInstances(),
                  this.enabled &&
                    this.entity.enabled &&
                    this._cloneSkinInstances();
              }
              destroyMeshInstances() {
                const t = this._meshInstances;
                if (t) {
                  this.removeFromLayers(), this._clearSkinInstances();
                  for (let r = 0; r < t.length; r++) t[r].destroy();
                  this._meshInstances.length = 0;
                }
              }
              addToLayers() {
                const t = this.system.app.scene.layers;
                for (let r = 0; r < this._layers.length; r++) {
                  const u = t.getLayerById(this._layers[r]);
                  u && u.addMeshInstances(this._meshInstances);
                }
              }
              removeFromLayers() {
                if (this._meshInstances && this._meshInstances.length) {
                  const t = this.system.app.scene.layers;
                  for (let r = 0; r < this._layers.length; r++) {
                    const u = t.getLayerById(this._layers[r]);
                    u && u.removeMeshInstances(this._meshInstances);
                  }
                }
              }
              onRemoveChild() {
                this.removeFromLayers();
              }
              onInsertChild() {
                this._meshInstances &&
                  this.enabled &&
                  this.entity.enabled &&
                  this.addToLayers();
              }
              onRemove() {
                this.destroyMeshInstances(),
                  (this.asset = null),
                  (this.materialAsset = null),
                  (this._assetReference.id = null);
                for (let t = 0; t < this._materialReferences.length; t++)
                  this._materialReferences[t].id = null;
                this.entity.off("remove", this.onRemoveChild, this),
                  this.entity.off("insert", this.onInsertChild, this);
              }
              onLayersChanged(t, r) {
                this.addToLayers(),
                  t.off("add", this.onLayerAdded, this),
                  t.off("remove", this.onLayerRemoved, this),
                  r.on("add", this.onLayerAdded, this),
                  r.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(t) {
                this.layers.indexOf(t.id) < 0 ||
                  t.addMeshInstances(this._meshInstances);
              }
              onLayerRemoved(t) {
                this.layers.indexOf(t.id) < 0 ||
                  t.removeMeshInstances(this._meshInstances);
              }
              onEnable() {
                const t = this.system.app,
                  r = t.scene;
                this._rootBone.onParentComponentEnable(),
                  this._cloneSkinInstances(),
                  r.on("set:layers", this.onLayersChanged, this),
                  r.layers &&
                    (r.layers.on("add", this.onLayerAdded, this),
                    r.layers.on("remove", this.onLayerRemoved, this));
                const u = this._type === "asset";
                this._meshInstances && this._meshInstances.length
                  ? this.addToLayers()
                  : u && this.asset && this._onRenderAssetAdded();
                for (let _ = 0; _ < this._materialReferences.length; _++)
                  this._materialReferences[_].asset &&
                    this.system.app.assets.load(
                      this._materialReferences[_].asset
                    );
                if (this._batchGroupId >= 0) {
                  var v;
                  (v = t.batcher) == null ||
                    v.insert(x.w.RENDER, this.batchGroupId, this.entity);
                }
              }
              onDisable() {
                const t = this.system.app,
                  r = t.scene;
                if (
                  (r.off("set:layers", this.onLayersChanged, this),
                  r.layers &&
                    (r.layers.off("add", this.onLayerAdded, this),
                    r.layers.off("remove", this.onLayerRemoved, this)),
                  this._batchGroupId >= 0)
                ) {
                  var u;
                  (u = t.batcher) == null ||
                    u.remove(x.w.RENDER, this.batchGroupId, this.entity);
                }
                this.removeFromLayers();
              }
              hide() {
                if (this._meshInstances)
                  for (let t = 0; t < this._meshInstances.length; t++)
                    this._meshInstances[t].visible = !1;
              }
              show() {
                if (this._meshInstances)
                  for (let t = 0; t < this._meshInstances.length; t++)
                    this._meshInstances[t].visible = !0;
              }
              _onRenderAssetAdded() {
                this._assetReference.asset &&
                  (this._assetReference.asset.resource
                    ? this._onRenderAssetLoad()
                    : this.enabled &&
                      this.entity.enabled &&
                      this.system.app.assets.load(this._assetReference.asset));
              }
              _onRenderAssetLoad() {
                if ((this.destroyMeshInstances(), this._assetReference.asset)) {
                  const t = this._assetReference.asset.resource;
                  t.off("set:meshes", this._onSetMeshes, this),
                    t.on("set:meshes", this._onSetMeshes, this),
                    t.meshes && this._onSetMeshes(t.meshes);
                }
              }
              _onSetMeshes(t) {
                this._cloneMeshes(t);
              }
              _clearSkinInstances() {
                for (let t = 0; t < this._meshInstances.length; t++) {
                  const r = this._meshInstances[t];
                  f.b.removeCachedSkinInstance(r.skinInstance),
                    (r.skinInstance = null);
                }
              }
              _cloneSkinInstances() {
                if (
                  this._meshInstances.length &&
                  this._rootBone.entity instanceof h.t
                )
                  for (let t = 0; t < this._meshInstances.length; t++) {
                    const r = this._meshInstances[t],
                      u = r.mesh;
                    u.skin &&
                      !r.skinInstance &&
                      (r.skinInstance = f.b.createCachedSkinInstance(
                        u.skin,
                        this._rootBone.entity,
                        this.entity
                      ));
                  }
              }
              _cloneMeshes(t) {
                if (t && t.length) {
                  const r = [];
                  for (let u = 0; u < t.length; u++) {
                    const v = t[u],
                      _ =
                        this._materialReferences[u] &&
                        this._materialReferences[u].asset &&
                        this._materialReferences[u].asset.resource,
                      m = new y.F(
                        v,
                        _ || this.system.defaultMaterial,
                        this.entity
                      );
                    r.push(m), v.morph && (m.morphInstance = new c.q(v.morph));
                  }
                  (this.meshInstances = r), this._cloneSkinInstances();
                }
              }
              _onRenderAssetUnload() {
                this._type === "asset" && this.destroyMeshInstances();
              }
              _onRenderAssetRemove() {
                this._assetReference.asset &&
                  this._assetReference.asset.resource &&
                  this._assetReference.asset.resource.off(
                    "set:meshes",
                    this._onSetMeshes,
                    this
                  ),
                  this._onRenderAssetUnload();
              }
              _onMaterialAdded(t, r, u) {
                u.resource
                  ? this._onMaterialLoad(t, r, u)
                  : this.enabled &&
                    this.entity.enabled &&
                    this.system.app.assets.load(u);
              }
              _updateMainMaterial(t, r) {
                t === 0 && (this.material = r);
              }
              _onMaterialLoad(t, r, u) {
                this._meshInstances[t] &&
                  (this._meshInstances[t].material = u.resource),
                  this._updateMainMaterial(t, u.resource);
              }
              _onMaterialRemove(t, r, u) {
                this._meshInstances[t] &&
                  (this._meshInstances[t].material =
                    this.system.defaultMaterial),
                  this._updateMainMaterial(t, this.system.defaultMaterial);
              }
              _onMaterialUnload(t, r, u) {
                this._meshInstances[t] &&
                  (this._meshInstances[t].material =
                    this.system.defaultMaterial),
                  this._updateMainMaterial(t, this.system.defaultMaterial);
              }
              resolveDuplicatedEntityReferenceProperties(t, r) {
                t.rootBone && r[t.rootBone] && (this.rootBone = r[t.rootBone]),
                  this._clearSkinInstances();
              }
            }
          },
          5080: (xe, V, a) => {
            "use strict";
            a.d(V, { J: () => n });
            var A = a(7481),
              x = a(7915),
              y = a(1594),
              c = a(4124),
              d = a(2930),
              h = a(8103);
            class f {
              constructor() {
                (this.enabled = !0), (this.rootBone = null);
              }
            }
            const s = [{ name: "rootBone", type: "entity" }, "enabled"],
              l = [
                "material",
                "meshInstances",
                "asset",
                "materialAssets",
                "castShadows",
                "receiveShadows",
                "castShadowsLightmap",
                "lightmapped",
                "lightmapSizeMultiplier",
                "renderStyle",
                "type",
                "layers",
                "isStatic",
                "batchGroupId",
              ];
            class n extends d.r {
              constructor(i) {
                super(i),
                  (this.id = "render"),
                  (this.ComponentType = h.y),
                  (this.DataType = f),
                  (this.schema = s),
                  (this.defaultMaterial = (0, y.h)(i.graphicsDevice)),
                  this.on("beforeremove", this.onRemove, this);
              }
              initializeComponentData(i, e, t) {
                (e.batchGroupId === null || e.batchGroupId === void 0) &&
                  (e.batchGroupId = -1),
                  e.layers && e.layers.length && (e.layers = e.layers.slice(0));
                for (let r = 0; r < l.length; r++)
                  e.hasOwnProperty(l[r]) && (i[l[r]] = e[l[r]]);
                e.aabbCenter &&
                  e.aabbHalfExtents &&
                  (i.customAabb = new x.I(
                    new A.e(e.aabbCenter),
                    new A.e(e.aabbHalfExtents)
                  )),
                  super.initializeComponentData(i, e, s);
              }
              cloneComponent(i, e) {
                const t = {};
                for (let _ = 0; _ < l.length; _++) t[l[_]] = i.render[l[_]];
                (t.enabled = i.render.enabled), delete t.meshInstances;
                const r = this.addComponent(e, t),
                  u = i.render.meshInstances,
                  v = u.map((_) => _.mesh);
                r._onSetMeshes(v);
                for (let _ = 0; _ < u.length; _++)
                  r.meshInstances[_].material = u[_].material;
                return (
                  i.render.customAabb &&
                    (r.customAabb = i.render.customAabb.clone()),
                  r
                );
              }
              onRemove(i, e) {
                e.onRemove();
              }
            }
            c.u._buildAccessors(h.y.prototype, s);
          },
          6225: (xe, V, a) => {
            "use strict";
            a.d(V, { H: () => i });
            var A = a(3021),
              x = a(7481),
              y = a(8379),
              c = a(4124);
            let d, h, f, s;
            const l = new A.k(),
              n = new A.k(),
              o = new x.e();
            class i extends c.u {
              constructor(t, r) {
                super(t, r),
                  (this._angularDamping = 0),
                  (this._angularFactor = new x.e(1, 1, 1)),
                  (this._angularVelocity = new x.e()),
                  (this._body = null),
                  (this._friction = 0.5),
                  (this._group = y.JV),
                  (this._linearDamping = 0),
                  (this._linearFactor = new x.e(1, 1, 1)),
                  (this._linearVelocity = new x.e()),
                  (this._mask = y.EE),
                  (this._mass = 1),
                  (this._restitution = 0),
                  (this._rollingFriction = 0),
                  (this._simulationEnabled = !1),
                  (this._type = y.I3);
              }
              static onLibraryLoaded() {
                typeof Ammo != "undefined" &&
                  ((d = new Ammo.btTransform()),
                  (h = new Ammo.btVector3()),
                  (f = new Ammo.btVector3()),
                  (s = new Ammo.btQuaternion()));
              }
              set angularDamping(t) {
                this._angularDamping !== t &&
                  ((this._angularDamping = t),
                  this._body && this._body.setDamping(this._linearDamping, t));
              }
              get angularDamping() {
                return this._angularDamping;
              }
              set angularFactor(t) {
                this._angularFactor.equals(t) ||
                  (this._angularFactor.copy(t),
                  this._body &&
                    this._type === y.DA &&
                    (h.setValue(t.x, t.y, t.z),
                    this._body.setAngularFactor(h)));
              }
              get angularFactor() {
                return this._angularFactor;
              }
              set angularVelocity(t) {
                this._body &&
                  this._type === y.DA &&
                  (this._body.activate(),
                  h.setValue(t.x, t.y, t.z),
                  this._body.setAngularVelocity(h),
                  this._angularVelocity.copy(t));
              }
              get angularVelocity() {
                if (this._body && this._type === y.DA) {
                  const t = this._body.getAngularVelocity();
                  this._angularVelocity.set(t.x(), t.y(), t.z());
                }
                return this._angularVelocity;
              }
              set body(t) {
                this._body !== t &&
                  ((this._body = t),
                  t && this._simulationEnabled && t.activate());
              }
              get body() {
                return this._body;
              }
              set friction(t) {
                this._friction !== t &&
                  ((this._friction = t),
                  this._body && this._body.setFriction(t));
              }
              get friction() {
                return this._friction;
              }
              set group(t) {
                this._group !== t &&
                  ((this._group = t),
                  this.enabled &&
                    this.entity.enabled &&
                    (this.disableSimulation(), this.enableSimulation()));
              }
              get group() {
                return this._group;
              }
              set linearDamping(t) {
                this._linearDamping !== t &&
                  ((this._linearDamping = t),
                  this._body && this._body.setDamping(t, this._angularDamping));
              }
              get linearDamping() {
                return this._linearDamping;
              }
              set linearFactor(t) {
                this._linearFactor.equals(t) ||
                  (this._linearFactor.copy(t),
                  this._body &&
                    this._type === y.DA &&
                    (h.setValue(t.x, t.y, t.z), this._body.setLinearFactor(h)));
              }
              get linearFactor() {
                return this._linearFactor;
              }
              set linearVelocity(t) {
                this._body &&
                  this._type === y.DA &&
                  (this._body.activate(),
                  h.setValue(t.x, t.y, t.z),
                  this._body.setLinearVelocity(h),
                  this._linearVelocity.copy(t));
              }
              get linearVelocity() {
                if (this._body && this._type === y.DA) {
                  const t = this._body.getLinearVelocity();
                  this._linearVelocity.set(t.x(), t.y(), t.z());
                }
                return this._linearVelocity;
              }
              set mask(t) {
                this._mask !== t &&
                  ((this._mask = t),
                  this.enabled &&
                    this.entity.enabled &&
                    (this.disableSimulation(), this.enableSimulation()));
              }
              get mask() {
                return this._mask;
              }
              set mass(t) {
                if (
                  this._mass !== t &&
                  ((this._mass = t), this._body && this._type === y.DA)
                ) {
                  const r = this.enabled && this.entity.enabled;
                  r && this.disableSimulation(),
                    this._body.getCollisionShape().calculateLocalInertia(t, h),
                    this._body.setMassProps(t, h),
                    this._body.updateInertiaTensor(),
                    r && this.enableSimulation();
                }
              }
              get mass() {
                return this._mass;
              }
              set restitution(t) {
                this._restitution !== t &&
                  ((this._restitution = t),
                  this._body && this._body.setRestitution(t));
              }
              get restitution() {
                return this._restitution;
              }
              set rollingFriction(t) {
                this._rollingFriction !== t &&
                  ((this._rollingFriction = t),
                  this._body && this._body.setRollingFriction(t));
              }
              get rollingFriction() {
                return this._rollingFriction;
              }
              set type(t) {
                if (this._type !== t) {
                  switch (((this._type = t), this.disableSimulation(), t)) {
                    case y.DA:
                      (this._group = y.Um), (this._mask = y.DD);
                      break;
                    case y.LY:
                      (this._group = y.qX), (this._mask = y.DD);
                      break;
                    case y.I3:
                    default:
                      (this._group = y.JV), (this._mask = y.EE);
                      break;
                  }
                  this.createBody();
                }
              }
              get type() {
                return this._type;
              }
              createBody() {
                const t = this.entity;
                let r;
                if (
                  (t.collision &&
                    ((r = t.collision.shape),
                    t.trigger && (t.trigger.destroy(), delete t.trigger)),
                  r)
                ) {
                  this._body && this.system.onRemove(t, this);
                  const u = this._type === y.DA ? this._mass : 0;
                  this._getEntityTransform(d);
                  const v = this.system.createBody(u, r, d);
                  if (
                    (v.setRestitution(this._restitution),
                    v.setFriction(this._friction),
                    v.setRollingFriction(this._rollingFriction),
                    v.setDamping(this._linearDamping, this._angularDamping),
                    this._type === y.DA)
                  ) {
                    const _ = this._linearFactor;
                    h.setValue(_.x, _.y, _.z), v.setLinearFactor(h);
                    const m = this._angularFactor;
                    h.setValue(m.x, m.y, m.z), v.setAngularFactor(h);
                  } else
                    this._type === y.LY &&
                      (v.setCollisionFlags(v.getCollisionFlags() | y.Fm),
                      v.setActivationState(y.dC));
                  (v.entity = t),
                    (this.body = v),
                    this.enabled && t.enabled && this.enableSimulation();
                }
              }
              isActive() {
                return this._body ? this._body.isActive() : !1;
              }
              activate() {
                this._body && this._body.activate();
              }
              enableSimulation() {
                const t = this.entity;
                if (
                  t.collision &&
                  t.collision.enabled &&
                  !this._simulationEnabled
                ) {
                  const r = this._body;
                  if (r) {
                    switch (
                      (this.system.addBody(r, this._group, this._mask),
                      this._type)
                    ) {
                      case y.DA:
                        this.system._dynamic.push(this),
                          r.forceActivationState(y.UQ),
                          this.syncEntityToBody();
                        break;
                      case y.LY:
                        this.system._kinematic.push(this),
                          r.forceActivationState(y.dC);
                        break;
                      case y.I3:
                        r.forceActivationState(y.UQ), this.syncEntityToBody();
                        break;
                    }
                    t.collision.type === "compound" &&
                      this.system._compounds.push(t.collision),
                      r.activate(),
                      (this._simulationEnabled = !0);
                  }
                }
              }
              disableSimulation() {
                const t = this._body;
                if (t && this._simulationEnabled) {
                  const r = this.system;
                  let u = r._compounds.indexOf(this.entity.collision);
                  u > -1 && r._compounds.splice(u, 1),
                    (u = r._dynamic.indexOf(this)),
                    u > -1 && r._dynamic.splice(u, 1),
                    (u = r._kinematic.indexOf(this)),
                    u > -1 && r._kinematic.splice(u, 1),
                    r.removeBody(t),
                    t.forceActivationState(y.$5),
                    (this._simulationEnabled = !1);
                }
              }
              applyForce(t, r, u, v, _, m) {
                const g = this._body;
                g &&
                  (g.activate(),
                  t instanceof x.e
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  r instanceof x.e
                    ? f.setValue(r.x, r.y, r.z)
                    : v !== void 0
                    ? f.setValue(v, _, m)
                    : f.setValue(0, 0, 0),
                  g.applyForce(h, f));
              }
              applyTorque(t, r, u) {
                const v = this._body;
                v &&
                  (v.activate(),
                  t instanceof x.e
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  v.applyTorque(h));
              }
              applyImpulse(t, r, u, v, _, m) {
                const g = this._body;
                g &&
                  (g.activate(),
                  t instanceof x.e
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  r instanceof x.e
                    ? f.setValue(r.x, r.y, r.z)
                    : v !== void 0
                    ? f.setValue(v, _, m)
                    : f.setValue(0, 0, 0),
                  g.applyImpulse(h, f));
              }
              applyTorqueImpulse(t, r, u) {
                const v = this._body;
                v &&
                  (v.activate(),
                  t instanceof x.e
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  v.applyTorqueImpulse(h));
              }
              isStatic() {
                return this._type === y.I3;
              }
              isStaticOrKinematic() {
                return this._type === y.I3 || this._type === y.LY;
              }
              isKinematic() {
                return this._type === y.LY;
              }
              _getEntityTransform(t) {
                const r = this.entity,
                  u = r.collision;
                if (u) {
                  const v = u.getShapePosition(),
                    _ = u.getShapeRotation();
                  h.setValue(v.x, v.y, v.z), s.setValue(_.x, _.y, _.z, _.w);
                } else {
                  const v = r.getPosition(),
                    _ = r.getRotation();
                  h.setValue(v.x, v.y, v.z), s.setValue(_.x, _.y, _.z, _.w);
                }
                t.setOrigin(h), t.setRotation(s);
              }
              syncEntityToBody() {
                const t = this._body;
                if (t) {
                  if (
                    (this._getEntityTransform(d),
                    t.setWorldTransform(d),
                    this._type === y.LY)
                  ) {
                    const r = t.getMotionState();
                    r && r.setWorldTransform(d);
                  }
                  t.activate();
                }
              }
              _updateDynamic() {
                const t = this._body;
                if (t.isActive()) {
                  const r = t.getMotionState();
                  if (r) {
                    const u = this.entity;
                    r.getWorldTransform(d);
                    const v = d.getOrigin(),
                      _ = d.getRotation(),
                      m = u.collision;
                    if (m && m._hasOffset) {
                      const g = m.data.linearOffset,
                        T = m.data.angularOffset,
                        E = n.copy(T).invert(),
                        M = l.set(_.x(), _.y(), _.z(), _.w()).mul(E);
                      M.transformVector(g, o),
                        u.setPosition(v.x() - o.x, v.y() - o.y, v.z() - o.z),
                        u.setRotation(M);
                    } else
                      u.setPosition(v.x(), v.y(), v.z()),
                        u.setRotation(_.x(), _.y(), _.z(), _.w());
                  }
                }
              }
              _updateKinematic() {
                const t = this._body.getMotionState();
                t && (this._getEntityTransform(d), t.setWorldTransform(d));
              }
              teleport(t, r, u, v, _, m) {
                t instanceof x.e
                  ? this.entity.setPosition(t)
                  : this.entity.setPosition(t, r, u),
                  r instanceof A.k
                    ? this.entity.setRotation(r)
                    : r instanceof x.e
                    ? this.entity.setEulerAngles(r)
                    : v !== void 0 && this.entity.setEulerAngles(v, _, m),
                  this.syncEntityToBody();
              }
              onEnable() {
                this._body || this.createBody(), this.enableSimulation();
              }
              onDisable() {
                this.disableSimulation();
              }
            }
          },
          8379: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $5: () => o,
              DA: () => x,
              DD: () => X,
              EE: () => Q,
              Er: () => te,
              Fm: () => d,
              I3: () => A,
              JV: () => r,
              LY: () => y,
              N6: () => g,
              NH: () => i,
              UQ: () => f,
              Uh: () => G,
              Um: () => t,
              ce: () => h,
              cn: () => ie,
              dC: () => n,
              iU: () => b,
              k: () => T,
              kp: () => l,
              lB: () => _,
              md: () => e,
              oo: () => s,
              qX: () => u,
              r3: () => D,
              rO: () => E,
              rU: () => F,
              rz: () => R,
              s8: () => m,
              uU: () => c,
              yb: () => P,
              yq: () => M,
              zK: () => v,
            });
            const A = "static",
              x = "dynamic",
              y = "kinematic",
              c = 1,
              d = 2,
              h = 4,
              f = 1,
              s = 2,
              l = 3,
              n = 4,
              o = 5,
              i = 0,
              e = 1,
              t = 1,
              r = 2,
              u = 4,
              v = 8,
              _ = 16,
              m = 32,
              g = 64,
              T = 128,
              E = 256,
              M = 512,
              R = 1024,
              P = 2048,
              F = 4096,
              b = 8192,
              D = 16384,
              G = 0,
              X = 65535,
              ie = 2,
              Q = 65533,
              te = 65529;
          },
          1849: (xe, V, a) => {
            "use strict";
            a.d(V, {
              z8: () => i,
              Ic: () => e,
              DL: () => n,
              K1: () => r,
              KT: () => o,
            });
            class A {
              constructor(v, _) {
                (this._pool = []),
                  (this._count = 0),
                  (this._constructor = v),
                  this._resize(_);
              }
              _resize(v) {
                if (v > this._pool.length)
                  for (let _ = this._pool.length; _ < v; _++)
                    this._pool[_] = new this._constructor();
              }
              allocate() {
                return (
                  this._count >= this._pool.length &&
                    this._resize(this._pool.length * 2),
                  this._pool[this._count++]
                );
              }
              freeAll() {
                this._count = 0;
              }
            }
            var x = a(7481),
              y = a(4124),
              c = a(2930),
              d = a(8379),
              h = a(6225);
            class f {
              constructor() {
                this.enabled = !0;
              }
            }
            let s, l;
            class n {
              constructor(v, _, m, g) {
                (this.entity = v),
                  (this.point = _),
                  (this.normal = m),
                  (this.hitFraction = g);
              }
            }
            class o {
              constructor(v, _, m) {
                arguments.length === 0
                  ? ((this.a = null),
                    (this.b = null),
                    (this.impulse = 0),
                    (this.localPointA = new x.e()),
                    (this.localPointB = new x.e()),
                    (this.pointA = new x.e()),
                    (this.pointB = new x.e()),
                    (this.normal = new x.e()))
                  : ((this.a = v),
                    (this.b = _),
                    (this.impulse = m.impulse),
                    (this.localPointA = m.localPoint),
                    (this.localPointB = m.localPointOther),
                    (this.pointA = m.point),
                    (this.pointB = m.pointOther),
                    (this.normal = m.normal));
              }
            }
            class i {
              constructor(
                v = new x.e(),
                _ = new x.e(),
                m = new x.e(),
                g = new x.e(),
                T = new x.e(),
                E = 0
              ) {
                (this.localPoint = v),
                  (this.localPointOther = _),
                  (this.point = m),
                  (this.pointOther = g),
                  (this.normal = T),
                  (this.impulse = E);
              }
            }
            class e {
              constructor(v, _) {
                (this.other = v), (this.contacts = _);
              }
            }
            const t = ["enabled"];
            class r extends c.r {
              constructor(v) {
                super(v),
                  (this.maxSubSteps = 10),
                  (this.fixedTimeStep = 0.016666666666666666),
                  (this.gravity = new x.e(0, -9.81, 0)),
                  (this._gravityFloat32 = new Float32Array(3)),
                  (this._dynamic = []),
                  (this._kinematic = []),
                  (this._triggers = []),
                  (this._compounds = []),
                  (this.id = "rigidbody"),
                  (this._stats = v.stats.frame),
                  (this.ComponentType = h.H),
                  (this.DataType = f),
                  (this.contactPointPool = null),
                  (this.contactResultPool = null),
                  (this.singleContactResultPool = null),
                  (this.schema = t),
                  (this.collisions = {}),
                  (this.frameCollisions = {}),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.on("remove", this.onRemove, this);
              }
              onLibraryLoaded() {
                if (typeof Ammo != "undefined") {
                  if (
                    ((this.collisionConfiguration =
                      new Ammo.btDefaultCollisionConfiguration()),
                    (this.dispatcher = new Ammo.btCollisionDispatcher(
                      this.collisionConfiguration
                    )),
                    (this.overlappingPairCache = new Ammo.btDbvtBroadphase()),
                    (this.solver =
                      new Ammo.btSequentialImpulseConstraintSolver()),
                    (this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(
                      this.dispatcher,
                      this.overlappingPairCache,
                      this.solver,
                      this.collisionConfiguration
                    )),
                    this.dynamicsWorld.setInternalTickCallback)
                  ) {
                    const v = Ammo.addFunction(
                      this._checkForCollisions.bind(this),
                      "vif"
                    );
                    this.dynamicsWorld.setInternalTickCallback(v);
                  }
                  (s = new Ammo.btVector3()),
                    (l = new Ammo.btVector3()),
                    h.H.onLibraryLoaded(),
                    (this.contactPointPool = new A(i, 1)),
                    (this.contactResultPool = new A(e, 1)),
                    (this.singleContactResultPool = new A(o, 1)),
                    this.app.systems.on("update", this.onUpdate, this);
                } else this.app.systems.off("update", this.onUpdate, this);
              }
              initializeComponentData(v, _, m) {
                const g = [
                  "mass",
                  "linearDamping",
                  "angularDamping",
                  "linearFactor",
                  "angularFactor",
                  "friction",
                  "rollingFriction",
                  "restitution",
                  "type",
                  "group",
                  "mask",
                ];
                for (const T of g)
                  if (_.hasOwnProperty(T)) {
                    const E = _[T];
                    Array.isArray(E)
                      ? (v[T] = new x.e(E[0], E[1], E[2]))
                      : (v[T] = E);
                  }
                super.initializeComponentData(v, _, ["enabled"]);
              }
              cloneComponent(v, _) {
                const m = v.rigidbody,
                  g = {
                    enabled: m.enabled,
                    mass: m.mass,
                    linearDamping: m.linearDamping,
                    angularDamping: m.angularDamping,
                    linearFactor: [
                      m.linearFactor.x,
                      m.linearFactor.y,
                      m.linearFactor.z,
                    ],
                    angularFactor: [
                      m.angularFactor.x,
                      m.angularFactor.y,
                      m.angularFactor.z,
                    ],
                    friction: m.friction,
                    rollingFriction: m.rollingFriction,
                    restitution: m.restitution,
                    type: m.type,
                    group: m.group,
                    mask: m.mask,
                  };
                return this.addComponent(_, g);
              }
              onBeforeRemove(v, _) {
                _.enabled && (_.enabled = !1);
              }
              onRemove(v, _) {
                const m = _.body;
                m && (this.removeBody(m), this.destroyBody(m), (_.body = null));
              }
              addBody(v, _, m) {
                _ !== void 0 && m !== void 0
                  ? this.dynamicsWorld.addRigidBody(v, _, m)
                  : this.dynamicsWorld.addRigidBody(v);
              }
              removeBody(v) {
                this.dynamicsWorld.removeRigidBody(v);
              }
              createBody(v, _, m) {
                const g = new Ammo.btVector3(0, 0, 0);
                v !== 0 && _.calculateLocalInertia(v, g);
                const T = new Ammo.btDefaultMotionState(m),
                  E = new Ammo.btRigidBodyConstructionInfo(v, T, _, g),
                  M = new Ammo.btRigidBody(E);
                return Ammo.destroy(E), Ammo.destroy(g), M;
              }
              destroyBody(v) {
                const _ = v.getMotionState();
                _ && Ammo.destroy(_), Ammo.destroy(v);
              }
              raycastFirst(v, _, m = {}) {
                if (m.filterTags || m.filterCallback)
                  return (m.sort = !0), this.raycastAll(v, _, m)[0] || null;
                let g = null;
                s.setValue(v.x, v.y, v.z), l.setValue(_.x, _.y, _.z);
                const T = new Ammo.ClosestRayResultCallback(s, l);
                if (
                  (typeof m.filterCollisionGroup == "number" &&
                    T.set_m_collisionFilterGroup(m.filterCollisionGroup),
                  typeof m.filterCollisionMask == "number" &&
                    T.set_m_collisionFilterMask(m.filterCollisionMask),
                  this.dynamicsWorld.rayTest(s, l, T),
                  T.hasHit())
                ) {
                  const E = T.get_m_collisionObject(),
                    M = Ammo.castObject(E, Ammo.btRigidBody);
                  if (M) {
                    const R = T.get_m_hitPointWorld(),
                      P = T.get_m_hitNormalWorld();
                    g = new n(
                      M.entity,
                      new x.e(R.x(), R.y(), R.z()),
                      new x.e(P.x(), P.y(), P.z()),
                      T.get_m_closestHitFraction()
                    );
                  }
                }
                return Ammo.destroy(T), g;
              }
              raycastAll(v, _, m = {}) {
                const g = [];
                s.setValue(v.x, v.y, v.z), l.setValue(_.x, _.y, _.z);
                const T = new Ammo.AllHitsRayResultCallback(s, l);
                if (
                  (typeof m.filterCollisionGroup == "number" &&
                    T.set_m_collisionFilterGroup(m.filterCollisionGroup),
                  typeof m.filterCollisionMask == "number" &&
                    T.set_m_collisionFilterMask(m.filterCollisionMask),
                  this.dynamicsWorld.rayTest(s, l, T),
                  T.hasHit())
                ) {
                  const E = T.get_m_collisionObjects(),
                    M = T.get_m_hitPointWorld(),
                    R = T.get_m_hitNormalWorld(),
                    P = T.get_m_hitFractions(),
                    F = E.size();
                  for (let b = 0; b < F; b++) {
                    const D = Ammo.castObject(E.at(b), Ammo.btRigidBody);
                    if (D && D.entity) {
                      if (
                        (m.filterTags && !D.entity.tags.has(...m.filterTags)) ||
                        (m.filterCallback && !m.filterCallback(D.entity))
                      )
                        continue;
                      const G = M.at(b),
                        X = R.at(b),
                        ie = new n(
                          D.entity,
                          new x.e(G.x(), G.y(), G.z()),
                          new x.e(X.x(), X.y(), X.z()),
                          P.at(b)
                        );
                      g.push(ie);
                    }
                  }
                  m.sort && g.sort((b, D) => b.hitFraction - D.hitFraction);
                }
                return Ammo.destroy(T), g;
              }
              _storeCollision(v, _) {
                let m = !1;
                const g = v.getGuid();
                return (
                  (this.collisions[g] = this.collisions[g] || {
                    others: [],
                    entity: v,
                  }),
                  this.collisions[g].others.indexOf(_) < 0 &&
                    (this.collisions[g].others.push(_), (m = !0)),
                  (this.frameCollisions[g] = this.frameCollisions[g] || {
                    others: [],
                    entity: v,
                  }),
                  this.frameCollisions[g].others.push(_),
                  m
                );
              }
              _createContactPointFromAmmo(v) {
                const _ = v.get_m_localPointA(),
                  m = v.get_m_localPointB(),
                  g = v.getPositionWorldOnA(),
                  T = v.getPositionWorldOnB(),
                  E = v.get_m_normalWorldOnB(),
                  M = this.contactPointPool.allocate();
                return (
                  M.localPoint.set(_.x(), _.y(), _.z()),
                  M.localPointOther.set(m.x(), m.y(), m.z()),
                  M.point.set(g.x(), g.y(), g.z()),
                  M.pointOther.set(T.x(), T.y(), T.z()),
                  M.normal.set(E.x(), E.y(), E.z()),
                  (M.impulse = v.getAppliedImpulse()),
                  M
                );
              }
              _createReverseContactPointFromAmmo(v) {
                const _ = v.get_m_localPointA(),
                  m = v.get_m_localPointB(),
                  g = v.getPositionWorldOnA(),
                  T = v.getPositionWorldOnB(),
                  E = v.get_m_normalWorldOnB(),
                  M = this.contactPointPool.allocate();
                return (
                  M.localPointOther.set(_.x(), _.y(), _.z()),
                  M.localPoint.set(m.x(), m.y(), m.z()),
                  M.pointOther.set(g.x(), g.y(), g.z()),
                  M.point.set(T.x(), T.y(), T.z()),
                  M.normal.set(E.x(), E.y(), E.z()),
                  (M.impulse = v.getAppliedImpulse()),
                  M
                );
              }
              _createSingleContactResult(v, _, m) {
                const g = this.singleContactResultPool.allocate();
                return (
                  (g.a = v),
                  (g.b = _),
                  (g.localPointA = m.localPoint),
                  (g.localPointB = m.localPointOther),
                  (g.pointA = m.point),
                  (g.pointB = m.pointOther),
                  (g.normal = m.normal),
                  (g.impulse = m.impulse),
                  g
                );
              }
              _createContactResult(v, _) {
                const m = this.contactResultPool.allocate();
                return (m.other = v), (m.contacts = _), m;
              }
              _cleanOldCollisions() {
                for (const v in this.collisions)
                  if (this.collisions.hasOwnProperty(v)) {
                    const _ = this.frameCollisions[v],
                      m = this.collisions[v],
                      g = m.entity,
                      T = g.collision,
                      E = g.rigidbody,
                      M = m.others;
                    let P = M.length;
                    for (; P--; ) {
                      const F = M[P];
                      (!_ || _.others.indexOf(F) < 0) &&
                        (M.splice(P, 1),
                        g.trigger
                          ? (T && T.fire("triggerleave", F),
                            F.rigidbody && F.rigidbody.fire("triggerleave", g))
                          : F.trigger ||
                            (E && E.fire("collisionend", F),
                            T && T.fire("collisionend", F)));
                    }
                    M.length === 0 && delete this.collisions[v];
                  }
              }
              _hasContactEvent(v) {
                const _ = v.collision;
                if (
                  _ &&
                  (_.hasEvent("collisionstart") ||
                    _.hasEvent("collisionend") ||
                    _.hasEvent("contact"))
                )
                  return !0;
                const m = v.rigidbody;
                return (
                  m &&
                  (m.hasEvent("collisionstart") ||
                    m.hasEvent("collisionend") ||
                    m.hasEvent("contact"))
                );
              }
              _checkForCollisions(v, _) {
                const g = Ammo.wrapPointer(
                    v,
                    Ammo.btDynamicsWorld
                  ).getDispatcher(),
                  T = g.getNumManifolds();
                this.frameCollisions = {};
                for (let E = 0; E < T; E++) {
                  const M = g.getManifoldByIndexInternal(E),
                    R = M.getBody0(),
                    P = M.getBody1(),
                    F = Ammo.castObject(R, Ammo.btRigidBody),
                    b = Ammo.castObject(P, Ammo.btRigidBody),
                    D = F.entity,
                    G = b.entity;
                  if (!D || !G) continue;
                  const X = F.getCollisionFlags(),
                    ie = b.getCollisionFlags(),
                    Q = M.getNumContacts(),
                    te = [],
                    ae = [];
                  let Z;
                  if (Q > 0)
                    if (X & d.ce || ie & d.ce) {
                      const J =
                          D.collision &&
                          (D.collision.hasEvent("triggerenter") ||
                            D.collision.hasEvent("triggerleave")),
                        ve =
                          G.collision &&
                          (G.collision.hasEvent("triggerenter") ||
                            G.collision.hasEvent("triggerleave")),
                        _e =
                          D.rigidbody &&
                          (D.rigidbody.hasEvent("triggerenter") ||
                            D.rigidbody.hasEvent("triggerleave")),
                        L =
                          G.rigidbody &&
                          (G.rigidbody.hasEvent("triggerenter") ||
                            G.rigidbody.hasEvent("triggerleave"));
                      J &&
                        ((Z = this._storeCollision(D, G)),
                        Z &&
                          !(ie & d.ce) &&
                          D.collision.fire("triggerenter", G)),
                        ve &&
                          ((Z = this._storeCollision(G, D)),
                          Z &&
                            !(X & d.ce) &&
                            G.collision.fire("triggerenter", D)),
                        _e &&
                          (Z || (Z = this._storeCollision(G, D)),
                          Z && D.rigidbody.fire("triggerenter", G)),
                        L &&
                          (Z || (Z = this._storeCollision(D, G)),
                          Z && G.rigidbody.fire("triggerenter", D));
                    } else {
                      const J = this._hasContactEvent(D),
                        ve = this._hasContactEvent(G),
                        _e = this.hasEvent("contact");
                      if (_e || J || ve) {
                        for (let L = 0; L < Q; L++) {
                          const ge = M.getContactPoint(L),
                            k = this._createContactPointFromAmmo(ge);
                          if (J || ve) {
                            te.push(k);
                            const j =
                              this._createReverseContactPointFromAmmo(ge);
                            ae.push(j);
                          }
                          if (_e) {
                            const j = this._createSingleContactResult(D, G, k);
                            this.fire("contact", j);
                          }
                        }
                        if (J) {
                          const L = this._createContactResult(G, te);
                          (Z = this._storeCollision(D, G)),
                            D.collision &&
                              (D.collision.fire("contact", L),
                              Z && D.collision.fire("collisionstart", L)),
                            D.rigidbody &&
                              (D.rigidbody.fire("contact", L),
                              Z && D.rigidbody.fire("collisionstart", L));
                        }
                        if (ve) {
                          const L = this._createContactResult(D, ae);
                          (Z = this._storeCollision(G, D)),
                            G.collision &&
                              (G.collision.fire("contact", L),
                              Z && G.collision.fire("collisionstart", L)),
                            G.rigidbody &&
                              (G.rigidbody.fire("contact", L),
                              Z && G.rigidbody.fire("collisionstart", L));
                        }
                      }
                    }
                }
                this._cleanOldCollisions(),
                  this.contactPointPool.freeAll(),
                  this.contactResultPool.freeAll(),
                  this.singleContactResultPool.freeAll();
              }
              onUpdate(v) {
                let _, m;
                (this._gravityFloat32[0] = this.gravity.x),
                  (this._gravityFloat32[1] = this.gravity.y),
                  (this._gravityFloat32[2] = this.gravity.z);
                const g = this.dynamicsWorld.getGravity();
                (g.x() !== this._gravityFloat32[0] ||
                  g.y() !== this._gravityFloat32[1] ||
                  g.z() !== this._gravityFloat32[2]) &&
                  (g.setValue(this.gravity.x, this.gravity.y, this.gravity.z),
                  this.dynamicsWorld.setGravity(g));
                const T = this._triggers;
                for (_ = 0, m = T.length; _ < m; _++) T[_].updateTransform();
                const E = this._compounds;
                for (_ = 0, m = E.length; _ < m; _++) E[_]._updateCompound();
                const M = this._kinematic;
                for (_ = 0, m = M.length; _ < m; _++) M[_]._updateKinematic();
                this.dynamicsWorld.stepSimulation(
                  v,
                  this.maxSubSteps,
                  this.fixedTimeStep
                );
                const R = this._dynamic;
                for (_ = 0, m = R.length; _ < m; _++) R[_]._updateDynamic();
                this.dynamicsWorld.setInternalTickCallback ||
                  this._checkForCollisions(
                    Ammo.getPointer(this.dynamicsWorld),
                    v
                  );
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this),
                  typeof Ammo != "undefined" &&
                    (Ammo.destroy(this.dynamicsWorld),
                    Ammo.destroy(this.solver),
                    Ammo.destroy(this.overlappingPairCache),
                    Ammo.destroy(this.dispatcher),
                    Ammo.destroy(this.collisionConfiguration),
                    (this.dynamicsWorld = null),
                    (this.solver = null),
                    (this.overlappingPairCache = null),
                    (this.dispatcher = null),
                    (this.collisionConfiguration = null));
              }
            }
            y.u._buildAccessors(h.H.prototype, t);
          },
          11: (xe, V, a) => {
            "use strict";
            a.d(V, { g: () => f });
            var A = a(8484),
              x = a(7994),
              y = a(371),
              c = a(2417),
              d = a(4124);
            const h = new A.$();
            class f extends d.u {
              constructor(l, n) {
                super(l, n),
                  (this._resolution = new x.Z(640, 320)),
                  (this._referenceResolution = new x.Z(640, 320)),
                  (this._scaleMode = c.b),
                  (this.scale = 1),
                  (this._scaleBlend = 0.5),
                  (this._priority = 0),
                  (this._screenSpace = !1),
                  (this.cull = this._screenSpace),
                  (this._screenMatrix = new A.$()),
                  (this._elements = new Set()),
                  l.app.graphicsDevice.on("resizecanvas", this._onResize, this);
              }
              syncDrawOrder() {
                this.system.queueDrawOrderSync(
                  this.entity.getGuid(),
                  this._processDrawOrderSync,
                  this
                );
              }
              _recurseDrawOrderSync(l, n) {
                if (!(l instanceof y.w)) return n;
                if (l.element) {
                  const e = l.element.drawOrder;
                  if (
                    ((l.element.drawOrder = n++),
                    l.element._batchGroupId >= 0 && e !== l.element.drawOrder)
                  ) {
                    var o;
                    (o = this.system.app.batcher) == null ||
                      o.markGroupDirty(l.element._batchGroupId);
                  }
                }
                l.particlesystem && (l.particlesystem.drawOrder = n++);
                const i = l.children;
                for (let e = 0; e < i.length; e++)
                  n = this._recurseDrawOrderSync(i[e], n);
                return n;
              }
              _processDrawOrderSync() {
                this._recurseDrawOrderSync(this.entity, 1),
                  this.fire("syncdraworder");
              }
              _calcProjectionMatrix() {
                const l = this._resolution.x / this.scale,
                  n = this._resolution.y / this.scale,
                  o = 0,
                  i = l,
                  e = -n;
                this._screenMatrix.setOrtho(o, i, e, 0, 1, -1),
                  this._screenSpace ||
                    (h.setScale(0.5 * l, 0.5 * n, 1),
                    this._screenMatrix.mul2(h, this._screenMatrix));
              }
              _updateScale() {
                this.scale = this._calcScale(
                  this._resolution,
                  this.referenceResolution
                );
              }
              _calcScale(l, n) {
                const o = Math.log2(l.x / n.x),
                  i = Math.log2(l.y / n.y);
                return Math.pow(
                  2,
                  o * (1 - this._scaleBlend) + i * this._scaleBlend
                );
              }
              _onResize(l, n) {
                this._screenSpace &&
                  (this._resolution.set(l, n),
                  (this.resolution = this._resolution));
              }
              _bindElement(l) {
                this._elements.add(l);
              }
              _unbindElement(l) {
                this._elements.delete(l);
              }
              onRemove() {
                this.system.app.graphicsDevice.off(
                  "resizecanvas",
                  this._onResize,
                  this
                ),
                  this.fire("remove"),
                  this._elements.forEach((l) => l._onScreenRemove()),
                  this._elements.clear(),
                  this.off();
              }
              set resolution(l) {
                this._screenSpace
                  ? this._resolution.set(
                      this.system.app.graphicsDevice.width,
                      this.system.app.graphicsDevice.height
                    )
                  : this._resolution.set(l.x, l.y),
                  this._updateScale(),
                  this._calcProjectionMatrix(),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:resolution", this._resolution),
                  this._elements.forEach((n) =>
                    n._onScreenResize(this._resolution)
                  );
              }
              get resolution() {
                return this._resolution;
              }
              set referenceResolution(l) {
                this._referenceResolution.set(l.x, l.y),
                  this._updateScale(),
                  this._calcProjectionMatrix(),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:referenceresolution", this._resolution),
                  this._elements.forEach((n) =>
                    n._onScreenResize(this._resolution)
                  );
              }
              get referenceResolution() {
                return this._scaleMode === c.b
                  ? this._resolution
                  : this._referenceResolution;
              }
              set screenSpace(l) {
                (this._screenSpace = l),
                  this._screenSpace &&
                    this._resolution.set(
                      this.system.app.graphicsDevice.width,
                      this.system.app.graphicsDevice.height
                    ),
                  (this.resolution = this._resolution),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:screenspace", this._screenSpace),
                  this._elements.forEach((n) => n._onScreenSpaceChange());
              }
              get screenSpace() {
                return this._screenSpace;
              }
              set scaleMode(l) {
                l !== c.b && l !== c.G && (l = c.b),
                  !this._screenSpace && l !== c.b && (l = c.b),
                  (this._scaleMode = l),
                  (this.resolution = this._resolution),
                  this.fire("set:scalemode", this._scaleMode);
              }
              get scaleMode() {
                return this._scaleMode;
              }
              set scaleBlend(l) {
                (this._scaleBlend = l),
                  this._updateScale(),
                  this._calcProjectionMatrix(),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:scaleblend", this._scaleBlend),
                  this._elements.forEach((n) =>
                    n._onScreenResize(this._resolution)
                  );
              }
              get scaleBlend() {
                return this._scaleBlend;
              }
              set priority(l) {
                l > 255 && (l = 255),
                  this._priority !== l &&
                    ((this._priority = l), this.syncDrawOrder());
              }
              get priority() {
                return this._priority;
              }
            }
          },
          2417: (xe, V, a) => {
            "use strict";
            a.d(V, { G: () => x, b: () => A });
            const A = "none",
              x = "blend";
          },
          3756: (xe, V, a) => {
            "use strict";
            a.d(V, { R: () => s });
            var A = a(4529),
              x = a(7994),
              y = a(4124),
              c = a(2930),
              d = a(11);
            class h {
              constructor() {
                this.enabled = !0;
              }
            }
            const f = ["enabled"];
            class s extends c.r {
              constructor(n) {
                super(n),
                  (this.id = "screen"),
                  (this.ComponentType = d.g),
                  (this.DataType = h),
                  (this.schema = f),
                  (this.windowResolution = new x.Z()),
                  (this._drawOrderSyncQueue = new A.Q()),
                  this.app.graphicsDevice.on(
                    "resizecanvas",
                    this._onResize,
                    this
                  ),
                  this.app.systems.on("update", this._onUpdate, this),
                  this.on("beforeremove", this.onRemoveComponent, this);
              }
              initializeComponentData(n, o, i) {
                o.priority !== void 0 && (n.priority = o.priority),
                  o.screenSpace !== void 0 && (n.screenSpace = o.screenSpace),
                  (n.cull = n.screenSpace),
                  o.scaleMode !== void 0 && (n.scaleMode = o.scaleMode),
                  o.scaleBlend !== void 0 && (n.scaleBlend = o.scaleBlend),
                  o.resolution !== void 0 &&
                    (o.resolution instanceof x.Z
                      ? n._resolution.copy(o.resolution)
                      : n._resolution.set(o.resolution[0], o.resolution[1]),
                    (n.resolution = n._resolution)),
                  o.referenceResolution !== void 0 &&
                    (o.referenceResolution instanceof x.Z
                      ? n._referenceResolution.copy(o.referenceResolution)
                      : n._referenceResolution.set(
                          o.referenceResolution[0],
                          o.referenceResolution[1]
                        ),
                    (n.referenceResolution = n._referenceResolution)),
                  n.syncDrawOrder(),
                  super.initializeComponentData(n, o, i);
              }
              destroy() {
                super.destroy(),
                  this.app.graphicsDevice.off(
                    "resizecanvas",
                    this._onResize,
                    this
                  ),
                  this.app.systems.off("update", this._onUpdate, this);
              }
              _onUpdate(n) {
                const o = this.store;
                for (const i in o)
                  o[i].entity.screen.update && o[i].entity.screen.update(n);
              }
              _onResize(n, o) {
                (this.windowResolution.x = n), (this.windowResolution.y = o);
              }
              cloneComponent(n, o) {
                const i = n.screen;
                return this.addComponent(o, {
                  enabled: i.enabled,
                  screenSpace: i.screenSpace,
                  scaleMode: i.scaleMode,
                  resolution: i.resolution.clone(),
                  referenceResolution: i.referenceResolution.clone(),
                });
              }
              onRemoveComponent(n, o) {
                o.onRemove();
              }
              processDrawOrderSyncQueue() {
                const n = this._drawOrderSyncQueue.list();
                for (let o = 0; o < n.length; o++) {
                  const i = n[o];
                  i.callback.call(i.scope);
                }
                this._drawOrderSyncQueue.clear();
              }
              queueDrawOrderSync(n, o, i) {
                this._drawOrderSyncQueue.list().length ||
                  this.app.once(
                    "prerender",
                    this.processDrawOrderSyncQueue,
                    this
                  ),
                  this._drawOrderSyncQueue.has(n) ||
                    this._drawOrderSyncQueue.push(n, { callback: o, scope: i });
              }
            }
            y.u._buildAccessors(d.g.prototype, f);
          },
          8226: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => y });
            var A = a(1870),
              x = a(4124);
            class y extends x.u {
              constructor(d, h) {
                super(d, h), this.on("set_scripts", this.onSetScripts, this);
              }
              send(d, h) {
                const f = Array.prototype.slice.call(arguments, 2),
                  s = this.entity.script.instances;
                let l;
                if (s && s[d] && ((l = s[d].instance[h]), l))
                  return l.apply(s[d].instance, f);
              }
              onEnable() {
                this.data.areScriptsLoaded &&
                  !this.system.preloading &&
                  (this.data.initialized
                    ? this.system._enableScriptComponent(this)
                    : this.system._initializeScriptComponent(this),
                  this.data.postInitialized ||
                    this.system._postInitializeScriptComponent(this));
              }
              onDisable() {
                this.system._disableScriptComponent(this);
              }
              onSetScripts(d, h, f) {
                if (!this.system._inTools || this.runInTools) {
                  if (this._updateScriptAttributes(h, f)) return;
                  this.enabled && this.system._disableScriptComponent(this),
                    this.system._destroyScriptComponent(this),
                    (this.data.areScriptsLoaded = !1);
                  const l = f.map(function (n) {
                    return n.url;
                  });
                  if (this._loadFromCache(l)) return;
                  this._loadScripts(l);
                }
              }
              _updateScriptAttributes(d, h) {
                let f = !0;
                if (d.length !== h.length) f = !1;
                else
                  for (let s = 0, l = h.length; s < l; s++)
                    if (d[s].url !== h[s].url) {
                      f = !1;
                      break;
                    }
                if (f)
                  for (const s in this.instances)
                    this.instances.hasOwnProperty(s) &&
                      this.system._updateAccessors(
                        this.entity,
                        this.instances[s]
                      );
                return f;
              }
              _loadFromCache(d) {
                const h = [],
                  f = this.system.app._scriptPrefix || "",
                  s = /^http(s)?:\/\//i;
                for (let l = 0, n = d.length; l < n; l++) {
                  let o = d[l];
                  s.test(o) || (o = A.A.join(f, o));
                  const i = this.system.app.loader.getFromCache(o, "script");
                  if (!i) return !1;
                  h.push(i);
                }
                for (let l = 0, n = h.length; l < n; l++) {
                  const o = h[l];
                  if (
                    o !== !0 &&
                    o &&
                    this.entity.script &&
                    !this.entity.script.instances[o._pcScriptName]
                  ) {
                    const i = new o(this.entity);
                    this.system._preRegisterInstance(
                      this.entity,
                      d[l],
                      o._pcScriptName,
                      i
                    );
                  }
                }
                return (
                  this.data && (this.data.areScriptsLoaded = !0),
                  this.system.preloading ||
                    (this.system.onInitialize(this.entity),
                    this.system.onPostInitialize(this.entity)),
                  !0
                );
              }
              _loadScripts(d) {
                let h = d.length;
                const f = this.system.app._scriptPrefix || "";
                d.forEach((s) => {
                  let l = null,
                    n = null;
                  s.toLowerCase().startsWith("http://") ||
                  s.toLowerCase().startsWith("https://")
                    ? ((n = s), (l = s))
                    : ((n = s), (l = A.A.join(f, s))),
                    this.system.app.loader.load(l, "script", (o, i) => {
                      if ((h--, o)) console.error(o);
                      else if (
                        i &&
                        this.entity.script &&
                        !this.entity.script.instances[i._pcScriptName]
                      ) {
                        const e = new i(this.entity);
                        this.system._preRegisterInstance(
                          this.entity,
                          n,
                          i._pcScriptName,
                          e
                        );
                      }
                      h === 0 &&
                        ((this.data.areScriptsLoaded = !0),
                        this.system.preloading ||
                          (this.system.onInitialize(this.entity),
                          this.system.onPostInitialize(this.entity)));
                    });
                });
              }
            }
          },
          8037: (xe, V, a) => {
            "use strict";
            a.d(V, { B: () => M });
            var A = a(8506),
              x = a(9048),
              y = a(5227),
              c = a(5567),
              d = a(2358),
              h = a(7994),
              f = a(7481),
              s = a(5596),
              l = a(371),
              n = a(4124),
              o = a(2930),
              i = a(8226);
            class e {
              constructor() {
                (this.scripts = []),
                  (this.enabled = !0),
                  (this.instances = {}),
                  (this._instances = {}),
                  (this.runInTools = !1),
                  (this.attributes = {}),
                  (this.initialized = !1),
                  (this.postInitialized = !1),
                  (this.areScriptsLoaded = !1);
              }
            }
            const t = ["enabled", "scripts", "instances", "runInTools"],
              r = "initialize",
              u = "postInitialize",
              v = "update",
              _ = "postUpdate",
              m = "fixedUpdate",
              g = "toolsUpdate",
              T = "onEnable",
              E = "onDisable";
            class M extends o.r {
              constructor(P) {
                super(P),
                  (this.id = "script"),
                  (this.ComponentType = i.u),
                  (this.DataType = e),
                  (this.schema = t),
                  (this.preloading = !1),
                  (this.instancesWithUpdate = []),
                  (this.instancesWithFixedUpdate = []),
                  (this.instancesWithPostUpdate = []),
                  (this.instancesWithToolsUpdate = []),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on(r, this.onInitialize, this),
                  this.app.systems.on(u, this.onPostInitialize, this),
                  this.app.systems.on(v, this.onUpdate, this),
                  this.app.systems.on(m, this.onFixedUpdate, this),
                  this.app.systems.on(_, this.onPostUpdate, this),
                  this.app.systems.on(g, this.onToolsUpdate, this);
              }
              initializeComponentData(P, F, b) {
                (b = ["runInTools", "enabled", "scripts"]),
                  F.scripts &&
                    F.scripts.length &&
                    F.scripts.forEach(function (D) {
                      if (D.attributes && Array.isArray(D.attributes)) {
                        const G = {};
                        for (let X = 0; X < D.attributes.length; X++)
                          G[D.attributes[X].name] = D.attributes[X];
                        D.attributes = G;
                      }
                    }),
                  super.initializeComponentData(P, F, b);
              }
              cloneComponent(P, F) {
                const b = this.store[P.getGuid()],
                  D = {
                    runInTools: b.data.runInTools,
                    scripts: [],
                    enabled: b.data.enabled,
                  },
                  G = b.data.scripts;
                for (let X = 0, ie = G.length; X < ie; X++) {
                  const Q = G[X].attributes;
                  Q && delete G[X].attributes,
                    D.scripts.push((0, A.X$)({}, G[X])),
                    Q &&
                      ((D.scripts[X].attributes = this._cloneAttributes(Q)),
                      (G[X].attributes = Q));
                }
                return this.addComponent(F, D);
              }
              onBeforeRemove(P, F) {
                F.enabled && this._disableScriptComponent(F),
                  this._destroyScriptComponent(F);
              }
              onInitialize(P) {
                if ((this._registerInstances(P), P.enabled)) {
                  P.script &&
                    P.script.enabled &&
                    this._initializeScriptComponent(P.script);
                  const F = P._children;
                  for (let b = 0, D = F.length; b < D; b++)
                    F[b] instanceof l.w && this.onInitialize(F[b]);
                }
              }
              onPostInitialize(P) {
                if (P.enabled) {
                  P.script &&
                    P.script.enabled &&
                    this._postInitializeScriptComponent(P.script);
                  const F = P._children;
                  for (let b = 0, D = F.length; b < D; b++)
                    F[b] instanceof l.w && this.onPostInitialize(F[b]);
                }
              }
              _callInstancesMethod(P, F) {
                const b = P.data.instances;
                for (const D in b)
                  if (b.hasOwnProperty(D)) {
                    const G = b[D].instance;
                    G[F] && G[F]();
                  }
              }
              _initializeScriptComponent(P) {
                this._callInstancesMethod(P, r),
                  (P.data.initialized = !0),
                  P.enabled &&
                    P.entity.enabled &&
                    this._enableScriptComponent(P);
              }
              _enableScriptComponent(P) {
                this._callInstancesMethod(P, T);
              }
              _disableScriptComponent(P) {
                this._callInstancesMethod(P, E);
              }
              _destroyScriptComponent(P) {
                const F = P.data.instances;
                for (const b in F)
                  if (F.hasOwnProperty(b)) {
                    const D = F[b].instance;
                    if ((D.destroy && D.destroy(), D.update)) {
                      const G = this.instancesWithUpdate.indexOf(D);
                      G >= 0 && this.instancesWithUpdate.splice(G, 1);
                    }
                    if (D.fixedUpdate) {
                      const G = this.instancesWithFixedUpdate.indexOf(D);
                      G >= 0 && this.instancesWithFixedUpdate.splice(G, 1);
                    }
                    if (D.postUpdate) {
                      const G = this.instancesWithPostUpdate.indexOf(D);
                      G >= 0 && this.instancesWithPostUpdate.splice(G, 1);
                    }
                    if (D.toolsUpdate) {
                      const G = this.instancesWithToolsUpdate.indexOf(D);
                      G >= 0 && this.instancesWithToolsUpdate.splice(G, 1);
                    }
                    P.instances[b].instance === P[b] && delete P[b],
                      delete P.instances[b];
                  }
              }
              _postInitializeScriptComponent(P) {
                this._callInstancesMethod(P, u), (P.data.postInitialized = !0);
              }
              _updateInstances(P, F, b) {
                for (let D = 0, G = F.length; D < G; D++) {
                  const X = F[D];
                  X &&
                    X.entity &&
                    X.entity.enabled &&
                    X.entity.script.enabled &&
                    X[P](b);
                }
              }
              onUpdate(P) {
                this._updateInstances(v, this.instancesWithUpdate, P);
              }
              onFixedUpdate(P) {
                this._updateInstances(m, this.instancesWithFixedUpdate, P);
              }
              onPostUpdate(P) {
                this._updateInstances(_, this.instancesWithPostUpdate, P);
              }
              onToolsUpdate(P) {
                this._updateInstances(g, this.instancesWithToolsUpdate, P);
              }
              broadcast(P, F) {
                const b = Array.prototype.slice.call(arguments, 2),
                  D = this.store;
                for (const G in D)
                  if (D.hasOwnProperty(G)) {
                    const X = D[G].data;
                    if (X.instances[P]) {
                      const ie = X.instances[P].instance[F];
                      ie && ie.apply(X.instances[P].instance, b);
                    }
                  }
              }
              _preRegisterInstance(P, F, b, D) {
                if (P.script) {
                  if (
                    ((P.script.data._instances =
                      P.script.data._instances || {}),
                    P.script.data._instances[b])
                  )
                    throw Error(
                      `Script name collision '${b}'. Scripts from '${F}' and '${
                        P.script.data._instances[b].url
                      }' {${P.getGuid()}}`
                    );
                  P.script.data._instances[b] = {
                    url: F,
                    name: b,
                    instance: D,
                  };
                }
              }
              _registerInstances(P) {
                if (P.script && P.script.data._instances) {
                  P.script.instances = P.script.data._instances;
                  for (const b in P.script.instances) {
                    const D = P.script.instances[b],
                      G = D.instance;
                    if (
                      (x.A.attach(G),
                      G.update && this.instancesWithUpdate.push(G),
                      G.fixedUpdate && this.instancesWithFixedUpdate.push(G),
                      G.postUpdate && this.instancesWithPostUpdate.push(G),
                      G.toolsUpdate && this.instancesWithToolsUpdate.push(G),
                      P.script.scripts && this._createAccessors(P, D),
                      P.script[b])
                    )
                      throw Error(
                        `Script with name '${b}' is already attached to Script Component`
                      );
                    P.script[b] = G;
                  }
                  delete P.script.data._instances;
                }
                const F = P._children;
                for (let b = 0, D = F.length; b < D; b++)
                  F[b] instanceof l.w && this._registerInstances(F[b]);
              }
              _cloneAttributes(P) {
                const F = {};
                for (const b in P)
                  if (P.hasOwnProperty(b))
                    if (P[b].type !== "entity") F[b] = (0, A.X$)({}, P[b]);
                    else {
                      const D = P[b].value;
                      delete P[b].value,
                        (F[b] = (0, A.X$)({}, P[b])),
                        (F[b].value = D),
                        (P[b].value = D);
                    }
                return F;
              }
              _createAccessors(P, F) {
                const b = P.script.scripts.length,
                  D = F.url;
                for (let G = 0; G < b; G++) {
                  const X = P.script.scripts[G];
                  if (X.url === D) {
                    const ie = X.attributes;
                    if (X.name && ie) {
                      for (const Q in ie)
                        ie.hasOwnProperty(Q) && this._createAccessor(ie[Q], F);
                      P.script.data.attributes[X.name] =
                        this._cloneAttributes(ie);
                    }
                    break;
                  }
                }
              }
              _createAccessor(P, F) {
                const b = this;
                (P = { name: P.name, value: P.value, type: P.type }),
                  this._convertAttributeValue(P),
                  Object.defineProperty(F.instance, P.name, {
                    get: function () {
                      return P.value;
                    },
                    set: function (D) {
                      const G = P.value;
                      (P.value = D),
                        b._convertAttributeValue(P),
                        F.instance.fire("set", P.name, G, P.value);
                    },
                    configurable: !0,
                  });
              }
              _updateAccessors(P, F) {
                const b = P.script.scripts.length,
                  D = F.url;
                for (let G = 0; G < b; G++) {
                  const X = P.script,
                    ie = X.scripts[G];
                  if (ie.url === D) {
                    const Q = ie.name,
                      te = ie.attributes;
                    if (Q) {
                      if (te)
                        for (const Z in te)
                          te.hasOwnProperty(Z) &&
                            this._createAccessor(te[Z], F);
                      const ae = X.data.attributes[Q];
                      if (ae)
                        for (const Z in ae) {
                          const J = ae[Z];
                          Z in te
                            ? te[Z].value !== J.value &&
                              F.instance.onAttributeChanged &&
                              F.instance.onAttributeChanged(
                                J.name,
                                J.value,
                                te[Z].value
                              )
                            : delete F.instance[J.name];
                        }
                      te
                        ? (X.data.attributes[Q] = this._cloneAttributes(te))
                        : delete X.data.attributes[Q];
                    }
                    break;
                  }
                }
              }
              _convertAttributeValue(P) {
                if (P.type === "rgb" || P.type === "rgba")
                  Array.isArray(P.value) &&
                    (P.value =
                      P.value.length === 3
                        ? new y.Q(P.value[0], P.value[1], P.value[2])
                        : new y.Q(
                            P.value[0],
                            P.value[1],
                            P.value[2],
                            P.value[3]
                          ));
                else if (P.type === "vec2")
                  Array.isArray(P.value) &&
                    (P.value = new h.Z(P.value[0], P.value[1]));
                else if (P.type === "vec3" || P.type === "vector")
                  Array.isArray(P.value) &&
                    (P.value = new f.e(P.value[0], P.value[1], P.value[2]));
                else if (P.type === "vec4")
                  Array.isArray(P.value) &&
                    (P.value = new s.Z(
                      P.value[0],
                      P.value[1],
                      P.value[2],
                      P.value[3]
                    ));
                else if (P.type === "entity")
                  P.value !== null &&
                    typeof P.value == "string" &&
                    (P.value = this.app.root.findByGuid(P.value));
                else if (P.type === "curve" || P.type === "colorcurve") {
                  const F = P.value.keys[0] instanceof Array ? d.K : c.I;
                  (P.value = new F(P.value.keys)),
                    (P.value.type = P.value.type);
                }
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off(r, this.onInitialize, this),
                  this.app.systems.off(u, this.onPostInitialize, this),
                  this.app.systems.off(v, this.onUpdate, this),
                  this.app.systems.off(m, this.onFixedUpdate, this),
                  this.app.systems.off(_, this.onPostUpdate, this),
                  this.app.systems.off(g, this.onToolsUpdate, this);
              }
            }
            n.u._buildAccessors(i.u.prototype, t);
          },
          9376: (xe, V, a) => {
            "use strict";
            a.d(V, { d: () => h });
            var A = a(5767),
              x = a(6087),
              y = a(897),
              c = a(4124),
              d = a(371);
            class h extends c.u {
              constructor(s, l) {
                super(s, l),
                  (this._scripts = []),
                  (this._updateList = new A.B({ sortBy: "__executionOrder" })),
                  (this._postUpdateList = new A.B({
                    sortBy: "__executionOrder",
                  })),
                  (this._scriptsIndex = {}),
                  (this._destroyedScripts = []),
                  (this._destroyed = !1),
                  (this._scriptsData = null),
                  (this._oldState = !0),
                  (this._enabled = !0),
                  (this._beingEnabled = !1),
                  (this._isLoopingThroughScripts = !1),
                  (this._executionOrder = -1),
                  this.on("set_enabled", this._onSetEnabled, this);
              }
              set scripts(s) {
                this._scriptsData = s;
                for (const l in s) {
                  if (!s.hasOwnProperty(l)) continue;
                  const n = this._scriptsIndex[l];
                  if (n) {
                    if (
                      (typeof s[l].enabled == "boolean" &&
                        (n.enabled = !!s[l].enabled),
                      typeof s[l].attributes == "object")
                    ) {
                      for (const o in s[l].attributes)
                        if (!x.x.reservedNames.has(o)) {
                          if (!n.__attributes.hasOwnProperty(o)) {
                            const i = this.system.app.scripts.get(l);
                            i && i.attributes.add(o, {});
                          }
                          n[o] = s[l].attributes[o];
                        }
                    }
                  } else console.log(this.order);
                }
              }
              get scripts() {
                return this._scripts;
              }
              set enabled(s) {
                const l = this._enabled;
                (this._enabled = s), this.fire("set", "enabled", l, s);
              }
              get enabled() {
                return this._enabled;
              }
              onEnable() {
                (this._beingEnabled = !0),
                  this._checkState(),
                  this.entity._beingEnabled || this.onPostStateChange(),
                  (this._beingEnabled = !1);
              }
              onDisable() {
                this._checkState();
              }
              onPostStateChange() {
                const s = this._beginLooping();
                for (let l = 0, n = this.scripts.length; l < n; l++) {
                  const o = this.scripts[l];
                  o._initialized &&
                    !o._postInitialized &&
                    o.enabled &&
                    ((o._postInitialized = !0),
                    o.postInitialize && this._scriptMethod(o, y.k5));
                }
                this._endLooping(s);
              }
              _beginLooping() {
                const s = this._isLoopingThroughScripts;
                return (this._isLoopingThroughScripts = !0), s;
              }
              _endLooping(s) {
                (this._isLoopingThroughScripts = s),
                  this._isLoopingThroughScripts ||
                    this._removeDestroyedScripts();
              }
              _onSetEnabled(s, l, n) {
                (this._beingEnabled = !0),
                  this._checkState(),
                  (this._beingEnabled = !1);
              }
              _checkState() {
                const s = this.enabled && this.entity.enabled;
                if (s === this._oldState) return;
                (this._oldState = s),
                  this.fire(s ? "enable" : "disable"),
                  this.fire("state", s),
                  s
                    ? this.system._addComponentToEnabled(this)
                    : this.system._removeComponentFromEnabled(this);
                const l = this._beginLooping();
                for (let n = 0, o = this.scripts.length; n < o; n++) {
                  const i = this.scripts[n];
                  i.enabled = i._enabled;
                }
                this._endLooping(l);
              }
              _onBeforeRemove() {
                this.fire("remove");
                const s = this._beginLooping();
                for (let l = 0; l < this.scripts.length; l++) {
                  const n = this.scripts[l];
                  n && this.destroy(n.__scriptType.__name);
                }
                this._endLooping(s);
              }
              _removeDestroyedScripts() {
                const s = this._destroyedScripts.length;
                if (s) {
                  for (let l = 0; l < s; l++) {
                    const n = this._destroyedScripts[l];
                    this._removeScriptInstance(n);
                  }
                  (this._destroyedScripts.length = 0),
                    this._resetExecutionOrder(0, this._scripts.length);
                }
              }
              _onInitializeAttributes() {
                for (let s = 0, l = this.scripts.length; s < l; s++)
                  this.scripts[s].__initializeAttributes();
              }
              _scriptMethod(s, l, n) {
                s[l](n);
              }
              _onInitialize() {
                const s = this._scripts,
                  l = this._beginLooping();
                for (let n = 0, o = s.length; n < o; n++) {
                  const i = s[n];
                  !i._initialized &&
                    i.enabled &&
                    ((i._initialized = !0),
                    i.initialize && this._scriptMethod(i, y.$x));
                }
                this._endLooping(l);
              }
              _onPostInitialize() {
                this.onPostStateChange();
              }
              _onUpdate(s) {
                const l = this._updateList;
                if (!l.length) return;
                const n = this._beginLooping();
                for (l.loopIndex = 0; l.loopIndex < l.length; l.loopIndex++) {
                  const o = l.items[l.loopIndex];
                  o.enabled && this._scriptMethod(o, y.Wx, s);
                }
                this._endLooping(n);
              }
              _onPostUpdate(s) {
                const l = this._postUpdateList;
                if (!l.length) return;
                const n = this._beginLooping();
                for (l.loopIndex = 0; l.loopIndex < l.length; l.loopIndex++) {
                  const o = l.items[l.loopIndex];
                  o.enabled && this._scriptMethod(o, y.ZP, s);
                }
                this._endLooping(n);
              }
              _insertScriptInstance(s, l, n) {
                l === -1
                  ? (this._scripts.push(s),
                    (s.__executionOrder = n),
                    s.update && this._updateList.append(s),
                    s.postUpdate && this._postUpdateList.append(s))
                  : (this._scripts.splice(l, 0, s),
                    (s.__executionOrder = l),
                    this._resetExecutionOrder(l + 1, n + 1),
                    s.update && this._updateList.insert(s),
                    s.postUpdate && this._postUpdateList.insert(s));
              }
              _removeScriptInstance(s) {
                const l = this._scripts.indexOf(s);
                return (
                  l === -1 ||
                    (this._scripts.splice(l, 1),
                    s.update && this._updateList.remove(s),
                    s.postUpdate && this._postUpdateList.remove(s)),
                  l
                );
              }
              _resetExecutionOrder(s, l) {
                for (let n = s; n < l; n++)
                  this._scripts[n].__executionOrder = n;
              }
              _resolveEntityScriptAttribute(s, l, n, o, i, e) {
                if (s.array) {
                  const t = n.length;
                  if (!t) return;
                  const r = n.slice();
                  for (let u = 0; u < t; u++) {
                    const v = r[u] instanceof d.w ? r[u].getGuid() : r[u];
                    e[v] && (r[u] = o ? e[v].getGuid() : e[v]);
                  }
                  i[l] = r;
                } else {
                  if (n instanceof d.w) n = n.getGuid();
                  else if (typeof n != "string") return;
                  e[n] && (i[l] = e[n]);
                }
              }
              has(s) {
                if (typeof s == "string") return !!this._scriptsIndex[s];
                if (!s) return !1;
                const l = s,
                  n = l.__name,
                  o = this._scriptsIndex[n];
                return (o && o.instance) instanceof l;
              }
              get(s) {
                if (typeof s == "string") {
                  const e = this._scriptsIndex[s];
                  return e ? e.instance : null;
                }
                if (!s) return null;
                const l = s,
                  n = l.__name,
                  o = this._scriptsIndex[n],
                  i = o && o.instance;
                return i instanceof l ? i : null;
              }
              create(s, l = {}) {
                const n = this;
                let o = s,
                  i = s;
                if (
                  (typeof o == "string"
                    ? (o = this.system.app.scripts.get(o))
                    : o && (i = o.__name),
                  o)
                ) {
                  if (
                    !this._scriptsIndex[i] ||
                    !this._scriptsIndex[i].instance
                  ) {
                    const e = new o({
                        app: this.system.app,
                        entity: this.entity,
                        enabled: l.hasOwnProperty("enabled") ? l.enabled : !0,
                        attributes: l.attributes,
                      }),
                      t = this._scripts.length;
                    let r = -1;
                    return (
                      typeof l.ind == "number" &&
                        l.ind !== -1 &&
                        t > l.ind &&
                        (r = l.ind),
                      this._insertScriptInstance(e, r, t),
                      (this._scriptsIndex[i] = {
                        instance: e,
                        onSwap: function () {
                          n.swap(i);
                        },
                      }),
                      (this[i] = e),
                      l.preloading || e.__initializeAttributes(),
                      this.fire("create", i, e),
                      this.fire("create:" + i, e),
                      this.system.app.scripts.on(
                        "swap:" + i,
                        this._scriptsIndex[i].onSwap
                      ),
                      l.preloading ||
                        (e.enabled &&
                          !e._initialized &&
                          ((e._initialized = !0),
                          e.initialize && this._scriptMethod(e, y.$x)),
                        e.enabled &&
                          !e._postInitialized &&
                          ((e._postInitialized = !0),
                          e.postInitialize && this._scriptMethod(e, y.k5))),
                      e
                    );
                  }
                } else
                  this._scriptsIndex[i] = {
                    awaiting: !0,
                    ind: this._scripts.length,
                  };
                return null;
              }
              destroy(s) {
                let l = s,
                  n = s;
                typeof n == "string"
                  ? (n = this.system.app.scripts.get(n))
                  : n && (l = n.__name);
                const o = this._scriptsIndex[l];
                if ((delete this._scriptsIndex[l], !o)) return !1;
                const i = o.instance;
                if (i && !i._destroyed)
                  if (
                    ((i.enabled = !1),
                    (i._destroyed = !0),
                    this._isLoopingThroughScripts)
                  )
                    this._destroyedScripts.push(i);
                  else {
                    const e = this._removeScriptInstance(i);
                    e >= 0 &&
                      this._resetExecutionOrder(e, this._scripts.length);
                  }
                return (
                  this.system.app.scripts.off("swap:" + l, o.onSwap),
                  delete this[l],
                  this.fire("destroy", l, i || null),
                  this.fire("destroy:" + l, i || null),
                  i && i.fire("destroy"),
                  !0
                );
              }
              swap(s) {
                let l = s,
                  n = s;
                typeof n == "string"
                  ? (n = this.system.app.scripts.get(n))
                  : n && (l = n.__name);
                const o = this._scriptsIndex[l];
                if (!o || !o.instance) return !1;
                const i = o.instance,
                  e = this._scripts.indexOf(i),
                  t = new n({
                    app: this.system.app,
                    entity: this.entity,
                    enabled: i.enabled,
                    attributes: i.__attributes,
                  });
                return t.swap
                  ? (t.__initializeAttributes(),
                    (this._scripts[e] = t),
                    (this._scriptsIndex[l].instance = t),
                    (this[l] = t),
                    (t.__executionOrder = e),
                    i.update && this._updateList.remove(i),
                    i.postUpdate && this._postUpdateList.remove(i),
                    t.update && this._updateList.insert(t),
                    t.postUpdate && this._postUpdateList.insert(t),
                    this._scriptMethod(t, y.qK, i),
                    this.fire("swap", l, t),
                    this.fire("swap:" + l, t),
                    !0)
                  : !1;
              }
              resolveDuplicatedEntityReferenceProperties(s, l) {
                const n = this.entity.script;
                for (const o in s._scriptsIndex) {
                  const i = this.system.app.scripts.get(o);
                  if (!i) continue;
                  const e = s._scriptsIndex[o];
                  if (!e || !e.instance) continue;
                  const t = n[o].__attributesRaw,
                    r = n[o].__attributes;
                  if (!t && !r) continue;
                  const u = !!t,
                    v = e.instance.__attributes;
                  for (const _ in v) {
                    if (!v[_]) continue;
                    const m = i.attributes.get(_);
                    if (m) {
                      if (m.type === "entity")
                        this._resolveEntityScriptAttribute(
                          m,
                          _,
                          v[_],
                          u,
                          t || r,
                          l
                        );
                      else if (m.type === "json" && Array.isArray(m.schema)) {
                        const g = v[_],
                          T = t ? t[_] : r[_];
                        for (let E = 0; E < m.schema.length; E++) {
                          const M = m.schema[E];
                          if (M.type === "entity")
                            if (m.array)
                              for (let R = 0; R < g.length; R++)
                                this._resolveEntityScriptAttribute(
                                  M,
                                  M.name,
                                  g[R][M.name],
                                  u,
                                  T[R],
                                  l
                                );
                            else
                              this._resolveEntityScriptAttribute(
                                M,
                                M.name,
                                g[M.name],
                                u,
                                T,
                                l
                              );
                        }
                      }
                    }
                  }
                }
              }
              move(s, l) {
                const n = this._scripts.length;
                if (l >= n || l < 0) return !1;
                let o = s,
                  i = s;
                typeof i != "string" ? (i = s.__name) : (o = null);
                const e = this._scriptsIndex[i];
                if (!e || !e.instance) return !1;
                const t = e.instance;
                if (o && !(t instanceof o)) return !1;
                const r = this._scripts.indexOf(t);
                return r === -1 || r === l
                  ? !1
                  : (this._scripts.splice(l, 0, this._scripts.splice(r, 1)[0]),
                    this._resetExecutionOrder(0, n),
                    this._updateList.sort(),
                    this._postUpdateList.sort(),
                    this.fire("move", i, t, l, r),
                    this.fire("move:" + i, t, l, r),
                    !0);
              }
            }
          },
          8871: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => o });
            var A = a(5767),
              x = a(2930),
              y = a(9376);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = "_onInitializeAttributes",
              h = "_onInitialize",
              f = "_onPostInitialize",
              s = "_onUpdate",
              l = "_onPostUpdate";
            let n = 0;
            class o extends x.r {
              constructor(e) {
                super(e),
                  (this.id = "script"),
                  (this.ComponentType = y.d),
                  (this.DataType = c),
                  (this._components = new A.B({ sortBy: "_executionOrder" })),
                  (this._enabledComponents = new A.B({
                    sortBy: "_executionOrder",
                  })),
                  (this.preloading = !0),
                  this.on("beforeremove", this._onBeforeRemove, this),
                  this.app.systems.on("initialize", this._onInitialize, this),
                  this.app.systems.on(
                    "postInitialize",
                    this._onPostInitialize,
                    this
                  ),
                  this.app.systems.on("update", this._onUpdate, this),
                  this.app.systems.on("postUpdate", this._onPostUpdate, this);
              }
              initializeComponentData(e, t) {
                if (
                  ((e._executionOrder = n++),
                  this._components.append(e),
                  n > Number.MAX_SAFE_INTEGER && this._resetExecutionOrder(),
                  (e.enabled = t.hasOwnProperty("enabled") ? !!t.enabled : !0),
                  e.enabled &&
                    e.entity.enabled &&
                    this._enabledComponents.append(e),
                  t.hasOwnProperty("order") && t.hasOwnProperty("scripts"))
                ) {
                  e._scriptsData = t.scripts;
                  for (let r = 0; r < t.order.length; r++)
                    e.create(t.order[r], {
                      enabled: t.scripts[t.order[r]].enabled,
                      attributes: t.scripts[t.order[r]].attributes,
                      preloading: this.preloading,
                    });
                }
              }
              cloneComponent(e, t) {
                const r = [],
                  u = {};
                for (let _ = 0; _ < e.script._scripts.length; _++) {
                  const m = e.script._scripts[_],
                    g = m.__scriptType.__name;
                  r.push(g);
                  const T = {};
                  for (const E in m.__attributes) T[E] = m.__attributes[E];
                  u[g] = { enabled: m._enabled, attributes: T };
                }
                for (const _ in e.script._scriptsIndex)
                  _.awaiting && r.splice(_.ind, 0, _);
                const v = { enabled: e.script.enabled, order: r, scripts: u };
                return this.addComponent(t, v);
              }
              _resetExecutionOrder() {
                n = 0;
                for (let e = 0, t = this._components.length; e < t; e++)
                  this._components.items[e]._executionOrder = n++;
              }
              _callComponentMethod(e, t, r) {
                for (e.loopIndex = 0; e.loopIndex < e.length; e.loopIndex++)
                  e.items[e.loopIndex][t](r);
              }
              _onInitialize() {
                (this.preloading = !1),
                  this._callComponentMethod(this._components, d),
                  this._callComponentMethod(this._enabledComponents, h);
              }
              _onPostInitialize() {
                this._callComponentMethod(this._enabledComponents, f);
              }
              _onUpdate(e) {
                this._callComponentMethod(this._enabledComponents, s, e);
              }
              _onPostUpdate(e) {
                this._callComponentMethod(this._enabledComponents, l, e);
              }
              _addComponentToEnabled(e) {
                this._enabledComponents.insert(e);
              }
              _removeComponentFromEnabled(e) {
                this._enabledComponents.remove(e);
              }
              _onBeforeRemove(e, t) {
                this._components.items.indexOf(t) >= 0 && t._onBeforeRemove(),
                  this._removeComponentFromEnabled(t),
                  this._components.remove(t);
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("initialize", this._onInitialize, this),
                  this.app.systems.off(
                    "postInitialize",
                    this._onPostInitialize,
                    this
                  ),
                  this.app.systems.off("update", this._onUpdate, this),
                  this.app.systems.off("postUpdate", this._onPostUpdate, this);
              }
            }
          },
          406: (xe, V, a) => {
            "use strict";
            a.d(V, { I: () => o });
            var A = a(8656),
              x = a(7994),
              y = a(7481),
              c = a(9391),
              d = a(1657),
              h = a(8219),
              f = a(3940),
              s = a(4124),
              l = a(9939);
            const n = new x.Z();
            class o extends s.u {
              constructor(e, t) {
                super(e, t),
                  (this._viewportReference = new d.D(this, "viewportEntity", {
                    "element#gain": this._onViewportElementGain,
                    "element#resize": this._onSetContentOrViewportSize,
                  })),
                  (this._contentReference = new d.D(this, "contentEntity", {
                    "element#gain": this._onContentElementGain,
                    "element#lose": this._onContentElementLose,
                    "element#resize": this._onSetContentOrViewportSize,
                  })),
                  (this._scrollbarUpdateFlags = {}),
                  (this._scrollbarReferences = {}),
                  (this._scrollbarReferences[c.Sz] = new d.D(
                    this,
                    "horizontalScrollbarEntity",
                    {
                      "scrollbar#set:value":
                        this._onSetHorizontalScrollbarValue,
                      "scrollbar#gain": this._onHorizontalScrollbarGain,
                    }
                  )),
                  (this._scrollbarReferences[c.Yn] = new d.D(
                    this,
                    "verticalScrollbarEntity",
                    {
                      "scrollbar#set:value": this._onSetVerticalScrollbarValue,
                      "scrollbar#gain": this._onVerticalScrollbarGain,
                    }
                  )),
                  (this._prevContentSizes = {}),
                  (this._prevContentSizes[c.Sz] = null),
                  (this._prevContentSizes[c.Yn] = null),
                  (this._scroll = new x.Z()),
                  (this._velocity = new y.e()),
                  (this._dragStartPosition = new y.e()),
                  (this._disabledContentInput = !1),
                  (this._disabledContentInputEntities = []),
                  this._toggleLifecycleListeners("on", e),
                  this._toggleElementListeners("on");
              }
              _toggleLifecycleListeners(e, t) {
                this[e](
                  "set_horizontal",
                  this._onSetHorizontalScrollingEnabled,
                  this
                ),
                  this[e](
                    "set_vertical",
                    this._onSetVerticalScrollingEnabled,
                    this
                  ),
                  t.app.systems.element[e](
                    "add",
                    this._onElementComponentAdd,
                    this
                  ),
                  t.app.systems.element[e](
                    "beforeremove",
                    this._onElementComponentRemove,
                    this
                  );
              }
              _toggleElementListeners(e) {
                if (this.entity.element) {
                  if (e === "on" && this._hasElementListeners) return;
                  this.entity.element[e](
                    "resize",
                    this._onSetContentOrViewportSize,
                    this
                  ),
                    this.entity.element[e](l.yX, this._onMouseWheel, this),
                    (this._hasElementListeners = e === "on");
                }
              }
              _onElementComponentAdd(e) {
                this.entity === e && this._toggleElementListeners("on");
              }
              _onElementComponentRemove(e) {
                this.entity === e && this._toggleElementListeners("off");
              }
              _onViewportElementGain() {
                this._syncAll();
              }
              _onContentElementGain() {
                this._destroyDragHelper(),
                  (this._contentDragHelper = new h.h(
                    this._contentReference.entity.element
                  )),
                  this._contentDragHelper.on(
                    "drag:start",
                    this._onContentDragStart,
                    this
                  ),
                  this._contentDragHelper.on(
                    "drag:end",
                    this._onContentDragEnd,
                    this
                  ),
                  this._contentDragHelper.on(
                    "drag:move",
                    this._onContentDragMove,
                    this
                  ),
                  (this._prevContentSizes[c.Sz] = null),
                  (this._prevContentSizes[c.Yn] = null),
                  this._syncAll();
              }
              _onContentElementLose() {
                this._destroyDragHelper();
              }
              _onContentDragStart() {
                this._contentReference.entity &&
                  this.enabled &&
                  this.entity.enabled &&
                  this._dragStartPosition.copy(
                    this._contentReference.entity.getLocalPosition()
                  );
              }
              _onContentDragEnd() {
                (this._prevContentDragPosition = null),
                  this._enableContentInput();
              }
              _onContentDragMove(e) {
                if (
                  this._contentReference.entity &&
                  this.enabled &&
                  this.entity.enabled &&
                  ((this._wasDragged = !0),
                  this._setScrollFromContentPosition(e),
                  this._setVelocityFromContentPositionDelta(e),
                  !this._disabledContentInput)
                ) {
                  const t = e.x - this._dragStartPosition.x,
                    r = e.y - this._dragStartPosition.y;
                  (Math.abs(t) > this.dragThreshold ||
                    Math.abs(r) > this.dragThreshold) &&
                    this._disableContentInput();
                }
              }
              _onSetContentOrViewportSize() {
                this._syncAll();
              }
              _onSetHorizontalScrollbarValue(e) {
                !this._scrollbarUpdateFlags[c.Sz] &&
                  this.enabled &&
                  this.entity.enabled &&
                  this._onSetScroll(e, null);
              }
              _onSetVerticalScrollbarValue(e) {
                !this._scrollbarUpdateFlags[c.Yn] &&
                  this.enabled &&
                  this.entity.enabled &&
                  this._onSetScroll(null, e);
              }
              _onSetHorizontalScrollingEnabled() {
                this._syncScrollbarEnabledState(c.Sz);
              }
              _onSetVerticalScrollingEnabled() {
                this._syncScrollbarEnabledState(c.Yn);
              }
              _onHorizontalScrollbarGain() {
                this._syncScrollbarEnabledState(c.Sz),
                  this._syncScrollbarPosition(c.Sz);
              }
              _onVerticalScrollbarGain() {
                this._syncScrollbarEnabledState(c.Yn),
                  this._syncScrollbarPosition(c.Yn);
              }
              _onSetScroll(e, t, r) {
                r !== !1 && this._velocity.set(0, 0, 0);
                const u = this._updateAxis(e, "x", c.Sz),
                  v = this._updateAxis(t, "y", c.Yn);
                (u || v) && this.fire("set:scroll", this._scroll);
              }
              _updateAxis(e, t, r) {
                const u = e !== null && Math.abs(e - this._scroll[t]) > 1e-5;
                return (
                  (u || this._isDragging() || e === 0) &&
                    ((this._scroll[t] = this._determineNewScrollValue(e, t, r)),
                    this._syncContentPosition(r),
                    this._syncScrollbarPosition(r)),
                  u
                );
              }
              _determineNewScrollValue(e, t, r) {
                if (!this._getScrollingEnabled(r)) return this._scroll[t];
                switch (this.scrollMode) {
                  case f.Gn:
                    return A.D.clamp(e, 0, this._getMaxScrollValue(r));
                  case f.nQ:
                    return this._setVelocityFromOvershoot(e, t, r), e;
                  case f.ll:
                    return e;
                  default:
                    return (
                      console.warn("Unhandled scroll mode:" + this.scrollMode),
                      e
                    );
                }
              }
              _syncAll() {
                this._syncContentPosition(c.Sz),
                  this._syncContentPosition(c.Yn),
                  this._syncScrollbarPosition(c.Sz),
                  this._syncScrollbarPosition(c.Yn),
                  this._syncScrollbarEnabledState(c.Sz),
                  this._syncScrollbarEnabledState(c.Yn);
              }
              _syncContentPosition(e) {
                const t = this._getAxis(e),
                  r = this._getSign(e),
                  u = this._contentReference.entity;
                if (u) {
                  const v = this._prevContentSizes[e],
                    _ = this._getContentSize(e);
                  if (v !== null && Math.abs(v - _) > 1e-4) {
                    const T = this._getMaxOffset(e, v),
                      E = this._getMaxOffset(e, _);
                    E === 0
                      ? (this._scroll[t] = 1)
                      : (this._scroll[t] = A.D.clamp(
                          (this._scroll[t] * T) / E,
                          0,
                          1
                        ));
                  }
                  const m = this._scroll[t] * this._getMaxOffset(e),
                    g = u.getLocalPosition();
                  (g[t] = m * r),
                    u.setLocalPosition(g),
                    (this._prevContentSizes[e] = _);
                }
              }
              _syncScrollbarPosition(e) {
                const t = this._getAxis(e),
                  r = this._scrollbarReferences[e].entity;
                r &&
                  r.scrollbar &&
                  ((this._scrollbarUpdateFlags[e] = !0),
                  (r.scrollbar.value = this._scroll[t]),
                  (r.scrollbar.handleSize = this._getScrollbarHandleSize(t, e)),
                  (this._scrollbarUpdateFlags[e] = !1));
              }
              _syncScrollbarEnabledState(e) {
                const t = this._scrollbarReferences[e].entity;
                if (t) {
                  const r = this._getScrollingEnabled(e),
                    u = this._getScrollbarVisibility(e);
                  switch (u) {
                    case f.aZ:
                      t.enabled = r;
                      return;
                    case f.xS:
                      t.enabled = r && this._contentIsLargerThanViewport(e);
                      return;
                    default:
                      console.warn("Unhandled scrollbar visibility:" + u),
                        (t.enabled = r);
                  }
                }
              }
              _contentIsLargerThanViewport(e) {
                return this._getContentSize(e) > this._getViewportSize(e);
              }
              _contentPositionToScrollValue(e) {
                const t = this._getMaxOffset(c.Sz),
                  r = this._getMaxOffset(c.Yn);
                return (
                  t === 0 ? (n.x = 0) : (n.x = e.x / t),
                  r === 0 ? (n.y = 0) : (n.y = e.y / -r),
                  n
                );
              }
              _getMaxOffset(e, t) {
                t = t === void 0 ? this._getContentSize(e) : t;
                const r = this._getViewportSize(e);
                return t < r ? -this._getViewportSize(e) : r - t;
              }
              _getMaxScrollValue(e) {
                return this._contentIsLargerThanViewport(e) ? 1 : 0;
              }
              _getScrollbarHandleSize(e, t) {
                const r = this._getViewportSize(t),
                  u = this._getContentSize(t);
                if (Math.abs(u) < 0.001) return 1;
                const v = Math.min(r / u, 1),
                  _ = this._toOvershoot(this._scroll[e], t);
                return _ === 0 ? v : v / (1 + Math.abs(_));
              }
              _getViewportSize(e) {
                return this._getSize(e, this._viewportReference);
              }
              _getContentSize(e) {
                return this._getSize(e, this._contentReference);
              }
              _getSize(e, t) {
                return t.entity && t.entity.element
                  ? t.entity.element[this._getCalculatedDimension(e)]
                  : 0;
              }
              _getScrollingEnabled(e) {
                if (e === c.Sz) return this.horizontal;
                if (e === c.Yn) return this.vertical;
              }
              _getScrollbarVisibility(e) {
                if (e === c.Sz) return this.horizontalScrollbarVisibility;
                if (e === c.Yn) return this.verticalScrollbarVisibility;
              }
              _getSign(e) {
                return e === c.Sz ? 1 : -1;
              }
              _getAxis(e) {
                return e === c.Sz ? "x" : "y";
              }
              _getCalculatedDimension(e) {
                return e === c.Sz ? "calculatedWidth" : "calculatedHeight";
              }
              _destroyDragHelper() {
                this._contentDragHelper && this._contentDragHelper.destroy();
              }
              onUpdate() {
                this._contentReference.entity &&
                  (this._updateVelocity(),
                  this._syncScrollbarEnabledState(c.Sz),
                  this._syncScrollbarEnabledState(c.Yn));
              }
              _updateVelocity() {
                if (!this._isDragging()) {
                  if (
                    (this.scrollMode === f.nQ &&
                      (this._hasOvershoot("x", c.Sz) &&
                        this._setVelocityFromOvershoot(
                          this.scroll.x,
                          "x",
                          c.Sz
                        ),
                      this._hasOvershoot("y", c.Yn) &&
                        this._setVelocityFromOvershoot(
                          this.scroll.y,
                          "y",
                          c.Yn
                        )),
                    Math.abs(this._velocity.x) > 1e-4 ||
                      Math.abs(this._velocity.y) > 1e-4)
                  ) {
                    const e = this._contentReference.entity.getLocalPosition();
                    (e.x += this._velocity.x),
                      (e.y += this._velocity.y),
                      this._contentReference.entity.setLocalPosition(e),
                      this._setScrollFromContentPosition(e);
                  }
                  (this._velocity.x *= 1 - this.friction),
                    (this._velocity.y *= 1 - this.friction);
                }
              }
              _hasOvershoot(e, t) {
                return Math.abs(this._toOvershoot(this.scroll[e], t)) > 0.001;
              }
              _toOvershoot(e, t) {
                const r = this._getMaxScrollValue(t);
                return e < 0 ? e : e > r ? e - r : 0;
              }
              _setVelocityFromOvershoot(e, t, r) {
                const v =
                  this._toOvershoot(e, r) *
                  this._getMaxOffset(r) *
                  this._getSign(r);
                Math.abs(v) > 0 &&
                  (this._velocity[t] = -v / (this.bounceAmount * 50 + 1));
              }
              _setVelocityFromContentPositionDelta(e) {
                this._prevContentDragPosition
                  ? (this._velocity.sub2(e, this._prevContentDragPosition),
                    this._prevContentDragPosition.copy(e))
                  : (this._velocity.set(0, 0, 0),
                    (this._prevContentDragPosition = e.clone()));
              }
              _setScrollFromContentPosition(e) {
                let t = this._contentPositionToScrollValue(e);
                this._isDragging() && (t = this._applyScrollValueTension(t)),
                  this._onSetScroll(t.x, t.y, !1);
              }
              _applyScrollValueTension(e) {
                let r = this._getMaxScrollValue(c.Sz),
                  u = this._toOvershoot(e.x, c.Sz);
                return (
                  u > 0
                    ? (e.x = r + 1 * Math.log10(1 + u))
                    : u < 0 && (e.x = -1 * Math.log10(1 - u)),
                  (r = this._getMaxScrollValue(c.Yn)),
                  (u = this._toOvershoot(e.y, c.Yn)),
                  u > 0
                    ? (e.y = r + 1 * Math.log10(1 + u))
                    : u < 0 && (e.y = -1 * Math.log10(1 - u)),
                  e
                );
              }
              _isDragging() {
                return (
                  this._contentDragHelper && this._contentDragHelper.isDragging
                );
              }
              _setScrollbarComponentsEnabled(e) {
                this._scrollbarReferences[c.Sz].hasComponent("scrollbar") &&
                  (this._scrollbarReferences[c.Sz].entity.scrollbar.enabled =
                    e),
                  this._scrollbarReferences[c.Yn].hasComponent("scrollbar") &&
                    (this._scrollbarReferences[c.Yn].entity.scrollbar.enabled =
                      e);
              }
              _setContentDraggingEnabled(e) {
                this._contentDragHelper &&
                  (this._contentDragHelper.enabled = e);
              }
              _onMouseWheel(e) {
                if (this.useMouseWheel) {
                  const t = e.event,
                    r =
                      (t.deltaX /
                        this._contentReference.entity.element.calculatedWidth) *
                      this.mouseWheelSensitivity.x,
                    u =
                      (t.deltaY /
                        this._contentReference.entity.element
                          .calculatedHeight) *
                      this.mouseWheelSensitivity.y,
                    v = A.D.clamp(
                      this._scroll.x + r,
                      0,
                      this._getMaxScrollValue(c.Sz)
                    ),
                    _ = A.D.clamp(
                      this._scroll.y + u,
                      0,
                      this._getMaxScrollValue(c.Yn)
                    );
                  this.scroll = new x.Z(v, _);
                }
              }
              _enableContentInput() {
                for (; this._disabledContentInputEntities.length; ) {
                  const e = this._disabledContentInputEntities.pop();
                  e.element && (e.element.useInput = !0);
                }
                this._disabledContentInput = !1;
              }
              _disableContentInput() {
                const e = (r) => {
                    r.element &&
                      r.element.useInput &&
                      (this._disabledContentInputEntities.push(r),
                      (r.element.useInput = !1));
                    const u = r.children;
                    for (let v = 0, _ = u.length; v < _; v++) e(u[v]);
                  },
                  t = this._contentReference.entity;
                if (t) {
                  const r = t.children;
                  for (let u = 0, v = r.length; u < v; u++) e(r[u]);
                }
                this._disabledContentInput = !0;
              }
              onEnable() {
                this._viewportReference.onParentComponentEnable(),
                  this._contentReference.onParentComponentEnable(),
                  this._scrollbarReferences[c.Sz].onParentComponentEnable(),
                  this._scrollbarReferences[c.Yn].onParentComponentEnable(),
                  this._setScrollbarComponentsEnabled(!0),
                  this._setContentDraggingEnabled(!0),
                  this._syncAll();
              }
              onDisable() {
                this._setScrollbarComponentsEnabled(!1),
                  this._setContentDraggingEnabled(!1);
              }
              onRemove() {
                this._toggleLifecycleListeners("off", this.system),
                  this._toggleElementListeners("off"),
                  this._destroyDragHelper();
              }
              set scroll(e) {
                this._onSetScroll(e.x, e.y);
              }
              get scroll() {
                return this._scroll;
              }
            }
          },
          3940: (xe, V, a) => {
            "use strict";
            a.d(V, {
              Gn: () => A,
              aZ: () => c,
              ll: () => y,
              nQ: () => x,
              xS: () => d,
            });
            const A = 0,
              x = 1,
              y = 2,
              c = 0,
              d = 1;
          },
          2281: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => s });
            var A = a(4124),
              x = a(2930),
              y = a(406);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            var d = a(7994);
            const h = [
                { name: "enabled", type: "boolean" },
                { name: "horizontal", type: "boolean" },
                { name: "vertical", type: "boolean" },
                { name: "scrollMode", type: "number" },
                { name: "bounceAmount", type: "number" },
                { name: "friction", type: "number" },
                { name: "dragThreshold", type: "number" },
                { name: "useMouseWheel", type: "boolean" },
                { name: "mouseWheelSensitivity", type: "vec2" },
                { name: "horizontalScrollbarVisibility", type: "number" },
                { name: "verticalScrollbarVisibility", type: "number" },
                { name: "viewportEntity", type: "entity" },
                { name: "contentEntity", type: "entity" },
                { name: "horizontalScrollbarEntity", type: "entity" },
                { name: "verticalScrollbarEntity", type: "entity" },
              ],
              f = 10;
            class s extends x.r {
              constructor(n) {
                super(n),
                  (this.id = "scrollview"),
                  (this.ComponentType = y.I),
                  (this.DataType = c),
                  (this.schema = h),
                  this.on("beforeremove", this._onRemoveComponent, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(n, o, i) {
                o.dragThreshold === void 0 && (o.dragThreshold = f),
                  o.useMouseWheel === void 0 && (o.useMouseWheel = !0),
                  o.mouseWheelSensitivity === void 0 &&
                    (o.mouseWheelSensitivity = new d.Z(1, 1)),
                  super.initializeComponentData(n, o, h);
              }
              onUpdate(n) {
                const o = this.store;
                for (const i in o) {
                  const e = o[i].entity,
                    t = e.scrollview;
                  t.enabled && e.enabled && t.onUpdate();
                }
              }
              _onRemoveComponent(n, o) {
                o.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            A.u._buildAccessors(y.I.prototype, h);
          },
          393: (xe, V, a) => {
            "use strict";
            a.d(V, { G: () => h });
            var A = a(8656),
              x = a(9391),
              y = a(4124),
              c = a(8219),
              d = a(1657);
            class h extends y.u {
              constructor(s, l) {
                super(s, l),
                  (this._handleReference = new d.D(this, "handleEntity", {
                    "element#gain": this._onHandleElementGain,
                    "element#lose": this._onHandleElementLose,
                    "element#set:anchor": this._onSetHandleAlignment,
                    "element#set:margin": this._onSetHandleAlignment,
                    "element#set:pivot": this._onSetHandleAlignment,
                  })),
                  this._toggleLifecycleListeners("on");
              }
              _toggleLifecycleListeners(s) {
                this[s]("set_value", this._onSetValue, this),
                  this[s]("set_handleSize", this._onSetHandleSize, this),
                  this[s]("set_orientation", this._onSetOrientation, this);
              }
              _onHandleElementGain() {
                this._destroyDragHelper(),
                  (this._handleDragHelper = new c.h(
                    this._handleReference.entity.element,
                    this._getAxis()
                  )),
                  this._handleDragHelper.on(
                    "drag:move",
                    this._onHandleDrag,
                    this
                  ),
                  this._updateHandlePositionAndSize();
              }
              _onHandleElementLose() {
                this._destroyDragHelper();
              }
              _onHandleDrag(s) {
                this._handleReference.entity &&
                  this.enabled &&
                  this.entity.enabled &&
                  (this.value = this._handlePositionToScrollValue(
                    s[this._getAxis()]
                  ));
              }
              _onSetValue(s, l, n) {
                Math.abs(n - l) > 1e-5 &&
                  ((this.data.value = A.D.clamp(n, 0, 1)),
                  this._updateHandlePositionAndSize(),
                  this.fire("set:value", this.data.value));
              }
              _onSetHandleSize(s, l, n) {
                Math.abs(n - l) > 1e-5 &&
                  ((this.data.handleSize = A.D.clamp(n, 0, 1)),
                  this._updateHandlePositionAndSize());
              }
              _onSetHandleAlignment() {
                this._updateHandlePositionAndSize();
              }
              _onSetOrientation(s, l, n) {
                n !== l &&
                  this._handleReference.hasComponent("element") &&
                  (this._handleReference.entity.element[
                    this._getOppositeDimension()
                  ] = 0);
              }
              _updateHandlePositionAndSize() {
                const s = this._handleReference.entity,
                  l = s && s.element;
                if (s) {
                  const n = s.getLocalPosition();
                  (n[this._getAxis()] = this._getHandlePosition()),
                    this._handleReference.entity.setLocalPosition(n);
                }
                l && (l[this._getDimension()] = this._getHandleLength());
              }
              _handlePositionToScrollValue(s) {
                return (s * this._getSign()) / this._getUsableTrackLength();
              }
              _scrollValueToHandlePosition(s) {
                return s * this._getSign() * this._getUsableTrackLength();
              }
              _getUsableTrackLength() {
                return Math.max(
                  this._getTrackLength() - this._getHandleLength(),
                  0.001
                );
              }
              _getTrackLength() {
                return this.entity.element
                  ? this.orientation === x.Sz
                    ? this.entity.element.calculatedWidth
                    : this.entity.element.calculatedHeight
                  : 0;
              }
              _getHandleLength() {
                return this._getTrackLength() * this.handleSize;
              }
              _getHandlePosition() {
                return this._scrollValueToHandlePosition(this.value);
              }
              _getSign() {
                return this.orientation === x.Sz ? 1 : -1;
              }
              _getAxis() {
                return this.orientation === x.Sz ? "x" : "y";
              }
              _getDimension() {
                return this.orientation === x.Sz ? "width" : "height";
              }
              _getOppositeDimension() {
                return this.orientation === x.Sz ? "height" : "width";
              }
              _destroyDragHelper() {
                this._handleDragHelper && this._handleDragHelper.destroy();
              }
              _setHandleDraggingEnabled(s) {
                this._handleDragHelper && (this._handleDragHelper.enabled = s);
              }
              onEnable() {
                this._handleReference.onParentComponentEnable(),
                  this._setHandleDraggingEnabled(!0);
              }
              onDisable() {
                this._setHandleDraggingEnabled(!1);
              }
              onRemove() {
                this._destroyDragHelper(),
                  this._toggleLifecycleListeners("off");
              }
            }
          },
          5902: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => h });
            var A = a(4124),
              x = a(2930),
              y = a(393);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = [
              { name: "enabled", type: "boolean" },
              { name: "orientation", type: "number" },
              { name: "value", type: "number" },
              { name: "handleSize", type: "number" },
              { name: "handleEntity", type: "entity" },
            ];
            class h extends x.r {
              constructor(s) {
                super(s),
                  (this.id = "scrollbar"),
                  (this.ComponentType = y.G),
                  (this.DataType = c),
                  (this.schema = d),
                  this.on("beforeremove", this._onRemoveComponent, this);
              }
              initializeComponentData(s, l, n) {
                super.initializeComponentData(s, l, d);
              }
              _onRemoveComponent(s, l) {
                l.onRemove();
              }
            }
            A.u._buildAccessors(y.G.prototype, d);
          },
          5460: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => c });
            var A = a(1145),
              x = a(4124),
              y = a(4963);
            class c extends x.u {
              constructor(h, f) {
                super(h, f),
                  (this._volume = 1),
                  (this._pitch = 1),
                  (this._positional = !0),
                  (this._refDistance = 1),
                  (this._maxDistance = 1e4),
                  (this._rollOffFactor = 1),
                  (this._distanceModel = A.q9),
                  (this._slots = {}),
                  (this._playingBeforeDisable = {});
              }
              _updateSoundInstances(h, f, s) {
                const l = this._slots;
                for (const n in l) {
                  const o = l[n];
                  if (!o.overlap) {
                    const i = o.instances;
                    for (let e = 0, t = i.length; e < t; e++)
                      i[e][h] = s ? o[h] * f : f;
                  }
                }
              }
              set distanceModel(h) {
                (this._distanceModel = h),
                  this._updateSoundInstances("distanceModel", h, !1);
              }
              get distanceModel() {
                return this._distanceModel;
              }
              set maxDistance(h) {
                (this._maxDistance = h),
                  this._updateSoundInstances("maxDistance", h, !1);
              }
              get maxDistance() {
                return this._maxDistance;
              }
              set refDistance(h) {
                (this._refDistance = h),
                  this._updateSoundInstances("refDistance", h, !1);
              }
              get refDistance() {
                return this._refDistance;
              }
              set rollOffFactor(h) {
                (this._rollOffFactor = h),
                  this._updateSoundInstances("rollOffFactor", h, !1);
              }
              get rollOffFactor() {
                return this._rollOffFactor;
              }
              set pitch(h) {
                (this._pitch = h), this._updateSoundInstances("pitch", h, !0);
              }
              get pitch() {
                return this._pitch;
              }
              set volume(h) {
                (this._volume = h), this._updateSoundInstances("volume", h, !0);
              }
              get volume() {
                return this._volume;
              }
              set positional(h) {
                this._positional = h;
                const f = this._slots;
                for (const s in f) {
                  const l = f[s];
                  if (!l.overlap) {
                    const n = l.instances,
                      o = n.length;
                    for (let i = o - 1; i >= 0; i--) {
                      const e = n[i].isPlaying || n[i].isSuspended,
                        t = n[i].currentTime;
                      e && n[i].stop();
                      const r = l._createInstance();
                      e && (r.play(), (r.currentTime = t)), n.push(r);
                    }
                  }
                }
              }
              get positional() {
                return this._positional;
              }
              set slots(h) {
                const f = this._slots;
                if (f) for (const l in f) f[l].stop();
                const s = {};
                for (const l in h)
                  h[l] instanceof y.a
                    ? (s[h[l].name] = h[l])
                    : h[l].name &&
                      (s[h[l].name] = new y.a(this, h[l].name, h[l]));
                (this._slots = s),
                  this.enabled && this.entity.enabled && this.onEnable();
              }
              get slots() {
                return this._slots;
              }
              onEnable() {
                if (this.system._inTools) return;
                const h = this._slots,
                  f = this._playingBeforeDisable;
                for (const s in h) {
                  const l = h[s];
                  l.autoPlay && l.isStopped
                    ? l.play()
                    : f[s]
                    ? l.resume()
                    : l.isLoaded || l.load();
                }
              }
              onDisable() {
                const h = this._slots,
                  f = {};
                for (const s in h)
                  h[s].overlap ||
                    (h[s].isPlaying && (h[s].pause(), (f[s] = !0)));
                this._playingBeforeDisable = f;
              }
              onRemove() {
                this.off();
              }
              addSlot(h, f) {
                const s = this._slots;
                if (s[h]) return null;
                const l = new y.a(this, h, f);
                return (
                  (s[h] = l),
                  l.autoPlay && this.enabled && this.entity.enabled && l.play(),
                  l
                );
              }
              removeSlot(h) {
                const f = this._slots;
                f[h] && (f[h].stop(), delete f[h]);
              }
              slot(h) {
                return this._slots[h];
              }
              _getSlotProperty(h, f) {
                if (!this.enabled || !this.entity.enabled) return;
                const s = this._slots[h];
                if (s) return s[f];
              }
              isPlaying(h) {
                return this._getSlotProperty(h, "isPlaying") || !1;
              }
              isLoaded(h) {
                return this._getSlotProperty(h, "isLoaded") || !1;
              }
              isPaused(h) {
                return this._getSlotProperty(h, "isPaused") || !1;
              }
              isStopped(h) {
                return this._getSlotProperty(h, "isStopped") || !1;
              }
              play(h) {
                if (!this.enabled || !this.entity.enabled) return null;
                const f = this._slots[h];
                return f ? f.play() : null;
              }
              pause(h) {
                const f = this._slots;
                if (h) {
                  const s = f[h];
                  if (!s) return;
                  s.pause();
                } else for (const s in f) f[s].pause();
              }
              resume(h) {
                const f = this._slots;
                if (h) {
                  const s = f[h];
                  if (!s) return;
                  s.isPaused && s.resume();
                } else for (const s in f) f[s].resume();
              }
              stop(h) {
                const f = this._slots;
                if (h) {
                  const s = f[h];
                  if (!s) return;
                  s.stop();
                } else for (const s in f) f[s].stop();
              }
            }
          },
          4963: (xe, V, a) => {
            "use strict";
            a.d(V, { a: () => s });
            var A = a(8976),
              x = a(8656),
              y = a(7481),
              c = a(3953),
              d = a(6046),
              h = a(7365);
            const f = {
              volume: 0,
              pitch: 0,
              loop: !1,
              startTime: 0,
              duration: 0,
              position: new y.e(),
              maxDistance: 0,
              refDistance: 0,
              rollOffFactor: 0,
              distanceModel: 0,
              onPlay: null,
              onPause: null,
              onResume: null,
              onStop: null,
              onEnd: null,
            };
            class s extends A.J {
              constructor(n, o = "Untitled", i = {}) {
                super(),
                  (this.name = void 0),
                  (this.instances = []),
                  (this._component = n),
                  (this._assets = n.system.app.assets),
                  (this._manager = n.system.manager),
                  (this.name = o),
                  (this._volume =
                    i.volume !== void 0
                      ? x.D.clamp(Number(i.volume) || 0, 0, 1)
                      : 1),
                  (this._pitch =
                    i.pitch !== void 0
                      ? Math.max(0.01, Number(i.pitch) || 0)
                      : 1),
                  (this._loop = !!(i.loop !== void 0 && i.loop)),
                  (this._duration = i.duration > 0 ? i.duration : null),
                  (this._startTime = Math.max(0, Number(i.startTime) || 0)),
                  (this._overlap = !!i.overlap),
                  (this._autoPlay = !!i.autoPlay),
                  (this._firstNode = null),
                  (this._lastNode = null),
                  (this._asset = i.asset),
                  this._asset instanceof c.V && (this._asset = this._asset.id),
                  (this._onInstancePlayHandler =
                    this._onInstancePlay.bind(this)),
                  (this._onInstancePauseHandler =
                    this._onInstancePause.bind(this)),
                  (this._onInstanceResumeHandler =
                    this._onInstanceResume.bind(this)),
                  (this._onInstanceStopHandler =
                    this._onInstanceStop.bind(this)),
                  (this._onInstanceEndHandler = this._onInstanceEnd.bind(this));
              }
              play() {
                if (
                  (this.overlap || this.stop(),
                  !this.isLoaded && !this._hasAsset())
                )
                  return;
                const n = this._createInstance();
                if ((this.instances.push(n), this.isLoaded)) n.play();
                else {
                  const o = function (e) {
                    const t = n._playWhenLoaded;
                    (n.sound = e), t && n.play();
                  };
                  this.off("load", o), this.once("load", o), this.load();
                }
                return n;
              }
              pause() {
                let n = !1;
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i].pause() && (n = !0);
                return n;
              }
              resume() {
                let n = !1;
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i].resume() && (n = !0);
                return n;
              }
              stop() {
                let n = !1;
                const o = this.instances;
                let i = o.length;
                for (; i--; ) o[i].stop(), (n = !0);
                return (o.length = 0), n;
              }
              load() {
                if (!this._hasAsset()) return;
                const n = this._assets.get(this._asset);
                if (!n) {
                  this._assets.off(
                    "add:" + this._asset,
                    this._onAssetAdd,
                    this
                  ),
                    this._assets.once(
                      "add:" + this._asset,
                      this._onAssetAdd,
                      this
                    );
                  return;
                }
                if (
                  (n.off("remove", this._onAssetRemoved, this),
                  n.on("remove", this._onAssetRemoved, this),
                  !n.resource)
                ) {
                  n.off("load", this._onAssetLoad, this),
                    n.once("load", this._onAssetLoad, this),
                    this._assets.load(n);
                  return;
                }
                this.fire("load", n.resource);
              }
              setExternalNodes(n, o) {
                if (!n) {
                  console.error("The firstNode must have a valid AudioNode");
                  return;
                }
                if (
                  (o || (o = n),
                  (this._firstNode = n),
                  (this._lastNode = o),
                  !this._overlap)
                ) {
                  const i = this.instances;
                  for (let e = 0, t = i.length; e < t; e++)
                    i[e].setExternalNodes(n, o);
                }
              }
              clearExternalNodes() {
                if (
                  ((this._firstNode = null),
                  (this._lastNode = null),
                  !this._overlap)
                ) {
                  const n = this.instances;
                  for (let o = 0, i = n.length; o < i; o++)
                    n[o].clearExternalNodes();
                }
              }
              getExternalNodes() {
                return [this._firstNode, this._lastNode];
              }
              _hasAsset() {
                return this._asset != null;
              }
              _createInstance() {
                let n = null;
                const o = this._component;
                let i = null;
                if (this._hasAsset()) {
                  const t = this._assets.get(this._asset);
                  t && (i = t.resource);
                }
                const e = f;
                return (
                  (e.volume = this._volume * o.volume),
                  (e.pitch = this._pitch * o.pitch),
                  (e.loop = this._loop),
                  (e.startTime = this._startTime),
                  (e.duration = this._duration),
                  (e.onPlay = this._onInstancePlayHandler),
                  (e.onPause = this._onInstancePauseHandler),
                  (e.onResume = this._onInstanceResumeHandler),
                  (e.onStop = this._onInstanceStopHandler),
                  (e.onEnd = this._onInstanceEndHandler),
                  o.positional
                    ? (e.position.copy(o.entity.getPosition()),
                      (e.maxDistance = o.maxDistance),
                      (e.refDistance = o.refDistance),
                      (e.rollOffFactor = o.rollOffFactor),
                      (e.distanceModel = o.distanceModel),
                      (n = new h.S(this._manager, i, e)))
                    : (n = new d.X(this._manager, i, e)),
                  this._firstNode &&
                    n.setExternalNodes(this._firstNode, this._lastNode),
                  n
                );
              }
              _onInstancePlay(n) {
                this.fire("play", n), this._component.fire("play", this, n);
              }
              _onInstancePause(n) {
                this.fire("pause", n), this._component.fire("pause", this, n);
              }
              _onInstanceResume(n) {
                this.fire("resume", n), this._component.fire("resume", this, n);
              }
              _onInstanceStop(n) {
                const o = this.instances.indexOf(n);
                o !== -1 && this.instances.splice(o, 1),
                  this.fire("stop", n),
                  this._component.fire("stop", this, n);
              }
              _onInstanceEnd(n) {
                const o = this.instances.indexOf(n);
                o !== -1 && this.instances.splice(o, 1),
                  this.fire("end", n),
                  this._component.fire("end", this, n);
              }
              _onAssetAdd(n) {
                this.load();
              }
              _onAssetLoad(n) {
                this.load();
              }
              _onAssetRemoved(n) {
                n.off("remove", this._onAssetRemoved, this),
                  this._assets.off("add:" + n.id, this._onAssetAdd, this),
                  this.stop();
              }
              updatePosition(n) {
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++) o[i].position = n;
              }
              set asset(n) {
                const o = this._asset;
                if (o) {
                  this._assets.off("add:" + o, this._onAssetAdd, this);
                  const i = this._assets.get(o);
                  i && i.off("remove", this._onAssetRemoved, this);
                }
                (this._asset = n),
                  this._asset instanceof c.V && (this._asset = this._asset.id),
                  this._hasAsset() &&
                    this._component.enabled &&
                    this._component.entity.enabled &&
                    this.load();
              }
              get asset() {
                return this._asset;
              }
              set autoPlay(n) {
                this._autoPlay = !!n;
              }
              get autoPlay() {
                return this._autoPlay;
              }
              set duration(n) {
                if (
                  ((this._duration = Math.max(0, Number(n) || 0) || null),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].duration = this._duration;
                }
              }
              get duration() {
                let n = 0;
                if (this._hasAsset()) {
                  const o = this._assets.get(this._asset);
                  n = o != null && o.resource ? o.resource.duration : 0;
                }
                return this._duration != null ? this._duration % (n || 1) : n;
              }
              get isLoaded() {
                if (this._hasAsset()) {
                  const n = this._assets.get(this._asset);
                  if (n) return !!n.resource;
                }
                return !1;
              }
              get isPaused() {
                const n = this.instances,
                  o = n.length;
                if (o === 0) return !1;
                for (let i = 0; i < o; i++) if (!n[i].isPaused) return !1;
                return !0;
              }
              get isPlaying() {
                const n = this.instances;
                for (let o = 0, i = n.length; o < i; o++)
                  if (n[o].isPlaying) return !0;
                return !1;
              }
              get isStopped() {
                const n = this.instances;
                for (let o = 0, i = n.length; o < i; o++)
                  if (!n[o].isStopped) return !1;
                return !0;
              }
              set loop(n) {
                this._loop = !!n;
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i].loop = this._loop;
              }
              get loop() {
                return this._loop;
              }
              set overlap(n) {
                this._overlap = !!n;
              }
              get overlap() {
                return this._overlap;
              }
              set pitch(n) {
                if (
                  ((this._pitch = Math.max(Number(n) || 0, 0.01)),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].pitch = this.pitch * this._component.pitch;
                }
              }
              get pitch() {
                return this._pitch;
              }
              set startTime(n) {
                if (
                  ((this._startTime = Math.max(0, Number(n) || 0)),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].startTime = this._startTime;
                }
              }
              get startTime() {
                return this._startTime;
              }
              set volume(n) {
                if (
                  ((this._volume = x.D.clamp(Number(n) || 0, 0, 1)),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].volume = this._volume * this._component.volume;
                }
              }
              get volume() {
                return this._volume;
              }
            }
          },
          5003: (xe, V, a) => {
            "use strict";
            a.d(V, { m: () => f });
            var A = a(9104),
              x = a(4124),
              y = a(2930),
              c = a(5460);
            class d {
              constructor() {
                this.enabled = !0;
              }
            }
            const h = ["enabled"];
            class f extends y.r {
              constructor(l) {
                super(l),
                  (this.id = "sound"),
                  (this.ComponentType = c.F),
                  (this.DataType = d),
                  (this.schema = h),
                  (this.manager = l.soundManager),
                  this.app.systems.on("update", this.onUpdate, this),
                  this.on("beforeremove", this.onBeforeRemove, this);
              }
              set volume(l) {
                this.manager.volume = l;
              }
              get volume() {
                return this.manager.volume;
              }
              get context() {
                return (0, A.U)() ? this.manager.context : null;
              }
              initializeComponentData(l, n, o) {
                o = [
                  "volume",
                  "pitch",
                  "positional",
                  "refDistance",
                  "maxDistance",
                  "rollOffFactor",
                  "distanceModel",
                  "slots",
                ];
                for (let i = 0; i < o.length; i++)
                  n.hasOwnProperty(o[i]) && (l[o[i]] = n[o[i]]);
                super.initializeComponentData(l, n, ["enabled"]);
              }
              cloneComponent(l, n) {
                const o = l.sound,
                  i = o.slots,
                  e = {};
                for (const r in i) {
                  const u = i[r];
                  e[r] = {
                    name: u.name,
                    volume: u.volume,
                    pitch: u.pitch,
                    loop: u.loop,
                    duration: u.duration,
                    startTime: u.startTime,
                    overlap: u.overlap,
                    autoPlay: u.autoPlay,
                    asset: u.asset,
                  };
                }
                const t = {
                  distanceModel: o.distanceModel,
                  enabled: o.enabled,
                  maxDistance: o.maxDistance,
                  pitch: o.pitch,
                  positional: o.positional,
                  refDistance: o.refDistance,
                  rollOffFactor: o.rollOffFactor,
                  slots: e,
                  volume: o.volume,
                };
                return this.addComponent(n, t);
              }
              onUpdate(l) {
                const n = this.store;
                for (const o in n)
                  if (n.hasOwnProperty(o)) {
                    const e = n[o].entity;
                    if (e.enabled) {
                      const t = e.sound;
                      if (t.enabled && t.positional) {
                        const r = e.getPosition(),
                          u = t.slots;
                        for (const v in u) u[v].updatePosition(r);
                      }
                    }
                  }
              }
              onBeforeRemove(l, n) {
                const o = n.slots;
                for (const i in o) o[i].overlap || o[i].stop();
                n.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            x.u._buildAccessors(c.F.prototype, h);
          },
          9882: (xe, V, a) => {
            "use strict";
            a.d(V, { V: () => g });
            var A = a(8656),
              x = a(5227),
              y = a(7994),
              c = a(5596),
              d = a(9391),
              h = a(5041),
              f = a(3035),
              s = a(3637),
              l = a(9611),
              n = a(4124),
              o = a(7288),
              i = a(7562);
            const e = "texture_emissiveMap",
              t = "texture_opacityMap",
              r = "material_emissive",
              u = "material_opacity",
              v = "innerOffset",
              _ = "outerScale",
              m = "atlasRect";
            class g extends n.u {
              constructor(E, M) {
                super(E, M),
                  (this._type = o.z),
                  (this._material = E.defaultMaterial),
                  (this._color = new x.Q(1, 1, 1, 1)),
                  (this._colorUniform = new Float32Array(3)),
                  (this._speed = 1),
                  (this._flipX = !1),
                  (this._flipY = !1),
                  (this._width = 1),
                  (this._height = 1),
                  (this._drawOrder = 0),
                  (this._layers = [d.uE]),
                  (this._outerScale = new y.Z(1, 1)),
                  (this._outerScaleUniform = new Float32Array(2)),
                  (this._innerOffset = new c.Z()),
                  (this._innerOffsetUniform = new Float32Array(4)),
                  (this._atlasRect = new c.Z()),
                  (this._atlasRectUniform = new Float32Array(4)),
                  (this._batchGroupId = -1),
                  (this._batchGroup = null),
                  (this._node = new f.t()),
                  (this._model = new l.K()),
                  (this._model.graph = this._node),
                  (this._meshInstance = null),
                  M.addChild(this._model.graph),
                  (this._model._entity = M),
                  (this._updateAabbFunc = this._updateAabb.bind(this)),
                  (this._addedModel = !1),
                  (this._autoPlayClip = null),
                  (this._clips = {}),
                  (this._defaultClip = new i.u(this, {
                    name: this.entity.name,
                    fps: 0,
                    loop: !1,
                    spriteAsset: null,
                  })),
                  (this._currentClip = this._defaultClip);
              }
              set type(E) {
                this._type !== E &&
                  ((this._type = E),
                  this._type === o.z
                    ? (this.stop(),
                      (this._currentClip = this._defaultClip),
                      this.enabled &&
                        this.entity.enabled &&
                        ((this._currentClip.frame = this.frame),
                        this._currentClip.sprite
                          ? this._showModel()
                          : this._hideModel()))
                    : this._type === o.s &&
                      (this.stop(),
                      this._autoPlayClip && this._tryAutoPlay(),
                      this._currentClip &&
                      this._currentClip.isPlaying &&
                      this.enabled &&
                      this.entity.enabled
                        ? this._showModel()
                        : this._hideModel()));
              }
              get type() {
                return this._type;
              }
              set frame(E) {
                this._currentClip.frame = E;
              }
              get frame() {
                return this._currentClip.frame;
              }
              set spriteAsset(E) {
                this._defaultClip.spriteAsset = E;
              }
              get spriteAsset() {
                return this._defaultClip._spriteAsset;
              }
              set sprite(E) {
                this._currentClip.sprite = E;
              }
              get sprite() {
                return this._currentClip.sprite;
              }
              set material(E) {
                (this._material = E),
                  this._meshInstance && (this._meshInstance.material = E);
              }
              get material() {
                return this._material;
              }
              set color(E) {
                (this._color.r = E.r),
                  (this._color.g = E.g),
                  (this._color.b = E.b),
                  this._meshInstance &&
                    ((this._colorUniform[0] = this._color.r),
                    (this._colorUniform[1] = this._color.g),
                    (this._colorUniform[2] = this._color.b),
                    this._meshInstance.setParameter(r, this._colorUniform));
              }
              get color() {
                return this._color;
              }
              set opacity(E) {
                (this._color.a = E),
                  this._meshInstance && this._meshInstance.setParameter(u, E);
              }
              get opacity() {
                return this._color.a;
              }
              set clips(E) {
                if (!E) {
                  for (const M in this._clips) this.removeClip(M);
                  return;
                }
                for (const M in this._clips) {
                  let R = !1;
                  for (const P in E)
                    if (E[P].name === M) {
                      (R = !0),
                        (this._clips[M].fps = E[P].fps),
                        (this._clips[M].loop = E[P].loop),
                        E[P].hasOwnProperty("sprite")
                          ? (this._clips[M].sprite = E[P].sprite)
                          : E[P].hasOwnProperty("spriteAsset") &&
                            (this._clips[M].spriteAsset = E[P].spriteAsset);
                      break;
                    }
                  R || this.removeClip(M);
                }
                for (const M in E) this._clips[E[M].name] || this.addClip(E[M]);
                this._autoPlayClip && this._tryAutoPlay(),
                  (!this._currentClip || !this._currentClip.sprite) &&
                    this._hideModel();
              }
              get clips() {
                return this._clips;
              }
              get currentClip() {
                return this._currentClip;
              }
              set speed(E) {
                this._speed = E;
              }
              get speed() {
                return this._speed;
              }
              set flipX(E) {
                this._flipX !== E &&
                  ((this._flipX = E), this._updateTransform());
              }
              get flipX() {
                return this._flipX;
              }
              set flipY(E) {
                this._flipY !== E &&
                  ((this._flipY = E), this._updateTransform());
              }
              get flipY() {
                return this._flipY;
              }
              set width(E) {
                E !== this._width &&
                  ((this._width = E),
                  (this._outerScale.x = this._width),
                  this.sprite &&
                    (this.sprite.renderMode === d.jZ ||
                      this.sprite.renderMode === d.FC) &&
                    this._updateTransform());
              }
              get width() {
                return this._width;
              }
              set height(E) {
                E !== this._height &&
                  ((this._height = E),
                  (this._outerScale.y = this.height),
                  this.sprite &&
                    (this.sprite.renderMode === d.jZ ||
                      this.sprite.renderMode === d.FC) &&
                    this._updateTransform());
              }
              get height() {
                return this._height;
              }
              set batchGroupId(E) {
                if (this._batchGroupId === E) return;
                const M = this._batchGroupId;
                if (((this._batchGroupId = E), this.entity.enabled && M >= 0)) {
                  var R;
                  (R = this.system.app.batcher) == null ||
                    R.remove(h.w.SPRITE, M, this.entity);
                }
                if (this.entity.enabled && E >= 0) {
                  var P;
                  (P = this.system.app.batcher) == null ||
                    P.insert(h.w.SPRITE, E, this.entity);
                } else
                  M >= 0 &&
                    this._currentClip &&
                    this._currentClip.sprite &&
                    this.enabled &&
                    this.entity.enabled &&
                    this._showModel();
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set autoPlayClip(E) {
                (this._autoPlayClip = E instanceof i.u ? E.name : E),
                  this._tryAutoPlay();
              }
              get autoPlayClip() {
                return this._autoPlayClip;
              }
              set drawOrder(E) {
                (this._drawOrder = E),
                  this._meshInstance && (this._meshInstance.drawOrder = E);
              }
              get drawOrder() {
                return this._drawOrder;
              }
              set layers(E) {
                this._addedModel && this._hideModel(),
                  (this._layers = E),
                  this._meshInstance &&
                    this.enabled &&
                    this.entity.enabled &&
                    this._showModel();
              }
              get layers() {
                return this._layers;
              }
              get aabb() {
                return this._meshInstance ? this._meshInstance.aabb : null;
              }
              onEnable() {
                const E = this.system.app,
                  M = E.scene;
                if (
                  (M.on("set:layers", this._onLayersChanged, this),
                  M.layers &&
                    (M.layers.on("add", this._onLayerAdded, this),
                    M.layers.on("remove", this._onLayerRemoved, this)),
                  this._showModel(),
                  this._autoPlayClip && this._tryAutoPlay(),
                  this._batchGroupId >= 0)
                ) {
                  var R;
                  (R = E.batcher) == null ||
                    R.insert(h.w.SPRITE, this._batchGroupId, this.entity);
                }
              }
              onDisable() {
                const E = this.system.app,
                  M = E.scene;
                if (
                  (M.off("set:layers", this._onLayersChanged, this),
                  M.layers &&
                    (M.layers.off("add", this._onLayerAdded, this),
                    M.layers.off("remove", this._onLayerRemoved, this)),
                  this.stop(),
                  this._hideModel(),
                  this._batchGroupId >= 0)
                ) {
                  var R;
                  (R = E.batcher) == null ||
                    R.remove(h.w.SPRITE, this._batchGroupId, this.entity);
                }
              }
              onDestroy() {
                var E;
                (this._currentClip = null),
                  this._defaultClip &&
                    (this._defaultClip._destroy(), (this._defaultClip = null));
                for (const M in this._clips) this._clips[M]._destroy();
                (this._clips = null),
                  this._hideModel(),
                  (this._model = null),
                  (E = this._node) == null || E.remove(),
                  (this._node = null),
                  this._meshInstance &&
                    ((this._meshInstance.material = null),
                    (this._meshInstance.mesh = null),
                    (this._meshInstance = null));
              }
              _showModel() {
                if (this._addedModel || !this._meshInstance) return;
                const E = [this._meshInstance];
                for (let M = 0, R = this._layers.length; M < R; M++) {
                  const P = this.system.app.scene.layers.getLayerById(
                    this._layers[M]
                  );
                  P && P.addMeshInstances(E);
                }
                this._addedModel = !0;
              }
              _hideModel() {
                if (!this._addedModel || !this._meshInstance) return;
                const E = [this._meshInstance];
                for (let M = 0, R = this._layers.length; M < R; M++) {
                  const P = this.system.app.scene.layers.getLayerById(
                    this._layers[M]
                  );
                  P && P.removeMeshInstances(E);
                }
                this._addedModel = !1;
              }
              _showFrame(E) {
                if (!this.sprite) return;
                const M = this.sprite.meshes[E];
                if (!M) {
                  this._meshInstance &&
                    ((this._meshInstance.mesh = null),
                    (this._meshInstance.visible = !1));
                  return;
                }
                let R;
                if (
                  (this.sprite.renderMode === d.FC
                    ? (R = this.system.default9SlicedMaterialSlicedMode)
                    : this.sprite.renderMode === d.jZ
                    ? (R = this.system.default9SlicedMaterialTiledMode)
                    : (R = this.system.defaultMaterial),
                  this._meshInstance ||
                    ((this._meshInstance = new s.F(
                      M,
                      this._material,
                      this._node
                    )),
                    (this._meshInstance.castShadow = !1),
                    (this._meshInstance.receiveShadow = !1),
                    (this._meshInstance.drawOrder = this._drawOrder),
                    this._model.meshInstances.push(this._meshInstance),
                    (this._colorUniform[0] = this._color.r),
                    (this._colorUniform[1] = this._color.g),
                    (this._colorUniform[2] = this._color.b),
                    this._meshInstance.setParameter(r, this._colorUniform),
                    this._meshInstance.setParameter(u, this._color.a),
                    this.enabled && this.entity.enabled && this._showModel()),
                  this._meshInstance.material !== R &&
                    (this._meshInstance.material = R),
                  this._meshInstance.mesh !== M &&
                    ((this._meshInstance.mesh = M),
                    (this._meshInstance.visible = !0),
                    (this._meshInstance._aabbVer = -1)),
                  this.sprite.atlas && this.sprite.atlas.texture
                    ? (this._meshInstance.setParameter(
                        e,
                        this.sprite.atlas.texture
                      ),
                      this._meshInstance.setParameter(
                        t,
                        this.sprite.atlas.texture
                      ))
                    : (this._meshInstance.deleteParameter(e),
                      this._meshInstance.deleteParameter(t)),
                  this.sprite.atlas &&
                    (this.sprite.renderMode === d.FC ||
                      this.sprite.renderMode === d.jZ))
                ) {
                  this._meshInstance._updateAabbFunc = this._updateAabbFunc;
                  const P = this.sprite.atlas.frames[this.sprite.frameKeys[E]];
                  if (P) {
                    const F = 2 / P.rect.z,
                      b = 2 / P.rect.w;
                    this._innerOffset.set(
                      P.border.x * F,
                      P.border.y * b,
                      P.border.z * F,
                      P.border.w * b
                    );
                    const D = this.sprite.atlas.texture;
                    this._atlasRect.set(
                      P.rect.x / D.width,
                      P.rect.y / D.height,
                      P.rect.z / D.width,
                      P.rect.w / D.height
                    );
                  } else this._innerOffset.set(0, 0, 0, 0);
                  (this._innerOffsetUniform[0] = this._innerOffset.x),
                    (this._innerOffsetUniform[1] = this._innerOffset.y),
                    (this._innerOffsetUniform[2] = this._innerOffset.z),
                    (this._innerOffsetUniform[3] = this._innerOffset.w),
                    this._meshInstance.setParameter(
                      v,
                      this._innerOffsetUniform
                    ),
                    (this._atlasRectUniform[0] = this._atlasRect.x),
                    (this._atlasRectUniform[1] = this._atlasRect.y),
                    (this._atlasRectUniform[2] = this._atlasRect.z),
                    (this._atlasRectUniform[3] = this._atlasRect.w),
                    this._meshInstance.setParameter(m, this._atlasRectUniform);
                } else this._meshInstance._updateAabbFunc = null;
                this._updateTransform();
              }
              _updateTransform() {
                let E = this.flipX ? -1 : 1,
                  M = this.flipY ? -1 : 1,
                  R = 0,
                  P = 0;
                if (
                  this.sprite &&
                  (this.sprite.renderMode === d.FC ||
                    this.sprite.renderMode === d.jZ)
                ) {
                  let F = 1,
                    b = 1;
                  if (this.sprite.atlas) {
                    const X =
                      this.sprite.atlas.frames[
                        this.sprite.frameKeys[this.frame]
                      ];
                    X &&
                      ((F = X.rect.z),
                      (b = X.rect.w),
                      (R = (0.5 - X.pivot.x) * this._width),
                      (P = (0.5 - X.pivot.y) * this._height));
                  }
                  const D = F / this.sprite.pixelsPerUnit,
                    G = b / this.sprite.pixelsPerUnit;
                  this._outerScale.set(
                    Math.max(this._width, this._innerOffset.x * D),
                    Math.max(this._height, this._innerOffset.y * G)
                  ),
                    (E *= D),
                    (M *= G),
                    (this._outerScale.x /= D),
                    (this._outerScale.y /= G),
                    (E *= A.D.clamp(
                      this._width / (this._innerOffset.x * D),
                      1e-4,
                      1
                    )),
                    (M *= A.D.clamp(
                      this._height / (this._innerOffset.y * G),
                      1e-4,
                      1
                    )),
                    this._meshInstance &&
                      ((this._outerScaleUniform[0] = this._outerScale.x),
                      (this._outerScaleUniform[1] = this._outerScale.y),
                      this._meshInstance.setParameter(
                        _,
                        this._outerScaleUniform
                      ));
                }
                this._node.setLocalScale(E, M, 1),
                  this._node.setLocalPosition(R, P, 0);
              }
              _updateAabb(E) {
                return (
                  E.center.set(0, 0, 0),
                  E.halfExtents.set(
                    this._outerScale.x * 0.5,
                    this._outerScale.y * 0.5,
                    0.001
                  ),
                  E.setFromTransformedAabb(E, this._node.getWorldTransform()),
                  E
                );
              }
              _tryAutoPlay() {
                if (!this._autoPlayClip || this.type !== o.s) return;
                const E = this._clips[this._autoPlayClip];
                E &&
                  !E.isPlaying &&
                  (!this._currentClip || !this._currentClip.isPlaying) &&
                  this.enabled &&
                  this.entity.enabled &&
                  this.play(E.name);
              }
              _onLayersChanged(E, M) {
                E.off("add", this.onLayerAdded, this),
                  E.off("remove", this.onLayerRemoved, this),
                  M.on("add", this.onLayerAdded, this),
                  M.on("remove", this.onLayerRemoved, this),
                  this.enabled && this.entity.enabled && this._showModel();
              }
              _onLayerAdded(E) {
                this.layers.indexOf(E.id) < 0 ||
                  (this._addedModel &&
                    this.enabled &&
                    this.entity.enabled &&
                    this._meshInstance &&
                    E.addMeshInstances([this._meshInstance]));
              }
              _onLayerRemoved(E) {
                !this._meshInstance ||
                  this.layers.indexOf(E.id) < 0 ||
                  E.removeMeshInstances([this._meshInstance]);
              }
              removeModelFromLayers() {
                for (let E = 0; E < this.layers.length; E++) {
                  const M = this.system.app.scene.layers.getLayerById(
                    this.layers[E]
                  );
                  M && M.removeMeshInstances([this._meshInstance]);
                }
              }
              addClip(E) {
                const M = new i.u(this, {
                  name: E.name,
                  fps: E.fps,
                  loop: E.loop,
                  spriteAsset: E.spriteAsset,
                });
                return (
                  (this._clips[E.name] = M),
                  M.name &&
                    M.name === this._autoPlayClip &&
                    this._tryAutoPlay(),
                  M
                );
              }
              removeClip(E) {
                delete this._clips[E];
              }
              clip(E) {
                return this._clips[E];
              }
              play(E) {
                const M = this._clips[E],
                  R = this._currentClip;
                return (
                  R && R !== M && (R._playing = !1),
                  (this._currentClip = M),
                  this._currentClip &&
                    ((this._currentClip = M), this._currentClip.play()),
                  M
                );
              }
              pause() {
                this._currentClip !== this._defaultClip &&
                  this._currentClip.isPlaying &&
                  this._currentClip.pause();
              }
              resume() {
                this._currentClip !== this._defaultClip &&
                  this._currentClip.isPaused &&
                  this._currentClip.resume();
              }
              stop() {
                this._currentClip !== this._defaultClip &&
                  this._currentClip.stop();
              }
            }
          },
          7288: (xe, V, a) => {
            "use strict";
            a.d(V, { s: () => x, z: () => A });
            const A = "simple",
              x = "animated";
          },
          7562: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => d });
            var A = a(8976),
              x = a(8656),
              y = a(3953),
              c = a(9391);
            class d extends A.J {
              constructor(f, s) {
                super(),
                  (this._component = f),
                  (this._frame = 0),
                  (this._sprite = null),
                  (this._spriteAsset = null),
                  (this.spriteAsset = s.spriteAsset),
                  (this.name = s.name),
                  (this.fps = s.fps || 0),
                  (this.loop = s.loop || !1),
                  (this._playing = !1),
                  (this._paused = !1),
                  (this._time = 0);
              }
              get duration() {
                if (this._sprite) {
                  const f = this.fps || Number.MIN_VALUE;
                  return this._sprite.frameKeys.length / Math.abs(f);
                }
                return 0;
              }
              set frame(f) {
                this._setFrame(f);
                const s = this.fps || Number.MIN_VALUE;
                this._setTime(this._frame / s);
              }
              get frame() {
                return this._frame;
              }
              get isPaused() {
                return this._paused;
              }
              get isPlaying() {
                return this._playing;
              }
              set sprite(f) {
                if (
                  (this._sprite &&
                    (this._sprite.off(
                      "set:meshes",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.off(
                      "set:pixelsPerUnit",
                      this._onSpritePpuChanged,
                      this
                    ),
                    this._sprite.off(
                      "set:atlas",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.atlas &&
                      this._sprite.atlas.off(
                        "set:texture",
                        this._onSpriteMeshesChange,
                        this
                      )),
                  (this._sprite = f),
                  this._sprite &&
                    (this._sprite.on(
                      "set:meshes",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.on(
                      "set:pixelsPerUnit",
                      this._onSpritePpuChanged,
                      this
                    ),
                    this._sprite.on(
                      "set:atlas",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.atlas &&
                      this._sprite.atlas.on(
                        "set:texture",
                        this._onSpriteMeshesChange,
                        this
                      )),
                  this._component.currentClip === this)
                ) {
                  let s;
                  !f || !f.atlas
                    ? ((s = this._component._meshInstance),
                      s &&
                        (s.deleteParameter("texture_emissiveMap"),
                        s.deleteParameter("texture_opacityMap")),
                      this._component._hideModel())
                    : (f.atlas.texture &&
                        ((s = this._component._meshInstance),
                        s &&
                          (s.setParameter(
                            "texture_emissiveMap",
                            f.atlas.texture
                          ),
                          s.setParameter(
                            "texture_opacityMap",
                            f.atlas.texture
                          )),
                        this._component.enabled &&
                          this._component.entity.enabled &&
                          this._component._showModel()),
                      this.time && this.fps
                        ? (this.time = this.time)
                        : (this.frame = this.frame));
                }
              }
              get sprite() {
                return this._sprite;
              }
              set spriteAsset(f) {
                const s = this._component.system.app.assets;
                let l = f;
                if ((f instanceof y.V && (l = f.id), this._spriteAsset !== l)) {
                  if (this._spriteAsset) {
                    const n = s.get(this._spriteAsset);
                    n && this._unbindSpriteAsset(n);
                  }
                  if (((this._spriteAsset = l), this._spriteAsset)) {
                    const n = s.get(this._spriteAsset);
                    n
                      ? this._bindSpriteAsset(n)
                      : ((this.sprite = null),
                        s.on(
                          "add:" + this._spriteAsset,
                          this._onSpriteAssetAdded,
                          this
                        ));
                  } else this.sprite = null;
                }
              }
              get spriteAsset() {
                return this._spriteAsset;
              }
              set time(f) {
                this._setTime(f),
                  this._sprite
                    ? (this.frame = Math.min(
                        this._sprite.frameKeys.length - 1,
                        Math.floor(this._time * Math.abs(this.fps))
                      ))
                    : (this.frame = 0);
              }
              get time() {
                return this._time;
              }
              _onSpriteAssetAdded(f) {
                this._component.system.app.assets.off(
                  "add:" + f.id,
                  this._onSpriteAssetAdded,
                  this
                ),
                  this._spriteAsset === f.id && this._bindSpriteAsset(f);
              }
              _bindSpriteAsset(f) {
                f.on("load", this._onSpriteAssetLoad, this),
                  f.on("remove", this._onSpriteAssetRemove, this),
                  f.resource
                    ? this._onSpriteAssetLoad(f)
                    : this._component.system.app.assets.load(f);
              }
              _unbindSpriteAsset(f) {
                f &&
                  (f.off("load", this._onSpriteAssetLoad, this),
                  f.off("remove", this._onSpriteAssetRemove, this),
                  f.resource &&
                    !f.resource.atlas &&
                    this._component.system.app.assets.off(
                      "load:" + f.data.textureAtlasAsset,
                      this._onTextureAtlasLoad,
                      this
                    ));
              }
              _onSpriteAssetLoad(f) {
                if (!f.resource) this.sprite = null;
                else if (f.resource.atlas) this.sprite = f.resource;
                else {
                  const s = f.data.textureAtlasAsset,
                    l = this._component.system.app.assets;
                  l.off("load:" + s, this._onTextureAtlasLoad, this),
                    l.once("load:" + s, this._onTextureAtlasLoad, this);
                }
              }
              _onTextureAtlasLoad(f) {
                const s = this._spriteAsset;
                s instanceof y.V
                  ? this._onSpriteAssetLoad(s)
                  : this._onSpriteAssetLoad(
                      this._component.system.app.assets.get(s)
                    );
              }
              _onSpriteAssetRemove(f) {
                this.sprite = null;
              }
              _onSpriteMeshesChange() {
                this._component.currentClip === this &&
                  this._component._showFrame(this.frame);
              }
              _onSpritePpuChanged() {
                this._component.currentClip === this &&
                  this.sprite.renderMode !== c.hA &&
                  this._component._showFrame(this.frame);
              }
              _update(f) {
                if (
                  this.fps === 0 ||
                  !this._playing ||
                  this._paused ||
                  !this._sprite
                )
                  return;
                const s = this.fps < 0 ? -1 : 1,
                  l = this._time + f * this._component.speed * s,
                  n = this.duration,
                  o = l > n || l < 0;
                this._setTime(l);
                let i = this.frame;
                this._sprite
                  ? (i = Math.floor(
                      (this._sprite.frameKeys.length * this._time) / n
                    ))
                  : (i = 0),
                  i !== this._frame && this._setFrame(i),
                  o &&
                    (this.loop
                      ? (this.fire("loop"), this._component.fire("loop", this))
                      : ((this._playing = !1),
                        (this._paused = !1),
                        this.fire("end"),
                        this._component.fire("end", this)));
              }
              _setTime(f) {
                this._time = f;
                const s = this.duration;
                this._time < 0
                  ? this.loop
                    ? (this._time = (this._time % s) + s)
                    : (this._time = 0)
                  : this._time > s &&
                    (this.loop ? (this._time %= s) : (this._time = s));
              }
              _setFrame(f) {
                this._sprite
                  ? (this._frame = x.D.clamp(
                      f,
                      0,
                      this._sprite.frameKeys.length - 1
                    ))
                  : (this._frame = f),
                  this._component.currentClip === this &&
                    this._component._showFrame(this._frame);
              }
              _destroy() {
                if (this._spriteAsset) {
                  const f = this._component.system.app.assets;
                  this._unbindSpriteAsset(f.get(this._spriteAsset));
                }
                this._sprite && (this.sprite = null),
                  this._spriteAsset && (this.spriteAsset = null);
              }
              play() {
                this._playing ||
                  ((this._playing = !0),
                  (this._paused = !1),
                  (this.frame = 0),
                  this.fire("play"),
                  this._component.fire("play", this));
              }
              pause() {
                !this._playing ||
                  this._paused ||
                  ((this._paused = !0),
                  this.fire("pause"),
                  this._component.fire("pause", this));
              }
              resume() {
                this._paused &&
                  ((this._paused = !1),
                  this.fire("resume"),
                  this._component.fire("resume", this));
              }
              stop() {
                this._playing &&
                  ((this._playing = !1),
                  (this._paused = !1),
                  (this._time = 0),
                  (this.frame = 0),
                  this.fire("stop"),
                  this._component.fire("stop", this));
              }
            }
          },
          4237: (xe, V, a) => {
            "use strict";
            a.d(V, { Y: () => o });
            var A = a(5227),
              x = a(1630),
              y = a(1208),
              c = a(9391),
              d = a(1369),
              h = a(4124),
              f = a(2930),
              s = a(9882);
            class l {
              constructor() {
                this.enabled = !0;
              }
            }
            const n = ["enabled"];
            class o extends f.r {
              constructor(e) {
                super(e),
                  (this.id = "sprite"),
                  (this.ComponentType = s.V),
                  (this.DataType = l),
                  (this.schema = n),
                  (this._defaultTexture = null),
                  (this._defaultMaterial = null),
                  (this._default9SlicedMaterialSlicedMode = null),
                  (this._default9SlicedMaterialTiledMode = null),
                  this.app.systems.on("update", this.onUpdate, this),
                  this.on("beforeremove", this.onBeforeRemove, this);
              }
              set defaultMaterial(e) {
                this._defaultMaterial = e;
              }
              get defaultMaterial() {
                if (!this._defaultMaterial) {
                  const e = new y.g(this.app.graphicsDevice, {
                      width: 1,
                      height: 1,
                      format: x.Lxj,
                      name: "sprite",
                    }),
                    t = new Uint8Array(e.lock());
                  (t[0] = t[1] = t[2] = t[3] = 255), e.unlock();
                  const r = new d.F();
                  r.diffuse.set(0, 0, 0),
                    r.emissive.set(0.5, 0.5, 0.5),
                    (r.emissiveMap = e),
                    (r.emissiveTint = !0),
                    (r.opacityMap = e),
                    (r.opacityMapChannel = "a"),
                    (r.opacityTint = !0),
                    (r.opacity = 0),
                    (r.useLighting = !1),
                    (r.useGammaTonemap = !1),
                    (r.useFog = !1),
                    (r.useSkybox = !1),
                    (r.blendType = c.bY),
                    (r.depthWrite = !1),
                    (r.pixelSnap = !1),
                    (r.cull = x.pLF),
                    r.update(),
                    (this._defaultTexture = e),
                    (this._defaultMaterial = r);
                }
                return this._defaultMaterial;
              }
              set default9SlicedMaterialSlicedMode(e) {
                this._default9SlicedMaterialSlicedMode = e;
              }
              get default9SlicedMaterialSlicedMode() {
                if (!this._default9SlicedMaterialSlicedMode) {
                  const e = this.defaultMaterial.clone();
                  (e.nineSlicedMode = c.FC),
                    e.update(),
                    (this._default9SlicedMaterialSlicedMode = e);
                }
                return this._default9SlicedMaterialSlicedMode;
              }
              set default9SlicedMaterialTiledMode(e) {
                this._default9SlicedMaterialTiledMode = e;
              }
              get default9SlicedMaterialTiledMode() {
                if (!this._default9SlicedMaterialTiledMode) {
                  const e = this.defaultMaterial.clone();
                  (e.nineSlicedMode = c.jZ),
                    e.update(),
                    (this._default9SlicedMaterialTiledMode = e);
                }
                return this._default9SlicedMaterialTiledMode;
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this),
                  this._defaultTexture &&
                    (this._defaultTexture.destroy(),
                    (this._defaultTexture = null));
              }
              initializeComponentData(e, t, r) {
                if (
                  (t.enabled !== void 0 && (e.enabled = t.enabled),
                  (e.type = t.type),
                  t.layers &&
                    Array.isArray(t.layers) &&
                    (e.layers = t.layers.slice(0)),
                  t.drawOrder !== void 0 && (e.drawOrder = t.drawOrder),
                  t.color !== void 0)
                ) {
                  if (t.color instanceof A.Q) {
                    var u;
                    e.color.set(
                      t.color.r,
                      t.color.g,
                      t.color.b,
                      (u = t.opacity) != null ? u : 1
                    );
                  } else {
                    var v;
                    e.color.set(
                      t.color[0],
                      t.color[1],
                      t.color[2],
                      (v = t.opacity) != null ? v : 1
                    );
                  }
                  e.color = e.color;
                }
                if (
                  (t.opacity !== void 0 && (e.opacity = t.opacity),
                  t.flipX !== void 0 && (e.flipX = t.flipX),
                  t.flipY !== void 0 && (e.flipY = t.flipY),
                  t.width !== void 0 && (e.width = t.width),
                  t.height !== void 0 && (e.height = t.height),
                  t.spriteAsset !== void 0 && (e.spriteAsset = t.spriteAsset),
                  t.sprite && (e.sprite = t.sprite),
                  t.frame !== void 0 && (e.frame = t.frame),
                  t.clips)
                )
                  for (const _ in t.clips) e.addClip(t.clips[_]);
                t.speed !== void 0 && (e.speed = t.speed),
                  t.autoPlayClip && (e.autoPlayClip = t.autoPlayClip),
                  (e.batchGroupId =
                    t.batchGroupId === void 0 || t.batchGroupId === null
                      ? -1
                      : t.batchGroupId),
                  super.initializeComponentData(e, t, r);
              }
              cloneComponent(e, t) {
                const r = e.sprite;
                return this.addComponent(t, {
                  enabled: r.enabled,
                  type: r.type,
                  spriteAsset: r.spriteAsset,
                  sprite: r.sprite,
                  frame: r.frame,
                  color: r.color.clone(),
                  opacity: r.opacity,
                  flipX: r.flipX,
                  flipY: r.flipY,
                  speed: r.speed,
                  clips: r.clips,
                  autoPlayClip: r.autoPlayClip,
                  batchGroupId: r.batchGroupId,
                  drawOrder: r.drawOrder,
                  layers: r.layers.slice(0),
                });
              }
              onUpdate(e) {
                const t = this.store;
                for (const r in t)
                  if (t.hasOwnProperty(r)) {
                    const u = t[r];
                    if (u.data.enabled && u.entity.enabled) {
                      const v = u.entity.sprite;
                      v._currentClip && v._currentClip._update(e);
                    }
                  }
              }
              onBeforeRemove(e, t) {
                t.onDestroy();
              }
            }
            h.u._buildAccessors(s.V.prototype, n);
          },
          2930: (xe, V, a) => {
            "use strict";
            a.d(V, { r: () => h });
            var A = a(8976),
              x = a(5227),
              y = a(7994),
              c = a(7481),
              d = a(5596);
            class h extends A.J {
              constructor(l) {
                super(), (this.app = l), (this.store = {}), (this.schema = []);
              }
              addComponent(l, n = {}) {
                const o = new this.ComponentType(this, l),
                  i = new this.DataType();
                return (
                  (this.store[l.getGuid()] = { entity: l, data: i }),
                  (l[this.id] = o),
                  (l.c[this.id] = o),
                  this.initializeComponentData(o, n, []),
                  this.fire("add", l, o),
                  o
                );
              }
              removeComponent(l) {
                const n = this.store[l.getGuid()],
                  o = l.c[this.id];
                this.fire("beforeremove", l, o),
                  delete this.store[l.getGuid()],
                  (l[this.id] = void 0),
                  delete l.c[this.id],
                  this.fire("remove", l, n.data);
              }
              cloneComponent(l, n) {
                const o = this.store[l.getGuid()];
                return this.addComponent(n, o.data);
              }
              initializeComponentData(l, n = {}, o) {
                for (let i = 0, e = o.length; i < e; i++) {
                  const t = o[i];
                  let r, u;
                  typeof t == "object"
                    ? ((r = t.name), (u = t.type))
                    : ((r = t), (u = void 0));
                  let v = n[r];
                  v !== void 0
                    ? (u !== void 0 && (v = f(v, u)), (l[r] = v))
                    : (l[r] = l.data[r]);
                }
                l.enabled && l.entity.enabled && l.onEnable();
              }
              getPropertiesOfType(l) {
                const n = [];
                return (
                  (this.schema || []).forEach(function (i) {
                    i && typeof i == "object" && i.type === l && n.push(i);
                  }),
                  n
                );
              }
              destroy() {
                this.off();
              }
            }
            function f(s, l) {
              if (!s) return s;
              switch (l) {
                case "rgb":
                  return s instanceof x.Q
                    ? s.clone()
                    : new x.Q(s[0], s[1], s[2]);
                case "rgba":
                  return s instanceof x.Q
                    ? s.clone()
                    : new x.Q(s[0], s[1], s[2], s[3]);
                case "vec2":
                  return s instanceof y.Z ? s.clone() : new y.Z(s[0], s[1]);
                case "vec3":
                  return s instanceof c.e
                    ? s.clone()
                    : new c.e(s[0], s[1], s[2]);
                case "vec4":
                  return s instanceof d.Z
                    ? s.clone()
                    : new d.Z(s[0], s[1], s[2], s[3]);
                case "boolean":
                case "number":
                case "string":
                  return s;
                case "entity":
                  return s;
                default:
                  throw new Error("Could not convert unhandled type: " + l);
              }
            }
          },
          1097: (xe, V, a) => {
            "use strict";
            a.d(V, { i: () => y });
            var A = a(7481),
              x = a(4124);
            class y extends x.u {
              constructor(d, h) {
                super(d, h),
                  (this._oldState = !0),
                  (this._size = new A.e()),
                  this.on("set_enabled", this._onSetEnabled, this);
              }
              set size(d) {
                d instanceof A.e
                  ? this._size.copy(d)
                  : d instanceof Array &&
                    d.length >= 3 &&
                    this.size.set(d[0], d[1], d[2]);
              }
              get size() {
                return this._size;
              }
              onEnable() {
                this._checkState();
              }
              onDisable() {
                this._checkState();
              }
              _onSetEnabled(d, h, f) {
                this._checkState();
              }
              _checkState() {
                const d = this.enabled && this.entity.enabled;
                d !== this._oldState &&
                  ((this._oldState = d),
                  this.fire("enable"),
                  this.fire("state", this.enabled));
              }
              _onBeforeRemove() {
                this.fire("remove");
              }
            }
          },
          6862: (xe, V, a) => {
            "use strict";
            a.d(V, { b: () => f });
            var A = a(7481),
              x = a(4124),
              y = a(2930),
              c = a(1097);
            class d {
              constructor() {
                this.enabled = !0;
              }
            }
            const h = ["enabled"];
            class f extends y.r {
              constructor(l) {
                super(l),
                  (this.id = "zone"),
                  (this.ComponentType = c.i),
                  (this.DataType = d),
                  (this.schema = h),
                  this.on("beforeremove", this._onBeforeRemove, this);
              }
              initializeComponentData(l, n, o) {
                (l.enabled = n.hasOwnProperty("enabled") ? !!n.enabled : !0),
                  n.size &&
                    (n.size instanceof A.e
                      ? l.size.copy(n.size)
                      : n.size instanceof Array &&
                        n.size.length >= 3 &&
                        l.size.set(n.size[0], n.size[1], n.size[2]));
              }
              cloneComponent(l, n) {
                const o = { size: l.zone.size };
                return this.addComponent(n, o);
              }
              _onBeforeRemove(l, n) {
                n._onBeforeRemove();
              }
            }
            x.u._buildAccessors(c.i.prototype, h);
          },
          8947: (xe, V, a) => {
            "use strict";
            a.d(V, {
              GL: () => d,
              Ol: () => A,
              Wx: () => y,
              hD: () => c,
              kY: () => x,
            });
            const A = "NONE",
              x = "FILL_WINDOW",
              y = "KEEP_ASPECT",
              c = "AUTO",
              d = "FIXED";
          },
          371: (xe, V, a) => {
            "use strict";
            a.d(V, { w: () => d });
            var A = a(4172),
              x = a(3035),
              y = a(4530);
            const c = [];
            class d extends x.t {
              constructor(s, l = (0, y.D)()) {
                super(s),
                  (this.anim = void 0),
                  (this.animation = void 0),
                  (this.audiolistener = void 0),
                  (this.button = void 0),
                  (this.camera = void 0),
                  (this.collision = void 0),
                  (this.element = void 0),
                  (this.layoutchild = void 0),
                  (this.layoutgroup = void 0),
                  (this.light = void 0),
                  (this.model = void 0),
                  (this.particlesystem = void 0),
                  (this.render = void 0),
                  (this.rigidbody = void 0),
                  (this.screen = void 0),
                  (this.script = void 0),
                  (this.scrollbar = void 0),
                  (this.scrollview = void 0),
                  (this.sound = void 0),
                  (this.sprite = void 0),
                  (this.c = {}),
                  (this._app = void 0),
                  (this._destroying = !1),
                  (this._guid = null),
                  (this._template = !1),
                  (this._app = l);
              }
              addComponent(s, l) {
                const n = this._app.systems[s];
                return !n || this.c[s] ? null : n.addComponent(this, l);
              }
              removeComponent(s) {
                const l = this._app.systems[s];
                l && this.c[s] && l.removeComponent(this);
              }
              findComponent(s) {
                const l = this.findOne(function (n) {
                  return n.c && n.c[s];
                });
                return l && l.c[s];
              }
              findComponents(s) {
                return this.find(function (n) {
                  return n.c && n.c[s];
                }).map(function (n) {
                  return n.c[s];
                });
              }
              getGuid() {
                return this._guid || this.setGuid(A.O.create()), this._guid;
              }
              setGuid(s) {
                const l = this._app._entityIndex;
                this._guid && delete l[this._guid],
                  (this._guid = s),
                  (l[this._guid] = this);
              }
              _notifyHierarchyStateChanged(s, l) {
                let n = !1;
                s === this && c.length === 0 && (n = !0),
                  (s._beingEnabled = !0),
                  s._onHierarchyStateChanged(l),
                  s._onHierarchyStatePostChanged && c.push(s);
                const o = s._children;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i]._enabled && this._notifyHierarchyStateChanged(o[i], l);
                if (((s._beingEnabled = !1), n)) {
                  for (let i = 0; i < c.length; i++)
                    c[i]._onHierarchyStatePostChanged();
                  c.length = 0;
                }
              }
              _onHierarchyStateChanged(s) {
                super._onHierarchyStateChanged(s);
                const l = this.c;
                for (const n in l)
                  if (l.hasOwnProperty(n)) {
                    const o = l[n];
                    o.enabled && (s ? o.onEnable() : o.onDisable());
                  }
              }
              _onHierarchyStatePostChanged() {
                const s = this.c;
                for (const l in s)
                  s.hasOwnProperty(l) && s[l].onPostStateChange();
              }
              findByGuid(s) {
                if (this._guid === s) return this;
                const l = this._app._entityIndex[s];
                return l && (l === this || l.isDescendantOf(this)) ? l : null;
              }
              destroy() {
                this._destroying = !0;
                for (const s in this.c) this.c[s].enabled = !1;
                for (const s in this.c) this.c[s].system.removeComponent(this);
                super.destroy(),
                  this._guid && delete this._app._entityIndex[this._guid],
                  (this._destroying = !1);
              }
              clone() {
                const s = {},
                  l = this._cloneRecursively(s);
                return (s[this.getGuid()] = l), h(this, this, l, s), l;
              }
              _cloneRecursively(s) {
                const l = new this.constructor(void 0, this._app);
                super._cloneInternal(l);
                for (const n in this.c)
                  this.c[n].system.cloneComponent(this, l);
                for (let n = 0; n < this._children.length; n++) {
                  const o = this._children[n];
                  if (o instanceof d) {
                    const i = o._cloneRecursively(s);
                    l.addChild(i), (s[o.getGuid()] = i);
                  }
                }
                return l;
              }
            }
            function h(f, s, l, n) {
              if (s instanceof d) {
                const o = s.c;
                for (const t in o) {
                  const r = o[t],
                    u = r.system.getPropertiesOfType("entity");
                  for (let v = 0, _ = u.length; v < _; v++) {
                    const g = u[v].name,
                      T = r[g];
                    if (!!f.findByGuid(T)) {
                      const M = n[T].getGuid();
                      M && (l.c[t][g] = M);
                    }
                  }
                }
                o.script &&
                  !l._app.useLegacyScriptAttributeCloning &&
                  l.script.resolveDuplicatedEntityReferenceProperties(
                    o.script,
                    n
                  ),
                  o.render &&
                    l.render.resolveDuplicatedEntityReferenceProperties(
                      o.render,
                      n
                    ),
                  o.anim &&
                    l.anim.resolveDuplicatedEntityReferenceProperties(
                      o.anim,
                      n
                    );
                const i = s.children.filter(function (t) {
                    return t instanceof d;
                  }),
                  e = l.children.filter(function (t) {
                    return t instanceof d;
                  });
                for (let t = 0, r = i.length; t < r; t++) h(f, i[t], e[t], n);
              }
            }
          },
          2471: (xe, V, a) => {
            "use strict";
            a.d(V, { M: () => x, P: () => A });
            const A = "msdf",
              x = "bitmap";
          },
          4289: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => x });
            var A = a(2471);
            class x {
              constructor(c, d) {
                (this.type = (d && d.type) || A.P),
                  (this.em = 1),
                  (this.textures = c),
                  (this.intensity = 0),
                  (this._data = null),
                  (this.data = d);
              }
              set data(c) {
                if (
                  ((this._data = c),
                  !!c &&
                    (this._data.intensity !== void 0 &&
                      (this.intensity = this._data.intensity),
                    this._data.info || (this._data.info = {}),
                    (!this._data.version || this._data.version < 2) &&
                      ((this._data.info.maps = [
                        {
                          width: this._data.info.width,
                          height: this._data.info.height,
                        },
                      ]),
                      this._data.chars)))
                )
                  for (const d in this._data.chars) this._data.chars[d].map = 0;
              }
              get data() {
                return this._data;
              }
            }
          },
          4530: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => y, V: () => c });
            var A = a(8136);
            let x;
            function y() {
              return x;
            }
            function c(d) {
              (x = d), A.A.set(d == null ? void 0 : d.graphicsDevice);
            }
          },
          6306: (xe, V, a) => {
            "use strict";
            a.d(V, { L: () => u });
            var A = a(5227),
              x = a(1630),
              y = a(4461),
              c = a(9061),
              d = a(1208),
              h = a(9391),
              f = a(5463),
              s = a(3637),
              l = a(2223),
              n = a(1232),
              o = a(4530),
              i = a(371),
              e = a(1268);
            const t = new Set(),
              r = { depth: 1, flags: x.YKI };
            class u {
              constructor(_, m, g) {
                (this.renderTarget = null),
                  _ instanceof y.G && (_ = (0, o.D)()),
                  (this.app = _),
                  (this.device = _.graphicsDevice),
                  (this.pickColor = new Float32Array(4)),
                  (this.pickColor[3] = 1),
                  (this.mapping = []),
                  (this.cameraEntity = null),
                  (this.layer = null),
                  (this.layerComp = null),
                  this.initLayerComposition();
                const T = this.device;
                (this.clearDepthCommand = new s.u(0, 0, function () {
                  T.clear(r);
                })),
                  (this.width = 0),
                  (this.height = 0),
                  this.resize(m, g);
              }
              getSelection(_, m, g, T) {
                const E = this.device;
                if (typeof _ == "object") {
                  const b = _;
                  (_ = b.x), (m = b.y), (g = b.width), (T = b.height);
                } else m = this.renderTarget.height - (m + (T || 1));
                (_ = Math.floor(_)),
                  (m = Math.floor(m)),
                  (g = Math.floor(Math.max(g || 1, 1))),
                  (T = Math.floor(Math.max(T || 1, 1)));
                const M = E.renderTarget;
                E.setRenderTarget(this.renderTarget), E.updateBegin();
                const R = new Uint8Array(4 * g * T);
                E.readPixels(_, m, g, T, R),
                  E.updateEnd(),
                  E.setRenderTarget(M);
                const P = this.mapping;
                for (let b = 0; b < g * T; b++) {
                  const D = R[4 * b + 0],
                    G = R[4 * b + 1],
                    X = R[4 * b + 2],
                    ie = (D << 16) | (G << 8) | X;
                  ie !== 16777215 && t.add(P[ie]);
                }
                const F = [];
                return t.forEach((b) => F.push(b)), t.clear(), F;
              }
              allocateRenderTarget() {
                const _ = new d.g(this.device, {
                  format: x.Lxj,
                  width: this.width,
                  height: this.height,
                  mipmaps: !1,
                  minFilter: x.uhC,
                  magFilter: x.uhC,
                  addressU: x.vq6,
                  addressV: x.vq6,
                  name: "pick",
                });
                this.renderTarget = new c.O({ colorBuffer: _, depth: !0 });
              }
              releaseRenderTarget() {
                (this.cameraEntity.camera.renderTarget = null),
                  this.renderTarget &&
                    (this.renderTarget.destroyTextureBuffers(),
                    this.renderTarget.destroy(),
                    (this.renderTarget = null));
              }
              initLayerComposition() {
                const _ = this.device,
                  m = this,
                  g = _.scope.resolve("uColor");
                (this.cameraEntity = new i.w()),
                  this.cameraEntity.addComponent("camera"),
                  (this.layer = new l.W({
                    name: "Picker",
                    shaderPass: h.cz,
                    opaqueSortMode: h.lU,
                    onDrawCall: function (T, E) {
                      (m.pickColor[0] = ((E >> 16) & 255) / 255),
                        (m.pickColor[1] = ((E >> 8) & 255) / 255),
                        (m.pickColor[2] = (E & 255) / 255),
                        g.setValue(m.pickColor),
                        _.setBlendState(e.t.NOBLEND),
                        (m.mapping[E] = T);
                    },
                  })),
                  this.layer.addCamera(this.cameraEntity.camera),
                  (this.layerComp = new n.e("picker")),
                  this.layerComp.pushOpaque(this.layer);
              }
              prepare(_, m, g) {
                _ instanceof f.i && (_ = _.node.camera),
                  g instanceof l.W && (g = [g]),
                  this.layer.clearMeshInstances();
                const T = this.layer.opaqueMeshInstances,
                  E = m.layers.layerList,
                  M = m.layers.subLayerEnabled,
                  R = m.layers.subLayerList;
                for (let P = 0; P < E.length; P++) {
                  const F = E[P];
                  if (
                    !(g && g.indexOf(F) < 0) &&
                    F.enabled &&
                    M[P] &&
                    F.cameras.indexOf(_) >= 0
                  ) {
                    F._clearDepthBuffer && T.push(this.clearDepthCommand);
                    const D = R[P]
                      ? F.instances.transparentMeshInstances
                      : F.instances.opaqueMeshInstances;
                    for (let G = 0; G < D.length; G++) {
                      const X = D[G];
                      X.pick && T.push(X);
                    }
                  }
                }
                (!this.renderTarget ||
                  this.width !== this.renderTarget.width ||
                  this.height !== this.renderTarget.height) &&
                  (this.releaseRenderTarget(), this.allocateRenderTarget()),
                  this.updateCamera(_),
                  (this.mapping.length = 0),
                  this.app.renderComposition(this.layerComp);
              }
              updateCamera(_) {
                this.cameraEntity.copy(_.entity),
                  (this.cameraEntity.name = "PickerCamera");
                const m = this.cameraEntity.camera;
                m.copy(_),
                  (m.clearColorBuffer = !0),
                  (m.clearDepthBuffer = !0),
                  (m.clearStencilBuffer = !0),
                  (m.clearColor = A.Q.WHITE),
                  (m.renderTarget = this.renderTarget),
                  this.layer.clearCameras(),
                  this.layer.addCamera(m),
                  (m.layers = [this.layer.id]);
              }
              resize(_, m) {
                (this.width = Math.floor(_)), (this.height = Math.floor(m));
              }
            }
          },
          6348: (xe, V, a) => {
            "use strict";
            a.d(V, { e: () => d });
            var A = a(8633),
              x = a(541),
              y = a(7448),
              c = a(9645);
            class d {
              constructor(f) {
                (this.handlerType = "animclip"), (this.maxRetries = 0);
              }
              load(f, s) {
                typeof f == "string" && (f = { load: f, original: f });
                const l = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                f.load.startsWith("blob:") &&
                  (l.responseType = A.l.ResponseType.JSON),
                  A.L.get(f.load, l, function (n, o) {
                    n
                      ? s(
                          `Error loading animation clip resource: ${f.original} [${n}]`
                        )
                      : s(null, o);
                  });
              }
              open(f, s) {
                const l = s.name,
                  n = s.duration,
                  o = s.inputs.map(function (t) {
                    return new y.C(1, t);
                  }),
                  i = s.outputs.map(function (t) {
                    return new y.C(t.components, t.data);
                  }),
                  e = s.curves.map(function (t) {
                    return new x.v(
                      [t.path],
                      t.inputIndex,
                      t.outputIndex,
                      t.interpolation
                    );
                  });
                return new c.z(l, n, o, i, e);
              }
              patch(f, s) {}
            }
          },
          2436: (xe, V, a) => {
            "use strict";
            a.d(V, { r: () => y });
            var A = a(8633),
              x = a(949);
            class y {
              constructor(d) {
                (this.handlerType = "animstategraph"), (this.maxRetries = 0);
              }
              load(d, h) {
                typeof d == "string" && (d = { load: d, original: d });
                const f = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                d.load.startsWith("blob:") &&
                  (f.responseType = A.l.ResponseType.JSON),
                  A.L.get(d.load, f, function (s, l) {
                    s
                      ? h(
                          `Error loading animation state graph resource: ${d.original} [${s}]`
                        )
                      : h(null, l);
                  });
              }
              open(d, h) {
                return new x.R(h);
              }
              patch(d, h) {}
            }
          },
          4060: (xe, V, a) => {
            "use strict";
            a.d(V, { T: () => s });
            var A = a(1870),
              x = a(3021),
              y = a(7481),
              c = a(8633),
              d = a(5465),
              h = a(7825),
              f = a(2004);
            class s {
              constructor(n) {
                (this.handlerType = "animation"),
                  (this.device = n.graphicsDevice),
                  (this.assets = n.assets),
                  (this.maxRetries = 0);
              }
              load(n, o, i) {
                typeof n == "string" && (n = { load: n, original: n });
                const e = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                (n.load.startsWith("blob:") || n.load.startsWith("data:")) &&
                  (A.A.getExtension(n.original).toLowerCase() === ".glb"
                    ? (e.responseType = c.l.ResponseType.ARRAY_BUFFER)
                    : (e.responseType = c.l.ResponseType.JSON)),
                  c.L.get(n.load, e, (t, r) => {
                    if (t)
                      o(
                        `Error loading animation resource: ${n.original} [${t}]`
                      );
                    else if (
                      A.A.getExtension(n.original).toLowerCase() === ".glb"
                    ) {
                      var u;
                      f.l.parse(
                        "filename.glb",
                        "",
                        r,
                        this.device,
                        this.assets,
                        (u = i == null ? void 0 : i.options) != null ? u : {},
                        (v, _) => {
                          if (v) o(v);
                          else {
                            var m;
                            const g = _.animations;
                            if (i != null && (m = i.data) != null && m.events)
                              for (let T = 0; T < g.length; T++)
                                g[T].events = new h.F(
                                  Object.values(i.data.events)
                                );
                            _.destroy(), o(null, g);
                          }
                        }
                      );
                    } else
                      o(
                        null,
                        this["_parseAnimationV" + r.animation.version](r)
                      );
                  });
              }
              open(n, o, i) {
                return o;
              }
              patch(n, o) {}
              _parseAnimationV3(n) {
                const o = n.animation,
                  i = new d.X5();
                (i.name = o.name), (i.duration = o.duration);
                for (let e = 0; e < o.nodes.length; e++) {
                  const t = new d.bP(),
                    r = o.nodes[e];
                  t._name = r.name;
                  for (let u = 0; u < r.keys.length; u++) {
                    const v = r.keys[u],
                      _ = v.time,
                      m = v.pos,
                      g = v.rot,
                      T = v.scale,
                      E = new y.e(m[0], m[1], m[2]),
                      M = new x.k().setFromEulerAngles(g[0], g[1], g[2]),
                      R = new y.e(T[0], T[1], T[2]),
                      P = new d.Uz(_, E, M, R);
                    t._keys.push(P);
                  }
                  i.addNode(t);
                }
                return i;
              }
              _parseAnimationV4(n) {
                const o = n.animation,
                  i = new d.X5();
                (i.name = o.name), (i.duration = o.duration);
                for (let e = 0; e < o.nodes.length; e++) {
                  const t = new d.bP(),
                    r = o.nodes[e];
                  t._name = r.name;
                  const u = r.defaults.p,
                    v = r.defaults.r,
                    _ = r.defaults.s;
                  for (let m = 0; m < r.keys.length; m++) {
                    const g = r.keys[m],
                      T = g.t,
                      E = u || g.p,
                      M = v || g.r,
                      R = _ || g.s,
                      P = new y.e(E[0], E[1], E[2]),
                      F = new x.k().setFromEulerAngles(M[0], M[1], M[2]),
                      b = new y.e(R[0], R[1], R[2]),
                      D = new d.Uz(T, P, F, b);
                    t._keys.push(D);
                  }
                  i.addNode(t);
                }
                return i;
              }
            }
          },
          792: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => f });
            var A = a(1870),
              x = a(8633),
              y = a(9104),
              c = a(6122);
            const d = (function () {
                if (typeof window == "undefined") return !1;
                const s = window.navigator.userAgent,
                  l = s.indexOf("MSIE ");
                if (l > 0)
                  return parseInt(s.substring(l + 5, s.indexOf(".", l)), 10);
                if (s.indexOf("Trident/") > 0) {
                  const o = s.indexOf("rv:");
                  return parseInt(s.substring(o + 3, s.indexOf(".", o)), 10);
                }
                return !1;
              })(),
              h = [
                ".ogg",
                ".mp3",
                ".wav",
                ".mp4a",
                ".m4a",
                ".mp4",
                ".aac",
                ".opus",
              ];
            class f {
              constructor(l) {
                (this.handlerType = "audio"),
                  (this.manager = l.soundManager),
                  (this.maxRetries = 0);
              }
              _isSupported(l) {
                const n = A.A.getExtension(l);
                return h.indexOf(n) > -1;
              }
              load(l, n) {
                typeof l == "string" && (l = { load: l, original: l });
                const o = function (t) {
                    n(null, new c.A(t));
                  },
                  i = function (t) {
                    let r = "Error loading audio url: " + l.original;
                    t && (r += ": " + (t.message || t)), console.warn(r), n(r);
                  };
                if (this._createSound) {
                  if (!this._isSupported(l.original)) {
                    i(`Audio format for ${l.original} not supported`);
                    return;
                  }
                  this._createSound(l.load, o, i);
                } else i(null);
              }
              open(l, n) {
                return n;
              }
              patch(l, n) {}
              _createSound(l, n, o) {
                if ((0, y.U)()) {
                  const i = this.manager;
                  if (!i.context) {
                    o("Audio manager has no audio context");
                    return;
                  }
                  const e = {
                    retry: this.maxRetries > 0,
                    maxRetries: this.maxRetries,
                  };
                  (l.startsWith("blob:") || l.startsWith("data:")) &&
                    (e.responseType = x.l.ResponseType.ARRAY_BUFFER),
                    x.L.get(l, e, function (t, r) {
                      if (t) {
                        o(t);
                        return;
                      }
                      i.context.decodeAudioData(r, n, o);
                    });
                } else {
                  let i = null;
                  try {
                    i = new Audio();
                  } catch (t) {
                    o("No support for Audio element");
                    return;
                  }
                  d && document.body.appendChild(i);
                  const e = function t() {
                    i.removeEventListener("canplaythrough", t),
                      d && document.body.removeChild(i),
                      n(i);
                  };
                  (i.onerror = function () {
                    (i.onerror = null), d && document.body.removeChild(i), o();
                  }),
                    i.addEventListener("canplaythrough", e),
                    (i.src = l);
                }
              }
            }
          },
          7712: (xe, V, a) => {
            "use strict";
            a.d(V, { r: () => u, w: () => _ });
            var A = a(5562),
              x = a(1630);
            function y() {
              const m = {
                  cTFETC1: 0,
                  cTFETC2: 1,
                  cTFBC1: 2,
                  cTFBC3: 3,
                  cTFPVRTC1_4_RGB: 8,
                  cTFPVRTC1_4_RGBA: 9,
                  cTFASTC_4x4: 10,
                  cTFATC_RGB: 11,
                  cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
                  cTFRGBA32: 13,
                  cTFRGB565: 14,
                  cTFRGBA4444: 16,
                },
                g = {
                  astc: m.cTFASTC_4x4,
                  dxt: m.cTFBC1,
                  etc1: m.cTFETC1,
                  etc2: m.cTFETC1,
                  pvr: m.cTFPVRTC1_4_RGB,
                  atc: m.cTFATC_RGB,
                  none: m.cTFRGB565,
                },
                T = {
                  astc: m.cTFASTC_4x4,
                  dxt: m.cTFBC3,
                  etc1: m.cTFRGBA4444,
                  etc2: m.cTFETC2,
                  pvr: m.cTFPVRTC1_4_RGBA,
                  atc: m.cTFATC_RGBA_INTERPOLATED_ALPHA,
                  none: m.cTFRGBA4444,
                },
                E = {
                  ETC1: 21,
                  ETC2_RGB: 22,
                  ETC2_RGBA: 23,
                  DXT1: 8,
                  DXT5: 10,
                  PVRTC_4BPP_RGB_1: 26,
                  PVRTC_4BPP_RGBA_1: 27,
                  ASTC_4x4: 28,
                  ATC_RGB: 29,
                  ATC_RGBA: 30,
                  R8_G8_B8_A8: 7,
                  R5_G6_B5: 3,
                  R4_G4_B4_A4: 5,
                },
                M = (L, ge) => {
                  switch (L) {
                    case m.cTFETC1:
                      return ge.formats.etc1 ? E.ETC1 : E.ETC2_RGB;
                    case m.cTFETC2:
                      return E.ETC2_RGBA;
                    case m.cTFBC1:
                      return E.DXT1;
                    case m.cTFBC3:
                      return E.DXT5;
                    case m.cTFPVRTC1_4_RGB:
                      return E.PVRTC_4BPP_RGB_1;
                    case m.cTFPVRTC1_4_RGBA:
                      return E.PVRTC_4BPP_RGBA_1;
                    case m.cTFASTC_4x4:
                      return E.ASTC_4x4;
                    case m.cTFATC_RGB:
                      return E.ATC_RGB;
                    case m.cTFATC_RGBA_INTERPOLATED_ALPHA:
                      return E.ATC_RGBA;
                    case m.cTFRGBA32:
                      return E.R8_G8_B8_A8;
                    case m.cTFRGB565:
                      return E.R5_G6_B5;
                    case m.cTFRGBA4444:
                      return E.R4_G4_B4_A4;
                  }
                },
                R = (L) => {
                  const ge = function (j, B) {
                    const $ = j * 0.00784313725490196 - 1,
                      le = B * (2 / 255) - 1,
                      O = Math.sqrt(1 - Math.min(1, $ * $ + le * le));
                    return Math.max(
                      0,
                      Math.min(255, Math.floor((O + 1) * 0.5 * 255))
                    );
                  };
                  for (let k = 0; k < L.length; k += 4) {
                    const j = L[k + 3],
                      B = L[k + 1];
                    (L[k + 0] = j), (L[k + 2] = ge(j, B)), (L[k + 3] = 255);
                  }
                  return L;
                },
                P = (L) => {
                  const ge = new Uint16Array(L.length / 4);
                  for (let k = 0; k < L.length; k += 4) {
                    const j = L[k + 0],
                      B = L[k + 1],
                      $ = L[k + 2];
                    ge[k / 4] = ((j & 248) << 8) | ((B & 252) << 3) | ($ >> 3);
                  }
                  return ge;
                },
                F = (L, ge) => (L & (L - 1)) === 0 && (ge & (ge - 1)) === 0,
                b = () =>
                  typeof performance != "undefined" ? performance.now() : 0;
              let D, G, X;
              const ie = (L, ge, k) => {
                  if (k) {
                    if (L.formats.astc) return "astc";
                  } else if (ge) {
                    if (L.formats.etc2) return "etc2";
                  } else if (L.formats.etc1 || L.formats.etc2) return "etc1";
                  return ((B) => {
                    for (let $ = 0; $ < B.length; ++$) {
                      const le = B[$];
                      if (L.formats[le]) return le;
                    }
                    return "none";
                  })(ge ? X : G);
                },
                Q = (L, ge, k, j) => {
                  switch (k) {
                    case m.cTFETC1:
                    case m.cTFETC2:
                      return !0;
                    case m.cTFBC1:
                    case m.cTFBC3:
                      return (L & 3) === 0 && (ge & 3) === 0;
                    case m.cTFPVRTC1_4_RGB:
                    case m.cTFPVRTC1_4_RGBA:
                      return F(L, ge) && (L === ge || j);
                    case m.cTFASTC_4x4:
                      return !0;
                    case m.cTFATC_RGB:
                    case m.cTFATC_RGBA_INTERPOLATED_ALPHA:
                      return !0;
                  }
                },
                te = (L, ge, k) => {
                  if (!D.KTX2File)
                    throw new Error(
                      "Basis transcoder module does not include support for KTX2."
                    );
                  const j = b(),
                    B = new D.KTX2File(new Uint8Array(ge)),
                    $ = B.getWidth(),
                    le = B.getHeight(),
                    O = B.getLevels(),
                    Y = !!B.getHasAlpha(),
                    ne = B.isUASTC && B.isUASTC();
                  if (!$ || !le || !O)
                    throw (
                      (B.close(),
                      B.delete(),
                      new Error(
                        `Invalid image dimensions url=${L} width=${$} height=${le} levels=${O}`
                      ))
                    );
                  const de = ie(k.deviceDetails, Y, ne),
                    re = !!k.isGGGR && de === "pvr";
                  let I;
                  if (
                    (re
                      ? (I = m.cTFRGBA32)
                      : ((I = Y ? T[de] : g[de]),
                        Q($, le, I, k.deviceDetails.webgl2) ||
                          (I = Y ? m.cTFRGBA32 : m.cTFRGB565)),
                    !B.startTranscoding())
                  )
                    throw (
                      (B.close(),
                      B.delete(),
                      new Error("Failed to start transcoding url=" + L))
                    );
                  let w;
                  const N = [];
                  for (let W = 0; W < O; ++W) {
                    const he = B.getImageTranscodedSizeInBytes(W, 0, 0, I),
                      ue = new Uint8Array(he);
                    if (!B.transcodeImage(ue, W, 0, 0, I, 0, -1, -1))
                      throw (
                        (B.close(),
                        B.delete(),
                        new Error("Failed to transcode image url=" + L))
                      );
                    const ye = I === m.cTFRGB565 || I === m.cTFRGBA4444;
                    N.push(ye ? new Uint16Array(ue.buffer) : ue);
                  }
                  if ((B.close(), B.delete(), re))
                    for (I = m.cTFRGB565, w = 0; w < N.length; ++w)
                      N[w] = P(R(N[w]));
                  return {
                    format: M(I, k.deviceDetails),
                    width: $,
                    height: le,
                    levels: N,
                    cubemap: !1,
                    transcodeTime: b() - j,
                    url: L,
                    unswizzledGGGR: re,
                  };
                },
                ae = (L, ge, k) => {
                  const j = b(),
                    B = new D.BasisFile(new Uint8Array(ge)),
                    $ = B.getImageWidth(0, 0),
                    le = B.getImageHeight(0, 0),
                    O = B.getNumImages(),
                    Y = B.getNumLevels(0),
                    ne = !!B.getHasAlpha(),
                    de = B.isUASTC && B.isUASTC();
                  if (!$ || !le || !O || !Y)
                    throw (
                      (B.close(),
                      B.delete(),
                      new Error(
                        `Invalid image dimensions url=${L} width=${$} height=${le} images=${O} levels=${Y}`
                      ))
                    );
                  const re = ie(k.deviceDetails, ne, de),
                    I = !!k.isGGGR && re === "pvr";
                  let w;
                  if (
                    (I
                      ? (w = m.cTFRGBA32)
                      : ((w = ne ? T[re] : g[re]),
                        Q($, le, w, k.deviceDetails.webgl2) ||
                          (w = ne ? m.cTFRGBA32 : m.cTFRGB565)),
                    !B.startTranscoding())
                  )
                    throw (
                      (B.close(),
                      B.delete(),
                      new Error("Failed to start transcoding url=" + L))
                    );
                  let N;
                  const W = [];
                  for (let he = 0; he < Y; ++he) {
                    const ue = B.getImageTranscodedSizeInBytes(0, he, w),
                      ye = new Uint8Array(ue);
                    if (!B.transcodeImage(ye, 0, he, w, 0, 0))
                      throw (
                        (B.close(),
                        B.delete(),
                        new Error("Failed to transcode image url=" + L))
                      );
                    const Oe = w === m.cTFRGB565 || w === m.cTFRGBA4444;
                    W.push(Oe ? new Uint16Array(ye.buffer) : ye);
                  }
                  if ((B.close(), B.delete(), I))
                    for (w = m.cTFRGB565, N = 0; N < W.length; ++N)
                      W[N] = P(R(W[N]));
                  return {
                    format: M(w, k.deviceDetails),
                    width: $,
                    height: le,
                    levels: W,
                    cubemap: !1,
                    transcodeTime: b() - j,
                    url: L,
                    unswizzledGGGR: I,
                  };
                },
                Z = (L, ge, k) => (k.isKTX2 ? te(L, ge, k) : ae(L, ge, k)),
                J = (L, ge, k) => {
                  try {
                    const j = Z(L, ge, k);
                    (j.levels = j.levels.map((B) => B.buffer)),
                      self.postMessage({ url: L, data: j }, j.levels);
                  } catch (j) {
                    self.postMessage({ url: L, err: j }, null);
                  }
                },
                ve = (L, ge) => {
                  const k = (j, B) => (
                    WebAssembly.instantiate(L.module, j)
                      .then(($) => {
                        B($);
                      })
                      .catch(($) => {
                        console.error("instantiate failed + " + $);
                      }),
                    {}
                  );
                  self
                    .BASIS(L.module ? { instantiateWasm: k } : null)
                    .then((j) => {
                      j.initializeBasis(),
                        (D = j),
                        (G = L.rgbPriority),
                        (X = L.rgbaPriority),
                        ge(null);
                    });
                },
                _e = [];
              self.onmessage = (L) => {
                const ge = L.data;
                switch (ge.type) {
                  case "init":
                    ve(ge.config, () => {
                      for (let k = 0; k < _e.length; ++k)
                        J(_e[k].url, _e[k].data, _e[k].options);
                      _e.length = 0;
                    });
                    break;
                  case "transcode":
                    D ? J(ge.url, ge.data, ge.options) : _e.push(ge);
                    break;
                }
              };
            }
            var c = a(8633);
            const d = (m) => ({
                astc: !!m.extCompressedTextureASTC,
                atc: !!m.extCompressedTextureATC,
                dxt: !!m.extCompressedTextureS3TC,
                etc1: !!m.extCompressedTextureETC1,
                etc2: !!m.extCompressedTextureETC,
                pvr: !!m.extCompressedTexturePVRTC,
              }),
              h = (m, g) => {
                const T = (P) => {
                    const F = [
                      "/* basis */",
                      P,
                      "",
                      "(" +
                        y.toString() +
                        `)()

`,
                    ].join(`
`);
                    return new Blob([F], { type: "application/javascript" });
                  },
                  E = () => {
                    try {
                      if (
                        typeof WebAssembly == "object" &&
                        typeof WebAssembly.instantiate == "function"
                      ) {
                        const P = new WebAssembly.Module(
                          Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)
                        );
                        if (P instanceof WebAssembly.Module)
                          return (
                            new WebAssembly.Instance(P) instanceof
                            WebAssembly.Instance
                          );
                      }
                    } catch (P) {}
                    return !1;
                  },
                  M = (P, F) => {
                    g(null, {
                      workerUrl: URL.createObjectURL(T(P)),
                      module: F,
                      rgbPriority: m.rgbPriority,
                      rgbaPriority: m.rgbaPriority,
                    });
                  },
                  R = {
                    cache: !0,
                    responseType: "text",
                    retry: m.maxRetries > 0,
                    maxRetries: m.maxRetries,
                  };
                if (m.glueUrl && m.wasmUrl && E()) {
                  let P = null,
                    F = null;
                  c.L.get(m.glueUrl, R, (G, X) => {
                    G ? g(G) : F ? M(X, F) : (P = X);
                  });
                  const b = fetch(m.wasmUrl),
                    D = () => {
                      b.then((G) => G.arrayBuffer())
                        .then((G) => WebAssembly.compile(G))
                        .then((G) => {
                          P ? M(P, G) : (F = G);
                        })
                        .catch((G) => {
                          g(G, null);
                        });
                    };
                  WebAssembly.compileStreaming
                    ? WebAssembly.compileStreaming(b)
                        .then((G) => {
                          P ? M(P, G) : (F = G);
                        })
                        .catch((G) => {
                          D();
                        })
                    : D();
                } else
                  c.L.get(m.fallbackUrl, R, (P, F) => {
                    P ? g(P, null) : M(F, null);
                  });
              };
            class f {
              constructor() {
                (this.callbacks = {}), (this.queue = []), (this.clients = []);
              }
              enqueueJob(g, T, E, M) {
                if (this.callbacks.hasOwnProperty(g)) this.callbacks[g].push(E);
                else {
                  this.callbacks[g] = [E];
                  const R = { url: g, data: T, options: M };
                  this.clients.length > 0
                    ? this.clients.shift().run(R)
                    : this.queue.push(R);
                }
              }
              enqueueClient(g) {
                this.queue.length > 0
                  ? g.run(this.queue.shift())
                  : this.clients.push(g);
              }
              handleResponse(g, T, E) {
                const M = this.callbacks[g];
                if (T) for (let R = 0; R < M.length; ++R) M[R](T);
                else {
                  E.format === x.kqw || E.format === x.LDn
                    ? (E.levels = E.levels.map(function (R) {
                        return new Uint16Array(R);
                      }))
                    : (E.levels = E.levels.map(function (R) {
                        return new Uint8Array(R);
                      }));
                  for (let R = 0; R < M.length; ++R) M[R](null, E);
                }
                delete this.callbacks[g];
              }
            }
            class s {
              constructor(g, T, E) {
                (this.queue = g),
                  (this.worker = new Worker(T.workerUrl)),
                  this.worker.addEventListener("message", (M) => {
                    const R = M.data;
                    this.queue.handleResponse(R.url, R.err, R.data),
                      this.eager || this.queue.enqueueClient(this);
                  }),
                  this.worker.postMessage({ type: "init", config: T }),
                  (this.eager = E);
              }
              run(g) {
                const T = [];
                g.data instanceof ArrayBuffer && T.push(g.data),
                  this.worker.postMessage(
                    {
                      type: "transcode",
                      url: g.url,
                      format: g.format,
                      data: g.data,
                      options: g.options,
                    },
                    T
                  ),
                  this.eager && this.queue.enqueueClient(this);
              }
            }
            const l = 1,
              n = ["etc1", "etc2", "astc", "dxt", "pvr", "atc"],
              o = ["astc", "dxt", "etc2", "pvr", "atc"],
              i = 5,
              e = new f();
            let t = null,
              r = !1;
            function u(m) {
              if (!r) {
                if (!m) m = t || {};
                else if (m.lazyInit) {
                  t = m;
                  return;
                }
                if (!m.glueUrl || !m.wasmUrl || !m.fallbackUrl) {
                  const g = A.F.getConfig("BASIS");
                  g &&
                    (m = {
                      glueUrl: g.glueUrl,
                      wasmUrl: g.wasmUrl,
                      fallbackUrl: g.fallbackUrl,
                      numWorkers: g.numWorkers,
                    });
                }
                if (m.glueUrl || m.wasmUrl || m.fallbackUrl) {
                  r = !0;
                  const g = Math.max(1, Math.min(16, m.numWorkers || l)),
                    T =
                      m.numWorkers === 1 ||
                      (m.hasOwnProperty("eagerWorkers") ? m.eagerWorkers : !0);
                  (m.rgbPriority = m.rgbPriority || n),
                    (m.rgbaPriority = m.rgbaPriority || o),
                    (m.maxRetries = m.hasOwnProperty("maxRetries")
                      ? m.maxRetries
                      : i),
                    h(m, (E, M) => {
                      if (E)
                        console.error(
                          `failed to initialize basis worker: ${E}`
                        );
                      else
                        for (let R = 0; R < g; ++R)
                          e.enqueueClient(new s(e, M, T));
                    });
                }
              }
            }
            let v = null;
            function _(m, g, T, E, M) {
              return (
                u(),
                v || (v = { webgl2: m.webgl2, formats: d(m) }),
                e.enqueueJob(g, T, E, {
                  deviceDetails: v,
                  isGGGR: !!(M != null && M.isGGGR),
                  isKTX2: !!(M != null && M.isKTX2),
                }),
                r
              );
            }
          },
          2629: (xe, V, a) => {
            "use strict";
            a.d(V, { _: () => x });
            var A = a(8633);
            class x {
              constructor(c) {
                (this.handlerType = "binary"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  A.L.get(
                    c.load,
                    {
                      responseType: A.l.ResponseType.ARRAY_BUFFER,
                      retry: this.maxRetries > 0,
                      maxRetries: this.maxRetries,
                    },
                    function (h, f) {
                      h
                        ? d(
                            `Error loading binary resource: ${c.original} [${h}]`
                          )
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          6498: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => l });
            var A = a(9222),
              x = a(8633),
              y = a(3259);
            let c;
            function d(n) {
              let o, i;
              if (typeof TextDecoder != "undefined")
                try {
                  (o = new TextDecoder("utf-8")),
                    (i = new TextDecoder("windows-1252"));
                } catch (r) {
                  console.warn(
                    "TextDecoder not supported - pc.Untar module will not work"
                  );
                }
              else
                console.warn(
                  "TextDecoder not supported - pc.Untar module will not work"
                );
              function e(r) {
                this._fields = r;
              }
              (e.parse = function (r, u, v) {
                const _ = new Uint8Array(r, u, v);
                let m = 0;
                const g = [];
                for (; m < v; ) {
                  let T;
                  for (T = m; T < v && _[T] !== 32; T++);
                  if (T >= v)
                    throw new Error("Invalid PAX header data format.");
                  const E = parseInt(
                      o.decode(new Uint8Array(r, u + m, T - m)),
                      10
                    ),
                    R = o
                      .decode(new Uint8Array(r, u + T + 1, E - (T - m) - 2))
                      .split("=");
                  if (R.length !== 2)
                    throw new Error("Invalid PAX header data format.");
                  R[1].length === 0 && (R[1] = null),
                    g.push({ name: R[0], value: R[1] }),
                    (m += E);
                }
                return new e(g);
              }),
                (e.prototype.applyHeader = function (r) {
                  for (let u = 0; u < this._fields.length; u++) {
                    let v = this._fields[u].name;
                    const _ = this._fields[u].value;
                    v === "path" && (v = "name"),
                      _ === null ? delete r[v] : (r[v] = _);
                  }
                });
              function t(r) {
                (this._arrayBuffer = r || new ArrayBuffer(0)),
                  (this._bufferView = new DataView(this._arrayBuffer)),
                  (this._globalPaxHeader = null),
                  (this._paxHeader = null),
                  (this._bytesRead = 0);
              }
              n || (c = t),
                (t.prototype._hasNext = function () {
                  return (
                    this._bytesRead + 4 < this._arrayBuffer.byteLength &&
                    this._bufferView.getUint32(this._bytesRead) !== 0
                  );
                }),
                (t.prototype._readNextFile = function () {
                  const r = new DataView(
                      this._arrayBuffer,
                      this._bytesRead,
                      512
                    ),
                    u = i.decode(r);
                  this._bytesRead += 512;
                  let v = u.substring(0, 100).replace(/\0/g, "");
                  const _ = u.substring(257, 263),
                    m = parseInt(u.substring(124, 136), 8),
                    g = u.substring(156, 157),
                    T = this._bytesRead;
                  let E = null,
                    M = !1;
                  switch (g) {
                    case "0":
                    case "":
                      if (((M = !0), !n)) {
                        const F = new Blob([
                          this._arrayBuffer.slice(
                            this._bytesRead,
                            this._bytesRead + m
                          ),
                        ]);
                        E = URL.createObjectURL(F);
                      }
                      break;
                    case "g":
                      this._globalPaxHeader = e.parse(
                        this._arrayBuffer,
                        this._bytesRead,
                        m
                      );
                      break;
                    case "x":
                      this._paxHeader = e.parse(
                        this._arrayBuffer,
                        this._bytesRead,
                        m
                      );
                      break;
                  }
                  this._bytesRead += m;
                  const R = m % 512;
                  if ((R !== 0 && (this._bytesRead += 512 - R), !M))
                    return null;
                  if (_.indexOf("ustar") !== -1) {
                    const F = u.substring(345, 500).replace(/\0/g, "");
                    F.length > 0 && (v = F.trim() + v.trim());
                  }
                  const P = { name: v, start: T, size: m, url: E };
                  return (
                    this._globalPaxHeader &&
                      this._globalPaxHeader.applyHeader(P),
                    this._paxHeader &&
                      (this._paxHeader.applyHeader(P),
                      (this._paxHeader = null)),
                    P
                  );
                }),
                (t.prototype.untar = function (r) {
                  if (!o)
                    return (
                      console.error(
                        "Cannot untar because TextDecoder interface is not available for this platform."
                      ),
                      []
                    );
                  const u = [];
                  for (; this._hasNext(); ) {
                    const v = this._readNextFile();
                    v && (r && v.name && (v.name = r + v.name), u.push(v));
                  }
                  return u;
                }),
                n &&
                  (self.onmessage = function (r) {
                    const u = r.data.id;
                    try {
                      const _ = new t(r.data.arrayBuffer).untar(r.data.prefix);
                      postMessage(
                        { id: u, files: _, arrayBuffer: r.data.arrayBuffer },
                        [r.data.arrayBuffer]
                      );
                    } catch (v) {
                      postMessage({ id: u, error: v.toString() });
                    }
                  });
            }
            let h = null;
            function f() {
              if (!h) {
                const n =
                    "(" +
                    d.toString() +
                    `)(true)

`,
                  o = new Blob([n], { type: "application/javascript" });
                h = URL.createObjectURL(o);
              }
              return h;
            }
            class s {
              constructor(o) {
                (this._requestId = 0),
                  (this._pendingRequests = {}),
                  (this._filenamePrefix = o),
                  (this._worker = new Worker(f())),
                  this._worker.addEventListener(
                    "message",
                    this._onMessage.bind(this)
                  );
              }
              _onMessage(o) {
                const i = o.data.id;
                if (!this._pendingRequests[i]) return;
                const e = this._pendingRequests[i];
                if ((delete this._pendingRequests[i], o.data.error))
                  e(o.data.error);
                else {
                  const t = o.data.arrayBuffer;
                  for (let r = 0, u = o.data.files.length; r < u; r++) {
                    const v = o.data.files[r],
                      _ = new Blob([t.slice(v.start, v.start + v.size)]);
                    v.url = URL.createObjectURL(_);
                  }
                  e(null, o.data.files);
                }
              }
              untar(o, i) {
                const e = this._requestId++;
                (this._pendingRequests[e] = i),
                  this._worker.postMessage(
                    { id: e, prefix: this._filenamePrefix, arrayBuffer: o },
                    [o]
                  );
              }
              hasPendingRequests() {
                return Object.keys(this._pendingRequests).length > 0;
              }
              destroy() {
                this._worker &&
                  (this._worker.terminate(),
                  (this._worker = null),
                  (this._pendingRequests = null));
              }
            }
            d();
            class l {
              constructor(o) {
                (this.handlerType = "bundle"),
                  (this._assets = o.assets),
                  (this._worker = null),
                  (this.maxRetries = 0);
              }
              load(o, i) {
                typeof o == "string" && (o = { load: o, original: o });
                const e = this;
                x.L.get(
                  o.load,
                  {
                    responseType: x.l.ResponseType.ARRAY_BUFFER,
                    retry: this.maxRetries > 0,
                    maxRetries: this.maxRetries,
                  },
                  function (t, r) {
                    if (t)
                      i(
                        "Error loading bundle resource " + o.original + ": " + t
                      );
                    else
                      try {
                        e._untar(r, i);
                      } catch (u) {
                        i(
                          "Error loading bundle resource " +
                            o.original +
                            ": " +
                            u
                        );
                      }
                  }
                );
              }
              _untar(o, i) {
                const e = this;
                if (A.i.workers)
                  e._worker || (e._worker = new s(e._assets.prefix)),
                    e._worker.untar(o, function (t, r) {
                      i(t, r),
                        e._worker.hasPendingRequests() ||
                          (e._worker.destroy(), (e._worker = null));
                    });
                else {
                  const r = new c(o).untar(e._assets.prefix);
                  i(null, r);
                }
              }
              open(o, i) {
                return new y.N(i);
              }
              patch(o, i) {}
            }
          },
          3484: (xe, V, a) => {
            "use strict";
            a.d(V, { a: () => f, I: () => h });
            var A = a(1870),
              x = a(3953),
              y = a(2004),
              c = a(6377);
            class d {
              constructor(l, n, o) {
                (this._device = l),
                  (this._assets = n),
                  (this._defaultMaterial = y.l.createDefaultMaterial()),
                  (this.maxRetries = o);
              }
              _getUrlWithoutParams(l) {
                return l.indexOf("?") >= 0 ? l.split("?")[0] : l;
              }
              load(l, n, o) {
                x.V.fetchArrayBuffer(
                  l.load,
                  (i, e) => {
                    i
                      ? n(i)
                      : y.l.parse(
                          this._getUrlWithoutParams(l.original),
                          A.A.extractPath(l.load),
                          e,
                          this._device,
                          o.registry,
                          o.options,
                          (t, r) => {
                            t
                              ? n(t)
                              : n(
                                  null,
                                  new c.V(
                                    r,
                                    o,
                                    this._assets,
                                    this._defaultMaterial
                                  )
                                );
                          }
                        );
                  },
                  o,
                  this.maxRetries
                );
              }
              open(l, n, o) {
                return n;
              }
              patch(l, n) {}
            }
            class h {
              instantiateModelEntity(l) {
                return null;
              }
              instantiateRenderEntity(l) {
                return null;
              }
              getMaterialVariants() {
                return null;
              }
              applyMaterialVariant(l, n) {}
              applyMaterialVariantInstances(l, n) {}
            }
            class f {
              constructor(l) {
                (this.handlerType = "container"),
                  (this.glbContainerParser = new d(
                    l.graphicsDevice,
                    l.assets,
                    0
                  )),
                  (this.parsers = {});
              }
              set maxRetries(l) {
                this.glbContainerParser.maxRetries = l;
                for (const n in this.parsers)
                  this.parsers.hasOwnProperty(n) &&
                    (this.parsers[n].maxRetries = l);
              }
              get maxRetries() {
                return this.glbContainerParser.maxRetries;
              }
              _getUrlWithoutParams(l) {
                return l.indexOf("?") >= 0 ? l.split("?")[0] : l;
              }
              _getParser(l) {
                const n = l
                  ? A.A.getExtension(this._getUrlWithoutParams(l))
                      .toLowerCase()
                      .replace(".", "")
                  : null;
                return this.parsers[n] || this.glbContainerParser;
              }
              load(l, n, o) {
                typeof l == "string" && (l = { load: l, original: l }),
                  this._getParser(l.original).load(l, n, o);
              }
              open(l, n, o) {
                return this._getParser(l).open(l, n, o);
              }
              patch(l, n) {}
            }
          },
          6341: (xe, V, a) => {
            "use strict";
            a.d(V, { C: () => x });
            var A = a(8633);
            class x {
              constructor(c) {
                (this.handlerType = "css"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  A.L.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(`Error loading css resource: ${c.original} [${h}]`)
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          8363: (xe, V, a) => {
            "use strict";
            a.d(V, { s: () => c });
            var A = a(1630),
              x = a(1208),
              y = a(3953);
            class c {
              constructor(h) {
                (this.handlerType = "cubemap"),
                  (this._device = h.graphicsDevice),
                  (this._registry = h.assets),
                  (this._loader = h.loader);
              }
              load(h, f, s) {
                this.loadAssets(s, f);
              }
              open(h, f, s) {
                return s ? s.resource : null;
              }
              patch(h, f) {
                this.loadAssets(h, function (s, l) {
                  s &&
                    (f.fire("error", h),
                    f.fire("error:" + h.id, s, h),
                    h.fire("error", h));
                });
              }
              getAssetIds(h) {
                const f = [];
                if (
                  ((f[0] = h.file),
                  (h.loadFaces || !h.file) && h.data && h.data.textures)
                )
                  for (let s = 0; s < 6; ++s) f[s + 1] = h.data.textures[s];
                else f[1] = f[2] = f[3] = f[4] = f[5] = f[6] = null;
                return f;
              }
              compareAssetIds(h, f) {
                return h && f
                  ? parseInt(h, 10) === h || typeof h == "string"
                    ? h === f
                    : h.url === f.url
                  : (h !== null) == (f !== null);
              }
              update(h, f, s) {
                const l = h.data || {},
                  n = h._handlerState.assets,
                  o = h._resources;
                let i, e, t;
                const r = [null, null, null, null, null, null, null],
                  u = function () {
                    return l.hasOwnProperty("type")
                      ? l.type
                      : l.hasOwnProperty("rgbm")
                      ? l.rgbm
                        ? A.fW0
                        : A.s64
                      : null;
                  };
                if (!h.loaded || s[0] !== n[0]) {
                  if (s[0])
                    if (((i = s[0].resource), i.cubemap))
                      for (t = 0; t < 6; ++t)
                        r[t + 1] = new x.g(this._device, {
                          name: h.name + "_prelitCubemap" + (i.width >> t),
                          cubemap: !0,
                          type: u() || i.type,
                          width: i.width >> t,
                          height: i.height >> t,
                          format: i.format,
                          levels: [i._levels[t]],
                          fixCubemapSeams: !0,
                          addressU: A.vq6,
                          addressV: A.vq6,
                          mipmaps: t === 0,
                        });
                    else (i.type = A.mEg), (r[1] = i);
                } else
                  (r[1] = o[1] || null),
                    (r[2] = o[2] || null),
                    (r[3] = o[3] || null),
                    (r[4] = o[4] || null),
                    (r[5] = o[5] || null),
                    (r[6] = o[6] || null);
                const v = s.slice(1);
                if (!h.loaded || !this.cmpArrays(v, n.slice(1))) {
                  if (v.indexOf(null) === -1) {
                    var _;
                    const m = v.map(function (M) {
                        return M.resource;
                      }),
                      g = [];
                    for (e = 0; e < m[0]._levels.length; ++e)
                      g.push(
                        m.map(function (M) {
                          return M._levels[e];
                        })
                      );
                    const T = m[0].format,
                      E = new x.g(this._device, {
                        name: h.name + "_faces",
                        cubemap: !0,
                        type: u() || m[0].type,
                        width: m[0].width,
                        height: m[0].height,
                        format: T === A.akF ? A.Lxj : T,
                        mipmaps: (_ = l.mipmaps) != null ? _ : !0,
                        levels: g,
                        minFilter: l.hasOwnProperty("minFilter")
                          ? l.minFilter
                          : m[0].minFilter,
                        magFilter: l.hasOwnProperty("magFilter")
                          ? l.magFilter
                          : m[0].magFilter,
                        anisotropy: l.hasOwnProperty("anisotropy")
                          ? l.anisotropy
                          : 1,
                        addressU: A.vq6,
                        addressV: A.vq6,
                        fixCubemapSeams: !!s[0],
                      });
                    r[0] = E;
                  }
                } else r[0] = o[0] || null;
                if (!this.cmpArrays(r, o))
                  for (
                    h.resources = r,
                      h._handlerState.assetIds = f,
                      h._handlerState.assets = s,
                      t = 0;
                    t < o.length;
                    ++t
                  )
                    o[t] !== null && r.indexOf(o[t]) === -1 && o[t].destroy();
                for (t = 0; t < n.length; ++t)
                  n[t] !== null && s.indexOf(n[t]) === -1 && n[t].unload();
              }
              cmpArrays(h, f) {
                if (h.length !== f.length) return !1;
                for (let s = 0; s < h.length; ++s) if (h[s] !== f[s]) return !1;
                return !0;
              }
              resolveId(h) {
                const f = parseInt(h, 10);
                return f === h || f.toString() === h ? f : h;
              }
              loadAssets(h, f) {
                h.hasOwnProperty("_handlerState") ||
                  (h._handlerState = {
                    assetIds: [null, null, null, null, null, null, null],
                    assets: [null, null, null, null, null, null, null],
                  });
                const s = this,
                  l = s.getAssetIds(h),
                  n = [null, null, null, null, null, null, null],
                  o = h._handlerState.assetIds,
                  i = h._handlerState.assets,
                  e = s._registry;
                let t = 7;
                const r = function (g, T) {
                    (n[g] = T),
                      t--,
                      t === 0 && (s.update(h, l, n), f(null, h.resources));
                  },
                  u = function (g, T, E) {
                    f(T);
                  },
                  v = function (g, T) {
                    T.loaded
                      ? r(g, T)
                      : (e.once("load:" + T.id, r.bind(s, g)),
                        e.once("error:" + T.id, u.bind(s, g)),
                        T.loading || e.load(T));
                  };
                let _;
                for (let m = 0; m < 7; ++m) {
                  const g = this.resolveId(l[m]);
                  if (!g) r(m, null);
                  else if (s.compareAssetIds(g, o[m])) r(m, i[m]);
                  else if (parseInt(g, 10) === g)
                    (_ = e.get(g)),
                      _
                        ? v(m, _)
                        : setTimeout(
                            function (T, E) {
                              const M = e.get(E);
                              M
                                ? v(T, M)
                                : u(
                                    T,
                                    "failed to find dependent cubemap asset=" +
                                      E
                                  );
                            }.bind(null, m, g)
                          );
                  else {
                    const T =
                      typeof g == "string" ? { url: g, filename: g } : g;
                    (_ = new y.V(h.name + "_part_" + m, "texture", T)),
                      e.add(_),
                      e.once("load:" + _.id, r.bind(s, m)),
                      e.once("error:" + _.id, u.bind(s, m)),
                      e.load(_);
                  }
                }
              }
            }
          },
          1872: (xe, V, a) => {
            "use strict";
            a.d(V, { p: () => A });
            class A {
              constructor() {
                this.handlerType = "folder";
              }
              load(y, c) {
                c(null, null);
              }
              open(y, c) {
                return c;
              }
            }
          },
          7369: (xe, V, a) => {
            "use strict";
            a.d(V, { q: () => h });
            var A = a(1870),
              x = a(8772),
              y = a(8633),
              c = a(4289);
            function d(f) {
              return (
                f.version < 3 &&
                  (f.version < 2 &&
                    (f.info.maps = f.info.maps || [
                      { width: f.info.width, height: f.info.height },
                    ]),
                  (f.chars = Object.keys(f.chars || {}).reduce(function (s, l) {
                    const n = f.chars[l],
                      o = n.letter !== void 0 ? n.letter : x.Y.fromCodePoint(l);
                    return f.version < 2 && (n.map = n.map || 0), (s[o] = n), s;
                  }, {})),
                  (f.version = 3)),
                f
              );
            }
            class h {
              constructor(s) {
                (this.handlerType = "font"),
                  (this._loader = s.loader),
                  (this.maxRetries = 0);
              }
              load(s, l, n) {
                typeof s == "string" && (s = { load: s, original: s });
                const o = this;
                A.A.getExtension(s.original) === ".json"
                  ? y.L.get(
                      s.load,
                      {
                        retry: this.maxRetries > 0,
                        maxRetries: this.maxRetries,
                      },
                      function (i, e) {
                        if (i)
                          l(
                            `Error loading font resource: ${s.original} [${i}]`
                          );
                        else {
                          const t = d(e);
                          o._loadTextures(
                            s.load.replace(".json", ".png"),
                            t,
                            function (r, u) {
                              if (r) return l(r);
                              l(null, { data: t, textures: u });
                            }
                          );
                        }
                      }
                    )
                  : (n && n.data && (n.data = d(n.data)),
                    this._loadTextures(s.load, n && n.data, l));
              }
              _loadTextures(s, l, n) {
                const o = l.info.maps.length;
                let i = 0,
                  e = null;
                const t = new Array(o),
                  r = this._loader,
                  u = function (_) {
                    const m = function (T, E) {
                      if (!e) {
                        if (T) return (e = T), n(T);
                        E.upload(), (t[_] = E), i++, i === o && n(null, t);
                      }
                    };
                    _ === 0
                      ? r.load(s, "texture", m)
                      : r.load(s.replace(".png", _ + ".png"), "texture", m);
                  };
                for (let v = 0; v < o; v++) u(v);
              }
              open(s, l, n) {
                let o;
                return (
                  l.textures
                    ? (o = new c.K(l.textures, l.data))
                    : (o = new c.K(l, null)),
                  o
                );
              }
              patch(s, l) {
                const n = s.resource;
                !n.data && s.data
                  ? (n.data = s.data)
                  : !s.data && n.data && (s.data = n.data),
                  s.data && (s.data = d(s.data));
              }
            }
          },
          3037: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => y });
            var A = a(8158),
              x = a(7766);
            class y {
              constructor(d) {
                (this.handlerType = "hierarchy"),
                  (this._app = d),
                  (this.maxRetries = 0);
              }
              load(d, h) {
                x.u.load(d, this.maxRetries, h);
              }
              open(d, h) {
                this._app.systems.script.preloading = !0;
                const s = new A.q(this._app, !1).parse(h);
                return (this._app.systems.script.preloading = !1), s;
              }
            }
          },
          2581: (xe, V, a) => {
            "use strict";
            a.d(V, { g: () => x });
            var A = a(8633);
            class x {
              constructor(c) {
                (this.handlerType = "html"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  A.L.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(`Error loading html resource: ${c.original} [${h}]`)
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          4230: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => x });
            var A = a(8633);
            class x {
              constructor(c) {
                (this.handlerType = "json"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c });
                const h = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                c.load.startsWith("blob:") &&
                  (h.responseType = A.l.ResponseType.JSON),
                  A.L.get(c.load, h, function (f, s) {
                    f
                      ? d(`Error loading JSON resource: ${c.original} [${f}]`)
                      : d(null, s);
                  });
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          9992: (xe, V, a) => {
            "use strict";
            a.d(V, { W: () => A });
            class A {
              constructor(y) {
                (this._handlers = {}),
                  (this._requests = {}),
                  (this._cache = {}),
                  (this._app = y);
              }
              addHandler(y, c) {
                (this._handlers[y] = c), (c._loader = this);
              }
              removeHandler(y) {
                delete this._handlers[y];
              }
              getHandler(y) {
                return this._handlers[y];
              }
              static makeKey(y, c) {
                return `${y}-${c}`;
              }
              load(y, c, d, h) {
                const f = this._handlers[c];
                if (!f) {
                  const l = `No resource handler for asset type: '${c}' when loading [${y}]`;
                  d(l);
                  return;
                }
                if (!y) {
                  this._loadNull(f, d, h);
                  return;
                }
                const s = A.makeKey(y, c);
                if (this._cache[s] !== void 0) d(null, this._cache[s]);
                else if (this._requests[s]) this._requests[s].push(d);
                else {
                  this._requests[s] = [d];
                  const l = this,
                    n = function (e, t) {
                      if (e) {
                        l._onFailure(s, e);
                        return;
                      }
                      f.load(
                        t,
                        function (r, u, v) {
                          if (l._requests[s]) {
                            if (r) {
                              l._onFailure(s, r);
                              return;
                            }
                            try {
                              l._onSuccess(s, f.open(t.original, u, h), v);
                            } catch (_) {
                              l._onFailure(s, _);
                            }
                          }
                        },
                        h
                      );
                    },
                    o = y.split("?")[0];
                  if (this._app.enableBundles && this._app.bundles.hasUrl(o)) {
                    if (!this._app.bundles.canLoadUrl(o)) {
                      n(`Bundle for ${y} not loaded yet`);
                      return;
                    }
                    this._app.bundles.loadUrl(o, function (i, e) {
                      n(i, { load: e, original: o });
                    });
                  } else
                    n(null, { load: y, original: (h && h.file.filename) || y });
                }
              }
              _loadNull(y, c, d) {
                const h = function (s, l, n) {
                  if (s) c(s);
                  else
                    try {
                      c(null, y.open(null, l, d), n);
                    } catch (o) {
                      c(o);
                    }
                };
                y.load(null, h, d);
              }
              _onSuccess(y, c, d) {
                c !== null ? (this._cache[y] = c) : delete this._cache[y];
                for (let h = 0; h < this._requests[y].length; h++)
                  this._requests[y][h](null, c, d);
                delete this._requests[y];
              }
              _onFailure(y, c) {
                if ((console.error(c), this._requests[y])) {
                  for (let d = 0; d < this._requests[y].length; d++)
                    this._requests[y][d](c);
                  delete this._requests[y];
                }
              }
              open(y, c) {
                const d = this._handlers[y];
                return d
                  ? d.open(null, c)
                  : (console.warn("No resource handler found for: " + y), c);
              }
              patch(y, c) {
                const d = this._handlers[y.type];
                if (!d) {
                  console.warn("No resource handler found for: " + y.type);
                  return;
                }
                d.patch && d.patch(y, c);
              }
              clearCache(y, c) {
                const d = A.makeKey(y, c);
                delete this._cache[d];
              }
              getFromCache(y, c) {
                const d = A.makeKey(y, c);
                if (this._cache[d]) return this._cache[d];
              }
              enableRetry(y = 5) {
                y = Math.max(0, y) || 0;
                for (const c in this._handlers)
                  this._handlers[c].maxRetries = y;
              }
              disableRetry() {
                for (const y in this._handlers)
                  this._handlers[y].maxRetries = 0;
              }
              destroy() {
                (this._handlers = {}),
                  (this._requests = {}),
                  (this._cache = {});
              }
            }
          },
          6153: (xe, V, a) => {
            "use strict";
            a.d(V, { U: () => l });
            var A = a(8633),
              x = a(1630),
              y = a(1208),
              c = a(9391),
              d = a(6679),
              h = a(3029),
              f = a(461);
            const s = {
              aoMap: "white",
              diffuseMap: "gray",
              specularMap: "gray",
              specularityFactorMap: "white",
              metalnessMap: "black",
              glossMap: "gray",
              sheenMap: "black",
              sheenGlossinessMap: "gray",
              clearCoatMap: "black",
              clearCoatGlossMap: "gray",
              clearCoatNormalMap: "normal",
              refractionMap: "white",
              emissiveMap: "gray",
              normalMap: "normal",
              heightMap: "gray",
              opacityMap: "gray",
              sphereMap: "gray",
              lightMap: "white",
            };
            class l {
              constructor(o) {
                (this.handlerType = "material"),
                  (this._assets = o.assets),
                  (this._device = o.graphicsDevice),
                  (this._placeholderTextures = null),
                  (this._parser = new f.m()),
                  (this.maxRetries = 0);
              }
              load(o, i) {
                typeof o == "string" && (o = { load: o, original: o }),
                  A.L.get(
                    o.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (e, t) {
                      e
                        ? i && i(`Error loading material: ${o.original} [${e}]`)
                        : i && ((t._engine = !0), i(null, t));
                    }
                  );
              }
              open(o, i) {
                const e = this._parser.parse(i);
                return i._engine && ((e._data = i), delete i._engine), e;
              }
              _createPlaceholders() {
                this._placeholderTextures = {};
                const o = {
                  white: [255, 255, 255, 255],
                  gray: [128, 128, 128, 255],
                  black: [0, 0, 0, 255],
                  normal: [128, 128, 255, 255],
                };
                for (const i in o) {
                  if (!o.hasOwnProperty(i)) continue;
                  this._placeholderTextures[i] = new y.g(this._device, {
                    width: 2,
                    height: 2,
                    format: x.Lxj,
                    name: "material_placeholder",
                  });
                  const e = this._placeholderTextures[i].lock();
                  for (let t = 0; t < 4; t++)
                    for (let r = 0; r < 4; r++) e[t * 4 + r] = o[i][r];
                  this._placeholderTextures[i].unlock();
                }
              }
              patch(o, i) {
                o.resource._data &&
                  ((o._data = o.resource._data), delete o.resource._data),
                  (o.data.name = o.name),
                  (o.resource.name = o.name),
                  this._bindAndAssignAssets(o, i),
                  o.off("unload", this._onAssetUnload, this),
                  o.on("unload", this._onAssetUnload, this);
              }
              _onAssetUnload(o) {
                delete o.data.parameters,
                  delete o.data.chunks,
                  delete o.data.name;
              }
              _assignTexture(o, i, e) {
                i.resource[o] = e;
              }
              _getPlaceholderTexture(o) {
                this._placeholderTextures || this._createPlaceholders();
                const i = s[o];
                return this._placeholderTextures[i];
              }
              _assignPlaceholderTexture(o, i) {
                i.resource[o] = this._getPlaceholderTexture(o);
              }
              _onTextureLoad(o, i, e) {
                this._assignTexture(o, i, e.resource), i.resource.update();
              }
              _onTextureAdd(o, i, e) {
                this._assets.load(e);
              }
              _onTextureRemoveOrUnload(o, i, e) {
                const t = i.resource;
                t &&
                  i.resource[o] === e.resource &&
                  (this._assignPlaceholderTexture(o, i), t.update());
              }
              _assignCubemap(o, i, e) {
                (i.resource[o] = e[0]),
                  o === "cubeMap" &&
                    (i.resource.prefilteredCubemaps = e.slice(1));
              }
              _onCubemapLoad(o, i, e) {
                this._assignCubemap(o, i, e.resources),
                  this._parser.initialize(i.resource, i.data);
              }
              _onCubemapAdd(o, i, e) {
                i.data.shadingModel === c.Tp && (i.loadFaces = !0),
                  this._assets.load(e);
              }
              _onCubemapRemoveOrUnload(o, i, e) {
                const t = i.resource;
                i.data.prefilteredCubeMap128 === e.resources[1] &&
                  (this._assignCubemap(o, i, [
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                  ]),
                  t.update());
              }
              _bindAndAssignAssets(o, i) {
                const e = this._parser.migrate(o.data),
                  t = o.resource,
                  r = e.mappingFormat === "path",
                  u = d.Gc;
                let v, _, m;
                for (v = 0; v < u.length; v++) {
                  (_ = u[v]), (m = t._assetReferences[_]);
                  const T = e[_],
                    E = t[_],
                    M = E === this._getPlaceholderTexture(_),
                    R = e.validated;
                  T && (!E || !R || M)
                    ? (m ||
                        ((m = new h.Y(
                          _,
                          o,
                          i,
                          {
                            load: this._onTextureLoad,
                            add: this._onTextureAdd,
                            remove: this._onTextureRemoveOrUnload,
                            unload: this._onTextureRemoveOrUnload,
                          },
                          this
                        )),
                        (t._assetReferences[_] = m)),
                      r ? (m.url = o.getAbsoluteUrl(T)) : (m.id = T),
                      m.asset &&
                        (m.asset.resource
                          ? this._assignTexture(_, o, m.asset.resource)
                          : this._assignPlaceholderTexture(_, o),
                        i.load(m.asset)))
                    : m && (r ? (m.url = null) : (m.id = null));
                }
                const g = d.W5;
                for (v = 0; v < g.length; v++)
                  (_ = g[v]),
                    (m = t._assetReferences[_]),
                    e[_] &&
                      !o.data.prefilteredCubeMap128 &&
                      (m ||
                        ((m = new h.Y(
                          _,
                          o,
                          i,
                          {
                            load: this._onCubemapLoad,
                            add: this._onCubemapAdd,
                            remove: this._onCubemapRemoveOrUnload,
                            unload: this._onCubemapRemoveOrUnload,
                          },
                          this
                        )),
                        (t._assetReferences[_] = m)),
                      r ? (m.url = e[_]) : (m.id = e[_]),
                      m.asset &&
                        (m.asset.loaded &&
                          this._assignCubemap(_, o, m.asset.resources),
                        i.load(m.asset)));
                this._parser.initialize(t, e);
              }
            }
          },
          2200: (xe, V, a) => {
            "use strict";
            a.d(V, { s: () => D });
            var A = a(1870),
              x = a(8633),
              y = a(1594),
              c = a(6377),
              d = a(2004);
            class h {
              constructor(X) {
                (this._device = X.device),
                  (this._defaultMaterial = X.defaultMaterial),
                  (this._assets = X.assets);
              }
              parse(X, ie, Q) {
                var te;
                d.l.parse(
                  "filename.glb",
                  "",
                  X,
                  this._device,
                  this._assets,
                  (te = Q == null ? void 0 : Q.options) != null ? te : {},
                  (ae, Z) => {
                    if (ae) ie(ae);
                    else {
                      const J = c.V.createModel(Z, this._defaultMaterial);
                      Z.destroy(), ie(null, J);
                    }
                  }
                );
              }
            }
            var f = a(8484),
              s = a(7481),
              l = a(7915),
              n = a(1630),
              o = a(970),
              i = a(5860),
              e = a(6089),
              t = a(1984),
              r = a(2310),
              u = a(3035),
              v = a(7197),
              _ = a(3637),
              m = a(9611),
              g = a(528),
              T = a(6414),
              E = a(1336),
              M = a(8097),
              R = a(8777);
            const P = {
                points: n._AA,
                lines: n.EEU,
                lineloop: n.HsS,
                linestrip: n.PTM,
                triangles: n.Qpk,
                trianglestrip: n.SF$,
                trianglefan: n.zl$,
              },
              F = {
                int8: n.VSW,
                uint8: n.EUX,
                int16: n.kF,
                uint16: n.rvO,
                int32: n.uVx,
                uint32: n.Bz3,
                float32: n.n$B,
              };
            class b {
              constructor(X) {
                (this._device = X.device),
                  (this._defaultMaterial = X.defaultMaterial);
              }
              parse(X, ie) {
                const Q = X.model;
                if (!Q) {
                  ie(null, null);
                  return;
                }
                if (Q.version <= 1) {
                  ie(
                    "JsonModelParser#parse: Trying to parse unsupported model format."
                  );
                  return;
                }
                const te = this._parseNodes(X),
                  ae = this._parseSkins(X, te),
                  Z = this._parseVertexBuffers(X),
                  J = this._parseIndexBuffers(X, Z),
                  ve = this._parseMorphs(X, te, Z),
                  _e = this._parseMeshes(
                    X,
                    ae.skins,
                    ve.morphs,
                    Z,
                    J.buffer,
                    J.data
                  ),
                  L = this._parseMeshInstances(
                    X,
                    te,
                    _e,
                    ae.skins,
                    ae.instances,
                    ve.morphs,
                    ve.instances
                  ),
                  ge = new m.K();
                (ge.graph = te[0]),
                  (ge.meshInstances = L),
                  (ge.skinInstances = ae.instances),
                  (ge.morphInstances = ve.instances),
                  ge.getGraph().syncHierarchy(),
                  ie(null, ge);
              }
              _parseNodes(X) {
                const ie = X.model,
                  Q = [];
                let te;
                for (te = 0; te < ie.nodes.length; te++) {
                  const ae = ie.nodes[te],
                    Z = new u.t(ae.name);
                  Z.setLocalPosition(
                    ae.position[0],
                    ae.position[1],
                    ae.position[2]
                  ),
                    Z.setLocalEulerAngles(
                      ae.rotation[0],
                      ae.rotation[1],
                      ae.rotation[2]
                    ),
                    Z.setLocalScale(ae.scale[0], ae.scale[1], ae.scale[2]),
                    (Z.scaleCompensation = !!ae.scaleCompensation),
                    Q.push(Z);
                }
                for (te = 1; te < ie.parents.length; te++)
                  Q[ie.parents[te]].addChild(Q[te]);
                return Q;
              }
              _parseSkins(X, ie) {
                const Q = X.model,
                  te = [],
                  ae = [];
                let Z, J;
                if (!this._device.supportsBoneTextures && Q.skins.length > 0) {
                  const ve = this._device.getBoneLimit();
                  (0, r.g)(Q, null, ve);
                }
                for (Z = 0; Z < Q.skins.length; Z++) {
                  const ve = Q.skins[Z],
                    _e = [];
                  for (J = 0; J < ve.inverseBindMatrices.length; J++) {
                    const j = ve.inverseBindMatrices[J];
                    _e[J] = new f.$().set(j);
                  }
                  const L = new M.M(this._device, _e, ve.boneNames);
                  te.push(L);
                  const ge = new R.h(L),
                    k = [];
                  for (J = 0; J < L.boneNames.length; J++) {
                    const j = L.boneNames[J],
                      B = ie[0].findByName(j);
                    k.push(B);
                  }
                  (ge.bones = k), ae.push(ge);
                }
                return { skins: te, instances: ae };
              }
              _getMorphVertexCount(X, ie, Q) {
                for (let te = 0; te < X.meshes.length; te++) {
                  const ae = X.meshes[te];
                  if (ae.morph === ie) return Q[ae.vertices].numVertices;
                }
              }
              _parseMorphs(X, ie, Q) {
                const te = X.model,
                  ae = [],
                  Z = [];
                let J, ve, _e, L, ge, k;
                if (te.morphs) {
                  const j = function ($, le, O) {
                    const Y = new Float32Array(O * 3);
                    for (let ne = 0; ne < le.length; ne++) {
                      const de = le[ne] * 3;
                      (Y[de] = $[ne * 3]),
                        (Y[de + 1] = $[ne * 3 + 1]),
                        (Y[de + 2] = $[ne * 3 + 2]);
                    }
                    return Y;
                  };
                  for (J = 0; J < te.morphs.length; J++) {
                    for (
                      L = te.morphs[J].targets,
                        k = [],
                        _e = this._getMorphVertexCount(te, J, Q),
                        ve = 0;
                      ve < L.length;
                      ve++
                    ) {
                      const le = L[ve].aabb,
                        O = le.min,
                        Y = le.max,
                        ne = new l.I(
                          new s.e(
                            (Y[0] + O[0]) * 0.5,
                            (Y[1] + O[1]) * 0.5,
                            (Y[2] + O[2]) * 0.5
                          ),
                          new s.e(
                            (Y[0] - O[0]) * 0.5,
                            (Y[1] - O[1]) * 0.5,
                            (Y[2] - O[2]) * 0.5
                          )
                        ),
                        de = L[ve].indices;
                      let re = L[ve].deltaPositions,
                        I = L[ve].deltaNormals;
                      de && ((re = j(re, de, _e)), (I = j(I, de, _e))),
                        (ge = new E.M({
                          deltaPositions: re,
                          deltaNormals: I,
                          name: L[ve].name,
                          aabb: ne,
                        })),
                        k.push(ge);
                    }
                    const B = new g.T(k, this._device);
                    ae.push(B);
                    const $ = new T.q(B);
                    Z.push($);
                  }
                }
                return { morphs: ae, instances: Z };
              }
              _parseVertexBuffers(X) {
                const ie = X.model,
                  Q = [],
                  te = {
                    position: n.JYe,
                    normal: n.XF6,
                    tangent: n.h3u,
                    blendWeight: n.Hn_,
                    blendIndices: n.aVd,
                    color: n.F8$,
                    texCoord0: n.slc,
                    texCoord1: n.zEd,
                    texCoord2: n.GHH,
                    texCoord3: n.z5t,
                    texCoord4: n.GWP,
                    texCoord5: n.NdR,
                    texCoord6: n.GBD,
                    texCoord7: n.zZp,
                  };
                for (let ae = 0; ae < ie.vertices.length; ae++) {
                  const Z = ie.vertices[ae],
                    J = [];
                  for (const k in Z) {
                    const j = Z[k];
                    J.push({
                      semantic: te[k],
                      components: j.components,
                      type: F[j.type],
                      normalize: te[k] === n.F8$,
                    });
                  }
                  const ve = new e.y(this._device, J),
                    _e = Z.position.data.length / Z.position.components,
                    L = new i.R(this._device, ve, _e),
                    ge = new t.P(L);
                  for (let k = 0; k < _e; k++) {
                    for (const j in Z) {
                      const B = Z[j];
                      switch (B.components) {
                        case 1:
                          ge.element[te[j]].set(B.data[k]);
                          break;
                        case 2:
                          ge.element[te[j]].set(
                            B.data[k * 2],
                            1 - B.data[k * 2 + 1]
                          );
                          break;
                        case 3:
                          ge.element[te[j]].set(
                            B.data[k * 3],
                            B.data[k * 3 + 1],
                            B.data[k * 3 + 2]
                          );
                          break;
                        case 4:
                          ge.element[te[j]].set(
                            B.data[k * 4],
                            B.data[k * 4 + 1],
                            B.data[k * 4 + 2],
                            B.data[k * 4 + 3]
                          );
                          break;
                      }
                    }
                    ge.next();
                  }
                  ge.end(), Q.push(L);
                }
                return Q;
              }
              _parseIndexBuffers(X, ie) {
                const Q = X.model;
                let te = null,
                  ae = null,
                  Z,
                  J = 0;
                for (Z = 0; Z < Q.meshes.length; Z++) {
                  const _e = Q.meshes[Z];
                  _e.indices !== void 0 && (J += _e.indices.length);
                }
                let ve = 0;
                for (Z = 0; Z < ie.length; Z++)
                  ve = Math.max(ve, ie[Z].numVertices);
                return (
                  J > 0 &&
                    (ve > 65535 && this._device.extUintElement
                      ? ((te = new o.h(this._device, n.gpl, J)),
                        (ae = new Uint32Array(te.lock())))
                      : ((te = new o.h(this._device, n.c02, J)),
                        (ae = new Uint16Array(te.lock())))),
                  { buffer: te, data: ae }
                );
              }
              _parseMeshes(X, ie, Q, te, ae, Z) {
                const J = X.model,
                  ve = [];
                let _e = 0;
                for (let L = 0; L < J.meshes.length; L++) {
                  const ge = J.meshes[L],
                    k = ge.aabb,
                    j = k.min,
                    B = k.max,
                    $ = new l.I(
                      new s.e(
                        (B[0] + j[0]) * 0.5,
                        (B[1] + j[1]) * 0.5,
                        (B[2] + j[2]) * 0.5
                      ),
                      new s.e(
                        (B[0] - j[0]) * 0.5,
                        (B[1] - j[1]) * 0.5,
                        (B[2] - j[2]) * 0.5
                      )
                    ),
                    le = ge.indices !== void 0,
                    O = new v.e(this._device);
                  (O.vertexBuffer = te[ge.vertices]),
                    (O.indexBuffer[0] = le ? ae : null),
                    (O.primitive[0].type = P[ge.type]),
                    (O.primitive[0].base = le ? ge.base + _e : ge.base),
                    (O.primitive[0].count = ge.count),
                    (O.primitive[0].indexed = le),
                    (O.skin = ge.skin !== void 0 ? ie[ge.skin] : null),
                    (O.morph = ge.morph !== void 0 ? Q[ge.morph] : null),
                    (O.aabb = $),
                    le && (Z.set(ge.indices, _e), (_e += ge.indices.length)),
                    ve.push(O);
                }
                return ae !== null && ae.unlock(), ve;
              }
              _parseMeshInstances(X, ie, Q, te, ae, Z, J) {
                const ve = X.model,
                  _e = [];
                let L;
                for (L = 0; L < ve.meshInstances.length; L++) {
                  const ge = ve.meshInstances[L],
                    k = ie[ge.node],
                    j = Q[ge.mesh],
                    B = new _.F(j, this._defaultMaterial, k);
                  if (j.skin) {
                    const $ = te.indexOf(j.skin);
                    B.skinInstance = ae[$];
                  }
                  if (j.morph) {
                    const $ = Z.indexOf(j.morph);
                    B.morphInstance = J[$];
                  }
                  _e.push(B);
                }
                return _e;
              }
            }
            class D {
              constructor(X) {
                (this.handlerType = "model"),
                  (this._parsers = []),
                  (this.device = X.graphicsDevice),
                  (this.assets = X.assets),
                  (this.defaultMaterial = (0, y.h)(this.device)),
                  (this.maxRetries = 0),
                  this.addParser(new b(this), function (ie, Q) {
                    return A.A.getExtension(ie) === ".json";
                  }),
                  this.addParser(new h(this), function (ie, Q) {
                    return A.A.getExtension(ie) === ".glb";
                  });
              }
              load(X, ie, Q) {
                typeof X == "string" && (X = { load: X, original: X });
                const te = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                (X.load.startsWith("blob:") || X.load.startsWith("data:")) &&
                  (A.A.getExtension(X.original).toLowerCase() === ".glb"
                    ? (te.responseType = x.l.ResponseType.ARRAY_BUFFER)
                    : (te.responseType = x.l.ResponseType.JSON)),
                  x.L.get(X.load, te, (ae, Z) => {
                    if (ie)
                      if (ae) ie(`Error loading model: ${X.original} [${ae}]`);
                      else {
                        for (let J = 0; J < this._parsers.length; J++) {
                          const ve = this._parsers[J];
                          if (ve.decider(X.original, Z)) {
                            ve.parser.parse(
                              Z,
                              (_e, L) => {
                                _e ? ie(_e) : ie(null, L);
                              },
                              Q
                            );
                            return;
                          }
                        }
                        ie("No parsers found");
                      }
                  });
              }
              open(X, ie) {
                return ie;
              }
              patch(X, ie) {
                if (!X.resource) return;
                const Q = X.data,
                  te = this;
                X.resource.meshInstances.forEach(function (ae, Z) {
                  if (Q.mapping) {
                    const J = function ge(k) {
                      k.resource
                        ? (ae.material = k.resource)
                        : (k.once("load", ge), ie.load(k)),
                        k.once("remove", function (j) {
                          ae.material === j.resource &&
                            (ae.material = te.defaultMaterial);
                        });
                    };
                    if (!Q.mapping[Z]) {
                      ae.material = te.defaultMaterial;
                      return;
                    }
                    const ve = Q.mapping[Z].material,
                      _e = Q.mapping[Z].path;
                    let L;
                    if (ve !== void 0)
                      ve
                        ? ((L = ie.get(ve)), L ? J(L) : ie.once("add:" + ve, J))
                        : (ae.material = te.defaultMaterial);
                    else if (_e) {
                      const ge = X.getAbsoluteUrl(Q.mapping[Z].path);
                      (L = ie.getByUrl(ge)),
                        L ? J(L) : ie.once("add:url:" + ge, J);
                    }
                  }
                });
              }
              addParser(X, ie) {
                this._parsers.push({ parser: X, decider: ie });
              }
            }
          },
          1552: (xe, V, a) => {
            "use strict";
            a.d(V, { H: () => d });
            var A = a(6768);
            function x(h) {
              const f = this;
              if (!f.resource) return;
              const s = h.resource,
                l = s.renders && s.renders[f.data.renderIndex];
              l && (f.resource.meshes = l.resource.meshes);
            }
            function y(h) {
              const f = this;
              f.registry.off("load:" + h.id, x, f),
                f.registry.on("load:" + h.id, x, f),
                f.registry.off("remove:" + h.id, c, f),
                f.registry.once("remove:" + h.id, c, f),
                h.resource ? x.call(f, h) : f.registry.load(h);
            }
            function c(h) {
              const f = this;
              f.registry.off("load:" + h.id, x, f),
                f.resource && f.resource.destroy();
            }
            class d {
              constructor(f) {
                (this.handlerType = "render"), (this._registry = f.assets);
              }
              load(f, s, l) {}
              open(f, s) {
                return new A.d();
              }
              patch(f, s) {
                if (!f.data.containerAsset) return;
                const l = s.get(f.data.containerAsset);
                if (!l) {
                  s.once("add:" + f.data.containerAsset, y, f);
                  return;
                }
                y.call(f, l);
              }
            }
          },
          7766: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => x });
            var A = a(8633);
            const x = {
              load: function (y, c, d) {
                typeof y == "string" && (y = { load: y, original: y }),
                  A.L.get(
                    y.load,
                    { retry: c > 0, maxRetries: c },
                    function (h, f) {
                      if (!h) d(h, f);
                      else {
                        let s = "Error while loading scene JSON " + y.original;
                        h.message
                          ? ((s += ": " + h.message),
                            h.stack &&
                              (s +=
                                `
` + h.stack))
                          : (s += ": " + h),
                          d(s);
                      }
                    }
                  );
              },
            };
          },
          2489: (xe, V, a) => {
            "use strict";
            a.d(V, { f: () => y });
            var A = a(7766),
              x = a(8158);
            class y {
              constructor(d) {
                (this.handlerType = "scene"),
                  (this._app = d),
                  (this.maxRetries = 0);
              }
              load(d, h) {
                A.u.load(d, this.maxRetries, h);
              }
              open(d, h) {
                this._app.systems.script.preloading = !0;
                const s = new x.q(this._app, !1).parse(h),
                  l = this._app.scene;
                return (
                  (l.root = s),
                  this._app.applySceneSettings(h.settings),
                  (this._app.systems.script.preloading = !1),
                  l
                );
              }
              patch(d, h) {}
            }
          },
          7367: (xe, V, a) => {
            "use strict";
            a.d(V, { S: () => c });
            var A = a(4595),
              x = a(3113),
              y = a(9992);
            class c {
              constructor(h) {
                (this.handlerType = "script"),
                  (this._app = h),
                  (this._scripts = {}),
                  (this._cache = {});
              }
              clearCache() {
                for (const h in this._cache) {
                  const f = this._cache[h],
                    s = f.parentNode;
                  s && s.removeChild(f);
                }
                this._cache = {};
              }
              load(h, f) {
                typeof h == "string" && (h = { load: h, original: h });
                const s = this;
                (A.K.app = this._app),
                  this._loadScript(h.load, (l, n, o) => {
                    if (l) f(l);
                    else if (A.K.legacy) {
                      let i = null;
                      x.j._types.length && (i = x.j._types.pop()),
                        i ? (this._scripts[n] = i) : (i = null),
                        f(null, i, o);
                    } else {
                      const i = {};
                      for (let e = 0; e < x.j._types.length; e++)
                        i[x.j._types[e].name] = x.j._types[e];
                      (x.j._types.length = 0),
                        f(null, i, o),
                        delete s._loader._cache[y.W.makeKey(n, "script")];
                    }
                  });
              }
              open(h, f) {
                return f;
              }
              patch(h, f) {}
              _loadScript(h, f) {
                const s = document.head,
                  l = document.createElement("script");
                (this._cache[h] = l),
                  (l.async = !1),
                  l.addEventListener(
                    "error",
                    function (o) {
                      f(`Script: ${o.target.src} failed to load`);
                    },
                    !1
                  );
                let n = !1;
                (l.onload = l.onreadystatechange =
                  function () {
                    !n &&
                      (!this.readyState ||
                        this.readyState === "loaded" ||
                        this.readyState === "complete") &&
                      ((n = !0), f(null, h, l));
                  }),
                  (l.src = h),
                  s.appendChild(l);
              }
            }
          },
          8501: (xe, V, a) => {
            "use strict";
            a.d(V, { e: () => x });
            var A = a(8633);
            class x {
              constructor(c) {
                (this.handlerType = "shader"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  A.L.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(
                            `Error loading shader resource: ${c.original} [${h}]`
                          )
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          473: (xe, V, a) => {
            "use strict";
            a.d(V, { Q: () => h });
            var A = a(1870),
              x = a(8633),
              y = a(8649);
            function c(f) {
              const s = this;
              s.resource && (s.resource.atlas = f.resource);
            }
            function d(f) {
              this.registry.load(f);
            }
            class h {
              constructor(s) {
                (this.handlerType = "sprite"),
                  (this._assets = s.assets),
                  (this._device = s.graphicsDevice),
                  (this.maxRetries = 0);
              }
              load(s, l) {
                typeof s == "string" && (s = { load: s, original: s }),
                  A.A.getExtension(s.original) === ".json" &&
                    x.L.get(
                      s.load,
                      {
                        retry: this.maxRetries > 0,
                        maxRetries: this.maxRetries,
                      },
                      function (n, o) {
                        n ? l(n) : l(null, o);
                      }
                    );
              }
              open(s, l) {
                const n = new y.k(this._device);
                return s && (n.__data = l), n;
              }
              patch(s, l) {
                const n = s.resource;
                if (
                  n.__data &&
                  ((s.data.pixelsPerUnit = n.__data.pixelsPerUnit),
                  (s.data.renderMode = n.__data.renderMode),
                  (s.data.frameKeys = n.__data.frameKeys),
                  n.__data.textureAtlasAsset)
                ) {
                  const o = l.getByUrl(n.__data.textureAtlasAsset);
                  o
                    ? (s.data.textureAtlasAsset = o.id)
                    : console.warn(
                        "Could not find textureatlas with url: " +
                          n.__data.textureAtlasAsset
                      );
                }
                n.startUpdate(),
                  (n.renderMode = s.data.renderMode),
                  (n.pixelsPerUnit = s.data.pixelsPerUnit),
                  (n.frameKeys = s.data.frameKeys),
                  this._updateAtlas(s),
                  n.endUpdate(),
                  s.off("change", this._onAssetChange, this),
                  s.on("change", this._onAssetChange, this);
              }
              _updateAtlas(s) {
                const l = s.resource;
                if (!s.data.textureAtlasAsset) {
                  l.atlas = null;
                  return;
                }
                this._assets.off("load:" + s.data.textureAtlasAsset, c, s),
                  this._assets.on("load:" + s.data.textureAtlasAsset, c, s);
                const n = this._assets.get(s.data.textureAtlasAsset);
                n && n.resource
                  ? (l.atlas = n.resource)
                  : n
                  ? this._assets.load(n)
                  : (this._assets.off("add:" + s.data.textureAtlasAsset, d, s),
                    this._assets.on("add:" + s.data.textureAtlasAsset, d, s));
              }
              _onAssetChange(s, l, n, o) {
                l === "data" &&
                  n &&
                  n.textureAtlasAsset &&
                  o &&
                  n.textureAtlasAsset !== o.textureAtlasAsset &&
                  (this._assets.off("load:" + o.textureAtlasAsset, c, s),
                  this._assets.off("add:" + o.textureAtlasAsset, d, s));
              }
            }
          },
          8774: (xe, V, a) => {
            "use strict";
            a.d(V, { R: () => y });
            var A = a(8633),
              x = a(1626);
            class y {
              constructor(d) {
                (this.handlerType = "template"),
                  (this._app = d),
                  (this.maxRetries = 0);
              }
              load(d, h) {
                typeof d == "string" && (d = { load: d, original: d });
                const f = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                A.L.get(d.load, f, function (s, l) {
                  s ? h("Error requesting template: " + d.original) : h(s, l);
                });
              }
              open(d, h) {
                return new x.B(this._app, h);
              }
            }
          },
          1351: (xe, V, a) => {
            "use strict";
            a.d(V, { O: () => x });
            var A = a(8633);
            class x {
              constructor(c) {
                (this.handlerType = "text"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  A.L.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(`Error loading text resource: ${c.original} [${h}]`)
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          9319: (xe, V, a) => {
            "use strict";
            a.d(V, { P: () => n });
            var A = a(1870),
              x = a(7994),
              y = a(5596),
              c = a(1630),
              d = a(8633),
              h = a(2199);
            const f = { repeat: c.x3I, clamp: c.vq6, mirror: c.qoY },
              s = {
                nearest: c.uhC,
                linear: c.DrA,
                nearest_mip_nearest: c.GLw,
                linear_mip_nearest: c.reG,
                nearest_mip_linear: c.hs2,
                linear_mip_linear: c.qn_,
              },
              l = /^data\.frames\.(\d+)$/;
            class n {
              constructor(i) {
                (this.handlerType = "textureatlas"),
                  (this._loader = i.loader),
                  (this.maxRetries = 0);
              }
              load(i, e) {
                typeof i == "string" && (i = { load: i, original: i });
                const t = this,
                  r = this._loader.getHandler("texture");
                if (A.A.getExtension(i.original) === ".json")
                  d.L.get(
                    i.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (u, v) {
                      if (u) e(u);
                      else {
                        const _ = i.original.replace(".json", ".png");
                        t._loader.load(_, "texture", function (m, g) {
                          m ? e(m) : e(null, { data: v, texture: g });
                        });
                      }
                    }
                  );
                else return r.load(i, e);
              }
              open(i, e) {
                const t = new h.L();
                if (e.texture && e.data)
                  (t.texture = e.texture), (t.__data = e.data);
                else {
                  const u = this._loader.getHandler("texture").open(i, e);
                  if (!u) return null;
                  t.texture = u;
                }
                return t;
              }
              patch(i, e) {
                if (!i.resource) return;
                i.resource.__data &&
                  (i.resource.__data.minfilter !== void 0 &&
                    (i.data.minfilter = i.resource.__data.minfilter),
                  i.resource.__data.magfilter !== void 0 &&
                    (i.data.magfilter = i.resource.__data.magfilter),
                  i.resource.__data.addressu !== void 0 &&
                    (i.data.addressu = i.resource.__data.addressu),
                  i.resource.__data.addressv !== void 0 &&
                    (i.data.addressv = i.resource.__data.addressv),
                  i.resource.__data.mipmaps !== void 0 &&
                    (i.data.mipmaps = i.resource.__data.mipmaps),
                  i.resource.__data.anisotropy !== void 0 &&
                    (i.data.anisotropy = i.resource.__data.anisotropy),
                  i.resource.__data.rgbm !== void 0 &&
                    (i.data.rgbm = !!i.resource.__data.rgbm),
                  (i.data.frames = i.resource.__data.frames),
                  delete i.resource.__data);
                const t = i.resource.texture;
                if (
                  t &&
                  ((t.name = i.name),
                  i.data.hasOwnProperty("minfilter") &&
                    t.minFilter !== s[i.data.minfilter] &&
                    (t.minFilter = s[i.data.minfilter]),
                  i.data.hasOwnProperty("magfilter") &&
                    t.magFilter !== s[i.data.magfilter] &&
                    (t.magFilter = s[i.data.magfilter]),
                  i.data.hasOwnProperty("addressu") &&
                    t.addressU !== f[i.data.addressu] &&
                    (t.addressU = f[i.data.addressu]),
                  i.data.hasOwnProperty("addressv") &&
                    t.addressV !== f[i.data.addressv] &&
                    (t.addressV = f[i.data.addressv]),
                  i.data.hasOwnProperty("mipmaps") &&
                    t.mipmaps !== i.data.mipmaps &&
                    (t.mipmaps = i.data.mipmaps),
                  i.data.hasOwnProperty("anisotropy") &&
                    t.anisotropy !== i.data.anisotropy &&
                    (t.anisotropy = i.data.anisotropy),
                  i.data.hasOwnProperty("rgbm"))
                ) {
                  const u = i.data.rgbm ? c.fW0 : c.s64;
                  t.type !== u && (t.type = u);
                }
                i.resource.texture = t;
                const r = {};
                for (const u in i.data.frames) {
                  const v = i.data.frames[u];
                  r[u] = {
                    rect: new y.Z(v.rect),
                    pivot: new x.Z(v.pivot),
                    border: new y.Z(v.border),
                  };
                }
                (i.resource.frames = r),
                  i.off("change", this._onAssetChange, this),
                  i.on("change", this._onAssetChange, this);
              }
              _onAssetChange(i, e, t) {
                let r;
                if (e === "data" || e === "data.frames") {
                  const u = {};
                  for (const v in t.frames)
                    (r = t.frames[v]),
                      (u[v] = {
                        rect: new y.Z(r.rect),
                        pivot: new x.Z(r.pivot),
                        border: new y.Z(r.border),
                      });
                  i.resource.frames = u;
                } else {
                  const u = e.match(l);
                  if (u) {
                    const v = u[1];
                    t
                      ? (i.resource.frames[v]
                          ? ((r = i.resource.frames[v]),
                            r.rect.set(
                              t.rect[0],
                              t.rect[1],
                              t.rect[2],
                              t.rect[3]
                            ),
                            r.pivot.set(t.pivot[0], t.pivot[1]),
                            r.border.set(
                              t.border[0],
                              t.border[1],
                              t.border[2],
                              t.border[3]
                            ))
                          : (i.resource.frames[v] = {
                              rect: new y.Z(t.rect),
                              pivot: new x.Z(t.pivot),
                              border: new y.Z(t.border),
                            }),
                        i.resource.fire("set:frame", v, i.resource.frames[v]))
                      : i.resource.frames[v] &&
                        (delete i.resource.frames[v],
                        i.resource.fire("remove:frame", v));
                  }
                }
              }
            }
          },
          5676: (xe, V, a) => {
            "use strict";
            a.d(V, { y: () => P, H: () => M });
            var A = a(1870),
              x = a(1630),
              y = a(1208),
              c = a(4751),
              d = a(3953),
              h = a(7712);
            class f {
              constructor(b, D) {
                (this.device = D), (this.maxRetries = 0);
              }
              load(b, D, G) {
                const X = this.device,
                  ie = (Q) => {
                    var te;
                    (0, h.w)(X, b.load, Q, D, {
                      isGGGR:
                        ((G == null ||
                        (te = G.file) == null ||
                        (te = te.variants) == null ||
                        (te = te.basis) == null
                          ? void 0
                          : te.opt) &
                          8) !==
                        0,
                    }) ||
                      D(
                        `Basis module not found. Asset '${G.name}' basis texture variant will not be loaded.`
                      );
                  };
                d.V.fetchArrayBuffer(
                  b.load,
                  (Q, te) => {
                    Q ? D(Q) : ie(te);
                  },
                  G,
                  this.maxRetries
                );
              }
              open(b, D, G, X = {}) {
                const ie = new y.g(
                  G,
                  (0, c._)(
                    {
                      name: b,
                      addressU: D.cubemap ? x.vq6 : x.x3I,
                      addressV: D.cubemap ? x.vq6 : x.x3I,
                      width: D.width,
                      height: D.height,
                      format: D.format,
                      cubemap: D.cubemap,
                      levels: D.levels,
                    },
                    X
                  )
                );
                return ie.upload(), ie;
              }
            }
            var s = a(8633),
              l = a(148);
            class n {
              constructor(b, D) {
                (this.crossOrigin = b.prefix ? "anonymous" : null),
                  (this.maxRetries = 0),
                  (this.device = D);
              }
              load(b, D, G) {
                var X;
                const ie = !!(G != null && (X = G.file) != null && X.contents);
                if (ie) {
                  if (this.device.supportsImageBitmap) {
                    this._loadImageBitmapFromBlob(
                      new Blob([G.file.contents]),
                      D
                    );
                    return;
                  }
                  b = {
                    load: URL.createObjectURL(new Blob([G.file.contents])),
                    original: b.original,
                  };
                }
                const Q = (ae, Z) => {
                  ie && URL.revokeObjectURL(b.load), D(ae, Z);
                };
                let te;
                G && G.options && G.options.hasOwnProperty("crossOrigin")
                  ? (te = G.options.crossOrigin)
                  : l._3.test(b.load) && (te = this.crossOrigin),
                  this.device.supportsImageBitmap
                    ? this._loadImageBitmap(b.load, b.original, te, Q)
                    : this._loadImage(b.load, b.original, te, Q);
              }
              open(b, D, G, X = {}) {
                const ie = new y.g(
                  G,
                  (0, c._)(
                    {
                      name: b,
                      width: D.width,
                      height: D.height,
                      format: x.Lxj,
                    },
                    X
                  )
                );
                return ie.setSource(D), ie;
              }
              _loadImage(b, D, G, X) {
                const ie = new Image();
                G && (ie.crossOrigin = G);
                let Q = 0;
                const te = this.maxRetries;
                let ae;
                (ie.onload = function () {
                  X(null, ie);
                }),
                  (ie.onerror = function () {
                    if (!ae)
                      if (te > 0 && ++Q <= te) {
                        const Z = Math.pow(2, Q) * 100;
                        console.log(
                          `Error loading Texture from: '${D}' - Retrying in ${Z}ms...`
                        );
                        const ve = b.indexOf("?") >= 0 ? "&" : "?";
                        ae = setTimeout(function () {
                          (ie.src = b + ve + "retry=" + Date.now()),
                            (ae = null);
                        }, Z);
                      } else X(`Error loading Texture from: '${D}'`);
                  }),
                  (ie.src = b);
              }
              _loadImageBitmap(b, D, G, X) {
                const ie = {
                  cache: !0,
                  responseType: "blob",
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                s.L.get(b, ie, (Q, te) => {
                  Q ? X(Q) : this._loadImageBitmapFromBlob(te, X);
                });
              }
              _loadImageBitmapFromBlob(b, D) {
                createImageBitmap(b, {
                  premultiplyAlpha: "none",
                  colorSpaceConversion: "none",
                })
                  .then((G) => D(null, G))
                  .catch((G) => D(G));
              }
            }
            const o = [1481919403, 3140563232, 169478669],
              i = {
                33776: x.S$n,
                33778: x.EPU,
                33779: x.E_6,
                36196: x.G24,
                37492: x.ZyS,
                37496: x.ArW,
                35840: x.xyx,
                35841: x.TyC,
                35842: x.Ijy,
                35843: x.apD,
                32849: x.akF,
                32856: x.Lxj,
                35905: x.lsY,
                35907: x.Mzz,
                35898: x.s_z,
                34843: x.Nnq,
                34842: x.WBN,
              };
            function e(F, b, D, G) {
              return F === x.s_z
                ? new Uint32Array(b, D, G / 4)
                : new Uint8Array(b, D, G);
            }
            class t {
              constructor(b) {
                this.maxRetries = 0;
              }
              load(b, D, G) {
                d.V.fetchArrayBuffer(b.load, D, G, this.maxRetries);
              }
              open(b, D, G, X = {}) {
                const ie = this.parse(D);
                if (!ie) return null;
                const Q = new y.g(
                  G,
                  (0, c._)(
                    {
                      name: b,
                      addressU: ie.cubemap ? x.vq6 : x.x3I,
                      addressV: ie.cubemap ? x.vq6 : x.x3I,
                      width: ie.width,
                      height: ie.height,
                      format: ie.format,
                      cubemap: ie.cubemap,
                      levels: ie.levels,
                    },
                    X
                  )
                );
                return Q.upload(), Q;
              }
              parse(b) {
                const D = new Uint32Array(b);
                if (o[0] !== D[0] || o[1] !== D[1] || o[2] !== D[2])
                  return null;
                const G = {
                  endianness: D[3],
                  glType: D[4],
                  glTypeSize: D[5],
                  glFormat: D[6],
                  glInternalFormat: D[7],
                  glBaseInternalFormat: D[8],
                  pixelWidth: D[9],
                  pixelHeight: D[10],
                  pixelDepth: D[11],
                  numberOfArrayElements: D[12],
                  numberOfFaces: D[13],
                  numberOfMipmapLevels: D[14],
                  bytesOfKeyValueData: D[15],
                };
                if (G.pixelDepth > 1 || G.numberOfArrayElements !== 0)
                  return null;
                const X = i[G.glInternalFormat];
                if (X === void 0) return null;
                let ie = 16 + G.bytesOfKeyValueData / 4;
                const Q = G.numberOfFaces > 1,
                  te = [];
                for (let ae = 0; ae < (G.numberOfMipmapLevels || 1); ae++) {
                  const Z = D[ie++];
                  Q && te.push([]);
                  const J = Q ? te[ae] : te;
                  for (let ve = 0; ve < (Q ? 6 : 1); ++ve)
                    J.push(e(X, b, ie * 4, Z)), (ie += (Z + 3) >> 2);
                }
                return {
                  format: X,
                  width: G.pixelWidth,
                  height: G.pixelHeight,
                  levels: te,
                  cubemap: Q,
                };
              }
            }
            var r = a(9482);
            const u = { KHR_DF_MODEL_ETC1S: 163, KHR_DF_MODEL_UASTC: 166 };
            class v {
              constructor(b, D) {
                (this.maxRetries = 0), (this.device = D);
              }
              load(b, D, G) {
                d.V.fetchArrayBuffer(
                  b.load,
                  (X, ie) => {
                    X ? D(X, ie) : this.parse(ie, b, D, G);
                  },
                  G,
                  this.maxRetries
                );
              }
              open(b, D, G, X = {}) {
                const ie = new y.g(
                  G,
                  (0, c._)(
                    {
                      name: b,
                      addressU: D.cubemap ? x.vq6 : x.x3I,
                      addressV: D.cubemap ? x.vq6 : x.x3I,
                      width: D.width,
                      height: D.height,
                      format: D.format,
                      cubemap: D.cubemap,
                      levels: D.levels,
                    },
                    X
                  )
                );
                return ie.upload(), ie;
              }
              parse(b, D, G, X) {
                const ie = new r.B(b),
                  Q = [ie.readU32be(), ie.readU32be(), ie.readU32be()];
                if (
                  Q[0] !== 2873840728 ||
                  Q[1] !== 540160187 ||
                  Q[2] !== 218765834
                )
                  return null;
                const te = {
                    vkFormat: ie.readU32(),
                    typeSize: ie.readU32(),
                    pixelWidth: ie.readU32(),
                    pixelHeight: ie.readU32(),
                    pixelDepth: ie.readU32(),
                    layerCount: ie.readU32(),
                    faceCount: ie.readU32(),
                    levelCount: ie.readU32(),
                    supercompressionScheme: ie.readU32(),
                  },
                  ae = {
                    dfdByteOffset: ie.readU32(),
                    dfdByteLength: ie.readU32(),
                    kvdByteOffset: ie.readU32(),
                    kvdByteLength: ie.readU32(),
                    sgdByteOffset: ie.readU64(),
                    sgdByteLength: ie.readU64(),
                  },
                  Z = [];
                for (let L = 0; L < Math.max(1, te.levelCount); ++L)
                  Z.push({
                    byteOffset: ie.readU64(),
                    byteLength: ie.readU64(),
                    uncompressedByteLength: ie.readU64(),
                  });
                if (ie.readU32() !== ae.kvdByteOffset - ae.dfdByteOffset)
                  return null;
                ie.skip(8);
                const ve = ie.readU8();
                if (
                  (ie.skip(ae.dfdByteLength - 9),
                  ie.skip(ae.kvdByteLength),
                  te.supercompressionScheme === 1 ||
                    ve === u.KHR_DF_MODEL_UASTC)
                ) {
                  var _e;
                  (0, h.w)(this.device, D.load, b, G, {
                    isGGGR:
                      ((X == null ||
                      (_e = X.file) == null ||
                      (_e = _e.variants) == null ||
                      (_e = _e.basis) == null
                        ? void 0
                        : _e.opt) &
                        8) !==
                      0,
                    isKTX2: !0,
                  }) ||
                    G(
                      'Basis module not found. Asset "' +
                        X.name +
                        '" basis texture variant will not be loaded.'
                    );
                } else G("unsupported KTX2 pixel format");
              }
            }
            class _ {
              constructor(b) {
                this.maxRetries = 0;
              }
              load(b, D, G) {
                d.V.fetchArrayBuffer(b.load, D, G, this.maxRetries);
              }
              open(b, D, G, X = {}) {
                const ie = new Uint32Array(D, 0, 32),
                  Q = ie[4],
                  te = ie[3],
                  ae = Math.max(ie[7], 1),
                  Z = ie[20] === 4,
                  J = ie[21],
                  ve = ie[22],
                  _e = ie[28] === 65024,
                  L = 827611204,
                  ge = 894720068,
                  k = 113,
                  j = 116,
                  B = 826496069,
                  $ = 825438800,
                  le = 825504336,
                  O = 825439312,
                  Y = 825504848;
                let ne = !1,
                  de = !1,
                  re = !1,
                  I = !1,
                  w = null,
                  N = 1,
                  W;
                if (
                  (Z
                    ? J === L
                      ? ((w = x.S$n), (ne = !0))
                      : J === ge
                      ? ((w = x.E_6), (ne = !0))
                      : J === k
                      ? ((w = x.WBN), (N = 2))
                      : J === j
                      ? ((w = x.s7h), (N = 4))
                      : J === B
                      ? ((w = x.G24), (ne = !0), (de = !0))
                      : J === $ || J === le
                      ? ((w = J === $ ? x.TyC : x.apD), (ne = !0), (re = !0))
                      : (J === O || J === Y) &&
                        ((w = J === O ? x.xyx : x.Ijy), (ne = !0), (I = !0))
                    : ve === 32 && (w = x.Lxj),
                  !w)
                )
                  return (
                    (W = new y.g(G, {
                      width: 4,
                      height: 4,
                      format: x.akF,
                      name: "dds-legacy-empty",
                    })),
                    W
                  );
                W = new y.g(
                  G,
                  (0, c._)(
                    {
                      name: b,
                      addressU: _e ? x.vq6 : x.x3I,
                      addressV: _e ? x.vq6 : x.x3I,
                      width: Q,
                      height: te,
                      format: w,
                      cubemap: _e,
                      mipmaps: ae > 1,
                    },
                    X
                  )
                );
                let he = 128;
                const ue = _e ? 6 : 1;
                let ye;
                const Oe = 4,
                  Ae = 4,
                  ke = J === L ? 8 : 16;
                let Ue, Ge, ht;
                for (let me = 0; me < ue; me++) {
                  let z = Q,
                    K = te;
                  for (let Te = 0; Te < ae; Te++) {
                    ne
                      ? de
                        ? (ye =
                            Math.floor((z + 3) / 4) *
                            Math.floor((K + 3) / 4) *
                            8)
                        : re
                        ? (ye = (Math.max(z, 16) * Math.max(K, 8)) / 4)
                        : I
                        ? (ye = (Math.max(z, 8) * Math.max(K, 8)) / 2)
                        : ((Ue = Math.floor((z + Oe - 1) / Oe)),
                          (Ge = Math.floor((K + Ae - 1) / Ae)),
                          (ht = Ue * Ge),
                          (ye = ht * ke))
                      : (ye = z * K * 4);
                    const H =
                      w === x.s7h
                        ? new Float32Array(D, he, ye)
                        : w === x.WBN
                        ? new Uint16Array(D, he, ye)
                        : new Uint8Array(D, he, ye);
                    _e
                      ? (W._levels[Te] || (W._levels[Te] = []),
                        (W._levels[Te][me] = H))
                      : (W._levels[Te] = H),
                      (he += ye * N),
                      (z = Math.max(z * 0.5, 1)),
                      (K = Math.max(K * 0.5, 1));
                  }
                }
                return W.upload(), W;
              }
            }
            class m {
              constructor(b) {
                this.maxRetries = 0;
              }
              load(b, D, G) {
                d.V.fetchArrayBuffer(b.load, D, G, this.maxRetries);
              }
              open(b, D, G, X = {}) {
                const ie = this.parse(D);
                if (!ie) return null;
                const Q = new y.g(
                  G,
                  (0, c._)(
                    {
                      name: b,
                      addressU: x.x3I,
                      addressV: x.vq6,
                      minFilter: x.uhC,
                      magFilter: x.uhC,
                      width: ie.width,
                      height: ie.height,
                      levels: ie.levels,
                      format: x.Lxj,
                      type: x.TOD,
                      mipmaps: !1,
                    },
                    X
                  )
                );
                return Q.upload(), Q;
              }
              parse(b) {
                const D = new r.B(b);
                if (!D.readLine().startsWith("#?RADIANCE")) return null;
                const X = {};
                for (;;) {
                  const Z = D.readLine();
                  if (Z.length === 0) break;
                  {
                    const J = Z.split("=");
                    J.length === 2 && (X[J[0]] = J[1]);
                  }
                }
                if (!X.hasOwnProperty("FORMAT")) return null;
                const ie = D.readLine().split(" ");
                if (ie.length !== 4) return null;
                const Q = parseInt(ie[1], 10),
                  te = parseInt(ie[3], 10),
                  ae = this._readPixels(D, te, Q, ie[0] === "-Y");
                return ae ? { width: te, height: Q, levels: [ae] } : null;
              }
              _readPixels(b, D, G, X) {
                if (D < 8 || D > 32767) return this._readPixelsFlat(b, D, G);
                const ie = [0, 0, 0, 0];
                if (
                  (b.readArray(ie), ie[0] !== 2 || ie[1] !== 2 || ie[2] & 128)
                )
                  return b.skip(-4), this._readPixelsFlat(b, D, G);
                const Q = new ArrayBuffer(D * G * 4),
                  te = new Uint8Array(Q);
                let ae = X ? 0 : D * 4 * (G - 1),
                  Z,
                  J,
                  ve,
                  _e,
                  L,
                  ge;
                for (J = 0; J < G; ++J) {
                  if ((J && b.readArray(ie), (ie[2] << 8) + ie[3] !== D))
                    return null;
                  for (_e = 0; _e < 4; ++_e)
                    for (Z = 0; Z < D; )
                      if (((L = b.readU8()), L > 128)) {
                        if (((L -= 128), Z + L > D)) return null;
                        for (ge = b.readU8(), ve = 0; ve < L; ++ve)
                          te[ae + _e + 4 * Z++] = ge;
                      } else {
                        if (L === 0 || Z + L > D) return null;
                        for (ve = 0; ve < L; ++ve)
                          te[ae + _e + 4 * Z++] = b.readU8();
                      }
                  ae += D * 4 * (X ? 1 : -1);
                }
                return te;
              }
              _readPixelsFlat(b, D, G) {
                return b.remainingBytes === D * G * 4
                  ? new Uint8Array(b.arraybuffer, b.offset)
                  : null;
              }
            }
            const g = { repeat: x.x3I, clamp: x.vq6, mirror: x.qoY },
              T = {
                nearest: x.uhC,
                linear: x.DrA,
                nearest_mip_nearest: x.GLw,
                linear_mip_nearest: x.reG,
                nearest_mip_linear: x.hs2,
                linear_mip_linear: x.qn_,
              },
              E = {
                default: x.s64,
                rgbm: x.fW0,
                rgbe: x.TOD,
                rgbp: x.mEg,
                swizzleGGGR: x.wmq,
              };
            class M {
              load(b, D, G) {
                throw new Error("not implemented");
              }
              open(b, D, G) {
                throw new Error("not implemented");
              }
            }
            const R = function (b) {
              const D = Math.log2(Math.max(b._width, b._height)) + 1,
                G = function (Q) {
                  return (
                    Q instanceof HTMLCanvasElement ||
                    Q instanceof HTMLImageElement ||
                    Q instanceof HTMLVideoElement
                  );
                };
              if (
                !(b._format === x.Lxj || b._format === x.s7h) ||
                b._volume ||
                b._compressed ||
                b._levels.length === 1 ||
                b._levels.length === D ||
                G(b._cubemap ? b._levels[0][0] : b._levels[0])
              )
                return;
              const X = function (Q, te, ae) {
                const Z = Math.max(1, Q >> 1),
                  J = Math.max(1, te >> 1),
                  ve = new ae.constructor(Z * J * 4),
                  _e = Math.floor(Q / Z),
                  L = Math.floor(te / J),
                  ge = _e * L;
                for (let k = 0; k < J; ++k)
                  for (let j = 0; j < Z; ++j)
                    for (let B = 0; B < 4; ++B) {
                      let $ = 0;
                      for (let le = 0; le < L; ++le)
                        for (let O = 0; O < _e; ++O)
                          $ += ae[(j * _e + O + (k * L + le) * Q) * 4 + B];
                      ve[(j + k * Z) * 4 + B] = $ / ge;
                    }
                return ve;
              };
              for (let ie = b._levels.length; ie < D; ++ie) {
                const Q = Math.max(1, b._width >> (ie - 1)),
                  te = Math.max(1, b._height >> (ie - 1));
                if (b._cubemap) {
                  const ae = [];
                  for (let Z = 0; Z < 6; ++Z)
                    ae.push(X(Q, te, b._levels[ie - 1][Z]));
                  b._levels.push(ae);
                } else b._levels.push(X(Q, te, b._levels[ie - 1]));
              }
              b._levelsUpdated = b._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0];
            };
            class P {
              constructor(b) {
                this.handlerType = "texture";
                const D = b.assets,
                  G = b.graphicsDevice;
                (this._device = G),
                  (this._assets = D),
                  (this.imgParser = new n(D, G)),
                  (this.parsers = {
                    dds: new _(D),
                    ktx: new t(D),
                    ktx2: new v(D, G),
                    basis: new f(D, G),
                    hdr: new m(D),
                  });
              }
              set crossOrigin(b) {
                this.imgParser.crossOrigin = b;
              }
              get crossOrigin() {
                return this.imgParser.crossOrigin;
              }
              set maxRetries(b) {
                this.imgParser.maxRetries = b;
                for (const D in this.parsers)
                  this.parsers.hasOwnProperty(D) &&
                    (this.parsers[D].maxRetries = b);
              }
              get maxRetries() {
                return this.imgParser.maxRetries;
              }
              _getUrlWithoutParams(b) {
                return b.indexOf("?") >= 0 ? b.split("?")[0] : b;
              }
              _getParser(b) {
                const D = A.A.getExtension(this._getUrlWithoutParams(b))
                  .toLowerCase()
                  .replace(".", "");
                return this.parsers[D] || this.imgParser;
              }
              _getTextureOptions(b) {
                const D = {};
                if (b) {
                  var G;
                  ((G = b.name) == null ? void 0 : G.length) > 0 &&
                    (D.name = b.name);
                  const X = b.data;
                  X.hasOwnProperty("minfilter") &&
                    (D.minFilter = T[X.minfilter]),
                    X.hasOwnProperty("magfilter") &&
                      (D.magFilter = T[X.magfilter]),
                    X.hasOwnProperty("addressu") &&
                      (D.addressU = g[X.addressu]),
                    X.hasOwnProperty("addressv") &&
                      (D.addressV = g[X.addressv]),
                    X.hasOwnProperty("mipmaps") && (D.mipmaps = X.mipmaps),
                    X.hasOwnProperty("anisotropy") &&
                      (D.anisotropy = X.anisotropy),
                    X.hasOwnProperty("flipY") && (D.flipY = !!X.flipY),
                    X.hasOwnProperty("type")
                      ? (D.type = E[X.type])
                      : X.hasOwnProperty("rgbm") && X.rgbm
                      ? (D.type = x.fW0)
                      : b.file && b.file.opt & 8 && (D.type = x.wmq);
                }
                return D;
              }
              load(b, D, G) {
                typeof b == "string" && (b = { load: b, original: b }),
                  this._getParser(b.original).load(b, D, G);
              }
              open(b, D, G) {
                if (!b) return;
                const X = this._getTextureOptions(G);
                let ie = this._getParser(b).open(b, D, this._device, X);
                return (
                  ie === null
                    ? (ie = new y.g(this._device, {
                        width: 4,
                        height: 4,
                        format: x.akF,
                      }))
                    : (R(ie),
                      D.unswizzledGGGR && (G.file.variants.basis.opt &= -9)),
                  ie
                );
              }
              patch(b, D) {
                const G = b.resource;
                if (!G) return;
                const X = this._getTextureOptions(b);
                for (const ie of Object.keys(X)) G[ie] = X[ie];
              }
            }
          },
          7706: (xe, V, a) => {
            "use strict";
            a.d(V, { X: () => A, f: () => x });
            const A = "en-US",
              x = {
                en: "en-US",
                es: "en-ES",
                zh: "zh-CN",
                "zh-HK": "zh-TW",
                "zh-TW": "zh-HK",
                "zh-MO": "zh-HK",
                fr: "fr-FR",
                de: "de-DE",
                it: "it-IT",
                ru: "ru-RU",
                ja: "ja-JP",
              };
          },
          4446: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => h });
            var A = a(8976),
              x = a(3953);
            class y {
              _validate(s) {
                if (!s.header)
                  throw new Error('pc.I18n#addData: Missing "header" field');
                if (!s.header.version)
                  throw new Error(
                    'pc.I18n#addData: Missing "header.version" field'
                  );
                if (s.header.version !== 1)
                  throw new Error(
                    'pc.I18n#addData: Invalid "header.version" field'
                  );
                if (s.data) {
                  if (!Array.isArray(s.data))
                    throw new Error(
                      'pc.I18n#addData: "data" field must be an array'
                    );
                } else throw new Error('pc.I18n#addData: Missing "data" field');
                for (let l = 0, n = s.data.length; l < n; l++) {
                  const o = s.data[l];
                  if (!o.info)
                    throw new Error(
                      `pc.I18n#addData: missing "data[${l}].info" field`
                    );
                  if (!o.info.locale)
                    throw new Error(
                      `pc.I18n#addData: missing "data[${l}].info.locale" field`
                    );
                  if (typeof o.info.locale != "string")
                    throw new Error(
                      `pc.I18n#addData: "data[${l}].info.locale" must be a string`
                    );
                  if (!o.messages)
                    throw new Error(
                      `pc.I18n#addData: missing "data[${l}].messages" field`
                    );
                }
              }
              parse(s) {
                return s.data;
              }
            }
            var c = a(7706),
              d = a(8866);
            class h extends A.J {
              constructor(s) {
                super(),
                  (this.locale = c.X),
                  (this._translations = {}),
                  (this._availableLangs = {}),
                  (this._app = s),
                  (this._assets = []),
                  (this._parser = new y());
              }
              set assets(s) {
                const l = {};
                for (let o = 0, i = s.length; o < i; o++) {
                  const e = s[o] instanceof x.V ? s[o].id : s[o];
                  l[e] = !0;
                }
                let n = this._assets.length;
                for (; n--; ) {
                  const o = this._assets[n];
                  if (!l[o]) {
                    this._app.assets.off("add:" + o, this._onAssetAdd, this);
                    const i = this._app.assets.get(o);
                    i && this._onAssetRemove(i), this._assets.splice(n, 1);
                  }
                }
                for (const o in l) {
                  const i = parseInt(o, 10);
                  if (this._assets.indexOf(i) !== -1) continue;
                  this._assets.push(i);
                  const e = this._app.assets.get(i);
                  e
                    ? this._onAssetAdd(e)
                    : this._app.assets.once("add:" + i, this._onAssetAdd, this);
                }
              }
              get assets() {
                return this._assets;
              }
              set locale(s) {
                if (this._locale === s) return;
                let l = (0, d.Xo)(s);
                if (
                  l === "in" &&
                  ((l = "id"), (s = (0, d.JD)(s, l)), this._locale === s)
                )
                  return;
                const n = this._locale;
                (this._locale = s),
                  (this._lang = l),
                  (this._pluralFn = (0, d.dc)(this._lang)),
                  this.fire("set:locale", s, n);
              }
              get locale() {
                return this._locale;
              }
              static findAvailableLocale(s, l) {
                return (0, d.Tw)(s, l);
              }
              findAvailableLocale(s) {
                if (this._translations[s]) return s;
                const l = (0, d.Xo)(s);
                return this._findFallbackLocale(s, l);
              }
              getText(s, l) {
                let n = s,
                  o;
                l || ((l = this._locale), (o = this._lang));
                let i = this._translations[l];
                return (
                  i ||
                    (o || (o = (0, d.Xo)(l)),
                    (l = this._findFallbackLocale(l, o)),
                    (i = this._translations[l])),
                  i &&
                    i.hasOwnProperty(s) &&
                    ((n = i[s]),
                    Array.isArray(n) && (n = n[0]),
                    n == null && (n = s)),
                  n
                );
              }
              getPluralText(s, l, n) {
                let o = s,
                  i,
                  e;
                n
                  ? ((i = (0, d.Xo)(n)), (e = (0, d.dc)(i)))
                  : ((n = this._locale),
                    (i = this._lang),
                    (e = this._pluralFn));
                let t = this._translations[n];
                if (
                  (t ||
                    ((n = this._findFallbackLocale(n, i)),
                    (i = (0, d.Xo)(n)),
                    (e = (0, d.dc)(i)),
                    (t = this._translations[n])),
                  t && t[s] && e)
                ) {
                  const r = e(l);
                  (o = t[s][r]), o == null && (o = s);
                }
                return o;
              }
              addData(s) {
                let l;
                try {
                  l = this._parser.parse(s);
                } catch (n) {
                  console.error(n);
                  return;
                }
                for (let n = 0, o = l.length; n < o; n++) {
                  const i = l[n],
                    e = i.info.locale,
                    t = i.messages;
                  if (!this._translations[e]) {
                    this._translations[e] = {};
                    const r = (0, d.Xo)(e);
                    this._availableLangs[r] || (this._availableLangs[r] = e);
                  }
                  Object.assign(this._translations[e], t),
                    this.fire("data:add", e, t);
                }
              }
              removeData(s) {
                let l;
                try {
                  l = this._parser.parse(s);
                } catch (n) {
                  console.error(n);
                  return;
                }
                for (let n = 0, o = l.length; n < o; n++) {
                  const i = l[n],
                    e = i.info.locale,
                    t = this._translations[e];
                  if (!t) continue;
                  const r = i.messages;
                  for (const u in r) delete t[u];
                  Object.keys(t).length === 0 &&
                    (delete this._translations[e],
                    delete this._availableLangs[(0, d.Xo)(e)]),
                    this.fire("data:remove", e, r);
                }
              }
              destroy() {
                (this._translations = null),
                  (this._availableLangs = null),
                  (this._assets = null),
                  (this._parser = null),
                  this.off();
              }
              _findFallbackLocale(s, l) {
                let n = c.f[s];
                return (n && this._translations[n]) ||
                  ((n = c.f[l]), n && this._translations[n]) ||
                  ((n = this._availableLangs[l]), n && this._translations[n])
                  ? n
                  : c.X;
              }
              _onAssetAdd(s) {
                s.on("load", this._onAssetLoad, this),
                  s.on("change", this._onAssetChange, this),
                  s.on("remove", this._onAssetRemove, this),
                  s.on("unload", this._onAssetUnload, this),
                  s.resource && this._onAssetLoad(s);
              }
              _onAssetLoad(s) {
                this.addData(s.resource);
              }
              _onAssetChange(s) {
                s.resource && this.addData(s.resource);
              }
              _onAssetRemove(s) {
                s.off("load", this._onAssetLoad, this),
                  s.off("change", this._onAssetChange, this),
                  s.off("remove", this._onAssetRemove, this),
                  s.off("unload", this._onAssetUnload, this),
                  s.resource && this.removeData(s.resource),
                  this._app.assets.once("add:" + s.id, this._onAssetAdd, this);
              }
              _onAssetUnload(s) {
                s.resource && this.removeData(s.resource);
              }
            }
          },
          8866: (xe, V, a) => {
            "use strict";
            a.d(V, { JD: () => d, Tw: () => h, Xo: () => c, dc: () => s });
            var A = a(7706);
            const x = {};
            function y(l, n) {
              for (let o = 0, i = l.length; o < i; o++) x[l[o]] = n;
            }
            function c(l) {
              const n = l.indexOf("-");
              return n !== -1 ? l.substring(0, n) : l;
            }
            function d(l, n) {
              const o = l.indexOf("-");
              return o !== -1 ? n + l.substring(o) : n;
            }
            function h(l, n) {
              if (n[l]) return l;
              let o = A.f[l];
              if (o && n[o]) return o;
              const i = c(l);
              return (o = A.f[i]), n[o] ? o : n[i] ? i : A.X;
            }
            y(["ja", "ko", "th", "vi", "zh", "id"], function (l) {
              return 0;
            }),
              y(["fa", "hi"], function (l) {
                return l >= 0 && l <= 1 ? 0 : 1;
              }),
              y(["fr", "pt"], function (l) {
                return l >= 0 && l < 2 ? 0 : 1;
              }),
              y(["da"], function (l) {
                return l === 1 || (!Number.isInteger(l) && l >= 0 && l <= 1)
                  ? 0
                  : 1;
              }),
              y(
                [
                  "de",
                  "en",
                  "it",
                  "el",
                  "es",
                  "tr",
                  "fi",
                  "sv",
                  "nb",
                  "no",
                  "ur",
                ],
                function (l) {
                  return l === 1 ? 0 : 1;
                }
              ),
              y(["ru", "uk"], function (l) {
                if (Number.isInteger(l)) {
                  const n = l % 10,
                    o = l % 100;
                  if (n === 1 && o !== 11) return 0;
                  if (n >= 2 && n <= 4 && (o < 12 || o > 14)) return 1;
                  if (n === 0 || (n >= 5 && n <= 9) || (o >= 11 && o <= 14))
                    return 2;
                }
                return 3;
              }),
              y(["pl"], function (l) {
                if (Number.isInteger(l)) {
                  if (l === 1) return 0;
                  const n = l % 10,
                    o = l % 100;
                  if (n >= 2 && n <= 4 && (o < 12 || o > 14)) return 1;
                  if (
                    (n >= 0 && n <= 1) ||
                    (n >= 5 && n <= 9) ||
                    (o >= 12 && o <= 14)
                  )
                    return 2;
                }
                return 3;
              }),
              y(["ar"], function (l) {
                if (l === 0) return 0;
                if (l === 1) return 1;
                if (l === 2) return 2;
                if (Number.isInteger(l)) {
                  const n = l % 100;
                  if (n >= 3 && n <= 10) return 3;
                  if (n >= 11 && n <= 99) return 4;
                }
                return 5;
              });
            const f = x[c(A.X)];
            function s(l) {
              return x[l] || f;
            }
          },
          7896: (xe, V, a) => {
            "use strict";
            a.d(V, {
              B7: () => ve,
              FW: () => k,
              Oj: () => L,
              e5: () => _e,
              z5: () => ge,
            });
            var A = a(9222),
              x = a(7481),
              y = a(5596),
              c = a(9663),
              d = a(9273),
              h = a(4530);
            let f, s;
            const l = new x.e(),
              n = new x.e(),
              o = new c.R(),
              i = new c.R(),
              e = new c.R();
            (o.end = new x.e()), (i.end = new x.e()), (e.end = new x.e());
            const t = new x.e(),
              r = new x.e(),
              u = new x.e(),
              v = new x.e(),
              _ = new x.e(),
              m = new x.e(),
              g = new x.e(),
              T = new x.e(),
              E = new x.e(),
              M = new x.e(),
              R = new x.e(),
              P = new x.e(),
              F = new x.e(),
              b = new x.e(),
              D = new x.e(),
              G = new x.e(),
              X = new x.e(),
              ie = new x.e(),
              Q = new x.e(),
              te = new x.e(),
              ae = new y.Z();
            function Z(j, B, $) {
              return R.cross(j, B).dot($);
            }
            function J(j, B, $) {
              t.sub2(B, j),
                r.sub2($[0], j),
                u.sub2($[1], j),
                v.sub2($[2], j),
                m.cross(v, t);
              let le = r.dot(m),
                O,
                Y;
              if (le >= 0) {
                if (((O = -u.dot(m)), O < 0 || ((Y = Z(t, u, r)), Y < 0)))
                  return -1;
                const ne = 1 / (O + le + Y);
                g.copy($[0]).mulScalar(O * ne),
                  T.copy($[1]).mulScalar(le * ne),
                  E.copy($[2]).mulScalar(Y * ne),
                  M.copy(g).add(T).add(E);
              } else {
                if (
                  (_.sub2($[3], j),
                  (O = _.dot(m)),
                  O < 0 || ((Y = Z(t, r, _)), Y < 0))
                )
                  return -1;
                le = -le;
                const ne = 1 / (O + le + Y);
                g.copy($[0]).mulScalar(O * ne),
                  T.copy($[3]).mulScalar(le * ne),
                  E.copy($[2]).mulScalar(Y * ne),
                  M.copy(g).add(T).add(E);
              }
              return t.sub2($[0], $[2]).lengthSq() < 1e-8 ||
                t.sub2($[1], $[3]).lengthSq() < 1e-8
                ? -1
                : M.sub(j).lengthSq();
            }
            class ve {
              constructor(B, $, le) {
                (this.event = B),
                  (this.element = $),
                  (this.camera = le),
                  (this._stopPropagation = !1);
              }
              stopPropagation() {
                (this._stopPropagation = !0),
                  this.event &&
                    (this.event.stopImmediatePropagation(),
                    this.event.stopPropagation());
              }
            }
            class _e extends ve {
              constructor(B, $, le, O, Y, ne, de) {
                super(B, $, le),
                  (this.x = O),
                  (this.y = Y),
                  (this.ctrlKey = B.ctrlKey || !1),
                  (this.altKey = B.altKey || !1),
                  (this.shiftKey = B.shiftKey || !1),
                  (this.metaKey = B.metaKey || !1),
                  (this.button = B.button),
                  d.K.isPointerLocked()
                    ? ((this.dx =
                        B.movementX ||
                        B.webkitMovementX ||
                        B.mozMovementX ||
                        0),
                      (this.dy =
                        B.movementY ||
                        B.webkitMovementY ||
                        B.mozMovementY ||
                        0))
                    : ((this.dx = O - ne), (this.dy = Y - de)),
                  (this.wheelDelta = 0),
                  B.type === "wheel" &&
                    (B.deltaY > 0
                      ? (this.wheelDelta = 1)
                      : B.deltaY < 0 && (this.wheelDelta = -1));
              }
            }
            class L extends ve {
              constructor(B, $, le, O, Y, ne) {
                super(B, $, le),
                  (this.touches = B.touches),
                  (this.changedTouches = B.changedTouches),
                  (this.x = O),
                  (this.y = Y),
                  (this.touch = ne);
              }
            }
            class ge extends ve {
              constructor(B, $, le, O) {
                super(B, $, le), (this.inputSource = O);
              }
            }
            class k {
              constructor(B, $) {
                (this._app = null),
                  (this._attached = !1),
                  (this._target = null),
                  (this._enabled = !0),
                  (this._lastX = 0),
                  (this._lastY = 0),
                  (this._upHandler = this._handleUp.bind(this)),
                  (this._downHandler = this._handleDown.bind(this)),
                  (this._moveHandler = this._handleMove.bind(this)),
                  (this._wheelHandler = this._handleWheel.bind(this)),
                  (this._touchstartHandler = this._handleTouchStart.bind(this)),
                  (this._touchendHandler = this._handleTouchEnd.bind(this)),
                  (this._touchcancelHandler = this._touchendHandler),
                  (this._touchmoveHandler = this._handleTouchMove.bind(this)),
                  (this._sortHandler = this._sortElements.bind(this)),
                  (this._elements = []),
                  (this._hoveredElement = null),
                  (this._pressedElement = null),
                  (this._touchedElements = {}),
                  (this._touchesForWhichTouchLeaveHasFired = {}),
                  (this._selectedElements = {}),
                  (this._selectedPressedElements = {}),
                  (this._useMouse = !$ || $.useMouse !== !1),
                  (this._useTouch = !$ || $.useTouch !== !1),
                  (this._useXr = !$ || $.useXr !== !1),
                  (this._selectEventsAttached = !1),
                  A.i.touch && (this._clickedEntities = {}),
                  this.attach(B);
              }
              set enabled(B) {
                this._enabled = B;
              }
              get enabled() {
                return this._enabled;
              }
              set app(B) {
                this._app = B;
              }
              get app() {
                return this._app || (0, h.D)();
              }
              attach(B) {
                this._attached && ((this._attached = !1), this.detach()),
                  (this._target = B),
                  (this._attached = !0);
                const $ = A.i.passiveEvents ? { passive: !0 } : !1;
                this._useMouse &&
                  (window.addEventListener("mouseup", this._upHandler, $),
                  window.addEventListener("mousedown", this._downHandler, $),
                  window.addEventListener("mousemove", this._moveHandler, $),
                  window.addEventListener("wheel", this._wheelHandler, $)),
                  this._useTouch &&
                    A.i.touch &&
                    (this._target.addEventListener(
                      "touchstart",
                      this._touchstartHandler,
                      $
                    ),
                    this._target.addEventListener(
                      "touchend",
                      this._touchendHandler,
                      !1
                    ),
                    this._target.addEventListener(
                      "touchmove",
                      this._touchmoveHandler,
                      !1
                    ),
                    this._target.addEventListener(
                      "touchcancel",
                      this._touchcancelHandler,
                      !1
                    )),
                  this.attachSelectEvents();
              }
              attachSelectEvents() {
                !this._selectEventsAttached &&
                  this._useXr &&
                  this.app &&
                  this.app.xr &&
                  this.app.xr.supported &&
                  (this._clickedEntities || (this._clickedEntities = {}),
                  (this._selectEventsAttached = !0),
                  this.app.xr.on("start", this._onXrStart, this));
              }
              detach() {
                if (!this._attached) return;
                this._attached = !1;
                const B = A.i.passiveEvents ? { passive: !0 } : !1;
                this._useMouse &&
                  (window.removeEventListener("mouseup", this._upHandler, B),
                  window.removeEventListener("mousedown", this._downHandler, B),
                  window.removeEventListener("mousemove", this._moveHandler, B),
                  window.removeEventListener("wheel", this._wheelHandler, B)),
                  this._useTouch &&
                    (this._target.removeEventListener(
                      "touchstart",
                      this._touchstartHandler,
                      B
                    ),
                    this._target.removeEventListener(
                      "touchend",
                      this._touchendHandler,
                      !1
                    ),
                    this._target.removeEventListener(
                      "touchmove",
                      this._touchmoveHandler,
                      !1
                    ),
                    this._target.removeEventListener(
                      "touchcancel",
                      this._touchcancelHandler,
                      !1
                    )),
                  this._selectEventsAttached &&
                    ((this._selectEventsAttached = !1),
                    this.app.xr.off("start", this._onXrStart, this),
                    this.app.xr.off("end", this._onXrEnd, this),
                    this.app.xr.off("update", this._onXrUpdate, this),
                    this.app.xr.input.off(
                      "selectstart",
                      this._onSelectStart,
                      this
                    ),
                    this.app.xr.input.off("selectend", this._onSelectEnd, this),
                    this.app.xr.input.off(
                      "remove",
                      this._onXrInputRemove,
                      this
                    )),
                  (this._target = null);
              }
              addElement(B) {
                this._elements.indexOf(B) === -1 && this._elements.push(B);
              }
              removeElement(B) {
                const $ = this._elements.indexOf(B);
                $ !== -1 && this._elements.splice($, 1);
              }
              _handleUp(B) {
                this._enabled &&
                  (d.K.isPointerLocked() ||
                    (this._calcMouseCoords(B),
                    this._onElementMouseEvent("mouseup", B)));
              }
              _handleDown(B) {
                this._enabled &&
                  (d.K.isPointerLocked() ||
                    (this._calcMouseCoords(B),
                    this._onElementMouseEvent("mousedown", B)));
              }
              _handleMove(B) {
                this._enabled &&
                  (this._calcMouseCoords(B),
                  this._onElementMouseEvent("mousemove", B),
                  (this._lastX = f),
                  (this._lastY = s));
              }
              _handleWheel(B) {
                this._enabled &&
                  (this._calcMouseCoords(B),
                  this._onElementMouseEvent("mousewheel", B));
              }
              _determineTouchedElements(B) {
                const $ = {},
                  le = this.app.systems.camera.cameras;
                for (let O = le.length - 1; O >= 0; O--) {
                  const Y = le[O];
                  let ne = 0;
                  const de = B.changedTouches.length;
                  for (let re = 0; re < de; re++) {
                    if ($[B.changedTouches[re].identifier]) {
                      ne++;
                      continue;
                    }
                    const I = this._calcTouchCoords(B.changedTouches[re]),
                      w = this._getTargetElementByCoords(Y, I.x, I.y);
                    w &&
                      (ne++,
                      ($[B.changedTouches[re].identifier] = {
                        element: w,
                        camera: Y,
                        x: I.x,
                        y: I.y,
                      }));
                  }
                  if (ne === de) break;
                }
                return $;
              }
              _handleTouchStart(B) {
                if (!this._enabled) return;
                const $ = this._determineTouchedElements(B);
                for (let le = 0, O = B.changedTouches.length; le < O; le++) {
                  const Y = B.changedTouches[le],
                    ne = $[Y.identifier],
                    de = this._touchedElements[Y.identifier];
                  ne &&
                    (!de || ne.element !== de.element) &&
                    (this._fireEvent(
                      B.type,
                      new L(B, ne.element, ne.camera, ne.x, ne.y, Y)
                    ),
                    (this._touchesForWhichTouchLeaveHasFired[Y.identifier] =
                      !1));
                }
                for (const le in $) this._touchedElements[le] = $[le];
              }
              _handleTouchEnd(B) {
                if (!this._enabled) return;
                const $ = this.app.systems.camera.cameras;
                for (const le in this._clickedEntities)
                  delete this._clickedEntities[le];
                for (let le = 0, O = B.changedTouches.length; le < O; le++) {
                  const Y = B.changedTouches[le],
                    ne = this._touchedElements[Y.identifier];
                  if (!ne) continue;
                  const de = ne.element,
                    re = ne.camera,
                    I = ne.x,
                    w = ne.y;
                  delete this._touchedElements[Y.identifier],
                    delete this._touchesForWhichTouchLeaveHasFired[
                      Y.identifier
                    ],
                    this._fireEvent(B.type, new L(B, de, re, I, w, Y));
                  const N = this._calcTouchCoords(Y);
                  for (let W = $.length - 1; W >= 0; W--)
                    this._getTargetElementByCoords($[W], N.x, N.y) === de &&
                      (this._clickedEntities[de.entity.getGuid()] ||
                        (this._fireEvent("click", new L(B, de, re, I, w, Y)),
                        (this._clickedEntities[de.entity.getGuid()] =
                          Date.now())));
                }
              }
              _handleTouchMove(B) {
                if ((B.preventDefault(), !this._enabled)) return;
                const $ = this._determineTouchedElements(B);
                for (let le = 0, O = B.changedTouches.length; le < O; le++) {
                  const Y = B.changedTouches[le],
                    ne = $[Y.identifier],
                    de = this._touchedElements[Y.identifier];
                  if (de) {
                    const re = this._calcTouchCoords(Y);
                    (!ne || ne.element !== de.element) &&
                      !this._touchesForWhichTouchLeaveHasFired[Y.identifier] &&
                      (this._fireEvent(
                        "touchleave",
                        new L(B, de.element, de.camera, re.x, re.y, Y)
                      ),
                      (this._touchesForWhichTouchLeaveHasFired[Y.identifier] =
                        !0)),
                      this._fireEvent(
                        "touchmove",
                        new L(B, de.element, de.camera, re.x, re.y, Y)
                      );
                  }
                }
              }
              _onElementMouseEvent(B, $) {
                let le = null;
                const O = this._hoveredElement;
                this._hoveredElement = null;
                const Y = this.app.systems.camera.cameras;
                let ne;
                for (
                  let de = Y.length - 1;
                  de >= 0 &&
                  ((ne = Y[de]),
                  (le = this._getTargetElementByCoords(ne, f, s)),
                  !le);
                  de--
                );
                if (
                  ((this._hoveredElement = le),
                  (B === "mousemove" || B === "mouseup") && this._pressedElement
                    ? this._fireEvent(
                        B,
                        new _e(
                          $,
                          this._pressedElement,
                          ne,
                          f,
                          s,
                          this._lastX,
                          this._lastY
                        )
                      )
                    : le &&
                      (this._fireEvent(
                        B,
                        new _e($, le, ne, f, s, this._lastX, this._lastY)
                      ),
                      B === "mousedown" && (this._pressedElement = le)),
                  O !== this._hoveredElement &&
                    (O &&
                      this._fireEvent(
                        "mouseleave",
                        new _e($, O, ne, f, s, this._lastX, this._lastY)
                      ),
                    this._hoveredElement &&
                      this._fireEvent(
                        "mouseenter",
                        new _e(
                          $,
                          this._hoveredElement,
                          ne,
                          f,
                          s,
                          this._lastX,
                          this._lastY
                        )
                      )),
                  B === "mouseup" && this._pressedElement)
                ) {
                  if (this._pressedElement === this._hoveredElement) {
                    const de = this._hoveredElement.entity.getGuid();
                    let re = !this._clickedEntities;
                    if (this._clickedEntities) {
                      const I = this._clickedEntities[de] || 0;
                      (re = Date.now() - I > 300),
                        delete this._clickedEntities[de];
                    }
                    re &&
                      this._fireEvent(
                        "click",
                        new _e(
                          $,
                          this._hoveredElement,
                          ne,
                          f,
                          s,
                          this._lastX,
                          this._lastY
                        )
                      );
                  }
                  this._pressedElement = null;
                }
              }
              _onXrStart() {
                this.app.xr.on("end", this._onXrEnd, this),
                  this.app.xr.on("update", this._onXrUpdate, this),
                  this.app.xr.input.on(
                    "selectstart",
                    this._onSelectStart,
                    this
                  ),
                  this.app.xr.input.on("selectend", this._onSelectEnd, this),
                  this.app.xr.input.on("remove", this._onXrInputRemove, this);
              }
              _onXrEnd() {
                this.app.xr.off("update", this._onXrUpdate, this),
                  this.app.xr.input.off(
                    "selectstart",
                    this._onSelectStart,
                    this
                  ),
                  this.app.xr.input.off("selectend", this._onSelectEnd, this),
                  this.app.xr.input.off("remove", this._onXrInputRemove, this);
              }
              _onXrUpdate() {
                if (!this._enabled) return;
                const B = this.app.xr.input.inputSources;
                for (let $ = 0; $ < B.length; $++)
                  this._onElementSelectEvent("selectmove", B[$], null);
              }
              _onXrInputRemove(B) {
                const $ = this._selectedElements[B.id];
                $ &&
                  ((B._elementEntity = null),
                  this._fireEvent("selectleave", new ge(null, $, null, B))),
                  delete this._selectedElements[B.id],
                  delete this._selectedPressedElements[B.id];
              }
              _onSelectStart(B, $) {
                this._enabled &&
                  this._onElementSelectEvent("selectstart", B, $);
              }
              _onSelectEnd(B, $) {
                this._enabled && this._onElementSelectEvent("selectend", B, $);
              }
              _onElementSelectEvent(B, $, le) {
                let O;
                const Y = this._selectedElements[$.id];
                let ne;
                const de = this.app.systems.camera.cameras;
                let re;
                if ($.elementInput) {
                  e.set($.getOrigin(), $.getDirection());
                  for (
                    let w = de.length - 1;
                    w >= 0 &&
                    ((re = de[w]),
                    (O = this._getTargetElementByRay(e, re)),
                    !O);
                    w--
                  );
                }
                ($._elementEntity = O || null),
                  O
                    ? ((this._selectedElements[$.id] = O), (ne = O))
                    : delete this._selectedElements[$.id],
                  Y !== ne &&
                    (Y && this._fireEvent("selectleave", new ge(le, Y, re, $)),
                    ne &&
                      this._fireEvent("selectenter", new ge(le, ne, re, $)));
                const I = this._selectedPressedElements[$.id];
                B === "selectmove" &&
                  I &&
                  this._fireEvent("selectmove", new ge(le, I, re, $)),
                  B === "selectstart" &&
                    ((this._selectedPressedElements[$.id] = ne),
                    ne &&
                      this._fireEvent("selectstart", new ge(le, ne, re, $))),
                  !$.elementInput &&
                    I &&
                    (delete this._selectedPressedElements[$.id],
                    Y && this._fireEvent("selectend", new ge(le, I, re, $))),
                  B === "selectend" &&
                    $.elementInput &&
                    (delete this._selectedPressedElements[$.id],
                    I && this._fireEvent("selectend", new ge(le, I, re, $)),
                    I &&
                      I === Y &&
                      this._fireEvent("click", new ge(le, I, re, $)));
              }
              _fireEvent(B, $) {
                let le = $.element;
                for (
                  ;
                  le.fire(B, $),
                    !(
                      $._stopPropagation ||
                      !le.entity.parent ||
                      ((le = le.entity.parent.element), !le)
                    );

                );
              }
              _calcMouseCoords(B) {
                const $ = this._target.getBoundingClientRect(),
                  le = Math.floor($.left),
                  O = Math.floor($.top);
                (f = B.clientX - le), (s = B.clientY - O);
              }
              _calcTouchCoords(B) {
                let $ = 0,
                  le = 0,
                  O = B.target;
                for (; !(O instanceof HTMLElement); ) O = O.parentNode;
                let Y = O;
                do
                  ($ += Y.offsetLeft - Y.scrollLeft),
                    (le += Y.offsetTop - Y.scrollTop),
                    (Y = Y.offsetParent);
                while (Y);
                return { x: B.pageX - $, y: B.pageY - le };
              }
              _sortElements(B, $) {
                const le = this.app.scene.layers.sortTransparentLayers(
                  B.layers,
                  $.layers
                );
                return le !== 0
                  ? le
                  : B.screen && !$.screen
                  ? -1
                  : !B.screen && $.screen
                  ? 1
                  : !B.screen && !$.screen
                  ? 0
                  : B.screen.screen.screenSpace && !$.screen.screen.screenSpace
                  ? -1
                  : $.screen.screen.screenSpace && !B.screen.screen.screenSpace
                  ? 1
                  : $.drawOrder - B.drawOrder;
              }
              _getTargetElementByCoords(B, $, le) {
                const O = this._calculateRayScreen($, le, B, o) ? o : null,
                  Y = this._calculateRay3d($, le, B, i) ? i : null;
                return this._getTargetElement(B, O, Y);
              }
              _getTargetElementByRay(B, $) {
                o.origin.copy(B.origin),
                  o.direction.copy(B.direction),
                  o.end
                    .copy(o.direction)
                    .mulScalar($.farClip * 2)
                    .add(o.origin);
                const le = o,
                  O = $.worldToScreen(le.origin, l),
                  Y = this._calculateRayScreen(O.x, O.y, $, i) ? i : null;
                return this._getTargetElement($, Y, le);
              }
              _getTargetElement(B, $, le) {
                let O = null,
                  Y = 1 / 0;
                this._elements.sort(this._sortHandler);
                for (let ne = 0, de = this._elements.length; ne < de; ne++) {
                  const re = this._elements[ne];
                  if (re.layers.some((I) => B.layersSet.has(I)))
                    if (re.screen && re.screen.screen.screenSpace) {
                      if (!$) continue;
                      if (this._checkElement($, re, !0) >= 0) {
                        O = re;
                        break;
                      }
                    } else {
                      if (!le) continue;
                      const I = this._checkElement(le, re, !1);
                      if (I >= 0 && (I < Y && ((O = re), (Y = I)), re.screen)) {
                        O = re;
                        break;
                      }
                    }
                }
                return O;
              }
              _calculateRayScreen(B, $, le, O) {
                const Y = this.app.graphicsDevice.width,
                  ne = this.app.graphicsDevice.height,
                  de = le.rect.z * Y,
                  re = le.rect.w * ne,
                  I = le.rect.x * Y,
                  w = I + de,
                  N = (1 - le.rect.y) * ne,
                  W = N - re;
                let he = (B * Y) / this._target.clientWidth,
                  ue = ($ * ne) / this._target.clientHeight;
                return he >= I && he <= w && ue <= N && ue >= W
                  ? ((he = (Y * (he - I)) / de),
                    (ue = (ne * (ue - W)) / re),
                    (ue = ne - ue),
                    O.origin.set(he, ue, 1),
                    O.direction.set(0, 0, -1),
                    O.end.copy(O.direction).mulScalar(2).add(O.origin),
                    !0)
                  : !1;
              }
              _calculateRay3d(B, $, le, O) {
                const Y = this._target.clientWidth,
                  ne = this._target.clientHeight,
                  de = le.rect.z * Y,
                  re = le.rect.w * ne,
                  I = le.rect.x * Y,
                  w = I + de,
                  N = (1 - le.rect.y) * ne,
                  W = N - re;
                let he = B,
                  ue = $;
                return B >= I && B <= w && $ <= N && ue >= W
                  ? ((he = (Y * (he - I)) / de),
                    (ue = (ne * (ue - W)) / re),
                    le.screenToWorld(he, ue, le.nearClip, l),
                    le.screenToWorld(he, ue, le.farClip, n),
                    O.origin.copy(l),
                    O.direction.set(0, 0, -1),
                    O.end.copy(n),
                    !0)
                  : !1;
              }
              _checkElement(B, $, le) {
                if (
                  $.maskedBy &&
                  this._checkElement(B, $.maskedBy.element, le) < 0
                )
                  return -1;
                let O;
                le
                  ? (O = k.calculateScaleToScreen($))
                  : (O = k.calculateScaleToWorld($));
                const Y = k.buildHitCorners(
                  $,
                  le ? $.screenCorners : $.worldCorners,
                  O
                );
                return J(B.origin, B.end, Y);
              }
              static buildHitCorners(B, $, le) {
                let O = $;
                if (B.entity && B.entity.button) {
                  const ne = B.entity.button.hitPadding || ae;
                  F.copy(B.entity.up),
                    b.copy(F).mulScalar(-1),
                    G.copy(B.entity.right),
                    D.copy(G).mulScalar(-1),
                    F.mulScalar(ne.w * le.y),
                    b.mulScalar(ne.y * le.y),
                    G.mulScalar(ne.z * le.x),
                    D.mulScalar(ne.x * le.x),
                    X.copy(O[0]).add(b).add(D),
                    ie.copy(O[1]).add(b).add(G),
                    Q.copy(O[2]).add(F).add(G),
                    te.copy(O[3]).add(F).add(D),
                    (O = [X, ie, Q, te]);
                }
                if (le.x < 0) {
                  const ne = O[2].x,
                    de = O[0].x;
                  (O[0].x = ne), (O[1].x = de), (O[2].x = de), (O[3].x = ne);
                }
                if (le.y < 0) {
                  const ne = O[2].y,
                    de = O[0].y;
                  (O[0].y = ne), (O[1].y = ne), (O[2].y = de), (O[3].y = de);
                }
                if (le.z < 0) {
                  const ne = O[2].x,
                    de = O[2].y,
                    re = O[2].z;
                  (O[2].x = O[0].x),
                    (O[2].y = O[0].y),
                    (O[2].z = O[0].z),
                    (O[0].x = ne),
                    (O[0].y = de),
                    (O[0].z = re);
                }
                return O;
              }
              static calculateScaleToScreen(B) {
                let $ = B.entity;
                const le = B.screen.screen.scale;
                for (P.set(le, le, le); $ && !$.screen; )
                  P.mul($.getLocalScale()), ($ = $.parent);
                return P;
              }
              static calculateScaleToWorld(B) {
                let $ = B.entity;
                for (P.set(1, 1, 1); $; )
                  P.mul($.getLocalScale()), ($ = $.parent);
                return P;
              }
            }
          },
          9686: (xe, V, a) => {
            "use strict";
            a.d(V, { W: () => ge });
            var A = a(9516),
              x = a(5227),
              y = a(8656),
              c = a(7481),
              d = a(7915),
              h = a(1630),
              f = a(9061),
              s = a(8524),
              l = a(1208),
              n = a(3637),
              o = a(818),
              i = a(7087),
              e = a(2910),
              t = a(7638),
              r = a(9391),
              u = a(5463),
              v = a(3035),
              _ = a(1369),
              m = a(7994),
              g = a(9833),
              T = a(5145);
            const E = new T.i();
            class M {
              constructor(j, B) {
                (this.scene = j),
                  (this.light = B),
                  this.store(),
                  (B.numCascades = 1),
                  B.type !== r.kx &&
                    (B._node.getWorldTransform(),
                    B.getBoundingSphere(E),
                    (this.lightBounds = new d.I()),
                    this.lightBounds.center.copy(E.center),
                    this.lightBounds.halfExtents.set(
                      E.radius,
                      E.radius,
                      E.radius
                    ));
              }
              store() {
                (this.mask = this.light.mask),
                  (this.shadowUpdateMode = this.light.shadowUpdateMode),
                  (this.enabled = this.light.enabled),
                  (this.intensity = this.light.intensity),
                  (this.rotation = this.light._node.getLocalRotation().clone()),
                  (this.numCascades = this.light.numCascades);
              }
              restore() {
                const j = this.light;
                (j.mask = this.mask),
                  (j.shadowUpdateMode = this.shadowUpdateMode),
                  (j.enabled = this.enabled),
                  (j.intensity = this.intensity),
                  j._node.setLocalRotation(this.rotation),
                  (j.numCascades = this.numCascades);
              }
              startBake() {
                (this.light.enabled = !0),
                  this.light._destroyShadowMap(),
                  this.light.beginFrame();
              }
              endBake(j) {
                const B = this.light;
                (B.enabled = !1),
                  B.shadowMap &&
                    (B.shadowMap.cached && j.add(B, B.shadowMap),
                    (B.shadowMap = null));
              }
            }
            const R = new m.Z();
            class P extends M {
              get numVirtualLights() {
                return this.light.type === r.kx ? this.light.bakeNumSamples : 1;
              }
              prepareVirtualLight(j, B) {
                const $ = this.light;
                if (($._node.setLocalRotation(this.rotation), j > 0)) {
                  const Y = $.bakeArea;
                  g.y.circlePointDeterministic(R, j, B),
                    R.mulScalar(Y * 0.5),
                    $._node.rotateLocal(R.x, 0, R.y);
                }
                $._node.getWorldTransform();
                const le = this.scene.gammaCorrection ? 2.2 : 1,
                  O = Math.pow(this.intensity, le);
                $.intensity = Math.pow(O / B, 1 / le);
              }
            }
            var F = a(371);
            const b = new c.e();
            class D extends M {
              constructor(j) {
                const B = new F.w("AmbientLight");
                B.addComponent("light", {
                  type: "directional",
                  affectDynamic: !0,
                  affectLightmapped: !1,
                  bake: !0,
                  bakeNumSamples: j.ambientBakeNumSamples,
                  castShadows: !0,
                  normalOffsetBias: 0.05,
                  shadowBias: 0.2,
                  shadowDistance: 1,
                  shadowResolution: 2048,
                  shadowType: r.MF,
                  color: x.Q.WHITE,
                  intensity: 1,
                  bakeDir: !1,
                }),
                  super(j, B.light.light);
              }
              get numVirtualLights() {
                return this.light.bakeNumSamples;
              }
              prepareVirtualLight(j, B) {
                g.y.spherePointDeterministic(
                  b,
                  j,
                  B,
                  0,
                  this.scene.ambientBakeSpherePart
                ),
                  this.light._node.lookAt(b.mulScalar(-1)),
                  this.light._node.rotateLocal(90, 0, 0);
                const $ = this.scene.gammaCorrection ? 2.2 : 1,
                  le = 2 * Math.PI * this.scene.ambientBakeSpherePart,
                  O = Math.pow(le, $);
                this.light.intensity = Math.pow(O / B, 1 / $);
              }
            }
            class G {
              constructor(j, B = null) {
                (this.node = j),
                  (this.component = j.render || j.model),
                  (B = B || this.component.meshInstances),
                  this.store(),
                  (this.meshInstances = B),
                  (this.bounds = null),
                  (this.renderTargets = []);
              }
              store() {
                this.castShadows = this.component.castShadows;
              }
              restore() {
                this.component.castShadows = this.castShadows;
              }
            }
            var X = a(9788),
              ie = a(333);
            const Q = 15;
            class te {
              constructor(j) {
                (this.device = j),
                  (this.shaderDilate = (0, ie.$$)(
                    j,
                    e.G.fullscreenQuadVS,
                    t.f.dilatePS,
                    "lmDilate"
                  )),
                  (this.constantTexSource = j.scope.resolve("source")),
                  (this.constantPixelOffset = j.scope.resolve("pixelOffset")),
                  (this.pixelOffset = new Float32Array(2)),
                  (this.shaderDenoise = null),
                  (this.sigmas = null),
                  (this.constantSigmas = null),
                  (this.kernel = null);
              }
              setSourceTexture(j) {
                this.constantTexSource.setValue(j);
              }
              prepare(j, B) {
                (this.pixelOffset[0] = 1 / j),
                  (this.pixelOffset[1] = 1 / B),
                  this.constantPixelOffset.setValue(this.pixelOffset);
              }
              prepareDenoise(j, B) {
                this.shaderDenoise ||
                  ((this.shaderDenoise = (0, ie.$$)(
                    this.device,
                    e.G.fullscreenQuadVS,
                    t.f.bilateralDeNoisePS,
                    "lmBilateralDeNoise"
                  )),
                  (this.sigmas = new Float32Array(2)),
                  (this.constantSigmas = this.device.scope.resolve("sigmas")),
                  (this.constantKernel =
                    this.device.scope.resolve("kernel[0]")),
                  (this.bZnorm = this.device.scope.resolve("bZnorm"))),
                  (this.sigmas[0] = j),
                  (this.sigmas[1] = B),
                  this.constantSigmas.setValue(this.sigmas),
                  this.evaluateDenoiseUniforms(j, B);
              }
              evaluateDenoiseUniforms(j, B) {
                function $(ne, de) {
                  return (
                    (0.39894 * Math.exp((-0.5 * ne * ne) / (de * de))) / de
                  );
                }
                this.kernel = this.kernel || new Float32Array(Q);
                const le = this.kernel,
                  O = Math.floor((Q - 1) / 2);
                for (let ne = 0; ne <= O; ++ne) {
                  const de = $(ne, j);
                  (le[O + ne] = de), (le[O - ne] = de);
                }
                this.constantKernel.setValue(this.kernel);
                const Y = 1 / $(0, B);
                this.bZnorm.setValue(Y);
              }
            }
            var ae = a(1268),
              Z = a(4870);
            const J = 2048,
              ve = 0,
              _e = 1,
              L = new c.e();
            class ge {
              constructor(j, B, $, le, O) {
                (this.device = j),
                  (this.root = B),
                  (this.scene = $),
                  (this.renderer = le),
                  (this.assets = O),
                  (this.shadowMapCache = le.shadowMapCache),
                  (this._tempSet = new Set()),
                  (this._initCalled = !1),
                  (this.passMaterials = []),
                  (this.ambientAOMaterial = null),
                  (this.fog = ""),
                  (this.ambientLight = new x.Q()),
                  (this.renderTargets = new Map()),
                  (this.stats = {
                    renderPasses: 0,
                    lightmapCount: 0,
                    totalRenderTime: 0,
                    forwardTime: 0,
                    fboTime: 0,
                    shadowMapTime: 0,
                    compileTime: 0,
                    shadersLinked: 0,
                  });
              }
              destroy() {
                X.j.decRef(this.blackTex),
                  (this.blackTex = null),
                  X.j.destroy(),
                  (this.device = null),
                  (this.root = null),
                  (this.scene = null),
                  (this.renderer = null),
                  (this.assets = null);
              }
              initBake(j) {
                if (!this._initCalled) {
                  (this._initCalled = !0),
                    (this.lightmapFilters = new te(j)),
                    (this.constantBakeDir = j.scope.resolve("bakeDir")),
                    (this.materials = []),
                    (this.blackTex = new l.g(this.device, {
                      width: 4,
                      height: 4,
                      format: h.Lxj,
                      type: h.fW0,
                      name: "lightmapBlack",
                    })),
                    X.j.incRef(this.blackTex);
                  const B = new u.i();
                  B.clearColor.set(0, 0, 0, 0),
                    (B.clearColorBuffer = !0),
                    (B.clearDepthBuffer = !1),
                    (B.clearStencilBuffer = !1),
                    (B.frustumCulling = !1),
                    (B.projection = r.RD),
                    (B.aspectRatio = 1),
                    (B.node = new v.t()),
                    (this.camera = B);
                }
                if (this.scene.clusteredLightingEnabled) {
                  const B = new o.p(
                    j.supportsAreaLights,
                    j.maxTextureSize,
                    () => {}
                  );
                  this.lightingParams = B;
                  const $ = this.scene.lighting;
                  (B.shadowsEnabled = $.shadowsEnabled),
                    (B.shadowAtlasResolution = $.shadowAtlasResolution),
                    (B.cookiesEnabled = $.cookiesEnabled),
                    (B.cookieAtlasResolution = $.cookieAtlasResolution),
                    (B.areaLightsEnabled = $.areaLightsEnabled),
                    (B.cells = new c.e(3, 3, 3)),
                    (B.maxLightsPerCell = 4),
                    (this.worldClusters = new i.q(j)),
                    (this.worldClusters.name = "ClusterLightmapper");
                }
              }
              finishBake(j) {
                this.materials = [];
                function B($) {
                  X.j.decRef($.colorBuffer), $.destroy();
                }
                this.renderTargets.forEach(($) => {
                  B($);
                }),
                  this.renderTargets.clear(),
                  j.forEach(($) => {
                    $.renderTargets.forEach((le) => {
                      B(le);
                    }),
                      ($.renderTargets.length = 0);
                  }),
                  (this.ambientAOMaterial = null),
                  this.worldClusters &&
                    (this.worldClusters.destroy(), (this.worldClusters = null));
              }
              createMaterialForPass(j, B, $, le) {
                const O = new _.F();
                if (
                  ((O.name = `lmMaterial-pass:${$}-ambient:${le}`),
                  (O.chunks.APIVersion = h.Cvi),
                  (O.chunks.transformVS =
                    `#define UV1LAYOUT
` + e.G.transformVS),
                  $ === ve)
                ) {
                  let Y = t.f.bakeLmEndPS;
                  le
                    ? (Y =
                        `
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${B.ambientBakeOcclusionContrast.toFixed(
                      1
                    )} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${B.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								` + Y)
                    : ((O.ambient = new x.Q(0, 0, 0)), (O.ambientTint = !0)),
                    (O.chunks.basePS =
                      e.G.basePS +
                      (B.lightmapPixelFormat === h.Lxj
                        ? `
#define LIGHTMAP_RGBM
`
                        : "")),
                    (O.chunks.endPS = Y),
                    (O.lightMap = this.blackTex);
                } else
                  (O.chunks.basePS =
                    e.G.basePS +
                    `
uniform sampler2D texture_dirLightMap;
uniform float bakeDir;
`),
                    (O.chunks.endPS = t.f.bakeDirLmEndPS);
                return (
                  (O.chunks.outputAlphaPS = `
`),
                  (O.chunks.outputAlphaOpaquePS = `
`),
                  (O.chunks.outputAlphaPremulPS = `
`),
                  (O.cull = h.pLF),
                  (O.forceUv1 = !0),
                  O.update(),
                  O
                );
              }
              createMaterials(j, B, $) {
                for (let le = 0; le < $; le++)
                  this.passMaterials[le] ||
                    (this.passMaterials[le] = this.createMaterialForPass(
                      j,
                      B,
                      le,
                      !1
                    ));
                this.ambientAOMaterial ||
                  ((this.ambientAOMaterial = this.createMaterialForPass(
                    j,
                    B,
                    0,
                    !0
                  )),
                  (this.ambientAOMaterial.onUpdateShader = function (le) {
                    return (
                      (le.litOptions.lightMapWithoutAmbient = !0),
                      (le.litOptions.separateAmbient = !0),
                      le
                    );
                  }));
              }
              createTexture(j, B) {
                return new l.g(this.device, {
                  width: j,
                  height: j,
                  format: this.scene.lightmapPixelFormat,
                  mipmaps: !1,
                  type:
                    this.scene.lightmapPixelFormat === h.Lxj ? h.fW0 : h.s64,
                  minFilter: h.uhC,
                  magFilter: h.uhC,
                  addressU: h.vq6,
                  addressV: h.vq6,
                  name: B,
                });
              }
              collectModels(j, B, $) {
                var le, O, Y;
                if (!j.enabled) return;
                let ne;
                if (
                  ((le = j.model) != null &&
                    le.model &&
                    (O = j.model) != null &&
                    O.enabled &&
                    ($ && $.push(new G(j)),
                    j.model.lightmapped &&
                      B &&
                      (ne = j.model.model.meshInstances)),
                  (Y = j.render) != null &&
                    Y.enabled &&
                    ($ && $.push(new G(j)),
                    j.render.lightmapped && B && (ne = j.render.meshInstances)),
                  ne)
                ) {
                  let de = !0;
                  for (let re = 0; re < ne.length; re++)
                    if (!ne[re].mesh.vertexBuffer.format.hasUv1) {
                      de = !1;
                      break;
                    }
                  if (de) {
                    const re = [];
                    for (let I = 0; I < ne.length; I++) {
                      const w = ne[I].mesh;
                      this._tempSet.has(w)
                        ? B.push(new G(j, [ne[I]]))
                        : re.push(ne[I]),
                        this._tempSet.add(w);
                    }
                    this._tempSet.clear(),
                      re.length > 0 && B.push(new G(j, re));
                  }
                }
                for (let de = 0; de < j._children.length; de++)
                  this.collectModels(j._children[de], B, $);
              }
              prepareShadowCasters(j) {
                const B = [];
                for (let $ = 0; $ < j.length; $++) {
                  const le = j[$].component;
                  if (
                    ((le.castShadows = le.castShadowsLightmap),
                    le.castShadowsLightmap)
                  ) {
                    const O = j[$].meshInstances;
                    for (let Y = 0; Y < O.length; Y++)
                      (O[Y].visibleThisFrame = !0), B.push(O[Y]);
                  }
                }
                return B;
              }
              updateTransforms(j) {
                for (let B = 0; B < j.length; B++) {
                  const $ = j[B].meshInstances;
                  for (let le = 0; le < $.length; le++)
                    $[le].node.getWorldTransform();
                }
              }
              calculateLightmapSize(j) {
                let B;
                const $ = this.scene.lightmapSizeMultiplier || 16,
                  le = L;
                let O, Y;
                j.model
                  ? ((Y = j.model.lightmapSizeMultiplier),
                    j.model.asset
                      ? ((B = this.assets.get(j.model.asset).data),
                        B.area && (O = B.area))
                      : j.model._area &&
                        ((B = j.model), B._area && (O = B._area)))
                  : j.render &&
                    ((Y = j.render.lightmapSizeMultiplier),
                    j.render.type !== "asset" &&
                      j.render._area &&
                      ((B = j.render), B._area && (O = B._area)));
                const ne = { x: 1, y: 1, z: 1, uv: 1 };
                O && ((ne.x = O.x), (ne.y = O.y), (ne.z = O.z), (ne.uv = O.uv));
                const de = Y || 1;
                (ne.x *= de), (ne.y *= de), (ne.z *= de);
                const re = j.render || j.model,
                  I = this.computeNodeBounds(re.meshInstances);
                le.copy(I.halfExtents);
                let w =
                  ne.x * le.y * le.z + ne.y * le.x * le.z + ne.z * le.x * le.y;
                return (
                  (w /= ne.uv),
                  (w = Math.sqrt(w)),
                  Math.min(
                    y.D.nextPowerOfTwo(w * $),
                    this.scene.lightmapMaxResolution || J
                  )
                );
              }
              setLightmapping(j, B, $, le) {
                for (let O = 0; O < j.length; O++) {
                  const Y = j[O],
                    ne = Y.meshInstances;
                  for (let de = 0; de < ne.length; de++) {
                    const re = ne[de];
                    if ((re.setLightmapped(B), B)) {
                      le && (re._shaderDefs |= le), (re.mask = r.be);
                      for (let I = 0; I < $; I++) {
                        const w = Y.renderTargets[I].colorBuffer;
                        (w.minFilter = h.DrA),
                          (w.magFilter = h.DrA),
                          re.setRealtimeLightmap(n.F.lightmapParamNames[I], w);
                      }
                    }
                  }
                }
              }
              bake(j, B = r.N9) {
                const $ = this.device;
                if ($.isWebGPU) return;
                const le = (0, A.t)();
                this.scene._updateSky($),
                  (this.stats.renderPasses = 0),
                  (this.stats.shadowMapTime = 0),
                  (this.stats.forwardTime = 0);
                const O = $._shaderStats.linked,
                  Y = $._renderTargetCreationTime,
                  ne = $._shaderStats.compileTime,
                  de = [],
                  re = [];
                if (j) {
                  for (let w = 0; w < j.length; w++)
                    this.collectModels(j[w], de, null);
                  this.collectModels(this.root, null, re);
                } else this.collectModels(this.root, de, re);
                if (de.length > 0) {
                  this.renderer.shadowRenderer.frameUpdate();
                  const w = B === r.N9 ? 2 : 1;
                  this.setLightmapping(de, !1, w),
                    this.initBake($),
                    this.bakeInternal(w, de, re);
                  let N = r.tT;
                  B === r.N9 && (N |= r.CO),
                    this.scene.ambientBake && (N |= r.tE),
                    this.setLightmapping(de, !0, w, N),
                    this.finishBake(de);
                }
                const I = (0, A.t)();
                (this.stats.totalRenderTime = I - le),
                  (this.stats.shadersLinked = $._shaderStats.linked - O),
                  (this.stats.compileTime = $._shaderStats.compileTime - ne),
                  (this.stats.fboTime = $._renderTargetCreationTime - Y),
                  (this.stats.lightmapCount = de.length);
              }
              allocateTextures(j, B) {
                for (let $ = 0; $ < j.length; $++) {
                  const le = j[$],
                    O = this.calculateLightmapSize(le.node);
                  for (let Y = 0; Y < B; Y++) {
                    const ne = this.createTexture(
                      O,
                      "lightmapper_lightmap_" + $
                    );
                    X.j.incRef(ne),
                      (le.renderTargets[Y] = new f.O({
                        colorBuffer: ne,
                        depth: !1,
                      }));
                  }
                  if (!this.renderTargets.has(O)) {
                    const Y = this.createTexture(
                      O,
                      "lightmapper_temp_lightmap_" + O
                    );
                    X.j.incRef(Y),
                      this.renderTargets.set(
                        O,
                        new f.O({ colorBuffer: Y, depth: !1 })
                      );
                  }
                }
              }
              prepareLightsToBake(j, B, $) {
                if (this.scene.ambientBake) {
                  const O = new D(this.scene);
                  $.push(O);
                }
                const le = j._lights;
                for (let O = 0; O < le.length; O++) {
                  const Y = le[O],
                    ne = new P(this.scene, Y);
                  B.push(ne),
                    Y.enabled &&
                      Y.mask & r.XE &&
                      ((Y.mask = 4294967295),
                      (Y.shadowUpdateMode = Y.type === r.kx ? r.M5 : r.e3),
                      $.push(ne));
                }
                $.sort();
              }
              restoreLights(j) {
                for (let B = 0; B < j.length; B++) j[B].restore();
              }
              setupScene() {
                (this.fog = this.scene.fog),
                  this.ambientLight.copy(this.scene.ambientLight),
                  (this.scene.fog = r.qX),
                  this.scene.ambientBake ||
                    this.scene.ambientLight.set(0, 0, 0),
                  this.renderer.setSceneConstants();
              }
              restoreScene() {
                (this.scene.fog = this.fog),
                  this.scene.ambientLight.copy(this.ambientLight);
              }
              computeNodeBounds(j) {
                const B = new d.I();
                if (j.length > 0) {
                  B.copy(j[0].aabb);
                  for (let $ = 1; $ < j.length; $++) B.add(j[$].aabb);
                }
                return B;
              }
              computeNodesBounds(j) {
                for (let B = 0; B < j.length; B++) {
                  const $ = j[B].meshInstances;
                  j[B].bounds = this.computeNodeBounds($);
                }
              }
              computeBounds(j) {
                const B = new d.I();
                for (let $ = 0; $ < j.length; $++) {
                  B.copy(j[0].aabb);
                  for (let le = 1; le < j.length; le++) B.add(j[le].aabb);
                }
                return B;
              }
              backupMaterials(j) {
                for (let B = 0; B < j.length; B++)
                  this.materials[B] = j[B].material;
              }
              restoreMaterials(j) {
                for (let B = 0; B < j.length; B++)
                  j[B].material = this.materials[B];
              }
              lightCameraPrepare(j, B) {
                const $ = B.light;
                let le;
                return (
                  $.type === r.Gy &&
                    ((le = $.getRenderData(null, 0).shadowCamera),
                    le._node.setPosition($._node.getPosition()),
                    le._node.setRotation($._node.getRotation()),
                    le._node.rotateLocal(-90, 0, 0),
                    (le.projection = r.$J),
                    (le.nearClip = $.attenuationEnd / 1e3),
                    (le.farClip = $.attenuationEnd),
                    (le.aspectRatio = 1),
                    (le.fov = $._outerConeAngle * 2),
                    this.renderer.updateCameraFrustum(le)),
                  le
                );
              }
              lightCameraPrepareAndCull(j, B, $, le) {
                const O = j.light;
                let Y = !0;
                if (O.type === r.kx) {
                  L.copy(le.center),
                    (L.y += le.halfExtents.y),
                    this.camera.node.setPosition(L),
                    this.camera.node.setEulerAngles(-90, 0, 0),
                    (this.camera.nearClip = 0),
                    (this.camera.farClip = le.halfExtents.y * 2);
                  const ne = Math.max(le.halfExtents.x, le.halfExtents.z);
                  this.camera.orthoHeight = ne;
                } else j.lightBounds.intersects(B.bounds) || (Y = !1);
                if (O.type === r.Gy) {
                  let ne = !1;
                  const de = B.meshInstances;
                  for (let re = 0; re < de.length; re++)
                    if (de[re]._isVisible($)) {
                      ne = !0;
                      break;
                    }
                  ne || (Y = !1);
                }
                return Y;
              }
              setupLightArray(j, B) {
                (j[r.kx].length = 0),
                  (j[r.dG].length = 0),
                  (j[r.Gy].length = 0),
                  (j[B.type][0] = B),
                  (B.visibleThisFrame = !0);
              }
              renderShadowMap(j, B, $) {
                const le = $.light,
                  O = this.scene.clusteredLightingEnabled;
                return (
                  !j &&
                    le.castShadows &&
                    (!le.shadowMap &&
                      !O &&
                      (le.shadowMap = this.shadowMapCache.get(this.device, le)),
                    le.type === r.kx
                      ? this.renderer._shadowRendererDirectional.cull(
                          le,
                          B,
                          this.camera
                        )
                      : this.renderer._shadowRendererLocal.cull(le, B),
                    this.renderer.shadowRenderer.render(le, this.camera, !1)),
                  !0
                );
              }
              postprocessTextures(j, B, $) {
                const O = this.lightmapFilters.shaderDilate,
                  Y = this.scene.lightmapFilterEnabled;
                Y &&
                  this.lightmapFilters.prepareDenoise(
                    this.scene.lightmapFilterRange,
                    this.scene.lightmapFilterSmoothness
                  ),
                  j.setBlendState(ae.t.NOBLEND),
                  j.setDepthState(Z.H.NODEPTH),
                  j.setStencilState(null, null);
                for (let ne = 0; ne < B.length; ne++) {
                  const de = B[ne];
                  for (let re = 0; re < $; re++) {
                    const I = de.renderTargets[re],
                      w = I.colorBuffer,
                      N = this.renderTargets.get(w.width),
                      W = N.colorBuffer;
                    this.lightmapFilters.prepare(w.width, w.height);
                    for (let he = 0; he < 1; he++) {
                      this.lightmapFilters.setSourceTexture(w);
                      const ue = Y && re === 0 && he === 0;
                      (0, s.l)(
                        j,
                        N,
                        ue ? this.lightmapFilters.shaderDenoise : O
                      ),
                        this.lightmapFilters.setSourceTexture(W),
                        (0, s.l)(j, I, O);
                    }
                  }
                }
              }
              bakeInternal(j, B, $) {
                const le = this.scene,
                  O = this.device,
                  Y = le.clusteredLightingEnabled;
                this.createMaterials(O, le, j),
                  this.setupScene(),
                  le.layers._update(O, Y),
                  this.computeNodesBounds(B),
                  this.allocateTextures(B, j);
                const ne = [],
                  de = [];
                this.prepareLightsToBake(le.layers, ne, de),
                  this.updateTransforms($);
                const re = this.prepareShadowCasters($);
                this.renderer.updateCpuSkinMatrices(re),
                  this.renderer.gpuUpdate(re);
                const I = this.computeBounds(re);
                let w, N, W, he;
                for (w = 0; w < B.length; w++)
                  for (W = B[w].meshInstances, N = 0; N < W.length; N++)
                    (he = W[N]),
                      he.setLightmapped(!1),
                      (he.mask = r.XE),
                      he.setRealtimeLightmap(
                        n.F.lightmapParamNames[0],
                        he.material.lightMap
                          ? he.material.lightMap
                          : this.blackTex
                      ),
                      he.setRealtimeLightmap(
                        n.F.lightmapParamNames[1],
                        this.blackTex
                      );
                for (N = 0; N < de.length; N++) de[N].light.enabled = !1;
                const ue = [[], [], []];
                let ye,
                  Oe,
                  Ae = !1;
                for (w = 0; w < de.length; w++) {
                  const ke = de[w],
                    Ue = ke instanceof D;
                  let Ge = ke.numVirtualLights;
                  j > 1 && Ge > 1 && ke.light.bakeDir && (Ge = 1);
                  for (let ht = 0; ht < Ge; ht++) {
                    Ge > 1 && ke.prepareVirtualLight(ht, Ge), ke.startBake();
                    let me = !1;
                    const z = this.lightCameraPrepare(O, ke);
                    for (Oe = 0; Oe < B.length; Oe++) {
                      const K = B[Oe];
                      if (
                        ((W = K.meshInstances),
                        !!this.lightCameraPrepareAndCull(ke, K, z, I))
                      ) {
                        if (
                          (this.setupLightArray(ue, ke.light),
                          Y &&
                            this.renderer.lightTextureAtlas.update(
                              ue[r.Gy],
                              ue[r.dG],
                              this.lightingParams
                            ),
                          (me = this.renderShadowMap(me, re, ke)),
                          Y)
                        ) {
                          const H = ue[r.Gy].concat(ue[r.dG]);
                          this.worldClusters.update(
                            H,
                            this.scene.gammaCorrection,
                            this.lightingParams
                          );
                        }
                        for (
                          this.backupMaterials(W), ye = 0;
                          ye < j && !((ye > 0 && ht > 0) || (Ue && ye > 0));
                          ye++
                        ) {
                          const H = K.renderTargets[ye],
                            q = K.renderTargets[ye].colorBuffer.width,
                            se = this.renderTargets.get(q),
                            Ce = se.colorBuffer;
                          ye === 0
                            ? (Ae = le.updateShaders)
                            : Ae && (le.updateShaders = !0);
                          let we = this.passMaterials[ye];
                          for (
                            Ue &&
                              ht + 1 === Ge &&
                              ye === 0 &&
                              (we = this.ambientAOMaterial),
                              N = 0;
                            N < W.length;
                            N++
                          )
                            W[N].material = we;
                          for (
                            this.renderer.updateShaders(W),
                              this.renderer.setCamera(this.camera, se, !0),
                              ye === _e &&
                                this.constantBakeDir.setValue(
                                  ke.light.bakeDir ? 1 : 0
                                ),
                              Y && this.worldClusters.activate(),
                              this.renderer._forwardTime = 0,
                              this.renderer._shadowMapTime = 0,
                              this.renderer.renderForward(
                                this.camera,
                                W,
                                W.length,
                                ue,
                                r.Su
                              ),
                              O.updateEnd(),
                              K.renderTargets[ye] = se,
                              this.renderTargets.set(q, H),
                              N = 0;
                            N < W.length;
                            N++
                          )
                            (he = W[N]),
                              he.setRealtimeLightmap(
                                n.F.lightmapParamNames[ye],
                                Ce
                              ),
                              (he._shaderDefs |= r.tT);
                        }
                        this.restoreMaterials(W);
                      }
                    }
                    ke.endBake(this.shadowMapCache);
                  }
                }
                for (
                  this.postprocessTextures(O, B, j), Oe = 0;
                  Oe < $.length;
                  Oe++
                )
                  $[Oe].restore();
                this.restoreLights(ne),
                  this.restoreScene(),
                  Y || this.shadowMapCache.clear();
              }
            }
          },
          3664: (xe, V, a) => {
            "use strict";
            a.d(V, { s: () => e, o: () => i });
            var A = a(5562);
            function x(t, r) {
              let u;
              const m = (b, D) => {
                  switch (D) {
                    case u.DT_INT8:
                      return new Int8Array(
                        b.buffer,
                        b.byteOffset,
                        b.byteLength
                      );
                    case u.DT_INT16:
                      return new Int16Array(
                        b.buffer,
                        b.byteOffset,
                        b.byteLength / 2
                      );
                    case u.DT_INT32:
                      return new Int32Array(
                        b.buffer,
                        b.byteOffset,
                        b.byteLength / 4
                      );
                    case u.DT_UINT8:
                      return new Uint8Array(
                        b.buffer,
                        b.byteOffset,
                        b.byteLength
                      );
                    case u.DT_UINT16:
                      return new Uint16Array(
                        b.buffer,
                        b.byteOffset,
                        b.byteLength / 2
                      );
                    case u.DT_UINT32:
                      return new Uint32Array(
                        b.buffer,
                        b.byteOffset,
                        b.byteLength / 4
                      );
                    case u.DT_FLOAT32:
                      return new Float32Array(
                        b.buffer,
                        b.byteOffset,
                        b.byteLength / 4
                      );
                  }
                  return null;
                },
                g = (b) => {
                  switch (b) {
                    case u.DT_INT8:
                      return 1;
                    case u.DT_INT16:
                      return 2;
                    case u.DT_INT32:
                      return 4;
                    case u.DT_UINT8:
                      return 1;
                    case u.DT_UINT16:
                      return 2;
                    case u.DT_UINT32:
                      return 4;
                    case u.DT_FLOAT32:
                      return 4;
                  }
                  return 1;
                },
                T = (b) => b.num_components() * g(b.data_type()),
                E = { 0: 0, 1: 1, 5: 2, 2: 3, 7: 4, 8: 5, 4: 6, 3: 7 },
                M = (b, D) => {
                  const G = (j, B, $) => {
                      (j[0] = B[0] - $[0]),
                        (j[1] = B[1] - $[1]),
                        (j[2] = B[2] - $[2]);
                    },
                    X = (j, B, $) => {
                      (j[0] = B[1] * $[2] - $[1] * B[2]),
                        (j[1] = B[2] * $[0] - $[2] * B[0]),
                        (j[2] = B[0] * $[1] - $[0] * B[1]);
                    },
                    ie = (j, B) => {
                      const $ = j[B + 0],
                        le = j[B + 1],
                        O = j[B + 2],
                        Y = 1 / Math.sqrt($ * $ + le * le + O * O);
                      (j[B + 0] *= Y), (j[B + 1] *= Y), (j[B + 2] *= Y);
                    },
                    Q = (j, B, $) => {
                      for (let le = 0; le < 3; ++le) j[le] = B[$ + le];
                    },
                    te = D.length / 3,
                    ae = b.length / 3,
                    Z = new Float32Array(b.length),
                    J = [0, 0, 0],
                    ve = [0, 0, 0],
                    _e = [0, 0, 0],
                    L = [0, 0, 0],
                    ge = [0, 0, 0],
                    k = [0, 0, 0];
                  for (let j = 0; j < te; ++j) {
                    const B = D[j * 3 + 0] * 3,
                      $ = D[j * 3 + 1] * 3,
                      le = D[j * 3 + 2] * 3;
                    Q(J, b, B),
                      Q(ve, b, $),
                      Q(_e, b, le),
                      G(L, ve, J),
                      G(ge, _e, J),
                      X(k, L, ge),
                      ie(k, 0);
                    for (let O = 0; O < 3; ++O)
                      (Z[B + O] += k[O]),
                        (Z[$ + O] += k[O]),
                        (Z[le + O] += k[O]);
                  }
                  for (let j = 0; j < ae; ++j) ie(Z, j * 3);
                  return new Uint8Array(Z.buffer);
                },
                R = (b) => {
                  const D = {},
                    G = new u.DecoderBuffer();
                  G.Init(b, b.length);
                  const X = new u.Decoder();
                  if (X.GetEncodedGeometryType(G) !== u.TRIANGULAR_MESH)
                    return (
                      (D.error = "Failed to decode draco mesh: not a mesh"), D
                    );
                  const ie = new u.Mesh(),
                    Q = X.DecodeBufferToMesh(G, ie);
                  if (!Q || !Q.ok() || ie.ptr === 0)
                    return (D.error = "Failed to decode draco asset"), D;
                  const te = ie.num_faces() * 3,
                    ae = ie.num_points() <= 65535,
                    Z = te * (ae ? 2 : 4),
                    J = u._malloc(Z);
                  ae
                    ? (X.GetTrianglesUInt16Array(ie, Z, J),
                      (D.indices = new Uint16Array(
                        u.HEAPU16.buffer,
                        J,
                        te
                      ).slice().buffer))
                    : (X.GetTrianglesUInt32Array(ie, Z, J),
                      (D.indices = new Uint32Array(
                        u.HEAPU32.buffer,
                        J,
                        te
                      ).slice().buffer)),
                    u._free(J);
                  const ve = [];
                  for (let B = 0; B < ie.num_attributes(); ++B)
                    ve.push(X.GetAttribute(ie, B));
                  ve.sort((B, $) => {
                    var le, O;
                    return (
                      ((le = E[B.attribute_type()]) != null ? le : E.length) -
                      ((O = E[$.attribute_type()]) != null ? O : E.length)
                    );
                  }),
                    (D.attributes = ve.map((B) => B.unique_id()));
                  let _e = 0;
                  const L = ve.map((B) => {
                      const $ = _e;
                      return (_e += Math.ceil(T(B) / 4) * 4), $;
                    }),
                    ge = ve.some((B) => B.attribute_type() === 1),
                    k = L[1];
                  if (!ge) {
                    for (let B = 1; B < L.length; ++B) L[B] += 12;
                    _e += 12;
                  }
                  D.vertices = new ArrayBuffer(ie.num_points() * _e);
                  const j = new Uint8Array(D.vertices);
                  for (let B = 0; B < ie.num_attributes(); ++B) {
                    const $ = ve[B],
                      le = T($),
                      O = ie.num_points() * le,
                      Y = u._malloc(O);
                    X.GetAttributeDataArrayForAllPoints(
                      ie,
                      $,
                      $.data_type(),
                      O,
                      Y
                    );
                    const ne = new Uint8Array(u.HEAPU8.buffer, Y, O);
                    for (let de = 0; de < ie.num_points(); ++de)
                      for (let re = 0; re < le; ++re)
                        j[de * _e + L[B] + re] = ne[de * le + re];
                    if (!ge && $.attribute_type() === 0) {
                      const de = M(
                        m(ne, $.data_type()),
                        ae
                          ? new Uint16Array(D.indices)
                          : new Uint32Array(D.indices)
                      );
                      for (let re = 0; re < ie.num_points(); ++re)
                        for (let I = 0; I < 12; ++I)
                          j[re * _e + k + I] = de[re * 12 + I];
                    }
                    u._free(Y);
                  }
                  return u.destroy(ie), u.destroy(X), u.destroy(G), D;
                },
                P = (b) => {
                  const D = R(new Uint8Array(b.buffer));
                  self.postMessage(
                    {
                      jobId: b.jobId,
                      error: D.error,
                      indices: D.indices,
                      vertices: D.vertices,
                      attributes: D.attributes,
                    },
                    [D.indices, D.vertices].filter((G) => G != null)
                  );
                },
                F = [];
              self.onmessage = (b) => {
                const D = b.data;
                switch (D.type) {
                  case "init":
                    self
                      .DracoDecoderModule({
                        instantiateWasm: (G, X) => (
                          WebAssembly.instantiate(D.module, G)
                            .then((ie) => X(ie))
                            .catch((ie) =>
                              console.error("instantiate failed + " + ie)
                            ),
                          {}
                        ),
                      })
                      .then((G) => {
                        (u = G), F.forEach((X) => P(X));
                      });
                    break;
                  case "decodeMesh":
                    u ? P(D) : F.push(D);
                    break;
                }
              };
            }
            var y = a(8633);
            const c = 3;
            class d {
              constructor() {
                (this.workers = [[], [], []]),
                  (this.jobId = 0),
                  (this.jobQueue = []),
                  (this.jobCallbacks = new Map()),
                  (this.run = (r, u) => {
                    r.postMessage(
                      { type: "decodeMesh", jobId: u.jobId, buffer: u.buffer },
                      [u.buffer]
                    );
                  });
              }
              init(r) {
                for (
                  r.forEach((u) => {
                    u.addEventListener("message", (v) => {
                      const _ = v.data,
                        m = this.jobCallbacks.get(_.jobId);
                      if (
                        (m &&
                          m(_.error, {
                            indices: _.indices,
                            vertices: _.vertices,
                            attributes: _.attributes,
                          }),
                        this.jobCallbacks.delete(_.jobId),
                        this.jobQueue.length > 0)
                      ) {
                        const g = this.jobQueue.shift();
                        this.run(u, g);
                      } else {
                        const g = this.workers[2].indexOf(u);
                        if (g !== -1)
                          this.workers[2].splice(g, 1), this.workers[1].push(u);
                        else {
                          const T = this.workers[1].indexOf(u);
                          T !== -1 &&
                            (this.workers[1].splice(T, 1),
                            this.workers[0].push(u));
                        }
                      }
                    });
                  }),
                    this.workers[0] = r;
                  this.jobQueue.length &&
                  (this.workers[0].length || this.workers[1].length);

                ) {
                  const u = this.jobQueue.shift();
                  if (this.workers[0].length > 0) {
                    const v = this.workers[0].shift();
                    this.workers[1].push(v), this.run(v, u);
                  } else {
                    const v = this.workers[1].shift();
                    this.workers[2].push(v), this.run(v, u);
                  }
                }
              }
              enqueueJob(r, u) {
                const v = { jobId: this.jobId++, buffer: r };
                if (
                  (this.jobCallbacks.set(v.jobId, u),
                  this.workers[0].length > 0)
                ) {
                  const _ = this.workers[0].shift();
                  this.workers[1].push(_), this.run(_, v);
                } else if (this.workers[1].length > 0) {
                  const _ = this.workers[1].shift();
                  this.workers[2].push(_), this.run(_, v);
                } else this.jobQueue.push(v);
              }
            }
            const h = (t) =>
                new Promise((r, u) => {
                  const v = {
                    cache: !0,
                    responseType: "text",
                    retry: c > 0,
                    maxRetries: c,
                  };
                  y.L.get(t, v, (_, m) => {
                    _ ? u(_) : r(m);
                  });
                }),
              f = (t) => {
                const r = () =>
                    fetch(t)
                      .then((v) => v.arrayBuffer())
                      .then((v) => WebAssembly.compile(v)),
                  u = () =>
                    WebAssembly.compileStreaming(fetch(t)).catch((v) => r());
                return WebAssembly.compileStreaming ? u() : r();
              },
              s = 1;
            let l, n;
            const o = (t) => {
                if (l) return !0;
                if (!t)
                  if (n) t = n;
                  else {
                    const r = A.F.getConfig("DracoDecoderModule");
                    r
                      ? (t = {
                          jsUrl: r.glueUrl,
                          wasmUrl: r.wasmUrl,
                          numWorkers: r.numWorkers,
                        })
                      : (t = {
                          jsUrl: "draco.wasm.js",
                          wasmUrl: "draco.wasm.wasm",
                          numWorkers: s,
                        });
                  }
                return !t.jsUrl || !t.wasmUrl
                  ? !1
                  : ((l = new d()),
                    Promise.all([h(t.jsUrl), f(t.wasmUrl)]).then(([r, u]) => {
                      const v = [
                          "/* draco */",
                          r,
                          "/* worker */",
                          `(
${x.toString()}
)()

`,
                        ].join(`
`),
                        _ = new Blob([v], { type: "application/javascript" }),
                        m = URL.createObjectURL(_),
                        g = Math.max(1, Math.min(16, t.numWorkers || s)),
                        T = [];
                      for (let E = 0; E < g; ++E) {
                        const M = new Worker(m);
                        M.postMessage({ type: "init", module: u }), T.push(M);
                      }
                      l.init(T);
                    }),
                    !0);
              },
              i = (t) => {
                t != null && t.lazyInit ? (n = t) : o(t);
              },
              e = (t, r) => (o() ? (l.enqueueJob(t, r), !0) : !1);
          },
          6377: (xe, V, a) => {
            "use strict";
            a.d(V, { V: () => s });
            var A = a(3637),
              x = a(9611),
              y = a(6414),
              c = a(8777),
              d = a(5506),
              h = a(371),
              f = a(3953);
            class s {
              constructor(n, o, i, e) {
                const t = function (m, g, T) {
                    const E = s.createAsset(o.name, m, g, T);
                    return i.add(E), E;
                  },
                  r = [];
                for (let _ = 0; _ < n.renders.length; ++_)
                  r.push(t("render", n.renders[_], _));
                const u = [];
                for (let _ = 0; _ < n.materials.length; ++_)
                  u.push(t("material", n.materials[_], _));
                const v = [];
                for (let _ = 0; _ < n.animations.length; ++_)
                  v.push(t("animation", n.animations[_], _));
                (this.data = n),
                  (this._model = null),
                  (this._assetName = o.name),
                  (this._assets = i),
                  (this._defaultMaterial = e),
                  (this.renders = r),
                  (this.materials = u),
                  (this.textures = n.textures),
                  (this.animations = v);
              }
              get model() {
                if (!this._model) {
                  const n = s.createModel(this.data, this._defaultMaterial),
                    o = s.createAsset(this._assetName, "model", n, 0);
                  this._assets.add(o), (this._model = o);
                }
                return this._model;
              }
              static createAsset(n, o, i, e) {
                const t = new f.V(n + "/" + o + "/" + e, o, { url: "" });
                return (t.resource = i), (t.loaded = !0), t;
              }
              instantiateModelEntity(n) {
                const o = new h.w();
                return (
                  o.addComponent(
                    "model",
                    Object.assign({ type: "asset", asset: this.model }, n)
                  ),
                  o
                );
              }
              instantiateRenderEntity(n) {
                const o = this._defaultMaterial,
                  i = [],
                  e = function (v, _, m, g, T, E, M) {
                    const R = T[m.id],
                      P = R === void 0 ? o : g[R],
                      F = new A.F(m, P);
                    return (
                      m.morph && (F.morphInstance = new y.q(m.morph)),
                      M.hasOwnProperty("skin") &&
                        i.push({ meshInstance: F, rootBone: v, entity: _ }),
                      F
                    );
                  },
                  t = (u, v, _) => {
                    const m = new h.w();
                    v._cloneInternal(m), u || (u = m);
                    let g = null,
                      T = null;
                    for (let M = 0; M < _.nodes.length; M++)
                      if (_.nodes[M] === v) {
                        const P = _.gltf.nodes[M];
                        if (P.hasOwnProperty("mesh")) {
                          const F = _.renders[P.mesh].meshes;
                          T = this.renders[P.mesh];
                          for (let b = 0; b < F.length; b++) {
                            const D = F[b];
                            if (D) {
                              const G = e(
                                u,
                                m,
                                D,
                                _.materials,
                                _.meshDefaultMaterials,
                                _.skins,
                                P
                              );
                              g || (g = []), g.push(G);
                            }
                          }
                        }
                        if (_.lights) {
                          const F = _.lights.get(P);
                          F && m.addChild(F.clone());
                        }
                        if (_.cameras) {
                          const F = _.cameras.get(P);
                          F && F.camera.system.cloneComponent(F, m);
                        }
                      }
                    g &&
                      (m.addComponent(
                        "render",
                        Object.assign(
                          { type: "asset", meshInstances: g, rootBone: u },
                          n
                        )
                      ),
                      m.render.assignAsset(T));
                    const E = v.children;
                    for (let M = 0; M < E.length; M++) {
                      const R = t(u, E[M], _);
                      m.addChild(R);
                    }
                    return m;
                  },
                  r = [];
                for (const u of this.data.scenes) r.push(t(null, u, this.data));
                return (
                  i.forEach((u) => {
                    u.meshInstance.skinInstance = d.b.createCachedSkinInstance(
                      u.meshInstance.mesh.skin,
                      u.rootBone,
                      u.entity
                    );
                  }),
                  s.createSceneHierarchy(r, "Entity")
                );
              }
              getMaterialVariants() {
                return this.data.variants
                  ? Object.keys(this.data.variants)
                  : [];
              }
              applyMaterialVariant(n, o) {
                const i = o ? this.data.variants[o] : null;
                if (i === void 0) return;
                const e = n.findComponents("render");
                for (let t = 0; t < e.length; t++) {
                  const r = e[t];
                  this._applyMaterialVariant(i, r.meshInstances);
                }
              }
              applyMaterialVariantInstances(n, o) {
                const i = o ? this.data.variants[o] : null;
                i !== void 0 && this._applyMaterialVariant(i, n);
              }
              _applyMaterialVariant(n, o) {
                o.forEach((i) => {
                  if (n === null) i.material = this._defaultMaterial;
                  else {
                    const e = this.data.meshVariants[i.mesh.id];
                    e && (i.material = this.data.materials[e[n]]);
                  }
                });
              }
              static createSceneHierarchy(n, o) {
                let i = null;
                if (n.length === 1) i = n[0];
                else {
                  i = new o("SceneGroup");
                  for (const e of n) i.addChild(e);
                }
                return i;
              }
              static createModel(n, o) {
                const i = function (u, v, _, m, g, T, E) {
                    const M = n.meshDefaultMaterials[v.id],
                      R = M === void 0 ? o : g[M],
                      P = new A.F(v, R, T);
                    if (v.morph) {
                      const F = new y.q(v.morph);
                      (P.morphInstance = F), u.morphInstances.push(F);
                    }
                    if (E.hasOwnProperty("skin")) {
                      const F = E.skin,
                        b = _[F];
                      v.skin = b;
                      const D = m[F];
                      (P.skinInstance = D), u.skinInstances.push(D);
                    }
                    u.meshInstances.push(P);
                  },
                  e = new x.K(),
                  t = [];
                for (const r of n.skins) {
                  const u = new c.h(r);
                  (u.bones = r.bones), t.push(u);
                }
                e.graph = s.createSceneHierarchy(n.scenes, "GraphNode");
                for (let r = 0; r < n.nodes.length; r++) {
                  const u = n.nodes[r];
                  if (u.root === e.graph) {
                    const v = n.gltf.nodes[r];
                    if (v.hasOwnProperty("mesh")) {
                      const _ = n.renders[v.mesh].meshes;
                      for (let m = 0; m < _.length; m++) {
                        const g = _[m];
                        g && i(e, g, n.skins, t, n.materials, u, v);
                      }
                    }
                  }
                }
                return e;
              }
              destroy() {
                const n = this._assets,
                  o = function (t) {
                    n.remove(t), t.unload();
                  },
                  i = function (t) {
                    t.forEach(function (r) {
                      o(r);
                    });
                  };
                this.animations &&
                  (i(this.animations), (this.animations = null)),
                  this.textures && (i(this.textures), (this.textures = null)),
                  this.materials &&
                    (i(this.materials), (this.materials = null)),
                  this.renders && (i(this.renders), (this.renders = null)),
                  this._model && (o(this._model), (this._model = null)),
                  (this.data = null),
                  (this.assets = null);
              }
            }
          },
          2004: (xe, V, a) => {
            "use strict";
            a.d(V, { l: () => at });
            var A = a(1870),
              x = a(5227),
              y = a(8484),
              c = a(8656),
              d = a(7994),
              h = a(7481),
              f = a(7915),
              s = a(1630),
              l = a(970),
              n = a(1208),
              o = a(5860),
              i = a(6089),
              e = a(8633),
              t = a(9391),
              r = a(3035),
              u = a(8026),
              v = a(7197),
              _ = a(528),
              m = a(1336),
              g = a(8531),
              T = a(6768),
              E = a(8097),
              M = a(1369),
              R = a(371),
              P = a(871),
              F = a(541),
              b = a(7448),
              D = a(9645),
              G = a(3953),
              X = a(148),
              ie = a(3664);
            class Q {
              constructor() {
                (this.gltf = void 0),
                  (this.nodes = void 0),
                  (this.scenes = void 0),
                  (this.animations = void 0),
                  (this.textures = void 0),
                  (this.materials = void 0),
                  (this.variants = void 0),
                  (this.meshVariants = void 0),
                  (this.meshDefaultMaterials = void 0),
                  (this.renders = void 0),
                  (this.skins = void 0),
                  (this.lights = void 0),
                  (this.cameras = void 0);
              }
              destroy() {
                this.renders &&
                  this.renders.forEach((pe) => {
                    pe.meshes = null;
                  });
              }
            }
            const te = (ce) => /^data:.*,.*$/i.test(ce),
              ae = (ce) => ce.substring(ce.indexOf(":") + 1, ce.indexOf(";")),
              Z = (ce) => {
                switch (ce) {
                  case "SCALAR":
                    return 1;
                  case "VEC2":
                    return 2;
                  case "VEC3":
                    return 3;
                  case "VEC4":
                    return 4;
                  case "MAT2":
                    return 4;
                  case "MAT3":
                    return 9;
                  case "MAT4":
                    return 16;
                  default:
                    return 3;
                }
              },
              J = (ce) => {
                switch (ce) {
                  case 5120:
                    return s.VSW;
                  case 5121:
                    return s.EUX;
                  case 5122:
                    return s.kF;
                  case 5123:
                    return s.rvO;
                  case 5124:
                    return s.uVx;
                  case 5125:
                    return s.Bz3;
                  case 5126:
                    return s.n$B;
                  default:
                    return 0;
                }
              },
              ve = (ce) => {
                switch (ce) {
                  case 5120:
                    return 1;
                  case 5121:
                    return 1;
                  case 5122:
                    return 2;
                  case 5123:
                    return 2;
                  case 5124:
                    return 4;
                  case 5125:
                    return 4;
                  case 5126:
                    return 4;
                  default:
                    return 0;
                }
              },
              _e = (ce) => {
                switch (ce) {
                  case 5120:
                    return Int8Array;
                  case 5121:
                    return Uint8Array;
                  case 5122:
                    return Int16Array;
                  case 5123:
                    return Uint16Array;
                  case 5124:
                    return Int32Array;
                  case 5125:
                    return Uint32Array;
                  case 5126:
                    return Float32Array;
                  default:
                    return null;
                }
              },
              L = {
                POSITION: s.JYe,
                NORMAL: s.XF6,
                TANGENT: s.h3u,
                COLOR_0: s.F8$,
                JOINTS_0: s.aVd,
                WEIGHTS_0: s.Hn_,
                TEXCOORD_0: s.slc,
                TEXCOORD_1: s.zEd,
                TEXCOORD_2: s.GHH,
                TEXCOORD_3: s.z5t,
                TEXCOORD_4: s.GWP,
                TEXCOORD_5: s.NdR,
                TEXCOORD_6: s.GBD,
                TEXCOORD_7: s.zZp,
              },
              ge = {
                [s.JYe]: 0,
                [s.XF6]: 1,
                [s.h3u]: 2,
                [s.F8$]: 3,
                [s.aVd]: 4,
                [s.Hn_]: 5,
                [s.slc]: 6,
                [s.zEd]: 7,
                [s.GHH]: 8,
                [s.z5t]: 9,
                [s.GWP]: 10,
                [s.NdR]: 11,
                [s.GBD]: 12,
                [s.zZp]: 13,
              },
              k = (ce) => {
                switch (ce) {
                  case s.VSW:
                    return (pe) => Math.max(pe / 127, -1);
                  case s.EUX:
                    return (pe) => pe / 255;
                  case s.kF:
                    return (pe) => Math.max(pe / 32767, -1);
                  case s.rvO:
                    return (pe) => pe / 65535;
                  default:
                    return (pe) => pe;
                }
              },
              j = (ce, pe, De) => {
                const fe = k(De),
                  Ze = pe.length;
                for (let Ne = 0; Ne < Ze; ++Ne) ce[Ne] = fe(pe[Ne]);
                return ce;
              },
              B = (ce, pe, De = !1) => {
                const fe = Z(ce.type),
                  Ze = _e(ce.componentType);
                if (!Ze) return null;
                let Ne;
                if (ce.sparse) {
                  const Ye = ce.sparse,
                    Ke = { count: Ye.count, type: "SCALAR" },
                    nt = B(Object.assign(Ke, Ye.indices), pe, !0),
                    ot = {
                      count: Ye.count,
                      type: ce.type,
                      componentType: ce.componentType,
                    },
                    ze = B(Object.assign(ot, Ye.values), pe, !0);
                  if (ce.hasOwnProperty("bufferView")) {
                    const et = {
                      bufferView: ce.bufferView,
                      byteOffset: ce.byteOffset,
                      componentType: ce.componentType,
                      count: ce.count,
                      type: ce.type,
                    };
                    Ne = B(et, pe, !0).slice();
                  } else Ne = new Ze(ce.count * fe);
                  for (let et = 0; et < Ye.count; ++et) {
                    const _t = nt[et];
                    for (let Qe = 0; Qe < fe; ++Qe)
                      Ne[_t * fe + Qe] = ze[et * fe + Qe];
                  }
                } else if (ce.hasOwnProperty("bufferView")) {
                  const Ye = pe[ce.bufferView];
                  if (De && Ye.hasOwnProperty("byteStride")) {
                    const Ke = fe * Ze.BYTES_PER_ELEMENT,
                      nt = new ArrayBuffer(ce.count * Ke),
                      ot = new Uint8Array(nt);
                    let ze = 0;
                    for (let et = 0; et < ce.count; ++et) {
                      let _t = (ce.byteOffset || 0) + et * Ye.byteStride;
                      for (let Qe = 0; Qe < Ke; ++Qe) ot[ze++] = Ye[_t++];
                    }
                    Ne = new Ze(nt);
                  } else
                    Ne = new Ze(
                      Ye.buffer,
                      Ye.byteOffset + (ce.byteOffset || 0),
                      ce.count * fe
                    );
                } else Ne = new Ze(ce.count * fe);
                return Ne;
              },
              $ = (ce, pe) => {
                const De = B(ce, pe, !0);
                if (De instanceof Float32Array || !ce.normalized) return De;
                const fe = new Float32Array(De.length);
                return j(fe, De, J(ce.componentType)), fe;
              },
              le = (ce) => {
                let pe = ce.min,
                  De = ce.max;
                if (!pe || !De) return null;
                if (ce.normalized) {
                  const fe = J(ce.componentType);
                  (pe = j([], pe, fe)), (De = j([], De, fe));
                }
                return new f.I(
                  new h.e(
                    (De[0] + pe[0]) * 0.5,
                    (De[1] + pe[1]) * 0.5,
                    (De[2] + pe[2]) * 0.5
                  ),
                  new h.e(
                    (De[0] - pe[0]) * 0.5,
                    (De[1] - pe[1]) * 0.5,
                    (De[2] - pe[2]) * 0.5
                  )
                );
              },
              O = (ce) => {
                if (!ce.hasOwnProperty("mode")) return s.Qpk;
                switch (ce.mode) {
                  case 0:
                    return s._AA;
                  case 1:
                    return s.EEU;
                  case 2:
                    return s.HsS;
                  case 3:
                    return s.PTM;
                  case 4:
                    return s.Qpk;
                  case 5:
                    return s.SF$;
                  case 6:
                    return s.zl$;
                  default:
                    return s.Qpk;
                }
              },
              Y = (ce) => {
                const pe = new Uint16Array(ce);
                for (let De = 0; De < ce; De++) pe[De] = De;
                return pe;
              },
              ne = (ce, pe) => {
                const De = ce[s.JYe];
                if (!De || De.components !== 3) return;
                let fe;
                if (De.size !== De.stride) {
                  const Ke = De.stride / s.sYG[De.type],
                    nt = new s.B8J[De.type](
                      De.buffer,
                      De.offset,
                      De.count * Ke
                    );
                  fe = new s.B8J[De.type](De.count * 3);
                  for (let ot = 0; ot < De.count; ++ot)
                    (fe[ot * 3 + 0] = nt[ot * Ke + 0]),
                      (fe[ot * 3 + 1] = nt[ot * Ke + 1]),
                      (fe[ot * 3 + 2] = nt[ot * Ke + 2]);
                } else
                  fe = new s.B8J[De.type](De.buffer, De.offset, De.count * 3);
                const Ze = De.count;
                pe || (pe = Y(Ze));
                const Ne = (0, g.Tj)(fe, pe),
                  Ye = new Float32Array(Ne.length);
                Ye.set(Ne),
                  (ce[s.XF6] = {
                    buffer: Ye.buffer,
                    size: 12,
                    offset: 0,
                    stride: 12,
                    count: Ze,
                    components: 3,
                    type: s.n$B,
                  });
              },
              de = (ce) => {
                let pe, De;
                const fe = [],
                  Ze = [],
                  Ne = [];
                for (pe = 0; pe < ce.format.elements.length; ++pe) {
                  const Ke = ce.format.elements[pe];
                  if (Ke.name === s.slc || Ke.name === s.zEd)
                    switch (Ke.dataType) {
                      case s.n$B:
                        fe.push({
                          offset: Ke.offset / 4 + 1,
                          stride: Ke.stride / 4,
                        });
                        break;
                      case s.rvO:
                        Ze.push({
                          offset: Ke.offset / 2 + 1,
                          stride: Ke.stride / 2,
                        });
                        break;
                      case s.EUX:
                        Ne.push({ offset: Ke.offset + 1, stride: Ke.stride });
                        break;
                    }
                }
                const Ye = (Ke, nt, ot) => {
                  const ze = new nt(ce.storage);
                  for (pe = 0; pe < Ke.length; ++pe) {
                    let et = Ke[pe].offset;
                    const _t = Ke[pe].stride;
                    for (De = 0; De < ce.numVertices; ++De)
                      (ze[et] = ot - ze[et]), (et += _t);
                  }
                };
                fe.length > 0 && Ye(fe, Float32Array, 1),
                  Ze.length > 0 && Ye(Ze, Uint16Array, 65535),
                  Ne.length > 0 && Ye(Ne, Uint8Array, 255);
              },
              re = (ce) => {
                const pe = (fe) => {
                    const Ze = [];
                    for (let Ne = 0; Ne < fe._levels.length; ++Ne) {
                      let Ye = [];
                      if (fe.cubemap)
                        for (let Ke = 0; Ke < 6; ++Ke)
                          Ye.push(fe._levels[Ne][Ke]);
                      else Ye = fe._levels[Ne];
                      Ze.push(Ye);
                    }
                    return Ze;
                  },
                  De = new n.g(ce.device, ce);
                return (De._levels = pe(ce)), De;
              },
              I = (ce) => {
                const pe = new G.V(
                  ce.name + "_clone",
                  ce.type,
                  ce.file,
                  ce.data,
                  ce.options
                );
                return (
                  (pe.loaded = !0),
                  (pe.resource = re(ce.resource)),
                  ce.registry.add(pe),
                  pe
                );
              },
              w = (ce, pe, De) => {
                const fe = pe[s.JYe];
                if (!fe) return null;
                const Ze = fe.count,
                  Ne = [];
                for (const gt in pe)
                  pe.hasOwnProperty(gt) &&
                    Ne.push({
                      semantic: gt,
                      components: pe[gt].components,
                      type: pe[gt].type,
                      normalize: !!pe[gt].normalize,
                    });
                Ne.sort((gt, Fe) => ge[gt.semantic] - ge[Fe.semantic]);
                let Ye, Ke, nt, ot, ze, et;
                const _t = new i.y(ce, Ne);
                let Qe = !0;
                for (Ye = 0; Ye < _t.elements.length; ++Ye)
                  if (
                    ((ze = _t.elements[Ye]),
                    (ot = pe[ze.name]),
                    (et = ot.offset - fe.offset),
                    ot.buffer !== fe.buffer ||
                      ot.stride !== ze.stride ||
                      ot.size !== ze.size ||
                      et !== ze.offset)
                  ) {
                    Qe = !1;
                    break;
                  }
                const lt = new o.R(ce, _t, Ze, s.y1K),
                  xt = lt.lock(),
                  Tt = new Uint32Array(xt);
                let ft;
                if (Qe)
                  (ft = new Uint32Array(
                    fe.buffer,
                    fe.offset,
                    (Ze * lt.format.size) / 4
                  )),
                    Tt.set(ft);
                else {
                  let gt, Fe;
                  for (Ye = 0; Ye < lt.format.elements.length; ++Ye) {
                    (ze = lt.format.elements[Ye]),
                      (gt = ze.stride / 4),
                      (ot = pe[ze.name]),
                      (Fe = ot.stride / 4),
                      (ft = new Uint32Array(
                        ot.buffer,
                        ot.offset,
                        (ot.count - 1) * Fe + (ot.size + 3) / 4
                      ));
                    let Qt = 0,
                      zt = ze.offset / 4;
                    const Lt = Math.floor((ot.size + 3) / 4);
                    for (Ke = 0; Ke < Ze; ++Ke) {
                      for (nt = 0; nt < Lt; ++nt) Tt[zt + nt] = ft[Qt + nt];
                      (Qt += Fe), (zt += gt);
                    }
                  }
                }
                return De && de(lt), lt.unlock(), lt;
              },
              N = (ce, pe, De, fe, Ze, Ne, Ye) => {
                const Ke = {},
                  nt = [];
                for (const et in pe)
                  pe.hasOwnProperty(et) &&
                    L.hasOwnProperty(et) &&
                    ((Ke[et] = pe[et]), nt.push(et + ":" + pe[et]));
                nt.sort();
                const ot = nt.join();
                let ze = Ye[ot];
                if (!ze) {
                  const et = {};
                  for (const _t in Ke) {
                    const Qe = fe[pe[_t]],
                      lt = B(Qe, Ze),
                      xt = Ze[Qe.bufferView],
                      Tt = L[_t],
                      ft = Z(Qe.type) * ve(Qe.componentType),
                      gt =
                        xt && xt.hasOwnProperty("byteStride")
                          ? xt.byteStride
                          : ft;
                    et[Tt] = {
                      buffer: lt.buffer,
                      size: ft,
                      offset: lt.byteOffset,
                      stride: gt,
                      count: Qe.count,
                      components: Z(Qe.type),
                      type: J(Qe.componentType),
                      normalize: Qe.normalized,
                    };
                  }
                  et.hasOwnProperty(s.XF6) || ne(et, De),
                    (ze = w(ce, et, Ne)),
                    (Ye[ot] = ze);
                }
                return ze;
              },
              W = (ce, pe, De, fe, Ze, Ne) => {
                let Ye, Ke, nt;
                const ot = pe.joints,
                  ze = ot.length,
                  et = [];
                if (pe.hasOwnProperty("inverseBindMatrices")) {
                  const xt = pe.inverseBindMatrices,
                    Tt = B(De[xt], fe, !0),
                    ft = [];
                  for (Ye = 0; Ye < ze; Ye++) {
                    for (Ke = 0; Ke < 16; Ke++) ft[Ke] = Tt[Ye * 16 + Ke];
                    (nt = new y.$()), nt.set(ft), et.push(nt);
                  }
                } else
                  for (Ye = 0; Ye < ze; Ye++) (nt = new y.$()), et.push(nt);
                const _t = [];
                for (Ye = 0; Ye < ze; Ye++) _t[Ye] = Ze[ot[Ye]].name;
                const Qe = _t.join("#");
                let lt = Ne.get(Qe);
                return lt || ((lt = new E.M(ce, et, _t)), Ne.set(Qe, lt)), lt;
              },
              he = (ce, pe, De, fe, Ze, Ne, Ye) => {
                var Ke;
                const nt = new v.e(ce);
                nt.aabb = le(De[pe.attributes.POSITION]);
                const ot = [];
                for (const [et, _t] of Object.entries(pe.attributes)) {
                  var ze;
                  const Qe = De[_t],
                    lt = L[et],
                    xt = J(Qe.componentType);
                  ot.push({
                    semantic: lt,
                    components: Z(Qe.type),
                    type: xt,
                    normalize:
                      (ze = Qe.normalized) != null
                        ? ze
                        : lt === s.F8$ && (xt === s.EUX || xt === s.rvO),
                  });
                }
                if (
                  (Ye.push(
                    new Promise((et, _t) => {
                      const Qe = pe.extensions.KHR_draco_mesh_compression;
                      (0, ie.s)(fe[Qe.bufferView].slice().buffer, (lt, xt) => {
                        if (lt) console.log(lt), _t(lt);
                        else {
                          var Tt;
                          const ft = {};
                          for (const [Bt, Nt] of Object.entries(Qe.attributes))
                            ft[L[Bt]] = xt.attributes.indexOf(Nt);
                          ot.sort(
                            (Bt, Nt) => ft[Bt.semantic] - ft[Nt.semantic]
                          ),
                            ((Tt = pe.attributes) != null && Tt.NORMAL) ||
                              ot.splice(1, 0, {
                                semantic: "NORMAL",
                                components: 3,
                                type: s.n$B,
                              });
                          const gt = new i.y(ce, ot),
                            Fe = xt.vertices.byteLength / gt.size,
                            Qt = Fe <= 65535 ? s.c02 : s.gpl,
                            zt = xt.indices.byteLength / (Fe <= 65535 ? 2 : 4),
                            Lt = new o.R(ce, gt, Fe, s.y1K, xt.vertices),
                            $t = new l.h(ce, Qt, zt, s.y1K, xt.indices);
                          (nt.vertexBuffer = Lt),
                            (nt.indexBuffer[0] = $t),
                            (nt.primitive[0].type = O(pe)),
                            (nt.primitive[0].base = 0),
                            (nt.primitive[0].count = $t ? zt : Fe),
                            (nt.primitive[0].indexed = !!$t),
                            et();
                        }
                      });
                    })
                  ),
                  pe != null &&
                    (Ke = pe.extensions) != null &&
                    Ke.KHR_materials_variants)
                ) {
                  const et = pe.extensions.KHR_materials_variants,
                    _t = {};
                  et.mappings.forEach((Qe) => {
                    Qe.variants.forEach((lt) => {
                      _t[lt] = Qe.material;
                    });
                  }),
                    (Ze[nt.id] = _t);
                }
                return (Ne[nt.id] = pe.material), nt;
              },
              ue = (ce, pe, De, fe, Ze, Ne, Ye, Ke, nt, ot) => {
                const ze = [];
                return (
                  pe.primitives.forEach((et) => {
                    var _t;
                    if (
                      (_t = et.extensions) != null &&
                      _t.KHR_draco_mesh_compression
                    )
                      ze.push(he(ce, et, De, fe, Ye, Ke, ot));
                    else {
                      let Qe = et.hasOwnProperty("indices")
                        ? B(De[et.indices], fe, !0)
                        : null;
                      const lt = N(ce, et.attributes, Qe, De, fe, Ze, Ne),
                        xt = O(et),
                        Tt = new v.e(ce);
                      if (
                        ((Tt.vertexBuffer = lt),
                        (Tt.primitive[0].type = xt),
                        (Tt.primitive[0].base = 0),
                        (Tt.primitive[0].indexed = Qe !== null),
                        Qe !== null)
                      ) {
                        let gt;
                        Qe instanceof Uint8Array
                          ? (gt = s.zYw)
                          : Qe instanceof Uint16Array
                          ? (gt = s.c02)
                          : (gt = s.gpl),
                          gt === s.gpl &&
                            !ce.extUintElement &&
                            ((gt = s.c02), (Qe = new Uint16Array(Qe))),
                          gt === s.zYw &&
                            ce.isWebGPU &&
                            ((gt = s.c02), (Qe = new Uint16Array(Qe)));
                        const Fe = new l.h(ce, gt, Qe.length, s.y1K, Qe);
                        (Tt.indexBuffer[0] = Fe),
                          (Tt.primitive[0].count = Qe.length);
                      } else Tt.primitive[0].count = lt.numVertices;
                      if (
                        et.hasOwnProperty("extensions") &&
                        et.extensions.hasOwnProperty("KHR_materials_variants")
                      ) {
                        const gt = et.extensions.KHR_materials_variants,
                          Fe = {};
                        gt.mappings.forEach((Qt) => {
                          Qt.variants.forEach((zt) => {
                            Fe[zt] = Qt.material;
                          });
                        }),
                          (Ye[Tt.id] = Fe);
                      }
                      Ke[Tt.id] = et.material;
                      let ft = De[et.attributes.POSITION];
                      if (((Tt.aabb = le(ft)), et.hasOwnProperty("targets"))) {
                        const gt = [];
                        et.targets.forEach((Fe, Qt) => {
                          const zt = {};
                          Fe.hasOwnProperty("POSITION") &&
                            ((ft = De[Fe.POSITION]),
                            (zt.deltaPositions = $(ft, fe)),
                            (zt.deltaPositionsType = s.n$B),
                            (zt.aabb = le(ft))),
                            Fe.hasOwnProperty("NORMAL") &&
                              ((ft = De[Fe.NORMAL]),
                              (zt.deltaNormals = $(ft, fe)),
                              (zt.deltaNormalsType = s.n$B)),
                            pe.hasOwnProperty("extras") &&
                            pe.extras.hasOwnProperty("targetNames")
                              ? (zt.name = pe.extras.targetNames[Qt])
                              : (zt.name = Qt.toString(10)),
                            pe.hasOwnProperty("weights") &&
                              (zt.defaultWeight = pe.weights[Qt]),
                            (zt.preserveData = nt.morphPreserveData),
                            gt.push(new m.M(zt));
                        }),
                          (Tt.morph = new _.T(gt, ce, {
                            preferHighPrecision: nt.morphPreferHighPrecision,
                          }));
                      }
                      ze.push(Tt);
                    }
                  }),
                  ze
                );
              },
              ye = (ce, pe, De) => {
                var fe;
                let Ze;
                const Ne = ce.texCoord;
                if (Ne)
                  for (Ze = 0; Ze < De.length; ++Ze) pe[De[Ze] + "MapUv"] = Ne;
                const Ye = [0, 0],
                  Ke = [1, 1],
                  nt =
                    (fe = ce.extensions) == null
                      ? void 0
                      : fe.KHR_texture_transform;
                if (nt) {
                  const ot = nt.offset || Ye,
                    ze = nt.scale || Ke,
                    et = nt.rotation ? -nt.rotation * c.D.RAD_TO_DEG : 0,
                    _t = new d.Z(ze[0], ze[1]),
                    Qe = new d.Z(ot[0], 1 - ze[1] - ot[1]);
                  for (Ze = 0; Ze < De.length; ++Ze)
                    (pe[`${De[Ze]}MapTiling`] = _t),
                      (pe[`${De[Ze]}MapOffset`] = Qe),
                      (pe[`${De[Ze]}MapRotation`] = et);
                }
              },
              Oe = (ce, pe, De) => {
                let fe, Ze;
                if (
                  (ce.hasOwnProperty("diffuseFactor")
                    ? ((fe = ce.diffuseFactor),
                      pe.diffuse.set(
                        Math.pow(fe[0], 1 / 2.2),
                        Math.pow(fe[1], 1 / 2.2),
                        Math.pow(fe[2], 1 / 2.2)
                      ),
                      (pe.opacity = fe[3]))
                    : (pe.diffuse.set(1, 1, 1), (pe.opacity = 1)),
                  ce.hasOwnProperty("diffuseTexture"))
                ) {
                  const Ne = ce.diffuseTexture;
                  (Ze = De[Ne.index]),
                    (pe.diffuseMap = Ze),
                    (pe.diffuseMapChannel = "rgb"),
                    (pe.opacityMap = Ze),
                    (pe.opacityMapChannel = "a"),
                    ye(Ne, pe, ["diffuse", "opacity"]);
                }
                if (
                  ((pe.useMetalness = !1),
                  ce.hasOwnProperty("specularFactor")
                    ? ((fe = ce.specularFactor),
                      pe.specular.set(
                        Math.pow(fe[0], 1 / 2.2),
                        Math.pow(fe[1], 1 / 2.2),
                        Math.pow(fe[2], 1 / 2.2)
                      ))
                    : pe.specular.set(1, 1, 1),
                  ce.hasOwnProperty("glossinessFactor")
                    ? (pe.gloss = ce.glossinessFactor)
                    : (pe.gloss = 1),
                  ce.hasOwnProperty("specularGlossinessTexture"))
                ) {
                  const Ne = ce.specularGlossinessTexture;
                  (pe.specularEncoding = "srgb"),
                    (pe.specularMap = pe.glossMap = De[Ne.index]),
                    (pe.specularMapChannel = "rgb"),
                    (pe.glossMapChannel = "a"),
                    ye(Ne, pe, ["gloss", "metalness"]);
                }
              },
              Ae = (ce, pe, De) => {
                if (
                  (ce.hasOwnProperty("clearcoatFactor")
                    ? (pe.clearCoat = ce.clearcoatFactor * 0.25)
                    : (pe.clearCoat = 0),
                  ce.hasOwnProperty("clearcoatTexture"))
                ) {
                  const fe = ce.clearcoatTexture;
                  (pe.clearCoatMap = De[fe.index]),
                    (pe.clearCoatMapChannel = "r"),
                    ye(fe, pe, ["clearCoat"]);
                }
                if (
                  (ce.hasOwnProperty("clearcoatRoughnessFactor")
                    ? (pe.clearCoatGloss = ce.clearcoatRoughnessFactor)
                    : (pe.clearCoatGloss = 0),
                  ce.hasOwnProperty("clearcoatRoughnessTexture"))
                ) {
                  const fe = ce.clearcoatRoughnessTexture;
                  (pe.clearCoatGlossMap = De[fe.index]),
                    (pe.clearCoatGlossMapChannel = "g"),
                    ye(fe, pe, ["clearCoatGloss"]);
                }
                if (ce.hasOwnProperty("clearcoatNormalTexture")) {
                  const fe = ce.clearcoatNormalTexture;
                  (pe.clearCoatNormalMap = De[fe.index]),
                    ye(fe, pe, ["clearCoatNormal"]),
                    fe.hasOwnProperty("scale") &&
                      (pe.clearCoatBumpiness = fe.scale);
                }
                pe.clearCoatGlossInvert = !0;
              },
              ke = (ce, pe, De) => {
                (pe.useLighting = !1),
                  pe.emissive.copy(pe.diffuse),
                  (pe.emissiveTint = pe.diffuseTint),
                  (pe.emissiveMap = pe.diffuseMap),
                  (pe.emissiveMapUv = pe.diffuseMapUv),
                  pe.emissiveMapTiling.copy(pe.diffuseMapTiling),
                  pe.emissiveMapOffset.copy(pe.diffuseMapOffset),
                  (pe.emissiveMapRotation = pe.diffuseMapRotation),
                  (pe.emissiveMapChannel = pe.diffuseMapChannel),
                  (pe.emissiveVertexColor = pe.diffuseVertexColor),
                  (pe.emissiveVertexColorChannel =
                    pe.diffuseVertexColorChannel),
                  (pe.useLighting = !1),
                  (pe.useSkybox = !1),
                  pe.diffuse.set(0, 0, 0),
                  (pe.diffuseTint = !1),
                  (pe.diffuseMap = null),
                  (pe.diffuseVertexColor = !1);
              },
              Ue = (ce, pe, De) => {
                if (
                  ((pe.useMetalnessSpecularColor = !0),
                  ce.hasOwnProperty("specularColorTexture") &&
                    ((pe.specularEncoding = "srgb"),
                    (pe.specularMap = De[ce.specularColorTexture.index]),
                    (pe.specularMapChannel = "rgb"),
                    ye(ce.specularColorTexture, pe, ["specular"])),
                  ce.hasOwnProperty("specularColorFactor"))
                ) {
                  const fe = ce.specularColorFactor;
                  pe.specular.set(
                    Math.pow(fe[0], 1 / 2.2),
                    Math.pow(fe[1], 1 / 2.2),
                    Math.pow(fe[2], 1 / 2.2)
                  );
                } else pe.specular.set(1, 1, 1);
                ce.hasOwnProperty("specularFactor")
                  ? (pe.specularityFactor = ce.specularFactor)
                  : (pe.specularityFactor = 1),
                  ce.hasOwnProperty("specularTexture") &&
                    ((pe.specularityFactorMapChannel = "a"),
                    (pe.specularityFactorMap = De[ce.specularTexture.index]),
                    ye(ce.specularTexture, pe, ["specularityFactor"]));
              },
              Ge = (ce, pe, De) => {
                ce.hasOwnProperty("ior") && (pe.refractionIndex = 1 / ce.ior);
              },
              ht = (ce, pe, De) => {
                (pe.blendType = t.i9),
                  (pe.useDynamicRefraction = !0),
                  ce.hasOwnProperty("transmissionFactor") &&
                    (pe.refraction = ce.transmissionFactor),
                  ce.hasOwnProperty("transmissionTexture") &&
                    ((pe.refractionMapChannel = "r"),
                    (pe.refractionMap = De[ce.transmissionTexture.index]),
                    ye(ce.transmissionTexture, pe, ["refraction"]));
              },
              me = (ce, pe, De) => {
                if (
                  ((pe.useSheen = !0), ce.hasOwnProperty("sheenColorFactor"))
                ) {
                  const fe = ce.sheenColorFactor;
                  pe.sheen.set(
                    Math.pow(fe[0], 1 / 2.2),
                    Math.pow(fe[1], 1 / 2.2),
                    Math.pow(fe[2], 1 / 2.2)
                  );
                } else pe.sheen.set(1, 1, 1);
                ce.hasOwnProperty("sheenColorTexture") &&
                  ((pe.sheenMap = De[ce.sheenColorTexture.index]),
                  (pe.sheenEncoding = "srgb"),
                  ye(ce.sheenColorTexture, pe, ["sheen"])),
                  ce.hasOwnProperty("sheenRoughnessFactor")
                    ? (pe.sheenGloss = ce.sheenRoughnessFactor)
                    : (pe.sheenGloss = 0),
                  ce.hasOwnProperty("sheenRoughnessTexture") &&
                    ((pe.sheenGlossMap = De[ce.sheenRoughnessTexture.index]),
                    (pe.sheenGlossMapChannel = "a"),
                    ye(ce.sheenRoughnessTexture, pe, ["sheenGloss"])),
                  (pe.sheenGlossInvert = !0);
              },
              z = (ce, pe, De) => {
                if (
                  ((pe.blendType = t.i9),
                  (pe.useDynamicRefraction = !0),
                  ce.hasOwnProperty("thicknessFactor") &&
                    (pe.thickness = ce.thicknessFactor),
                  ce.hasOwnProperty("thicknessTexture") &&
                    ((pe.thicknessMap = De[ce.thicknessTexture.index]),
                    (pe.thicknessMapChannel = "g"),
                    ye(ce.thicknessTexture, pe, ["thickness"])),
                  ce.hasOwnProperty("attenuationDistance") &&
                    (pe.attenuationDistance = ce.attenuationDistance),
                  ce.hasOwnProperty("attenuationColor"))
                ) {
                  const fe = ce.attenuationColor;
                  pe.attenuation.set(
                    Math.pow(fe[0], 1 / 2.2),
                    Math.pow(fe[1], 1 / 2.2),
                    Math.pow(fe[2], 1 / 2.2)
                  );
                }
              },
              K = (ce, pe, De) => {
                ce.hasOwnProperty("emissiveStrength") &&
                  (pe.emissiveIntensity = ce.emissiveStrength);
              },
              Te = (ce, pe, De) => {
                (pe.useIridescence = !0),
                  ce.hasOwnProperty("iridescenceFactor") &&
                    (pe.iridescence = ce.iridescenceFactor),
                  ce.hasOwnProperty("iridescenceTexture") &&
                    ((pe.iridescenceMapChannel = "r"),
                    (pe.iridescenceMap = De[ce.iridescenceTexture.index]),
                    ye(ce.iridescenceTexture, pe, ["iridescence"])),
                  ce.hasOwnProperty("iridescenceIor") &&
                    (pe.iridescenceRefractionIndex = ce.iridescenceIor),
                  ce.hasOwnProperty("iridescenceThicknessMinimum") &&
                    (pe.iridescenceThicknessMin =
                      ce.iridescenceThicknessMinimum),
                  ce.hasOwnProperty("iridescenceThicknessMaximum") &&
                    (pe.iridescenceThicknessMax =
                      ce.iridescenceThicknessMaximum),
                  ce.hasOwnProperty("iridescenceThicknessTexture") &&
                    ((pe.iridescenceThicknessMapChannel = "g"),
                    (pe.iridescenceThicknessMap =
                      De[ce.iridescenceThicknessTexture.index]),
                    ye(ce.iridescenceThicknessTexture, pe, [
                      "iridescenceThickness",
                    ]));
              },
              H = (ce, pe, De) => {
                const fe = new M.F();
                (fe.occludeSpecular = t.aP),
                  (fe.diffuseTint = !0),
                  (fe.diffuseVertexColor = !0),
                  (fe.specularTint = !0),
                  (fe.specularVertexColor = !0),
                  ce.hasOwnProperty("name") && (fe.name = ce.name);
                let Ze, Ne;
                if (ce.hasOwnProperty("pbrMetallicRoughness")) {
                  const Ke = ce.pbrMetallicRoughness;
                  if (
                    (Ke.hasOwnProperty("baseColorFactor")
                      ? ((Ze = Ke.baseColorFactor),
                        fe.diffuse.set(
                          Math.pow(Ze[0], 1 / 2.2),
                          Math.pow(Ze[1], 1 / 2.2),
                          Math.pow(Ze[2], 1 / 2.2)
                        ),
                        (fe.opacity = Ze[3]))
                      : (fe.diffuse.set(1, 1, 1), (fe.opacity = 1)),
                    Ke.hasOwnProperty("baseColorTexture"))
                  ) {
                    const nt = Ke.baseColorTexture;
                    (Ne = pe[nt.index]),
                      (fe.diffuseMap = Ne),
                      (fe.diffuseMapChannel = "rgb"),
                      (fe.opacityMap = Ne),
                      (fe.opacityMapChannel = "a"),
                      ye(nt, fe, ["diffuse", "opacity"]);
                  }
                  if (
                    ((fe.useMetalness = !0),
                    fe.specular.set(1, 1, 1),
                    Ke.hasOwnProperty("metallicFactor")
                      ? (fe.metalness = Ke.metallicFactor)
                      : (fe.metalness = 1),
                    Ke.hasOwnProperty("roughnessFactor")
                      ? (fe.gloss = Ke.roughnessFactor)
                      : (fe.gloss = 1),
                    (fe.glossInvert = !0),
                    Ke.hasOwnProperty("metallicRoughnessTexture"))
                  ) {
                    const nt = Ke.metallicRoughnessTexture;
                    (fe.metalnessMap = fe.glossMap = pe[nt.index]),
                      (fe.metalnessMapChannel = "b"),
                      (fe.glossMapChannel = "g"),
                      ye(nt, fe, ["gloss", "metalness"]);
                  }
                }
                if (ce.hasOwnProperty("normalTexture")) {
                  const Ke = ce.normalTexture;
                  (fe.normalMap = pe[Ke.index]),
                    ye(Ke, fe, ["normal"]),
                    Ke.hasOwnProperty("scale") && (fe.bumpiness = Ke.scale);
                }
                if (ce.hasOwnProperty("occlusionTexture")) {
                  const Ke = ce.occlusionTexture;
                  (fe.aoMap = pe[Ke.index]),
                    (fe.aoMapChannel = "r"),
                    ye(Ke, fe, ["ao"]);
                }
                if (
                  (ce.hasOwnProperty("emissiveFactor")
                    ? ((Ze = ce.emissiveFactor),
                      fe.emissive.set(
                        Math.pow(Ze[0], 1 / 2.2),
                        Math.pow(Ze[1], 1 / 2.2),
                        Math.pow(Ze[2], 1 / 2.2)
                      ),
                      (fe.emissiveTint = !0))
                    : (fe.emissive.set(0, 0, 0), (fe.emissiveTint = !1)),
                  ce.hasOwnProperty("emissiveTexture"))
                ) {
                  const Ke = ce.emissiveTexture;
                  (fe.emissiveMap = pe[Ke.index]), ye(Ke, fe, ["emissive"]);
                }
                if (ce.hasOwnProperty("alphaMode"))
                  switch (ce.alphaMode) {
                    case "MASK":
                      (fe.blendType = t.Rj),
                        ce.hasOwnProperty("alphaCutoff")
                          ? (fe.alphaTest = ce.alphaCutoff)
                          : (fe.alphaTest = 0.5);
                      break;
                    case "BLEND":
                      (fe.blendType = t.i9), (fe.depthWrite = !1);
                      break;
                    default:
                    case "OPAQUE":
                      fe.blendType = t.Rj;
                      break;
                  }
                else fe.blendType = t.Rj;
                ce.hasOwnProperty("doubleSided")
                  ? ((fe.twoSidedLighting = ce.doubleSided),
                    (fe.cull = ce.doubleSided ? s.pLF : s.K1r))
                  : ((fe.twoSidedLighting = !1), (fe.cull = s.K1r));
                const Ye = {
                  KHR_materials_clearcoat: Ae,
                  KHR_materials_emissive_strength: K,
                  KHR_materials_ior: Ge,
                  KHR_materials_iridescence: Te,
                  KHR_materials_pbrSpecularGlossiness: Oe,
                  KHR_materials_sheen: me,
                  KHR_materials_specular: Ue,
                  KHR_materials_transmission: ht,
                  KHR_materials_unlit: ke,
                  KHR_materials_volume: z,
                };
                if (ce.hasOwnProperty("extensions"))
                  for (const Ke in ce.extensions) {
                    const nt = Ye[Ke];
                    nt !== void 0 && nt(ce.extensions[Ke], fe, pe);
                  }
                return fe.update(), fe;
              },
              q = (ce, pe, De, fe, Ze, Ne, Ye) => {
                const Ke = (Bt) => new b.C(Z(Bt.type), $(Bt, fe)),
                  nt = { STEP: P.Un, LINEAR: P.tF, CUBICSPLINE: P.yQ },
                  ot = {},
                  ze = {},
                  et = {};
                let _t = 1,
                  Qe;
                for (Qe = 0; Qe < ce.samplers.length; ++Qe) {
                  const Bt = ce.samplers[Qe];
                  ot.hasOwnProperty(Bt.input) ||
                    (ot[Bt.input] = Ke(De[Bt.input])),
                    ze.hasOwnProperty(Bt.output) ||
                      (ze[Bt.output] = Ke(De[Bt.output]));
                  const Nt =
                      Bt.hasOwnProperty("interpolation") &&
                      nt.hasOwnProperty(Bt.interpolation)
                        ? nt[Bt.interpolation]
                        : P.tF,
                    es = {
                      paths: [],
                      input: Bt.input,
                      output: Bt.output,
                      interpolation: Nt,
                    };
                  et[Qe] = es;
                }
                const lt = [],
                  xt = {
                    translation: "localPosition",
                    rotation: "localRotation",
                    scale: "localScale",
                  },
                  Tt = (Bt) => {
                    const Nt = [];
                    for (; Bt; ) Nt.unshift(Bt.name), (Bt = Bt.parent);
                    return Nt;
                  },
                  ft = (Bt, Nt, es) => {
                    const kt = ze[Bt.output];
                    if (!kt) return;
                    let ds;
                    if (Ne && Ne[Nt.mesh]) {
                      const fs = Ne[Nt.mesh];
                      fs.hasOwnProperty("extras") &&
                        fs.extras.hasOwnProperty("targetNames") &&
                        (ds = fs.extras.targetNames);
                    }
                    const os = kt.data,
                      ls = os.length / ot[Bt.input].data.length,
                      Ps = os.length / ls,
                      us = Ps * 4,
                      Xe = new ArrayBuffer(us * ls);
                    for (let fs = 0; fs < ls; fs++) {
                      var vs;
                      const bs = new Float32Array(Xe, us * fs, Ps);
                      for (let Os = 0; Os < Ps; Os++) bs[Os] = os[Os * ls + fs];
                      const Ms = new b.C(1, bs),
                        Ts =
                          (vs = ds) != null && vs[fs] ? `name.${ds[fs]}` : fs;
                      ze[-_t] = Ms;
                      const Js = {
                        paths: [
                          {
                            entityPath: es,
                            component: "graph",
                            propertyPath: [`weight.${Ts}`],
                          },
                        ],
                        input: Bt.input,
                        output: -_t,
                        interpolation: Bt.interpolation,
                      };
                      _t++, (et[`morphCurve-${Qe}-${fs}`] = Js);
                    }
                  };
                for (Qe = 0; Qe < ce.channels.length; ++Qe) {
                  const Bt = ce.channels[Qe],
                    Nt = Bt.target,
                    es = et[Bt.sampler],
                    kt = Ze[Nt.node],
                    ds = Ye[Nt.node],
                    os = Tt(kt);
                  Nt.path.startsWith("weights")
                    ? (ft(es, ds, os), (et[Bt.sampler].morphCurve = !0))
                    : es.paths.push({
                        entityPath: os,
                        component: "graph",
                        propertyPath: [xt[Nt.path]],
                      });
                }
                const gt = [],
                  Fe = [],
                  Qt = [];
                for (const Bt in ot) gt.push(ot[Bt]), (ot[Bt] = gt.length - 1);
                for (const Bt in ze) Fe.push(ze[Bt]), (ze[Bt] = Fe.length - 1);
                for (const Bt in et) {
                  const Nt = et[Bt];
                  Nt.morphCurve ||
                    (Qt.push(
                      new F.v(
                        Nt.paths,
                        ot[Nt.input],
                        ze[Nt.output],
                        Nt.interpolation
                      )
                    ),
                    Nt.paths.length > 0 &&
                      Nt.paths[0].propertyPath[0] === "localRotation" &&
                      Nt.interpolation !== P.yQ &&
                      lt.push(Qt[Qt.length - 1].output));
                }
                lt.sort();
                let zt = null,
                  Lt;
                for (Qe = 0; Qe < lt.length; ++Qe) {
                  const Bt = lt[Qe];
                  if (Qe === 0 || Bt !== zt) {
                    if (((Lt = Fe[Bt]), Lt.components === 4)) {
                      const Nt = Lt.data,
                        es = Nt.length - 4;
                      for (let kt = 0; kt < es; kt += 4)
                        Nt[kt + 0] * Nt[kt + 4] +
                          Nt[kt + 1] * Nt[kt + 5] +
                          Nt[kt + 2] * Nt[kt + 6] +
                          Nt[kt + 3] * Nt[kt + 7] <
                          0 &&
                          ((Nt[kt + 4] *= -1),
                          (Nt[kt + 5] *= -1),
                          (Nt[kt + 6] *= -1),
                          (Nt[kt + 7] *= -1));
                    }
                    zt = Bt;
                  }
                }
                let $t = 0;
                for (Qe = 0; Qe < gt.length; Qe++)
                  (Lt = gt[Qe]._data),
                    ($t = Math.max(
                      $t,
                      Lt.length === 0 ? 0 : Lt[Lt.length - 1]
                    ));
                return new D.z(
                  ce.hasOwnProperty("name") ? ce.name : "animation_" + pe,
                  $t,
                  gt,
                  Fe,
                  Qt
                );
              },
              se = new y.$(),
              Ce = new h.e(),
              we = (ce, pe) => {
                const De = new r.t();
                if (
                  (ce.hasOwnProperty("name") && ce.name.length > 0
                    ? (De.name = ce.name)
                    : (De.name = "node_" + pe),
                  ce.hasOwnProperty("matrix") &&
                    (se.data.set(ce.matrix),
                    se.getTranslation(Ce),
                    De.setLocalPosition(Ce),
                    se.getEulerAngles(Ce),
                    De.setLocalEulerAngles(Ce),
                    se.getScale(Ce),
                    De.setLocalScale(Ce)),
                  ce.hasOwnProperty("rotation"))
                ) {
                  const fe = ce.rotation;
                  De.setLocalRotation(fe[0], fe[1], fe[2], fe[3]);
                }
                if (ce.hasOwnProperty("translation")) {
                  const fe = ce.translation;
                  De.setLocalPosition(fe[0], fe[1], fe[2]);
                }
                if (ce.hasOwnProperty("scale")) {
                  const fe = ce.scale;
                  De.setLocalScale(fe[0], fe[1], fe[2]);
                }
                return De;
              },
              Me = (ce, pe) => {
                const De = ce.type === "orthographic" ? t.RD : t.$J,
                  fe = De === t.RD ? ce.orthographic : ce.perspective,
                  Ze = {
                    enabled: !1,
                    projection: De,
                    nearClip: fe.znear,
                    aspectRatioMode: t.LF,
                  };
                fe.zfar && (Ze.farClip = fe.zfar),
                  De === t.RD
                    ? ((Ze.orthoHeight = 0.5 * fe.ymag),
                      fe.ymag &&
                        ((Ze.aspectRatioMode = t.E5),
                        (Ze.aspectRatio = fe.xmag / fe.ymag)))
                    : ((Ze.fov = fe.yfov * c.D.RAD_TO_DEG),
                      fe.aspectRatio &&
                        ((Ze.aspectRatioMode = t.E5),
                        (Ze.aspectRatio = fe.aspectRatio)));
                const Ne = new R.w(ce.name);
                return Ne.addComponent("camera", Ze), Ne;
              },
              Ie = (ce, pe) => {
                const De = {
                  enabled: !1,
                  type: ce.type === "point" ? "omni" : ce.type,
                  color: ce.hasOwnProperty("color")
                    ? new x.Q(ce.color)
                    : x.Q.WHITE,
                  range: ce.hasOwnProperty("range") ? ce.range : 9999,
                  falloffMode: t.Nk,
                  intensity: ce.hasOwnProperty("intensity")
                    ? c.D.clamp(ce.intensity, 0, 2)
                    : 1,
                };
                ce.hasOwnProperty("spot") &&
                  ((De.innerConeAngle = ce.spot.hasOwnProperty("innerConeAngle")
                    ? ce.spot.innerConeAngle * c.D.RAD_TO_DEG
                    : 0),
                  (De.outerConeAngle = ce.spot.hasOwnProperty("outerConeAngle")
                    ? ce.spot.outerConeAngle * c.D.RAD_TO_DEG
                    : Math.PI / 4)),
                  ce.hasOwnProperty("intensity") &&
                    (De.luminance =
                      ce.intensity *
                      u.v.getLightUnitConversion(
                        u.A[De.type],
                        De.outerConeAngle,
                        De.innerConeAngle
                      ));
                const fe = new R.w(pe.name);
                return (
                  fe.rotateLocal(90, 0, 0), fe.addComponent("light", De), fe
                );
              },
              Le = (ce, pe, De, fe) => {
                if (!pe.hasOwnProperty("skins") || pe.skins.length === 0)
                  return [];
                const Ze = new Map();
                return pe.skins.map((Ne) =>
                  W(ce, Ne, pe.accessors, fe, De, Ze)
                );
              },
              tt = (ce, pe, De, fe, Ze) => {
                var Ne, Ye, Ke;
                const nt = {},
                  ot = {},
                  ze = {},
                  et = [];
                return {
                  meshes:
                    !Ze.skipMeshes &&
                    (pe == null || (Ne = pe.meshes) == null
                      ? void 0
                      : Ne.length) &&
                    (pe == null || (Ye = pe.accessors) == null
                      ? void 0
                      : Ye.length) &&
                    (pe == null || (Ke = pe.bufferViews) == null
                      ? void 0
                      : Ke.length)
                      ? pe.meshes.map((lt) =>
                          ue(ce, lt, pe.accessors, De, fe, nt, ot, ze, Ze, et)
                        )
                      : [],
                  meshVariants: ot,
                  meshDefaultMaterials: ze,
                  promises: et,
                };
              },
              vt = (ce, pe, De, fe) => {
                var Ze, Ne, Ye, Ke;
                if (
                  !ce.hasOwnProperty("materials") ||
                  ce.materials.length === 0
                )
                  return [];
                const nt =
                    De == null || (Ze = De.material) == null
                      ? void 0
                      : Ze.preprocess,
                  ot =
                    (Ne =
                      De == null || (Ye = De.material) == null
                        ? void 0
                        : Ye.process) != null
                      ? Ne
                      : H,
                  ze =
                    De == null || (Ke = De.material) == null
                      ? void 0
                      : Ke.postprocess;
                return ce.materials.map((et) => {
                  nt && nt(et);
                  const _t = ot(et, pe, fe);
                  return ze && ze(et, _t), _t;
                });
              },
              it = (ce) => {
                if (
                  !ce.hasOwnProperty("extensions") ||
                  !ce.extensions.hasOwnProperty("KHR_materials_variants")
                )
                  return null;
                const pe = ce.extensions.KHR_materials_variants.variants,
                  De = {};
                for (let fe = 0; fe < pe.length; fe++) De[pe[fe].name] = fe;
                return De;
              },
              At = (ce, pe, De, fe) => {
                var Ze, Ne;
                if (
                  !ce.hasOwnProperty("animations") ||
                  ce.animations.length === 0
                )
                  return [];
                const Ye =
                    fe == null || (Ze = fe.animation) == null
                      ? void 0
                      : Ze.preprocess,
                  Ke =
                    fe == null || (Ne = fe.animation) == null
                      ? void 0
                      : Ne.postprocess;
                return ce.animations.map((nt, ot) => {
                  Ye && Ye(nt);
                  const ze = q(
                    nt,
                    ot,
                    ce.accessors,
                    De,
                    pe,
                    ce.meshes,
                    ce.nodes
                  );
                  return Ke && Ke(nt, ze), ze;
                });
              },
              Rt = (ce, pe) => {
                var De, fe, Ze, Ne;
                if (!ce.hasOwnProperty("nodes") || ce.nodes.length === 0)
                  return [];
                const Ye =
                    pe == null || (De = pe.node) == null
                      ? void 0
                      : De.preprocess,
                  Ke =
                    (fe =
                      pe == null || (Ze = pe.node) == null
                        ? void 0
                        : Ze.process) != null
                      ? fe
                      : we,
                  nt =
                    pe == null || (Ne = pe.node) == null
                      ? void 0
                      : Ne.postprocess,
                  ot = ce.nodes.map((ze, et) => {
                    Ye && Ye(ze);
                    const _t = Ke(ze, et);
                    return nt && nt(ze, _t), _t;
                  });
                for (let ze = 0; ze < ce.nodes.length; ++ze) {
                  const et = ce.nodes[ze];
                  if (et.hasOwnProperty("children")) {
                    const _t = ot[ze],
                      Qe = {};
                    for (let lt = 0; lt < et.children.length; ++lt) {
                      const xt = ot[et.children[lt]];
                      xt.parent ||
                        (Qe.hasOwnProperty(xt.name)
                          ? (xt.name += Qe[xt.name]++)
                          : (Qe[xt.name] = 1),
                        _t.addChild(xt));
                    }
                  }
                }
                return ot;
              },
              Ft = (ce, pe) => {
                var De;
                const fe = [],
                  Ze = ce.scenes.length;
                if (
                  Ze === 1 &&
                  ((De = ce.scenes[0].nodes) == null ? void 0 : De.length) === 1
                ) {
                  const Ne = ce.scenes[0].nodes[0];
                  fe.push(pe[Ne]);
                } else
                  for (let Ne = 0; Ne < Ze; Ne++) {
                    const Ye = ce.scenes[Ne];
                    if (Ye.nodes) {
                      const Ke = new r.t(Ye.name);
                      for (let nt = 0; nt < Ye.nodes.length; nt++) {
                        const ot = pe[Ye.nodes[nt]];
                        Ke.addChild(ot);
                      }
                      fe.push(Ke);
                    }
                  }
                return fe;
              },
              ut = (ce, pe, De) => {
                let fe = null;
                if (
                  ce.hasOwnProperty("nodes") &&
                  ce.hasOwnProperty("cameras") &&
                  ce.cameras.length > 0
                ) {
                  var Ze, Ne, Ye, Ke;
                  const nt =
                      De == null || (Ze = De.camera) == null
                        ? void 0
                        : Ze.preprocess,
                    ot =
                      (Ne =
                        De == null || (Ye = De.camera) == null
                          ? void 0
                          : Ye.process) != null
                        ? Ne
                        : Me,
                    ze =
                      De == null || (Ke = De.camera) == null
                        ? void 0
                        : Ke.postprocess;
                  ce.nodes.forEach((et, _t) => {
                    if (et.hasOwnProperty("camera")) {
                      const Qe = ce.cameras[et.camera];
                      if (Qe) {
                        nt && nt(Qe);
                        const lt = ot(Qe, pe[_t]);
                        ze && ze(Qe, lt),
                          lt && (fe || (fe = new Map()), fe.set(et, lt));
                      }
                    }
                  });
                }
                return fe;
              },
              Pt = (ce, pe, De) => {
                let fe = null;
                if (
                  ce.hasOwnProperty("nodes") &&
                  ce.hasOwnProperty("extensions") &&
                  ce.extensions.hasOwnProperty("KHR_lights_punctual") &&
                  ce.extensions.KHR_lights_punctual.hasOwnProperty("lights")
                ) {
                  const nt = ce.extensions.KHR_lights_punctual.lights;
                  if (nt.length) {
                    var Ze, Ne, Ye, Ke;
                    const ot =
                        De == null || (Ze = De.light) == null
                          ? void 0
                          : Ze.preprocess,
                      ze =
                        (Ne =
                          De == null || (Ye = De.light) == null
                            ? void 0
                            : Ye.process) != null
                          ? Ne
                          : Ie,
                      et =
                        De == null || (Ke = De.light) == null
                          ? void 0
                          : Ke.postprocess;
                    ce.nodes.forEach((_t, Qe) => {
                      if (
                        _t.hasOwnProperty("extensions") &&
                        _t.extensions.hasOwnProperty("KHR_lights_punctual") &&
                        _t.extensions.KHR_lights_punctual.hasOwnProperty(
                          "light"
                        )
                      ) {
                        const lt = _t.extensions.KHR_lights_punctual.light,
                          xt = nt[lt];
                        if (xt) {
                          ot && ot(xt);
                          const Tt = ze(xt, pe[Qe]);
                          et && et(xt, Tt),
                            Tt && (fe || (fe = new Map()), fe.set(_t, Tt));
                        }
                      }
                    });
                  }
                }
                return fe;
              },
              bt = (ce, pe, De) => {
                ce.nodes.forEach((fe) => {
                  fe.hasOwnProperty("mesh") &&
                    fe.hasOwnProperty("skin") &&
                    pe[fe.mesh].meshes.forEach((Ne) => {
                      Ne.skin = De[fe.skin];
                    });
                });
              },
              Zt = (ce, pe, De, fe, Ze) =>
                Kt(fl, null, function* () {
                  var Ne, Ye;
                  const Ke =
                      Ze == null || (Ne = Ze.global) == null
                        ? void 0
                        : Ne.preprocess,
                    nt =
                      Ze == null || (Ye = Ze.global) == null
                        ? void 0
                        : Ye.postprocess;
                  Ke && Ke(pe);
                  const ot = pe.asset && pe.asset.generator === "PlayCanvas",
                    ze = Rt(pe, Ze),
                    et = Ft(pe, ze),
                    _t = Pt(pe, ze, Ze),
                    Qe = ut(pe, ze, Ze),
                    lt = it(pe),
                    xt = yield Promise.all(De),
                    {
                      meshes: Tt,
                      meshVariants: ft,
                      meshDefaultMaterials: gt,
                      promises: Fe,
                    } = tt(ce, pe, xt, ot, Ze),
                    Qt = At(pe, ze, xt, Ze),
                    zt = yield Promise.all(fe),
                    Lt = zt.map((kt) => kt.resource),
                    $t = vt(pe, Lt, Ze, ot),
                    Bt = Le(ce, pe, ze, xt),
                    Nt = [];
                  for (let kt = 0; kt < Tt.length; kt++)
                    (Nt[kt] = new T.d()), (Nt[kt].meshes = Tt[kt]);
                  bt(pe, Nt, Bt);
                  const es = new Q();
                  return (
                    (es.gltf = pe),
                    (es.nodes = ze),
                    (es.scenes = et),
                    (es.animations = Qt),
                    (es.textures = zt),
                    (es.materials = $t),
                    (es.variants = lt),
                    (es.meshVariants = ft),
                    (es.meshDefaultMaterials = gt),
                    (es.renders = Nt),
                    (es.skins = Bt),
                    (es.lights = _t),
                    (es.cameras = Qe),
                    nt && nt(pe, es),
                    yield Promise.all(Fe),
                    es
                  );
                }),
              Xt = (ce, pe) => {
                const De = (Ne, Ye) => {
                    switch (Ne) {
                      case 9728:
                        return s.uhC;
                      case 9729:
                        return s.DrA;
                      case 9984:
                        return s.GLw;
                      case 9985:
                        return s.reG;
                      case 9986:
                        return s.hs2;
                      case 9987:
                        return s.qn_;
                      default:
                        return Ye;
                    }
                  },
                  fe = (Ne, Ye) => {
                    switch (Ne) {
                      case 33071:
                        return s.vq6;
                      case 33648:
                        return s.qoY;
                      case 10497:
                        return s.x3I;
                      default:
                        return Ye;
                    }
                  };
                if (ce) {
                  var Ze;
                  (pe = (Ze = pe) != null ? Ze : {}),
                    (ce.minFilter = De(pe.minFilter, s.qn_)),
                    (ce.magFilter = De(pe.magFilter, s.DrA)),
                    (ce.addressU = fe(pe.wrapS, s.x3I)),
                    (ce.addressV = fe(pe.wrapT, s.x3I));
                }
              };
            let yt = 0;
            const Pe = (ce, pe, De, fe, Ze) => {
                var Ne, Ye, Ke;
                if (!ce.images || ce.images.length === 0) return [];
                const nt =
                    Ze == null || (Ne = Ze.image) == null
                      ? void 0
                      : Ne.preprocess,
                  ot =
                    Ze == null || (Ye = Ze.image) == null
                      ? void 0
                      : Ye.processAsync,
                  ze =
                    Ze == null || (Ke = Ze.image) == null
                      ? void 0
                      : Ke.postprocess,
                  et = {
                    "image/png": "png",
                    "image/jpeg": "jpg",
                    "image/basis": "basis",
                    "image/ktx": "ktx",
                    "image/ktx2": "ktx2",
                    "image/vnd-ms.dds": "dds",
                  },
                  _t = (Qe, lt, xt, Tt, ft) =>
                    new Promise((gt, Fe) => {
                      const Qt = (zt) => {
                        const Lt = (Qe.name || "gltf-texture") + "-" + yt++,
                          $t = { url: lt || Lt };
                        if ((zt && ($t.contents = zt.slice(0).buffer), Tt)) {
                          const Nt = et[Tt];
                          Nt && ($t.filename = $t.url + "." + Nt);
                        }
                        const Bt = new G.V(Lt, "texture", $t, null, ft);
                        Bt.on("load", (Nt) => gt(Nt)),
                          Bt.on("error", (Nt) => Fe(Nt)),
                          fe.add(Bt),
                          fe.load(Bt);
                      };
                      xt ? xt.then((zt) => Qt(zt)) : Qt(null);
                    });
                return ce.images.map((Qe, lt) => {
                  nt && nt(Qe);
                  let xt;
                  return (
                    ot
                      ? (xt = new Promise((Tt, ft) => {
                          ot(Qe, (gt, Fe) => {
                            gt ? ft(gt) : Tt(Fe);
                          });
                        }))
                      : (xt = new Promise((Tt) => {
                          Tt(null);
                        })),
                    (xt = xt.then(
                      (Tt) =>
                        Tt ||
                        (Qe.hasOwnProperty("uri")
                          ? te(Qe.uri)
                            ? _t(Qe, Qe.uri, null, ae(Qe.uri), null)
                            : _t(
                                Qe,
                                X._3.test(Qe.uri)
                                  ? Qe.uri
                                  : A.A.join(De, Qe.uri),
                                null,
                                null,
                                { crossOrigin: "anonymous" }
                              )
                          : Qe.hasOwnProperty("bufferView") &&
                            Qe.hasOwnProperty("mimeType")
                          ? _t(Qe, null, pe[Qe.bufferView], Qe.mimeType, null)
                          : Promise.reject(
                              new Error(
                                `Invalid image found in gltf (neither uri or bufferView found). index=${lt}`
                              )
                            ))
                    )),
                    ze && (xt = xt.then((Tt) => (ze(Qe, Tt), Tt))),
                    xt
                  );
                });
              },
              $e = (ce, pe, De) => {
                var fe, Ze, Ne, Ye, Ke;
                if (
                  !(ce != null && (fe = ce.images) != null && fe.length) ||
                  !(ce != null && (Ze = ce.textures) != null && Ze.length)
                )
                  return [];
                const nt =
                    De == null || (Ne = De.texture) == null
                      ? void 0
                      : Ne.preprocess,
                  ot =
                    De == null || (Ye = De.texture) == null
                      ? void 0
                      : Ye.processAsync,
                  ze =
                    De == null || (Ke = De.texture) == null
                      ? void 0
                      : Ke.postprocess,
                  et = new Set();
                return ce.textures.map((_t) => {
                  nt && nt(_t);
                  let Qe;
                  return (
                    ot
                      ? (Qe = new Promise((lt, xt) => {
                          ot(_t, ce.images, (Tt, ft) => {
                            Tt ? xt(Tt) : lt(ft);
                          });
                        }))
                      : (Qe = new Promise((lt) => {
                          lt(null);
                        })),
                    (Qe = Qe.then((lt) => {
                      var xt, Tt, ft, gt, Fe;
                      lt =
                        (xt =
                          (Tt =
                            (ft = lt) != null
                              ? ft
                              : _t == null ||
                                (gt = _t.extensions) == null ||
                                (gt = gt.KHR_texture_basisu) == null
                              ? void 0
                              : gt.source) != null
                            ? Tt
                            : _t == null ||
                              (Fe = _t.extensions) == null ||
                              (Fe = Fe.EXT_texture_webp) == null
                            ? void 0
                            : Fe.source) != null
                          ? xt
                          : _t.source;
                      const Qt = et.has(lt);
                      return (
                        et.add(lt),
                        pe[lt].then((zt) => {
                          var Lt;
                          const $t = Qt ? I(zt) : zt;
                          return (
                            Xt(
                              $t.resource,
                              ((Lt = ce.samplers) != null ? Lt : [])[_t.sampler]
                            ),
                            $t
                          );
                        })
                      );
                    })),
                    ze && (Qe = Qe.then((lt) => (ze(_t, lt), lt))),
                    Qe
                  );
                });
              },
              Je = (ce, pe, De, fe) => {
                var Ze, Ne, Ye;
                if (!ce.buffers || ce.buffers.length === 0) return [];
                const Ke =
                    fe == null || (Ze = fe.buffer) == null
                      ? void 0
                      : Ze.preprocess,
                  nt =
                    fe == null || (Ne = fe.buffer) == null
                      ? void 0
                      : Ne.processAsync,
                  ot =
                    fe == null || (Ye = fe.buffer) == null
                      ? void 0
                      : Ye.postprocess;
                return ce.buffers.map((ze, et) => {
                  Ke && Ke(ze);
                  let _t;
                  return (
                    nt
                      ? (_t = new Promise((Qe, lt) => {
                          nt(ze, (xt, Tt) => {
                            xt ? lt(xt) : Qe(Tt);
                          });
                        }))
                      : (_t = new Promise((Qe) => {
                          Qe(null);
                        })),
                    (_t = _t.then((Qe) => {
                      if (Qe) return Qe;
                      if (ze.hasOwnProperty("uri")) {
                        if (te(ze.uri)) {
                          const lt = atob(ze.uri.split(",")[1]),
                            xt = new Uint8Array(lt.length);
                          for (let Tt = 0; Tt < lt.length; Tt++)
                            xt[Tt] = lt.charCodeAt(Tt);
                          return xt;
                        }
                        return new Promise((lt, xt) => {
                          e.L.get(
                            X._3.test(ze.uri) ? ze.uri : A.A.join(De, ze.uri),
                            {
                              cache: !0,
                              responseType: "arraybuffer",
                              retry: !1,
                            },
                            (Tt, ft) => {
                              Tt ? xt(Tt) : lt(new Uint8Array(ft));
                            }
                          );
                        });
                      }
                      return pe;
                    })),
                    ot && (_t = _t.then((Qe) => (ot(ce.buffers[et], Qe), Qe))),
                    _t
                  );
                });
              },
              rt = (ce, pe) => {
                const fe = JSON.parse(
                  ((Ze) => {
                    if (typeof TextDecoder != "undefined")
                      return new TextDecoder().decode(Ze);
                    let Ne = "";
                    for (let Ye = 0; Ye < Ze.length; Ye++)
                      Ne += String.fromCharCode(Ze[Ye]);
                    return decodeURIComponent(escape(Ne));
                  })(ce)
                );
                if (
                  fe.asset &&
                  fe.asset.version &&
                  parseFloat(fe.asset.version) < 2
                ) {
                  pe(
                    `Invalid gltf version. Expected version 2.0 or above but found version '${fe.asset.version}'.`
                  );
                  return;
                }
                pe(null, fe);
              },
              ct = (ce, pe) => {
                const De =
                    ce instanceof ArrayBuffer
                      ? new DataView(ce)
                      : new DataView(ce.buffer, ce.byteOffset, ce.byteLength),
                  fe = De.getUint32(0, !0),
                  Ze = De.getUint32(4, !0),
                  Ne = De.getUint32(8, !0);
                if (fe !== 1179937895) {
                  pe(
                    "Invalid magic number found in glb header. Expected 0x46546C67, found 0x" +
                      fe.toString(16)
                  );
                  return;
                }
                if (Ze !== 2) {
                  pe(
                    "Invalid version number found in glb header. Expected 2, found " +
                      Ze
                  );
                  return;
                }
                if (Ne <= 0 || Ne > De.byteLength) {
                  pe("Invalid length found in glb header. Found " + Ne);
                  return;
                }
                const Ye = [];
                let Ke = 12;
                for (; Ke < Ne; ) {
                  const nt = De.getUint32(Ke, !0);
                  Ke + nt + 8 > De.byteLength &&
                    pe(`Invalid chunk length found in glb. Found ${nt}`);
                  const ot = De.getUint32(Ke + 4, !0),
                    ze = new Uint8Array(De.buffer, De.byteOffset + Ke + 8, nt);
                  Ye.push({ length: nt, type: ot, data: ze }), (Ke += nt + 8);
                }
                if (Ye.length !== 1 && Ye.length !== 2) {
                  pe("Invalid number of chunks found in glb file.");
                  return;
                }
                if (Ye[0].type !== 1313821514) {
                  pe(
                    `Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${Ye[0].type.toString(
                      16
                    )}`
                  );
                  return;
                }
                if (Ye.length > 1 && Ye[1].type !== 5130562) {
                  pe(
                    `Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${Ye[1].type.toString(
                      16
                    )}`
                  );
                  return;
                }
                pe(null, {
                  gltfChunk: Ye[0].data,
                  binaryChunk: Ye.length === 2 ? Ye[1].data : null,
                });
              },
              Ve = (ce, pe, De) => {
                const fe = () => {
                  const Ze = new Uint8Array(pe);
                  return (
                    Ze[0] === 103 &&
                    Ze[1] === 108 &&
                    Ze[2] === 84 &&
                    Ze[3] === 70
                  );
                };
                (ce && ce.toLowerCase().endsWith(".glb")) || fe()
                  ? ct(pe, De)
                  : De(null, { gltfChunk: pe, binaryChunk: null });
              },
              wt = (ce, pe, De) => {
                var fe, Ze, Ne, Ye;
                const Ke = [],
                  nt =
                    De == null || (fe = De.bufferView) == null
                      ? void 0
                      : fe.preprocess,
                  ot =
                    De == null || (Ze = De.bufferView) == null
                      ? void 0
                      : Ze.processAsync,
                  ze =
                    De == null || (Ne = De.bufferView) == null
                      ? void 0
                      : Ne.postprocess;
                if (!((Ye = ce.bufferViews) != null && Ye.length)) return Ke;
                for (let et = 0; et < ce.bufferViews.length; ++et) {
                  const _t = ce.bufferViews[et];
                  nt && nt(_t);
                  let Qe;
                  ot
                    ? (Qe = new Promise((lt, xt) => {
                        ot(_t, pe, (Tt, ft) => {
                          Tt ? xt(Tt) : lt(ft);
                        });
                      }))
                    : (Qe = new Promise((lt) => {
                        lt(null);
                      })),
                    (Qe = Qe.then(
                      (lt) =>
                        lt ||
                        pe[_t.buffer].then(
                          (xt) =>
                            new Uint8Array(
                              xt.buffer,
                              xt.byteOffset + (_t.byteOffset || 0),
                              _t.byteLength
                            )
                        )
                    )),
                    _t.hasOwnProperty("byteStride") &&
                      (Qe = Qe.then(
                        (lt) => ((lt.byteStride = _t.byteStride), lt)
                      )),
                    ze && (Qe = Qe.then((lt) => (ze(_t, lt), lt))),
                    Ke.push(Qe);
                }
                return Ke;
              };
            class at {
              static parse(pe, De, fe, Ze, Ne, Ye, Ke) {
                Ve(pe, fe, (nt, ot) => {
                  if (nt) {
                    Ke(nt);
                    return;
                  }
                  rt(ot.gltfChunk, (ze, et) => {
                    if (ze) {
                      Ke(ze);
                      return;
                    }
                    const _t = Je(et, ot.binaryChunk, De, Ye),
                      Qe = wt(et, _t, Ye),
                      lt = Pe(et, Qe, De, Ne, Ye),
                      xt = $e(et, lt, Ye);
                    Zt(Ze, et, Qe, xt, Ye)
                      .then((Tt) => Ke(null, Tt))
                      .catch((Tt) => Ke(Tt));
                  });
                });
              }
              static createDefaultMaterial() {
                return H({ name: "defaultGlbMaterial" }, []);
              }
            }
          },
          461: (xe, V, a) => {
            "use strict";
            a.d(V, { m: () => i });
            var A = a(4751),
              x = a(5227),
              y = a(7994),
              c = a(7481),
              d = a(1208),
              h = a(7915),
              f = a(9391),
              s = a(1369),
              l = a(1630),
              n = a(6679);
            class o {
              constructor() {
                (this.removeInvalid = !0),
                  (this.valid = !0),
                  (this.enumValidators = {
                    occludeSpecular: this._createEnumValidator([
                      f.Av,
                      f.aP,
                      f.Nt,
                    ]),
                    cull: this._createEnumValidator([
                      l.pLF,
                      l.K1r,
                      l.CWw,
                      l.AQ1,
                    ]),
                    blendType: this._createEnumValidator([
                      f.Ni,
                      f.dc,
                      f.i9,
                      f.Rj,
                      f.bY,
                      f.$M,
                      f.HG,
                      f.LL,
                      f.rZ,
                      f.Z7,
                      f.HV,
                    ]),
                    depthFunc: this._createEnumValidator([
                      l.gaK,
                      l.v1A,
                      l.sTv,
                      l.fsA,
                      l.q3J,
                      l.v_N,
                      l.wGs,
                      l.vpx,
                    ]),
                    shadingModel: this._createEnumValidator([f.Tp, f.SB]),
                  });
              }
              setInvalid(t, r) {
                (this.valid = !1), this.removeInvalid && delete r[t];
              }
              validate(t) {
                const r = n.lY,
                  u = n.PQ,
                  v = t.mappingFormat === "path";
                for (const _ in t) {
                  const m = r[_];
                  if (!m) {
                    u[_] ? delete t[_] : (this.valid = !1);
                    continue;
                  }
                  if (m.startsWith("enum")) {
                    const g = m.split(":")[1];
                    this.enumValidators[g] &&
                      (this.enumValidators[g](t[_]) || this.setInvalid(_, t));
                  } else if (m === "number")
                    typeof t[_] != "number" && this.setInvalid(_, t);
                  else if (m === "boolean")
                    typeof t[_] != "boolean" && this.setInvalid(_, t);
                  else if (m === "string")
                    typeof t[_] != "string" && this.setInvalid(_, t);
                  else if (m === "vec2")
                    (t[_] instanceof Array && t[_].length === 2) ||
                      this.setInvalid(_, t);
                  else if (m === "rgb")
                    (t[_] instanceof Array && t[_].length === 3) ||
                      this.setInvalid(_, t);
                  else if (m === "texture")
                    v
                      ? typeof t[_] == "string" ||
                        t[_] === null ||
                        t[_] instanceof d.g ||
                        this.setInvalid(_, t)
                      : typeof t[_] == "number" ||
                        t[_] === null ||
                        t[_] instanceof d.g ||
                        this.setInvalid(_, t);
                  else if (m === "boundingbox")
                    (t[_].center &&
                      t[_].center instanceof Array &&
                      t[_].center.length === 3) ||
                      this.setInvalid(_, t),
                      (t[_].halfExtents &&
                        t[_].halfExtents instanceof Array &&
                        t[_].halfExtents.length === 3) ||
                        this.setInvalid(_, t);
                  else if (m === "cubemap")
                    typeof t[_] == "number" ||
                      t[_] === null ||
                      t[_] === void 0 ||
                      (t[_] instanceof d.g && t[_].cubemap) ||
                      this.setInvalid(_, t);
                  else if (m === "chunks") {
                    const g = Object.keys(t[_]);
                    for (let T = 0; T < g.length; T++)
                      typeof t[_][g[T]] != "string" &&
                        this.setInvalid(g[T], t[_]);
                  } else console.error("Unknown material type: " + m);
                }
                return (t.validated = !0), this.valid;
              }
              _createEnumValidator(t) {
                return function (r) {
                  return t.indexOf(r) >= 0;
                };
              }
            }
            class i {
              constructor() {
                this._validator = null;
              }
              parse(t) {
                const r = this.migrate(t),
                  u = this._validate(r),
                  v = new s.F();
                return this.initialize(v, u), v;
              }
              initialize(t, r) {
                r.validated || (r = this._validate(r)),
                  r.chunks && (t.chunks = (0, A._)({}, r.chunks));
                for (const u in r) {
                  const v = n.lY[u],
                    _ = r[u];
                  if (v === "vec2") t[u] = new y.Z(_[0], _[1]);
                  else if (v === "rgb") t[u] = new x.Q(_[0], _[1], _[2]);
                  else if (v === "texture")
                    _ instanceof d.g
                      ? (t[u] = _)
                      : (t[u] instanceof d.g &&
                          typeof _ == "number" &&
                          _ > 0) ||
                        (t[u] = null);
                  else if (v === "cubemap")
                    _ instanceof d.g
                      ? (t[u] = _)
                      : (t[u] instanceof d.g &&
                          typeof _ == "number" &&
                          _ > 0) ||
                        (t[u] = null),
                      u === "cubeMap" && !_ && (t.prefilteredCubemaps = null);
                  else if (v === "boundingbox") {
                    const m = new c.e(_.center[0], _.center[1], _.center[2]),
                      g = new c.e(
                        _.halfExtents[0],
                        _.halfExtents[1],
                        _.halfExtents[2]
                      );
                    t[u] = new h.I(m, g);
                  } else t[u] = r[u];
                }
                t.update();
              }
              migrate(t) {
                t.shadingModel === void 0 &&
                  (t.shader === "blinn"
                    ? (t.shadingModel = f.SB)
                    : (t.shadingModel = f.Tp)),
                  t.shader && delete t.shader,
                  t.mapping_format &&
                    ((t.mappingFormat = t.mapping_format),
                    delete t.mapping_format);
                let r;
                const u = [
                  ["bumpMapFactor", "bumpiness"],
                  ["aoUvSet", "aoMapUv"],
                  ["aoMapVertexColor", "aoVertexColor"],
                  ["diffuseMapVertexColor", "diffuseVertexColor"],
                  ["emissiveMapVertexColor", "emissiveVertexColor"],
                  ["specularMapVertexColor", "specularVertexColor"],
                  ["metalnessMapVertexColor", "metalnessVertexColor"],
                  ["opacityMapVertexColor", "opacityVertexColor"],
                  ["glossMapVertexColor", "glossVertexColor"],
                  ["lightMapVertexColor", "lightVertexColor"],
                  ["diffuseMapTint", "diffuseTint"],
                  ["specularMapTint", "specularTint"],
                  ["emissiveMapTint", "emissiveTint"],
                  ["metalnessMapTint", "metalnessTint"],
                  ["clearCoatGlossiness", "clearCoatGloss"],
                ];
                for (r = 0; r < u.length; r++) {
                  const _ = u[r][0],
                    m = u[r][1];
                  t[_] !== void 0 &&
                    (t[m] === void 0 && (t[m] = t[_]), delete t[_]);
                }
                const v = ["fresnelFactor", "shadowSampleType"];
                for (r = 0; r < v.length; r++) {
                  const _ = v[r];
                  t.hasOwnProperty(_) && delete t[_];
                }
                return t;
              }
              _validate(t) {
                return (
                  t.validated ||
                    (this._validator || (this._validator = new o()),
                    this._validator.validate(t)),
                  t
                );
              }
            }
          },
          8158: (xe, V, a) => {
            "use strict";
            a.d(V, { q: () => c });
            var A = a(371);
            const x = {
              setCompressedPRS: function (d, h, f) {
                const s = f.singleVecs;
                let l, n;
                const o = h.___1;
                o || ((l = f.tripleVecs), (n = h.___2));
                let i = o ? o[0] : l[n];
                d.setLocalPosition(s[i], s[i + 1], s[i + 2]),
                  (i = o ? o[1] : l[n + 1]),
                  d.setLocalEulerAngles(s[i], s[i + 1], s[i + 2]),
                  (i = o ? o[2] : l[n + 2]),
                  d.setLocalScale(s[i], s[i + 1], s[i + 2]);
              },
              oneCharToKey: function (d, h) {
                const f = d.charCodeAt(0) - h.fieldFirstCode;
                return h.fieldArray[f];
              },
              multCharToKey: function (d, h) {
                let f = 0;
                for (let s = 0; s < d.length; s++)
                  f = f * h.fieldCodeBase + d.charCodeAt(s) - h.fieldFirstCode;
                return h.fieldArray[f];
              },
            };
            class y {
              constructor(h, f) {
                (this._node = h), (this._data = f);
              }
              run() {
                const h = Object.prototype.toString.call(this._node);
                return (
                  h === "[object Object]"
                    ? this._handleMap()
                    : h === "[object Array]"
                    ? this._handleArray()
                    : (this._result = this._node),
                  this._result
                );
              }
              _handleMap() {
                (this._result = {}),
                  Object.keys(this._node).forEach(this._handleKey, this);
              }
              _handleKey(h) {
                let f = h;
                const s = h.length;
                s === 1
                  ? (f = x.oneCharToKey(h, this._data))
                  : s === 2 && (f = x.multCharToKey(h, this._data)),
                  (this._result[f] = new y(this._node[h], this._data).run());
              }
              _handleArray() {
                (this._result = []),
                  this._node.forEach(this._handleArElt, this);
              }
              _handleArElt(h) {
                const f = new y(h, this._data).run();
                this._result.push(f);
              }
            }
            class c {
              constructor(h, f) {
                (this._app = h), (this._isTemplate = f);
              }
              parse(h) {
                const f = {};
                let s = null;
                const l = h.compressedFormat;
                l &&
                  !h.entDecompressed &&
                  ((h.entDecompressed = !0),
                  (h.entities = new y(h.entities, l).run()));
                for (const n in h.entities) {
                  const o = h.entities[n],
                    i = this._createEntity(o, l);
                  (f[n] = i), o.parent === null && (s = i);
                }
                for (const n in h.entities) {
                  const o = f[n],
                    i = h.entities[n].children,
                    e = i.length;
                  for (let t = 0; t < e; t++) {
                    const r = f[i[t]];
                    r && o.addChild(r);
                  }
                }
                return this._openComponentData(s, h.entities), s;
              }
              _createEntity(h, f) {
                var s;
                const l = new A.w(h.name, this._app);
                if (
                  (l.setGuid(h.resource_id),
                  this._setPosRotScale(l, h, f),
                  (l._enabled = (s = h.enabled) != null ? s : !0),
                  this._isTemplate
                    ? (l._template = !0)
                    : (l._enabledInHierarchy = l._enabled),
                  (l.template = h.template),
                  h.tags)
                )
                  for (let n = 0; n < h.tags.length; n++) l.tags.add(h.tags[n]);
                return (
                  h.labels &&
                    h.labels.forEach(function (n) {
                      l.addLabel(n);
                    }),
                  l
                );
              }
              _setPosRotScale(h, f, s) {
                if (s) x.setCompressedPRS(h, f, s);
                else {
                  const l = f.position,
                    n = f.rotation,
                    o = f.scale;
                  h.setLocalPosition(l[0], l[1], l[2]),
                    h.setLocalEulerAngles(n[0], n[1], n[2]),
                    h.setLocalScale(o[0], o[1], o[2]);
                }
              }
              _openComponentData(h, f) {
                const s = this._app.systems.list;
                let l = s.length;
                const n = f[h.getGuid()];
                for (let i = 0; i < l; i++) {
                  const e = s[i],
                    t = n.components[e.id];
                  t && e.addComponent(h, t);
                }
                l = n.children.length;
                const o = h._children;
                for (let i = 0; i < l; i++)
                  o[i] && (o[i] = this._openComponentData(o[i], f));
                return h;
              }
            }
          },
          7258: (xe, V, a) => {
            "use strict";
            a.d(V, { j: () => A });
            class A {
              constructor(y, c) {
                (this.name = void 0),
                  (this.url = void 0),
                  (this.data = null),
                  (this._loading = !1),
                  (this._onLoadedCallbacks = []),
                  (this.name = y),
                  (this.url = c);
              }
              get loaded() {
                return !!this.data;
              }
              get loading() {
                return this._loading;
              }
            }
          },
          8576: (xe, V, a) => {
            "use strict";
            a.d(V, { C: () => c });
            var A = a(1870),
              x = a(148),
              y = a(7258);
            class c {
              constructor(h) {
                (this._app = void 0),
                  (this._list = []),
                  (this._index = {}),
                  (this._urlIndex = {}),
                  (this._app = h);
              }
              destroy() {
                this._app = null;
              }
              list() {
                return this._list;
              }
              add(h, f) {
                if (this._index.hasOwnProperty(h)) return !1;
                const s = new y.j(h, f),
                  l = this._list.push(s);
                return (
                  (this._index[s.name] = l - 1),
                  (this._urlIndex[s.url] = l - 1),
                  !0
                );
              }
              find(h) {
                return this._index.hasOwnProperty(h)
                  ? this._list[this._index[h]]
                  : null;
              }
              findByUrl(h) {
                return this._urlIndex.hasOwnProperty(h)
                  ? this._list[this._urlIndex[h]]
                  : null;
              }
              remove(h) {
                if (this._index.hasOwnProperty(h)) {
                  const f = this._index[h];
                  let s = this._list[f];
                  delete this._urlIndex[s.url],
                    delete this._index[h],
                    this._list.splice(f, 1);
                  for (let l = 0; l < this._list.length; l++)
                    (s = this._list[l]),
                      (this._index[s.name] = l),
                      (this._urlIndex[s.url] = l);
                }
              }
              _loadSceneData(h, f, s) {
                const l = this._app;
                let n = h;
                if (
                  (typeof h == "string" &&
                    (h =
                      this.findByUrl(n) ||
                      this.find(n) ||
                      new y.j("Untitled", n)),
                  (n = h.url),
                  !n)
                ) {
                  s("Cannot find scene to load");
                  return;
                }
                if (h.loaded) {
                  s(null, h);
                  return;
                }
                l.assets &&
                  l.assets.prefix &&
                  !x._3.test(n) &&
                  (n = A.A.join(l.assets.prefix, n)),
                  h._onLoadedCallbacks.push(s),
                  h._loading ||
                    l.loader.getHandler("hierarchy").load(n, (i, e) => {
                      (h.data = e), (h._loading = !1);
                      for (let t = 0; t < h._onLoadedCallbacks.length; t++)
                        h._onLoadedCallbacks[t](i, h);
                      f || (h.data = null), (h._onLoadedCallbacks.length = 0);
                    }),
                  (h._loading = !0);
              }
              loadSceneData(h, f) {
                this._loadSceneData(h, !0, f);
              }
              unloadSceneData(h) {
                typeof h == "string" && (h = this.findByUrl(h)),
                  h && (h.data = null);
              }
              _loadSceneHierarchy(h, f, s) {
                this._loadSceneData(h, !1, (l, n) => {
                  if (l) {
                    s && s(l);
                    return;
                  }
                  f && f(n);
                  const o = this._app,
                    i = () => {
                      const e = o.loader.getHandler("hierarchy");
                      o.systems.script.preloading = !0;
                      const t = e.open(n.url, n.data);
                      (o.systems.script.preloading = !1),
                        o.loader.clearCache(n.url, "hierarchy"),
                        o.root.addChild(t),
                        o.systems.fire("initialize", t),
                        o.systems.fire("postInitialize", t),
                        o.systems.fire("postPostInitialize", t),
                        s && s(null, t);
                    };
                  o._preloadScripts(n.data, i);
                });
              }
              loadSceneHierarchy(h, f) {
                this._loadSceneHierarchy(h, null, f);
              }
              loadSceneSettings(h, f) {
                this._loadSceneData(h, !1, (s, l) => {
                  s
                    ? f && f(s)
                    : (this._app.applySceneSettings(l.data.settings),
                      f && f(null));
                });
              }
              changeScene(h, f) {
                const s = this._app,
                  l = (n) => {
                    const { children: o } = s.root;
                    for (; o.length; ) o[0].destroy();
                    s.applySceneSettings(n.data.settings);
                  };
                this._loadSceneHierarchy(h, l, f);
              }
              loadScene(h, f) {
                const s = this._app,
                  l = s.loader.getHandler("scene");
                s.assets &&
                  s.assets.prefix &&
                  !x._3.test(h) &&
                  (h = A.A.join(s.assets.prefix, h)),
                  l.load(h, (n, o) => {
                    if (n) f && f(n);
                    else {
                      const i = () => {
                        s.systems.script.preloading = !0;
                        const e = l.open(h, o),
                          t = this.findByUrl(h);
                        t && !t.loaded && (t.data = o),
                          (s.systems.script.preloading = !1),
                          s.loader.clearCache(h, "scene"),
                          s.loader.patch(
                            { resource: e, type: "scene" },
                            s.assets
                          ),
                          s.root.addChild(e.root),
                          s.systems.rigidbody &&
                            typeof Ammo != "undefined" &&
                            s.systems.rigidbody.gravity.set(
                              e._gravity.x,
                              e._gravity.y,
                              e._gravity.z
                            ),
                          f && f(null, e);
                      };
                      s._preloadScripts(o, i);
                    }
                  });
              }
            }
          },
          4595: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => h });
            var A = a(9048),
              x = a(4530),
              y = a(3113);
            let c = !1,
              d = !1;
            const h = {
              app: null,
              create: function (f, s) {
                if (!c) return;
                const l = s(h.app);
                (l._pcScriptName = f),
                  y.j.push(l, c),
                  this.fire("created", f, s);
              },
              attribute: function (f, s, l, n) {},
              createLoadingScreen: function (f) {
                if (d) return;
                d = !0;
                const s = (0, x.D)();
                f(s);
              },
            };
            Object.defineProperty(h, "legacy", {
              get: function () {
                return c;
              },
              set: function (f) {
                c = f;
              },
            }),
              A.A.attach(h);
          },
          897: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $x: () => A,
              Wx: () => y,
              ZP: () => c,
              k5: () => x,
              qK: () => d,
            });
            const A = "initialize",
              x = "postInitialize",
              y = "update",
              c = "postUpdate",
              d = "swap";
          },
          6087: (xe, V, a) => {
            "use strict";
            a.d(V, { x: () => i });
            var A = a(5227),
              x = a(5567),
              y = a(2358),
              c = a(7994),
              d = a(7481),
              h = a(5596),
              f = a(3035),
              s = a(3953);
            const l = ["x", "y", "z", "w"],
              n = [void 0, void 0, c.Z, d.e, h.Z];
            function o(e, t, r, u) {
              switch (t.type) {
                case "boolean":
                  return !!r;
                case "number":
                  if (typeof r == "number") return r;
                  if (typeof r == "string") {
                    const v = parseInt(r, 10);
                    return isNaN(v) ? null : v;
                  } else if (typeof r == "boolean") return 0 + r;
                  return null;
                case "json": {
                  const v = {};
                  if (Array.isArray(t.schema)) {
                    (!r || typeof r != "object") && (r = {});
                    for (let _ = 0; _ < t.schema.length; _++) {
                      const m = t.schema[_];
                      if (m.name)
                        if (m.array) {
                          v[m.name] = [];
                          const g = Array.isArray(r[m.name]) ? r[m.name] : [];
                          for (let T = 0; T < g.length; T++)
                            v[m.name].push(o(e, m, g[T]));
                        } else {
                          const g = r.hasOwnProperty(m.name)
                            ? r[m.name]
                            : m.default;
                          v[m.name] = o(e, m, g);
                        }
                    }
                  }
                  return v;
                }
                case "asset":
                  return r instanceof s.V
                    ? r
                    : typeof r == "number"
                    ? e.assets.get(r) || null
                    : (typeof r == "string" && e.assets.get(parseInt(r, 10))) ||
                      null;
                case "entity":
                  return r instanceof f.t
                    ? r
                    : typeof r == "string"
                    ? e.getEntityFromIndex(r)
                    : null;
                case "rgb":
                case "rgba":
                  if (r instanceof A.Q)
                    return u instanceof A.Q ? (u.copy(r), u) : r.clone();
                  if (r instanceof Array && r.length >= 3 && r.length <= 4) {
                    for (let v = 0; v < r.length; v++)
                      if (typeof r[v] != "number") return null;
                    return (
                      u || (u = new A.Q()),
                      (u.r = r[0]),
                      (u.g = r[1]),
                      (u.b = r[2]),
                      (u.a = r.length === 3 ? 1 : r[3]),
                      u
                    );
                  } else if (
                    typeof r == "string" &&
                    /#([0-9abcdef]{2}){3,4}/i.test(r)
                  )
                    return u || (u = new A.Q()), u.fromString(r), u;
                  return null;
                case "vec2":
                case "vec3":
                case "vec4": {
                  const v = parseInt(t.type.slice(3), 10),
                    _ = n[v];
                  if (r instanceof _)
                    return u instanceof _ ? (u.copy(r), u) : r.clone();
                  if (r instanceof Array && r.length === v) {
                    for (let m = 0; m < r.length; m++)
                      if (typeof r[m] != "number") return null;
                    u || (u = new _());
                    for (let m = 0; m < v; m++) u[l[m]] = r[m];
                    return u;
                  }
                  return null;
                }
                case "curve":
                  if (r) {
                    let v;
                    if (r instanceof x.I || r instanceof y.K) v = r.clone();
                    else {
                      const _ = r.keys[0] instanceof Array ? y.K : x.I;
                      (v = new _(r.keys)), (v.type = r.type);
                    }
                    return v;
                  }
                  break;
              }
              return r;
            }
            class i {
              constructor(t) {
                (this.scriptType = t), (this.index = {});
              }
              add(t, r) {
                this.index[t] ||
                  i.reservedNames.has(t) ||
                  ((this.index[t] = r),
                  Object.defineProperty(this.scriptType.prototype, t, {
                    get: function () {
                      return this.__attributes[t];
                    },
                    set: function (u) {
                      const v = "attr",
                        _ = "attr:" + t,
                        m = this.__attributes[t];
                      let g = m;
                      if (
                        (m &&
                          r.type !== "json" &&
                          r.type !== "entity" &&
                          m.clone &&
                          (this.hasEvent(v) || this.hasEvent(_)) &&
                          (g = m.clone()),
                        r.array)
                      ) {
                        if (((this.__attributes[t] = []), u))
                          for (let T = 0, E = u.length; T < E; T++)
                            this.__attributes[t].push(
                              o(this.app, r, u[T], m ? m[T] : null)
                            );
                      } else this.__attributes[t] = o(this.app, r, u, m);
                      this.fire(v, t, this.__attributes[t], g),
                        this.fire(_, this.__attributes[t], g);
                    },
                  }));
              }
              remove(t) {
                return this.index[t]
                  ? (delete this.index[t],
                    delete this.scriptType.prototype[t],
                    !0)
                  : !1;
              }
              has(t) {
                return !!this.index[t];
              }
              get(t) {
                return this.index[t] || null;
              }
            }
            i.reservedNames = new Set([
              "app",
              "entity",
              "enabled",
              "_enabled",
              "_enabledOld",
              "_destroyed",
              "__attributes",
              "__attributesRaw",
              "__scriptType",
              "__executionOrder",
              "_callbacks",
              "_callbackActive",
              "has",
              "get",
              "on",
              "off",
              "fire",
              "once",
              "hasEvent",
            ]);
          },
          4277: (xe, V, a) => {
            "use strict";
            a.d(V, { r: () => x });
            var A = a(8976);
            class x extends A.J {
              constructor(c) {
                super(),
                  (this.app = c),
                  (this._scripts = {}),
                  (this._list = []);
              }
              destroy() {
                (this.app = null), this.off();
              }
              add(c) {
                const d = c.__name;
                return this._scripts.hasOwnProperty(d)
                  ? (setTimeout(() => {
                      if (c.prototype.swap) {
                        const h = this._scripts[d],
                          f = this._list.indexOf(h);
                        (this._list[f] = c),
                          (this._scripts[d] = c),
                          this.fire("swap", d, c),
                          this.fire("swap:" + d, c);
                      } else
                        console.warn(
                          `script registry already has '${d}' script, define 'swap' method for new script type to enable code hot swapping`
                        );
                    }),
                    !1)
                  : ((this._scripts[d] = c),
                    this._list.push(c),
                    this.fire("add", d, c),
                    this.fire("add:" + d, c),
                    setTimeout(() => {
                      if (
                        !this._scripts.hasOwnProperty(d) ||
                        !this.app ||
                        !this.app.systems ||
                        !this.app.systems.script
                      )
                        return;
                      const h = this.app.systems.script._components;
                      let f;
                      const s = [],
                        l = [];
                      for (
                        h.loopIndex = 0;
                        h.loopIndex < h.length;
                        h.loopIndex++
                      ) {
                        const n = h.items[h.loopIndex];
                        if (n._scriptsIndex[d] && n._scriptsIndex[d].awaiting) {
                          n._scriptsData &&
                            n._scriptsData[d] &&
                            (f = n._scriptsData[d].attributes);
                          const o = n.create(d, {
                            preloading: !0,
                            ind: n._scriptsIndex[d].ind,
                            attributes: f,
                          });
                          o && s.push(o);
                        }
                      }
                      for (let n = 0; n < s.length; n++)
                        s[n].__initializeAttributes();
                      for (let n = 0; n < s.length; n++)
                        s[n].enabled &&
                          ((s[n]._initialized = !0),
                          l.push(s[n]),
                          s[n].initialize && s[n].initialize());
                      for (let n = 0; n < l.length; n++)
                        !l[n].enabled ||
                          l[n]._postInitialized ||
                          ((l[n]._postInitialized = !0),
                          l[n].postInitialize && l[n].postInitialize());
                    }),
                    !0);
              }
              remove(c) {
                let d = c,
                  h = c;
                if (
                  (typeof h != "string" ? (h = d.__name) : (d = this.get(h)),
                  this.get(h) !== d)
                )
                  return !1;
                delete this._scripts[h];
                const f = this._list.indexOf(d);
                return (
                  this._list.splice(f, 1),
                  this.fire("remove", h, d),
                  this.fire("remove:" + h, d),
                  !0
                );
              }
              get(c) {
                return this._scripts[c] || null;
              }
              has(c) {
                if (typeof c == "string")
                  return this._scripts.hasOwnProperty(c);
                if (!c) return !1;
                const d = c.__name;
                return this._scripts[d] === c;
              }
              list() {
                return this._list;
              }
            }
          },
          714: (xe, V, a) => {
            "use strict";
            a.d(V, { e: () => d });
            var A = a(8976),
              x = a(897),
              y = a(6087);
            const c = new RegExp(
              "^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*"
            );
            class d extends A.J {
              constructor(f) {
                super(),
                  (this.app = void 0),
                  (this.entity = void 0),
                  (this._enabled = void 0),
                  (this._enabledOld = void 0),
                  (this._initialized = void 0),
                  (this._postInitialized = void 0),
                  (this.__destroyed = void 0),
                  (this.__attributes = void 0),
                  (this.__attributesRaw = void 0),
                  (this.__scriptType = void 0),
                  (this.__executionOrder = void 0),
                  this.initScriptType(f);
              }
              set enabled(f) {
                (this._enabled = !!f),
                  this.enabled !== this._enabledOld &&
                    ((this._enabledOld = this.enabled),
                    this.fire(this.enabled ? "enable" : "disable"),
                    this.fire("state", this.enabled),
                    !this._initialized &&
                      this.enabled &&
                      ((this._initialized = !0),
                      this.__initializeAttributes(!0),
                      this.initialize &&
                        this.entity.script._scriptMethod(this, x.$x)),
                    this._initialized &&
                      !this._postInitialized &&
                      this.enabled &&
                      !this.entity.script._beingEnabled &&
                      ((this._postInitialized = !0),
                      this.postInitialize &&
                        this.entity.script._scriptMethod(this, x.k5)));
              }
              get enabled() {
                return (
                  this._enabled &&
                  !this._destroyed &&
                  this.entity.script.enabled &&
                  this.entity.enabled
                );
              }
              initScriptType(f) {
                const s = this.constructor;
                (this.app = f.app),
                  (this.entity = f.entity),
                  (this._enabled =
                    typeof f.enabled == "boolean" ? f.enabled : !0),
                  (this._enabledOld = this.enabled),
                  (this.__destroyed = !1),
                  (this.__attributes = {}),
                  (this.__attributesRaw = f.attributes || {}),
                  (this.__scriptType = s),
                  (this.__executionOrder = -1);
              }
              static __getScriptName(f) {
                if (typeof f != "function") return;
                if ("name" in Function.prototype) return f.name;
                if (f === Function || f === Function.prototype.constructor)
                  return "Function";
                const s = ("" + f).match(c);
                return s ? s[1] : void 0;
              }
              static get scriptName() {
                return this.__name;
              }
              static get attributes() {
                return (
                  this.hasOwnProperty("__attributes") ||
                    (this.__attributes = new y.x(this)),
                  this.__attributes
                );
              }
              __initializeAttributes(f) {
                if (!(!f && !this.__attributesRaw)) {
                  for (const s in this.__scriptType.attributes.index)
                    this.__attributesRaw &&
                    this.__attributesRaw.hasOwnProperty(s)
                      ? (this[s] = this.__attributesRaw[s])
                      : this.__attributes.hasOwnProperty(s) ||
                        (this.__scriptType.attributes.index[s].hasOwnProperty(
                          "default"
                        )
                          ? (this[s] =
                              this.__scriptType.attributes.index[s].default)
                          : (this[s] = null));
                  this.__attributesRaw = null;
                }
              }
              static extend(f) {
                for (const s in f)
                  f.hasOwnProperty(s) && (this.prototype[s] = f[s]);
              }
            }
            d.__name = null;
          },
          3113: (xe, V, a) => {
            "use strict";
            a.d(V, { j: () => A });
            class A {
              static push(y, c) {
                c && A._types.length > 0
                  ? console.assert(
                      "Script Ordering Error. Contact support@playcanvas.com"
                    )
                  : A._types.push(y);
              }
            }
            A._types = [];
          },
          2633: (xe, V, a) => {
            "use strict";
            a.d(V, { Iz: () => s, so: () => l, tX: () => o });
            var A = a(8976),
              x = a(4595),
              y = a(7788),
              c = a(6087),
              d = a(714),
              h = a(3113);
            const f = new Set([
              "system",
              "entity",
              "create",
              "destroy",
              "swap",
              "move",
              "data",
              "scripts",
              "_scripts",
              "_scriptsIndex",
              "_scriptsData",
              "enabled",
              "_oldState",
              "onEnable",
              "onDisable",
              "onPostStateChange",
              "_onSetEnabled",
              "_checkState",
              "_onBeforeRemove",
              "_onInitializeAttributes",
              "_onInitialize",
              "_onPostInitialize",
              "_onUpdate",
              "_onPostUpdate",
              "_callbacks",
              "_callbackActive",
              "has",
              "get",
              "on",
              "off",
              "fire",
              "once",
              "hasEvent",
            ]);
            function s() {
              return f;
            }
            function l(i, e) {
              if (x.K.legacy) return null;
              if (f.has(i))
                throw new Error(
                  `Script name '${i}' is reserved, please rename the script`
                );
              const t = function (u) {
                A.J.prototype.initEventHandler.call(this),
                  d.e.prototype.initScriptType.call(this, u);
              };
              return (
                (t.prototype = Object.create(d.e.prototype)),
                (t.prototype.constructor = t),
                (t.extend = d.e.extend),
                (t.attributes = new c.x(t)),
                o(t, i, e),
                t
              );
            }
            const n = {};
            c.x.reservedNames.forEach((i, e, t) => {
              n[i] = 1;
            }),
              (l.reservedAttributes = n);
            function o(i, e, t) {
              if (i.legacy) return;
              if (typeof i != "function")
                throw new Error(
                  `script class: '${i}' must be a constructor function (i.e. class).`
                );
              if (!(i.prototype instanceof d.e))
                throw new Error(
                  `script class: '${d.e.__getScriptName(
                    i
                  )}' does not extend pc.ScriptType.`
                );
              if (((e = e || i.__name || d.e.__getScriptName(i)), f.has(e)))
                throw new Error(
                  `script name: '${e}' is reserved, please change script name`
                );
              (i.__name = e),
                (t ? t.scripts : y.v.getApplication().scripts).add(i),
                h.j.push(i, i.legacy);
            }
          },
          1626: (xe, V, a) => {
            "use strict";
            a.d(V, { B: () => x });
            var A = a(8158);
            class x {
              constructor(c, d) {
                (this._app = void 0),
                  (this._data = void 0),
                  (this._templateRoot = null),
                  (this._app = c),
                  (this._data = d);
              }
              instantiate() {
                return (
                  this._templateRoot || this._parseTemplate(),
                  this._templateRoot.clone()
                );
              }
              _parseTemplate() {
                const c = new A.q(this._app, !0);
                this._templateRoot = c.parse(this._data);
              }
            }
          },
          1657: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => c });
            var A = a(4124),
              x = a(371),
              y = a(8976);
            class c extends y.J {
              constructor(h, f, s) {
                if ((super(), !h || !(h instanceof A.u)))
                  throw new Error(
                    "The parentComponent argument is required and must be a Component"
                  );
                if (!f || typeof f != "string")
                  throw new Error(
                    "The propertyName argument is required and must be a string"
                  );
                if (s && typeof s != "object")
                  throw new Error(
                    "If provided, the eventConfig argument must be an object"
                  );
                (this._parentComponent = h),
                  (this._entityPropertyName = f),
                  (this._entity = null),
                  (this._app = h.system.app),
                  this._configureEventListeners(s || {}, {
                    "entity#destroy": this._onEntityDestroy,
                  }),
                  this._toggleLifecycleListeners("on");
              }
              _configureEventListeners(h, f) {
                const s = this._parseEventListenerConfig(
                    h,
                    "external",
                    this._parentComponent
                  ),
                  l = this._parseEventListenerConfig(f, "internal", this);
                (this._eventListenerConfigs = s.concat(l)),
                  (this._listenerStatusFlags = {}),
                  (this._gainListeners = {}),
                  (this._loseListeners = {});
              }
              _parseEventListenerConfig(h, f, s) {
                return Object.keys(h).map(function (l, n) {
                  const o = l.split("#"),
                    i = o[0],
                    e = o[1],
                    t = h[l];
                  if (
                    o.length !== 2 ||
                    typeof i != "string" ||
                    i.length === 0 ||
                    typeof e != "string" ||
                    e.length === 0
                  )
                    throw new Error(
                      "Invalid event listener description: `" + l + "`"
                    );
                  if (typeof t != "function")
                    throw new Error(
                      "Invalid or missing callback for event listener `" +
                        l +
                        "`"
                    );
                  return {
                    id: f + "_" + n + "_" + l,
                    sourceName: i,
                    eventName: e,
                    callback: t,
                    scope: s,
                  };
                }, this);
              }
              _toggleLifecycleListeners(h) {
                this._parentComponent[h](
                  "set_" + this._entityPropertyName,
                  this._onSetEntity,
                  this
                ),
                  this._parentComponent.system[h](
                    "beforeremove",
                    this._onParentComponentRemove,
                    this
                  ),
                  this._app.systems[h](
                    "postPostInitialize",
                    this._updateEntityReference,
                    this
                  ),
                  this._app[h]("tools:sceneloaded", this._onSceneLoaded, this);
                const f = [];
                for (let s = 0; s < this._eventListenerConfigs.length; ++s) {
                  const l = this._eventListenerConfigs[s],
                    n = this._app.systems[l.sourceName];
                  n &&
                    (f.indexOf(n) === -1 && f.push(n),
                    n &&
                      l.eventName === "gain" &&
                      (this._gainListeners[l.sourceName] = l),
                    n &&
                      l.eventName === "lose" &&
                      (this._loseListeners[l.sourceName] = l));
                }
                for (let s = 0; s < f.length; ++s)
                  f[s][h]("add", this._onComponentAdd, this),
                    f[s][h]("beforeremove", this._onComponentRemove, this);
              }
              _onSetEntity(h, f, s) {
                if (s instanceof x.w) this._updateEntityReference();
                else {
                  if (s != null && typeof s != "string") {
                    console.warn(
                      "Entity field `" +
                        this._entityPropertyName +
                        "` was set to unexpected type '" +
                        typeof s +
                        "'"
                    );
                    return;
                  }
                  f !== s && this._updateEntityReference();
                }
              }
              onParentComponentEnable() {
                this._entity || this._updateEntityReference();
              }
              _onSceneLoaded() {
                this._updateEntityReference();
              }
              _updateEntityReference() {
                let h = this._parentComponent.data[this._entityPropertyName],
                  f;
                if (h instanceof x.w)
                  (f = h),
                    (h = f.getGuid()),
                    (this._parentComponent.data[this._entityPropertyName] = h);
                else {
                  const l = this._parentComponent.system.app.root;
                  f =
                    this._parentComponent.entity.isDescendantOf(l) && h
                      ? l.findByGuid(h)
                      : null;
                }
                this._entity !== f &&
                  (this._entity && this._onBeforeEntityChange(),
                  (this._entity = f),
                  this._entity && this._onAfterEntityChange(),
                  this.fire("set:entity", this._entity));
              }
              _onBeforeEntityChange() {
                this._toggleEntityListeners("off"),
                  this._callAllGainOrLoseListeners(this._loseListeners);
              }
              _onAfterEntityChange() {
                this._toggleEntityListeners("on"),
                  this._callAllGainOrLoseListeners(this._gainListeners);
              }
              _onComponentAdd(h, f) {
                const s = f.system.id;
                h === this._entity &&
                  (this._callGainOrLoseListener(s, this._gainListeners),
                  this._toggleComponentListeners("on", s));
              }
              _onComponentRemove(h, f) {
                const s = f.system.id;
                h === this._entity &&
                  (this._callGainOrLoseListener(s, this._loseListeners),
                  this._toggleComponentListeners("off", s, !0));
              }
              _callAllGainOrLoseListeners(h) {
                for (const f in this._entity.c)
                  this._callGainOrLoseListener(f, h);
              }
              _callGainOrLoseListener(h, f) {
                if (this._entity.c.hasOwnProperty(h) && f[h]) {
                  const s = f[h];
                  s.callback.call(s.scope);
                }
              }
              _toggleEntityListeners(h, f) {
                if (this._entity)
                  for (let s = 0; s < this._eventListenerConfigs.length; ++s)
                    this._safeToggleListener(
                      h,
                      this._eventListenerConfigs[s],
                      f
                    );
              }
              _toggleComponentListeners(h, f, s) {
                for (let l = 0; l < this._eventListenerConfigs.length; ++l) {
                  const n = this._eventListenerConfigs[l];
                  n.sourceName === f && this._safeToggleListener(h, n, s);
                }
              }
              _safeToggleListener(h, f, s) {
                const l = h === "on";
                if (l && this._listenerStatusFlags[f.id]) return;
                const n = this._getEventSource(f.sourceName, s);
                n &&
                  (n[h](f.eventName, f.callback, f.scope),
                  (this._listenerStatusFlags[f.id] = l));
              }
              _getEventSource(h, f) {
                if (h === "entity") return this._entity;
                const s = this._entity[h];
                return (
                  s ||
                  (f || console.warn("Entity has no component with name " + h),
                  null)
                );
              }
              _onEntityDestroy(h) {
                this._entity === h &&
                  (this._toggleEntityListeners("off", !0),
                  (this._entity = null));
              }
              _onParentComponentRemove(h, f) {
                f === this._parentComponent &&
                  (this._toggleLifecycleListeners("off"),
                  this._toggleEntityListeners("off", !0));
              }
              hasComponent(h) {
                return this._entity && this._entity.c
                  ? !!this._entity.c[h]
                  : !1;
              }
              get entity() {
                return this._entity;
              }
            }
          },
          184: (xe, V, a) => {
            "use strict";
            a.d(V, {
              Bk: () => _,
              Di: () => t,
              EM: () => c,
              Ew: () => l,
              LF: () => f,
              VS: () => i,
              W9: () => T,
              cX: () => o,
              dp: () => n,
              fC: () => u,
              h8: () => A,
              mk: () => x,
              nz: () => m,
              p7: () => y,
              tf: () => h,
              uZ: () => e,
              ux: () => v,
              vi: () => d,
              wP: () => s,
              wg: () => g,
              xH: () => r,
            });
            const A = "inline",
              x = "immersive-vr",
              y = "immersive-ar",
              c = "viewer",
              d = "local",
              h = "local-floor",
              f = "bounded-floor",
              s = "unbounded",
              l = "gaze",
              n = "screen",
              o = "tracked-pointer",
              i = "none",
              e = "left",
              t = "right",
              r = "point",
              u = "plane",
              v = "mesh",
              _ = "cpu-optimized",
              m = "gpu-optimized",
              g = "luminance-alpha",
              T = "float32";
          },
          8839: (xe, V, a) => {
            "use strict";
            a.d(V, { t: () => f });
            var A = a(8976),
              x = a(9222),
              y = a(8484),
              c = a(1630),
              d = a(1208),
              h = a(184);
            class f extends A.J {
              constructor(l) {
                super(),
                  (this._manager = void 0),
                  (this._available = !1),
                  (this._depthInfoCpu = null),
                  (this._depthInfoGpu = null),
                  (this._usage = null),
                  (this._dataFormat = null),
                  (this._matrixDirty = !1),
                  (this._matrix = new y.$()),
                  (this._emptyBuffer = new Uint8Array(32)),
                  (this._depthBuffer = null),
                  (this._texture = void 0),
                  (this._manager = l),
                  (this._texture = new d.g(this._manager.app.graphicsDevice, {
                    format: c._3,
                    mipmaps: !1,
                    addressU: c.vq6,
                    addressV: c.vq6,
                    minFilter: c.DrA,
                    magFilter: c.DrA,
                    name: "XRDepthSensing",
                  })),
                  this.supported &&
                    (this._manager.on("start", this._onSessionStart, this),
                    this._manager.on("end", this._onSessionEnd, this));
              }
              destroy() {
                this._texture.destroy(), (this._texture = null);
              }
              _onSessionStart() {
                const l = this._manager.session;
                try {
                  (this._usage = l.depthUsage),
                    (this._dataFormat = l.depthDataFormat);
                } catch (n) {
                  (this._usage = null),
                    (this._dataFormat = null),
                    (this._available = !1),
                    this.fire("error", n);
                }
              }
              _onSessionEnd() {
                (this._depthInfoCpu = null),
                  (this._depthInfoGpu = null),
                  (this._usage = null),
                  (this._dataFormat = null),
                  this._available &&
                    ((this._available = !1), this.fire("unavailable")),
                  (this._depthBuffer = null),
                  (this._texture._width = 4),
                  (this._texture._height = 4),
                  (this._texture._levels[0] = this._emptyBuffer),
                  this._texture.upload();
              }
              _updateTexture() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                if (l) {
                  let n = !1;
                  if (
                    ((l.width !== this._texture.width ||
                      l.height !== this._texture.height) &&
                      ((this._texture._width = l.width),
                      (this._texture._height = l.height),
                      (this._matrixDirty = !0),
                      (n = !0)),
                    this._depthInfoCpu)
                  ) {
                    const o = this._depthInfoCpu.data;
                    (this._depthBuffer = new Uint8Array(o)),
                      (this._texture._levels[0] = this._depthBuffer),
                      this._texture.upload();
                  } else
                    this._depthInfoGpu &&
                      ((this._texture._levels[0] = this._depthInfoGpu.texture),
                      this._texture.upload());
                  n && this.fire("resize", l.width, l.height);
                } else
                  this._depthBuffer &&
                    ((this._depthBuffer = null),
                    (this._texture._width = 4),
                    (this._texture._height = 4),
                    (this._texture._levels[0] = this._emptyBuffer),
                    this._texture.upload());
              }
              update(l, n) {
                if (!this._usage) return;
                let o = null,
                  i = null;
                if (
                  (this._usage === h.Bk && n
                    ? (o = l.getDepthInformation(n))
                    : this._usage === h.nz &&
                      n &&
                      (i = l.getDepthInformation(n)),
                  ((this._depthInfoCpu && !o) ||
                    (!this._depthInfoCpu && o) ||
                    (this.depthInfoGpu && !i) ||
                    (!this._depthInfoGpu && i)) &&
                    (this._matrixDirty = !0),
                  (this._depthInfoCpu = o),
                  (this._depthInfoGpu = i),
                  this._updateTexture(),
                  this._matrixDirty)
                ) {
                  this._matrixDirty = !1;
                  const e = this._depthInfoCpu || this._depthInfoGpu;
                  e
                    ? this._matrix.data.set(
                        e.normDepthBufferFromNormView.matrix
                      )
                    : this._matrix.setIdentity();
                }
                (this._depthInfoCpu || this._depthInfoGpu) && !this._available
                  ? ((this._available = !0), this.fire("available"))
                  : !this._depthInfoCpu &&
                    !this._depthInfoGpu &&
                    this._available &&
                    ((this._available = !1), this.fire("unavailable"));
              }
              getDepth(l, n) {
                return this._depthInfoCpu
                  ? this._depthInfoCpu.getDepthInMeters(l, n)
                  : null;
              }
              get supported() {
                return x.i.browser && !!window.XRDepthInformation;
              }
              get available() {
                return this._available;
              }
              get usage() {
                return this._usage;
              }
              get dataFormat() {
                return this._dataFormat;
              }
              get width() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                return (l && l.width) || 0;
              }
              get height() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                return (l && l.height) || 0;
              }
              get texture() {
                return this._texture;
              }
              get uvMatrix() {
                return this._matrix;
              }
              get rawValueToMeters() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                return (l && l.rawValueToMeters) || 0;
              }
            }
          },
          7419: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => x });
            var A = a(9222);
            class x {
              constructor(c) {
                (this._manager = void 0),
                  (this._supported = A.i.browser && !!window.XRDOMOverlayState),
                  (this._root = null),
                  (this._manager = c);
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return (
                  this._supported &&
                  this._manager.active &&
                  this._manager._session.domOverlayState !== null
                );
              }
              get state() {
                return !this._supported ||
                  !this._manager.active ||
                  !this._manager._session.domOverlayState
                  ? null
                  : this._manager._session.domOverlayState.type;
              }
              set root(c) {
                !this._supported || this._manager.active || (this._root = c);
              }
              get root() {
                return this._root;
              }
            }
          },
          4584: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => h });
            var A = a(8976),
              x = a(3021),
              y = a(7481);
            const c = [],
              d = [];
            class h extends A.J {
              constructor(s, l, n) {
                super(),
                  (this.manager = void 0),
                  (this._xrHitTestSource = void 0),
                  (this._transient = void 0),
                  (this.manager = s),
                  (this._xrHitTestSource = l),
                  (this._transient = n);
              }
              remove() {
                if (!this._xrHitTestSource) return;
                const s = this.manager.hitTest.sources,
                  l = s.indexOf(this);
                l !== -1 && s.splice(l, 1), this.onStop();
              }
              onStop() {
                this._xrHitTestSource.cancel(),
                  (this._xrHitTestSource = null),
                  this.fire("remove"),
                  this.manager.hitTest.fire("remove", this);
              }
              update(s) {
                if (this._transient) {
                  const l = s.getHitTestResultsForTransientInput(
                    this._xrHitTestSource
                  );
                  for (let n = 0; n < l.length; n++) {
                    const o = l[n];
                    let i;
                    o.inputSource &&
                      (i = this.manager.input._getByInputSource(o.inputSource)),
                      this.updateHitResults(o.results, i);
                  }
                } else
                  this.updateHitResults(
                    s.getHitTestResults(this._xrHitTestSource)
                  );
              }
              updateHitResults(s, l) {
                for (let n = 0; n < s.length; n++) {
                  const o = s[n].getPose(this.manager._referenceSpace);
                  let i = c.pop();
                  i || (i = new y.e()), i.copy(o.transform.position);
                  let e = d.pop();
                  e || (e = new x.k()),
                    e.copy(o.transform.orientation),
                    this.fire("result", i, e, l),
                    this.manager.hitTest.fire("result", this, i, e, l),
                    c.push(i),
                    d.push(e);
                }
              }
            }
          },
          8076: (xe, V, a) => {
            "use strict";
            a.d(V, { _: () => d });
            var A = a(9222),
              x = a(8976),
              y = a(184),
              c = a(4584);
            class d extends x.J {
              constructor(f) {
                super(),
                  (this.manager = void 0),
                  (this._supported =
                    A.i.browser &&
                    !!(
                      window.XRSession &&
                      window.XRSession.prototype.requestHitTestSource
                    )),
                  (this._session = null),
                  (this.sources = []),
                  (this.manager = f),
                  this._supported &&
                    (this.manager.on("start", this._onSessionStart, this),
                    this.manager.on("end", this._onSessionEnd, this));
              }
              _onSessionStart() {
                this.manager.type === y.p7 &&
                  (this._session = this.manager.session);
              }
              _onSessionEnd() {
                if (this._session) {
                  this._session = null;
                  for (let f = 0; f < this.sources.length; f++)
                    this.sources[f].onStop();
                  this.sources = [];
                }
              }
              isAvailable(f, s) {
                let l;
                return (
                  this._supported ||
                    (l = new Error("XR HitTest is not supported")),
                  this._session ||
                    (l = new Error("XR Session is not started (1)")),
                  this.manager.type !== y.p7 &&
                    (l = new Error("XR HitTest is available only for AR")),
                  l ? (f && f(l), s && s.fire("error", l), !1) : !0
                );
              }
              start(f = {}) {
                if (!this.isAvailable(f.callback, this)) return;
                !f.profile && !f.spaceType && (f.spaceType = y.EM);
                let s;
                const l = f.offsetRay;
                if (l) {
                  const o = new DOMPoint(l.origin.x, l.origin.y, l.origin.z, 1),
                    i = new DOMPoint(
                      l.direction.x,
                      l.direction.y,
                      l.direction.z,
                      0
                    );
                  s = new XRRay(o, i);
                }
                const n = f.callback;
                f.spaceType
                  ? this._session
                      .requestReferenceSpace(f.spaceType)
                      .then((o) => {
                        if (!this._session) {
                          const i = new Error("XR Session is not started (2)");
                          n && n(i), this.fire("error", i);
                          return;
                        }
                        this._session
                          .requestHitTestSource({
                            space: o,
                            entityTypes: f.entityTypes || void 0,
                            offsetRay: s,
                          })
                          .then((i) => {
                            this._onHitTestSource(i, !1, n);
                          })
                          .catch((i) => {
                            n && n(i), this.fire("error", i);
                          });
                      })
                      .catch((o) => {
                        n && n(o), this.fire("error", o);
                      })
                  : this._session
                      .requestHitTestSourceForTransientInput({
                        profile: f.profile,
                        entityTypes: f.entityTypes || void 0,
                        offsetRay: s,
                      })
                      .then((o) => {
                        this._onHitTestSource(o, !0, n);
                      })
                      .catch((o) => {
                        n && n(o), this.fire("error", o);
                      });
              }
              _onHitTestSource(f, s, l) {
                if (!this._session) {
                  f.cancel();
                  const o = new Error("XR Session is not started (3)");
                  l && l(o), this.fire("error", o);
                  return;
                }
                const n = new c.Z(this.manager, f, s);
                this.sources.push(n), l && l(null, n), this.fire("add", n);
              }
              update(f) {
                for (let s = 0; s < this.sources.length; s++)
                  this.sources[s].update(f);
              }
              get supported() {
                return this._supported;
              }
            }
          },
          7525: (xe, V, a) => {
            "use strict";
            a.d(V, { l: () => c });
            var A = a(8976),
              x = a(9222),
              y = a(9700);
            class c extends A.J {
              constructor(h) {
                super(),
                  (this._manager = void 0),
                  (this._supported =
                    x.i.browser && !!window.XRImageTrackingResult),
                  (this._available = !1),
                  (this._images = []),
                  (this._manager = h),
                  this._supported &&
                    (this._manager.on("start", this._onSessionStart, this),
                    this._manager.on("end", this._onSessionEnd, this));
              }
              add(h, f) {
                if (!this._supported || this._manager.active) return null;
                const s = new y.A(h, f);
                return this._images.push(s), s;
              }
              remove(h) {
                if (this._manager.active) return;
                const f = this._images.indexOf(h);
                f !== -1 && (h.destroy(), this._images.splice(f, 1));
              }
              _onSessionStart() {
                this._manager.session
                  .getTrackedImageScores()
                  .then((h) => {
                    this._available = !0;
                    for (let f = 0; f < h.length; f++)
                      this._images[f]._trackable = h[f] === "trackable";
                  })
                  .catch((h) => {
                    (this._available = !1), this.fire("error", h);
                  });
              }
              _onSessionEnd() {
                this._available = !1;
                for (let h = 0; h < this._images.length; h++) {
                  const f = this._images[h];
                  (f._pose = null),
                    (f._measuredWidth = 0),
                    f._tracking && ((f._tracking = !1), f.fire("untracked"));
                }
              }
              prepareImages(h) {
                this._images.length
                  ? Promise.all(
                      this._images.map(function (f) {
                        return f.prepare();
                      })
                    )
                      .then(function (f) {
                        h(null, f);
                      })
                      .catch(function (f) {
                        h(f, null);
                      })
                  : h(null, null);
              }
              update(h) {
                if (!this._available) return;
                const f = h.getImageTrackingResults(),
                  s = {};
                for (let l = 0; l < f.length; l++) {
                  s[f[l].index] = f[l];
                  const n = this._images[f[l].index];
                  (n._emulated = f[l].trackingState === "emulated"),
                    (n._measuredWidth = f[l].measuredWidthInMeters),
                    (n._pose = h.getPose(
                      f[l].imageSpace,
                      this._manager._referenceSpace
                    ));
                }
                for (let l = 0; l < this._images.length; l++)
                  this._images[l]._tracking && !s[l]
                    ? ((this._images[l]._tracking = !1),
                      this._images[l].fire("untracked"))
                    : !this._images[l]._tracking &&
                      s[l] &&
                      ((this._images[l]._tracking = !0),
                      this._images[l].fire("tracked"));
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return this._available;
              }
              get images() {
                return this._images;
              }
            }
          },
          7223: (xe, V, a) => {
            "use strict";
            a.d(V, { g: () => m });
            var A = a(8976),
              x = a(8484),
              y = a(3021),
              c = a(7481),
              d = a(9663),
              h = a(9222),
              f = a(184);
            class s {
              constructor(T, E) {
                (this._index = void 0),
                  (this._hand = void 0),
                  (this._joints = []),
                  (this._tip = null),
                  (this._index = T),
                  (this._hand = E),
                  this._hand._fingers.push(this);
              }
              get index() {
                return this._index;
              }
              get hand() {
                return this._hand;
              }
              get joints() {
                return this._joints;
              }
              get tip() {
                return this._tip;
              }
            }
            const l =
                h.i.browser && window.XRHand
                  ? [
                      "thumb-tip",
                      "index-finger-tip",
                      "middle-finger-tip",
                      "ring-finger-tip",
                      "pinky-finger-tip",
                    ]
                  : [],
              n = {};
            for (let g = 0; g < l.length; g++) n[l[g]] = !0;
            class o {
              constructor(T, E, M, R = null) {
                (this._index = void 0),
                  (this._id = void 0),
                  (this._hand = void 0),
                  (this._finger = void 0),
                  (this._wrist = void 0),
                  (this._tip = void 0),
                  (this._radius = null),
                  (this._localTransform = new x.$()),
                  (this._worldTransform = new x.$()),
                  (this._localPosition = new c.e()),
                  (this._localRotation = new y.k()),
                  (this._position = new c.e()),
                  (this._rotation = new y.k()),
                  (this._dirtyLocal = !0),
                  (this._index = T),
                  (this._id = E),
                  (this._hand = M),
                  (this._finger = R),
                  (this._wrist = E === "wrist"),
                  (this._tip = this._finger && !!n[E]);
              }
              update(T) {
                (this._dirtyLocal = !0),
                  (this._radius = T.radius),
                  this._localPosition.copy(T.transform.position),
                  this._localRotation.copy(T.transform.orientation);
              }
              _updateTransforms() {
                this._dirtyLocal &&
                  ((this._dirtyLocal = !1),
                  this._localTransform.setTRS(
                    this._localPosition,
                    this._localRotation,
                    c.e.ONE
                  ));
                const E = this._hand._manager.camera.parent;
                E
                  ? this._worldTransform.mul2(
                      E.getWorldTransform(),
                      this._localTransform
                    )
                  : this._worldTransform.copy(this._localTransform);
              }
              getPosition() {
                return (
                  this._updateTransforms(),
                  this._worldTransform.getTranslation(this._position),
                  this._position
                );
              }
              getRotation() {
                return (
                  this._updateTransforms(),
                  this._rotation.setFromMat4(this._worldTransform),
                  this._rotation
                );
              }
              get index() {
                return this._index;
              }
              get hand() {
                return this._hand;
              }
              get finger() {
                return this._finger;
              }
              get wrist() {
                return this._wrist;
              }
              get tip() {
                return this._tip;
              }
              get radius() {
                return this._radius || 0.005;
              }
            }
            let i = [];
            const e = new c.e(),
              t = new c.e(),
              r = new c.e();
            h.i.browser &&
              window.XRHand &&
              (i = [
                [
                  "thumb-metacarpal",
                  "thumb-phalanx-proximal",
                  "thumb-phalanx-distal",
                  "thumb-tip",
                ],
                [
                  "index-finger-metacarpal",
                  "index-finger-phalanx-proximal",
                  "index-finger-phalanx-intermediate",
                  "index-finger-phalanx-distal",
                  "index-finger-tip",
                ],
                [
                  "middle-finger-metacarpal",
                  "middle-finger-phalanx-proximal",
                  "middle-finger-phalanx-intermediate",
                  "middle-finger-phalanx-distal",
                  "middle-finger-tip",
                ],
                [
                  "ring-finger-metacarpal",
                  "ring-finger-phalanx-proximal",
                  "ring-finger-phalanx-intermediate",
                  "ring-finger-phalanx-distal",
                  "ring-finger-tip",
                ],
                [
                  "pinky-finger-metacarpal",
                  "pinky-finger-phalanx-proximal",
                  "pinky-finger-phalanx-intermediate",
                  "pinky-finger-phalanx-distal",
                  "pinky-finger-tip",
                ],
              ]);
            class u extends A.J {
              constructor(T) {
                super(),
                  (this._manager = void 0),
                  (this._inputSource = void 0),
                  (this._tracking = !1),
                  (this._fingers = []),
                  (this._joints = []),
                  (this._jointsById = {}),
                  (this._tips = []),
                  (this._wrist = null);
                const E = T._xrInputSource.hand;
                if (
                  ((this._manager = T._manager),
                  (this._inputSource = T),
                  E.get("wrist"))
                ) {
                  const M = new o(0, "wrist", this, null);
                  (this._wrist = M),
                    this._joints.push(M),
                    (this._jointsById.wrist = M);
                }
                for (let M = 0; M < i.length; M++) {
                  const R = new s(M, this);
                  for (let P = 0; P < i[M].length; P++) {
                    const F = i[M][P];
                    if (!E.get(F)) continue;
                    const b = new o(P, F, this, R);
                    this._joints.push(b),
                      (this._jointsById[F] = b),
                      b.tip && (this._tips.push(b), (R._tip = b)),
                      R._joints.push(b);
                  }
                }
              }
              update(T) {
                const E = this._inputSource._xrInputSource;
                for (let X = 0; X < this._joints.length; X++) {
                  const ie = this._joints[X],
                    Q = E.hand.get(ie._id);
                  if (Q) {
                    let te;
                    if (
                      (T.session.visibilityState !== "hidden" &&
                        (te = T.getJointPose(Q, this._manager._referenceSpace)),
                      te)
                    )
                      ie.update(te),
                        ie.wrist &&
                          !this._tracking &&
                          ((this._tracking = !0), this.fire("tracking"));
                    else if (ie.wrist) {
                      this._tracking &&
                        ((this._tracking = !1), this.fire("trackinglost"));
                      break;
                    }
                  }
                }
                const M = this._jointsById["thumb-metacarpal"],
                  R = this._jointsById["thumb-tip"],
                  P = this._jointsById["index-finger-phalanx-proximal"],
                  F = this._jointsById["index-finger-tip"],
                  b = this._jointsById["ring-finger-phalanx-proximal"],
                  D = this._jointsById["pinky-finger-phalanx-proximal"];
                if (M && R && P && F && b && D) {
                  (this._inputSource._dirtyRay = !0),
                    this._inputSource._rayLocal.origin.lerp(
                      R._localPosition,
                      F._localPosition,
                      0.5
                    );
                  let X = M,
                    ie = D;
                  if (this._inputSource.handedness === f.uZ) {
                    const Q = X;
                    (X = ie), (ie = Q);
                  }
                  e.sub2(X._localPosition, this._wrist._localPosition),
                    t.sub2(ie._localPosition, this._wrist._localPosition),
                    r.cross(e, t).normalize(),
                    e.lerp(P._localPosition, b._localPosition, 0.5),
                    e.sub(this._wrist._localPosition).normalize(),
                    this._inputSource._rayLocal.direction
                      .lerp(r, e, 0.5)
                      .normalize();
                }
                this._fingerIsClosed(1) &&
                this._fingerIsClosed(2) &&
                this._fingerIsClosed(3) &&
                this._fingerIsClosed(4)
                  ? this._inputSource._squeezing ||
                    ((this._inputSource._squeezing = !0),
                    this._inputSource.fire("squeezestart"),
                    this._manager.input.fire("squeezestart", this._inputSource))
                  : this._inputSource._squeezing &&
                    ((this._inputSource._squeezing = !1),
                    this._inputSource.fire("squeeze"),
                    this._manager.input.fire("squeeze", this._inputSource),
                    this._inputSource.fire("squeezeend"),
                    this._manager.input.fire("squeezeend", this._inputSource));
              }
              _fingerIsClosed(T) {
                const E = this._fingers[T];
                return (
                  e
                    .sub2(
                      E.joints[0]._localPosition,
                      E.joints[1]._localPosition
                    )
                    .normalize(),
                  t
                    .sub2(
                      E.joints[2]._localPosition,
                      E.joints[3]._localPosition
                    )
                    .normalize(),
                  e.dot(t) < -0.8
                );
              }
              getJointById(T) {
                return this._jointsById[T] || null;
              }
              get fingers() {
                return this._fingers;
              }
              get joints() {
                return this._joints;
              }
              get tips() {
                return this._tips;
              }
              get wrist() {
                return this._wrist;
              }
              get tracking() {
                return this._tracking;
              }
            }
            const v = new y.k();
            let _ = 0;
            class m extends A.J {
              constructor(T, E) {
                super(),
                  (this._id = void 0),
                  (this._manager = void 0),
                  (this._xrInputSource = void 0),
                  (this._ray = new d.R()),
                  (this._rayLocal = new d.R()),
                  (this._grip = !1),
                  (this._hand = null),
                  (this._localTransform = null),
                  (this._worldTransform = null),
                  (this._position = new c.e()),
                  (this._rotation = new y.k()),
                  (this._localPosition = null),
                  (this._localRotation = null),
                  (this._dirtyLocal = !0),
                  (this._dirtyRay = !1),
                  (this._selecting = !1),
                  (this._squeezing = !1),
                  (this._elementInput = !0),
                  (this._elementEntity = null),
                  (this._hitTestSources = []),
                  (this._id = ++_),
                  (this._manager = T),
                  (this._xrInputSource = E),
                  E.hand && (this._hand = new u(this));
              }
              get id() {
                return this._id;
              }
              get inputSource() {
                return this._xrInputSource;
              }
              get targetRayMode() {
                return this._xrInputSource.targetRayMode;
              }
              get handedness() {
                return this._xrInputSource.handedness;
              }
              get profiles() {
                return this._xrInputSource.profiles;
              }
              get grip() {
                return this._grip;
              }
              get hand() {
                return this._hand;
              }
              get gamepad() {
                return this._xrInputSource.gamepad || null;
              }
              get selecting() {
                return this._selecting;
              }
              get squeezing() {
                return this._squeezing;
              }
              set elementInput(T) {
                this._elementInput !== T &&
                  ((this._elementInput = T),
                  this._elementInput || (this._elementEntity = null));
              }
              get elementInput() {
                return this._elementInput;
              }
              get elementEntity() {
                return this._elementEntity;
              }
              get hitTestSources() {
                return this._hitTestSources;
              }
              update(T) {
                if (this._hand) this._hand.update(T);
                else {
                  if (this._xrInputSource.gripSpace) {
                    const M = T.getPose(
                      this._xrInputSource.gripSpace,
                      this._manager._referenceSpace
                    );
                    M &&
                      (this._grip ||
                        ((this._grip = !0),
                        (this._localTransform = new x.$()),
                        (this._worldTransform = new x.$()),
                        (this._localPosition = new c.e()),
                        (this._localRotation = new y.k())),
                      (this._dirtyLocal = !0),
                      this._localPosition.copy(M.transform.position),
                      this._localRotation.copy(M.transform.orientation));
                  }
                  const E = T.getPose(
                    this._xrInputSource.targetRaySpace,
                    this._manager._referenceSpace
                  );
                  E &&
                    ((this._dirtyRay = !0),
                    this._rayLocal.origin.copy(E.transform.position),
                    this._rayLocal.direction.set(0, 0, -1),
                    v.copy(E.transform.orientation),
                    v.transformVector(
                      this._rayLocal.direction,
                      this._rayLocal.direction
                    ));
                }
              }
              _updateTransforms() {
                this._dirtyLocal &&
                  ((this._dirtyLocal = !1),
                  this._localTransform.setTRS(
                    this._localPosition,
                    this._localRotation,
                    c.e.ONE
                  ));
                const T = this._manager.camera.parent;
                T
                  ? this._worldTransform.mul2(
                      T.getWorldTransform(),
                      this._localTransform
                    )
                  : this._worldTransform.copy(this._localTransform);
              }
              _updateRayTransforms() {
                const T = this._dirtyRay;
                if (((this._dirtyRay = !1), this._manager.camera.parent)) {
                  const M = this._manager.camera.parent.getWorldTransform();
                  M.getTranslation(this._position),
                    this._rotation.setFromMat4(M),
                    this._rotation.transformVector(
                      this._rayLocal.origin,
                      this._ray.origin
                    ),
                    this._ray.origin.add(this._position),
                    this._rotation.transformVector(
                      this._rayLocal.direction,
                      this._ray.direction
                    );
                } else
                  T &&
                    (this._ray.origin.copy(this._rayLocal.origin),
                    this._ray.direction.copy(this._rayLocal.direction));
              }
              getPosition() {
                return this._position
                  ? (this._updateTransforms(),
                    this._worldTransform.getTranslation(this._position),
                    this._position)
                  : null;
              }
              getLocalPosition() {
                return this._localPosition;
              }
              getRotation() {
                return this._rotation
                  ? (this._updateTransforms(),
                    this._rotation.setFromMat4(this._worldTransform),
                    this._rotation)
                  : null;
              }
              getLocalRotation() {
                return this._localRotation;
              }
              getOrigin() {
                return this._updateRayTransforms(), this._ray.origin;
              }
              getDirection() {
                return this._updateRayTransforms(), this._ray.direction;
              }
              hitTestStart(T = {}) {
                T.profile = this._xrInputSource.profiles[0];
                const E = T.callback;
                (T.callback = (M, R) => {
                  R && this.onHitTestSourceAdd(R), E && E(M, R);
                }),
                  this._manager.hitTest.start(T);
              }
              onHitTestSourceAdd(T) {
                this._hitTestSources.push(T),
                  this.fire("hittest:add", T),
                  T.on(
                    "result",
                    function (E, M, R) {
                      R === this && this.fire("hittest:result", T, E, M);
                    },
                    this
                  ),
                  T.once(
                    "remove",
                    function () {
                      this.onHitTestSourceRemove(T),
                        this.fire("hittest:remove", T);
                    },
                    this
                  );
              }
              onHitTestSourceRemove(T) {
                const E = this._hitTestSources.indexOf(T);
                E !== -1 && this._hitTestSources.splice(E, 1);
              }
            }
          },
          1298: (xe, V, a) => {
            "use strict";
            a.d(V, { $: () => y });
            var A = a(8976),
              x = a(7223);
            class y extends A.J {
              constructor(d) {
                super(),
                  (this.manager = void 0),
                  (this._inputSources = []),
                  (this._onInputSourcesChangeEvt = void 0),
                  (this.manager = d),
                  (this._onInputSourcesChangeEvt = (h) => {
                    this._onInputSourcesChange(h);
                  }),
                  this.manager.on("start", this._onSessionStart, this),
                  this.manager.on("end", this._onSessionEnd, this);
              }
              _onSessionStart() {
                const d = this.manager.session;
                d.addEventListener(
                  "inputsourceschange",
                  this._onInputSourcesChangeEvt
                ),
                  d.addEventListener("select", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      s.fire("select", f),
                      this.fire("select", s, f);
                  }),
                  d.addEventListener("selectstart", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._selecting = !0),
                      s.fire("selectstart", f),
                      this.fire("selectstart", s, f);
                  }),
                  d.addEventListener("selectend", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._selecting = !1),
                      s.fire("selectend", f),
                      this.fire("selectend", s, f);
                  }),
                  d.addEventListener("squeeze", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      s.fire("squeeze", f),
                      this.fire("squeeze", s, f);
                  }),
                  d.addEventListener("squeezestart", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._squeezing = !0),
                      s.fire("squeezestart", f),
                      this.fire("squeezestart", s, f);
                  }),
                  d.addEventListener("squeezeend", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._squeezing = !1),
                      s.fire("squeezeend", f),
                      this.fire("squeezeend", s, f);
                  });
                const h = d.inputSources;
                for (let f = 0; f < h.length; f++) this._addInputSource(h[f]);
              }
              _onSessionEnd() {
                let d = this._inputSources.length;
                for (; d--; ) {
                  const f = this._inputSources[d];
                  this._inputSources.splice(d, 1),
                    f.fire("remove"),
                    this.fire("remove", f);
                }
                this.manager.session.removeEventListener(
                  "inputsourceschange",
                  this._onInputSourcesChangeEvt
                );
              }
              _onInputSourcesChange(d) {
                for (let h = 0; h < d.removed.length; h++)
                  this._removeInputSource(d.removed[h]);
                for (let h = 0; h < d.added.length; h++)
                  this._addInputSource(d.added[h]);
              }
              _getByInputSource(d) {
                for (let h = 0; h < this._inputSources.length; h++)
                  if (this._inputSources[h].inputSource === d)
                    return this._inputSources[h];
                return null;
              }
              _addInputSource(d) {
                if (this._getByInputSource(d)) return;
                const h = new x.g(this.manager, d);
                this._inputSources.push(h), this.fire("add", h);
              }
              _removeInputSource(d) {
                for (let h = 0; h < this._inputSources.length; h++) {
                  if (this._inputSources[h].inputSource !== d) continue;
                  const f = this._inputSources[h];
                  this._inputSources.splice(h, 1);
                  let s = f.hitTestSources.length;
                  for (; s--; ) f.hitTestSources[s].remove();
                  f.fire("remove"), this.fire("remove", f);
                  return;
                }
              }
              update(d) {
                for (let h = 0; h < this._inputSources.length; h++)
                  this._inputSources[h].update(d);
              }
              get inputSources() {
                return this._inputSources;
              }
            }
          },
          7408: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => o });
            var A = a(8976),
              x = a(5227),
              y = a(8484),
              c = a(3021),
              d = a(7481),
              h = a(184);
            const f = new d.e(),
              s = new d.e(),
              l = new y.$(),
              n = new y.$();
            class o extends A.J {
              constructor(e) {
                super(),
                  (this._manager = void 0),
                  (this._supported = !1),
                  (this._available = !1),
                  (this._lightProbeRequested = !1),
                  (this._lightProbe = null),
                  (this._intensity = 0),
                  (this._rotation = new c.k()),
                  (this._color = new x.Q()),
                  (this._sphericalHarmonics = new Float32Array(27)),
                  (this._manager = e),
                  this._manager.on("start", this._onSessionStart, this),
                  this._manager.on("end", this._onSessionEnd, this);
              }
              _onSessionStart() {
                this._manager.session.requestLightProbe &&
                  (this._supported = !0);
              }
              _onSessionEnd() {
                (this._supported = !1),
                  (this._available = !1),
                  (this._lightProbeRequested = !1),
                  (this._lightProbe = null);
              }
              start() {
                let e;
                if (
                  (this._manager.session ||
                    (e = new Error("XR session is not running")),
                  !e &&
                    this._manager.type !== h.p7 &&
                    (e = new Error("XR session type is not AR")),
                  !e &&
                    !this._supported &&
                    (e = new Error("light-estimation is not supported")),
                  ((!e && this._lightProbe) || this._lightProbeRequested) &&
                    (e = new Error("light estimation is already requested")),
                  e)
                ) {
                  this.fire("error", e);
                  return;
                }
                (this._lightProbeRequested = !0),
                  this._manager.session
                    .requestLightProbe()
                    .then((t) => {
                      const r = this._lightProbeRequested;
                      (this._lightProbeRequested = !1),
                        this._manager.active
                          ? r && (this._lightProbe = t)
                          : this.fire(
                              "error",
                              new Error("XR session is not active")
                            );
                    })
                    .catch((t) => {
                      (this._lightProbeRequested = !1), this.fire("error", t);
                    });
              }
              end() {
                (this._lightProbeRequested = !1),
                  (this._lightProbe = null),
                  (this._available = !1);
              }
              update(e) {
                if (!this._lightProbe) return;
                const t = e.getLightEstimate(this._lightProbe);
                if (!t) return;
                this._available ||
                  ((this._available = !0), this.fire("available"));
                const r = t.primaryLightIntensity;
                (this._intensity = Math.max(
                  1,
                  Math.max(r.x, Math.max(r.y, r.z))
                )),
                  f.copy(r).mulScalar(1 / this._intensity),
                  this._color.set(f.x, f.y, f.z),
                  f.set(0, 0, 0),
                  s.copy(t.primaryLightDirection),
                  l.setLookAt(s, f, d.e.UP),
                  n.setFromAxisAngle(d.e.RIGHT, 90),
                  l.mul(n),
                  this._rotation.setFromMat4(l),
                  this._sphericalHarmonics.set(
                    t.sphericalHarmonicsCoefficients
                  );
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return this._available;
              }
              get intensity() {
                return this._available ? this._intensity : null;
              }
              get color() {
                return this._available ? this._color : null;
              }
              get rotation() {
                return this._available ? this._rotation : null;
              }
              get sphericalHarmonics() {
                return this._available ? this._sphericalHarmonics : null;
              }
            }
          },
          3205: (xe, V, a) => {
            "use strict";
            a.d(V, { M: () => u });
            var A = a(8976),
              x = a(9222),
              y = a(2209),
              c = a(8484),
              d = a(3021),
              h = a(7481),
              f = a(5596),
              s = a(184),
              l = a(8839),
              n = a(7419),
              o = a(8076),
              i = a(7525),
              e = a(1298),
              t = a(7408),
              r = a(5638);
            class u extends A.J {
              constructor(_) {
                super(),
                  (this.app = void 0),
                  (this._supported = x.i.browser && !!navigator.xr),
                  (this._available = {}),
                  (this._type = null),
                  (this._spaceType = null),
                  (this._session = null),
                  (this._baseLayer = null),
                  (this._referenceSpace = null),
                  (this.depthSensing = void 0),
                  (this.domOverlay = void 0),
                  (this.hitTest = void 0),
                  (this.imageTracking = void 0),
                  (this.planeDetection = void 0),
                  (this.input = void 0),
                  (this.lightEstimation = void 0),
                  (this._camera = null),
                  (this.views = []),
                  (this.viewsPool = []),
                  (this._localPosition = new h.e()),
                  (this._localRotation = new d.k()),
                  (this._depthNear = 0.1),
                  (this._depthFar = 1e3),
                  (this._width = 0),
                  (this._height = 0),
                  (this.app = _),
                  (this._available[s.h8] = !1),
                  (this._available[s.mk] = !1),
                  (this._available[s.p7] = !1),
                  (this.depthSensing = new l.t(this)),
                  (this.domOverlay = new n.F(this)),
                  (this.hitTest = new o._(this)),
                  (this.imageTracking = new i.l(this)),
                  (this.planeDetection = new r.y(this)),
                  (this.input = new e.$(this)),
                  (this.lightEstimation = new t.u(this)),
                  this._supported &&
                    (navigator.xr.addEventListener("devicechange", () => {
                      this._deviceAvailabilityCheck();
                    }),
                    this._deviceAvailabilityCheck());
              }
              destroy() {
                this.depthSensing.destroy(), (this.depthSensing = null);
              }
              start(_, m, g, T) {
                let E = T;
                if (
                  (typeof T == "object" && (E = T.callback),
                  !this._available[m])
                ) {
                  E && E(new Error("XR is not available"));
                  return;
                }
                if (this._session) {
                  E && E(new Error("XR session is already started"));
                  return;
                }
                (this._camera = _),
                  (this._camera.camera.xr = this),
                  (this._type = m),
                  (this._spaceType = g),
                  this._setClipPlanes(_.nearClip, _.farClip);
                const M = { requiredFeatures: [g], optionalFeatures: [] };
                if (m === s.p7) {
                  if (
                    (M.optionalFeatures.push("light-estimation"),
                    M.optionalFeatures.push("hit-test"),
                    T &&
                      (T.imageTracking &&
                        this.imageTracking.supported &&
                        M.optionalFeatures.push("image-tracking"),
                      T.planeDetection &&
                        M.optionalFeatures.push("plane-detection")),
                    this.domOverlay.supported &&
                      this.domOverlay.root &&
                      (M.optionalFeatures.push("dom-overlay"),
                      (M.domOverlay = { root: this.domOverlay.root })),
                    T && T.depthSensing && this.depthSensing.supported)
                  ) {
                    M.optionalFeatures.push("depth-sensing");
                    const R = [s.Bk],
                      P = [s.wg];
                    if (T.depthSensing.usagePreference) {
                      const F = R.indexOf(T.depthSensing.usagePreference);
                      F !== -1 && R.splice(F, 1),
                        R.unshift(T.depthSensing.usagePreference);
                    }
                    if (T.depthSensing.dataFormatPreference) {
                      const F = P.indexOf(T.depthSensing.dataFormatPreference);
                      F !== -1 && P.splice(F, 1),
                        P.unshift(T.depthSensing.dataFormatPreference);
                    }
                    M.depthSensing = {
                      usagePreference: R,
                      dataFormatPreference: P,
                    };
                  }
                } else m === s.mk && M.optionalFeatures.push("hand-tracking");
                T &&
                  T.optionalFeatures &&
                  (M.optionalFeatures = M.optionalFeatures.concat(
                    T.optionalFeatures
                  )),
                  this.imageTracking.supported &&
                  this.imageTracking.images.length
                    ? this.imageTracking.prepareImages((R, P) => {
                        if (R) {
                          E && E(R), this.fire("error", R);
                          return;
                        }
                        P !== null && (M.trackedImages = P),
                          this._onStartOptionsReady(m, g, M, E);
                      })
                    : this._onStartOptionsReady(m, g, M, E);
              }
              _onStartOptionsReady(_, m, g, T) {
                navigator.xr
                  .requestSession(_, g)
                  .then((E) => {
                    this._onSessionStart(E, m, T);
                  })
                  .catch((E) => {
                    (this._camera.camera.xr = null),
                      (this._camera = null),
                      (this._type = null),
                      (this._spaceType = null),
                      T && T(E),
                      this.fire("error", E);
                  });
              }
              end(_) {
                if (!this._session) {
                  _ && _(new Error("XR Session is not initialized"));
                  return;
                }
                _ && this.once("end", _), this._session.end();
              }
              isAvailable(_) {
                return this._available[_];
              }
              _deviceAvailabilityCheck() {
                for (const _ in this._available) this._sessionSupportCheck(_);
              }
              _sessionSupportCheck(_) {
                navigator.xr
                  .isSessionSupported(_)
                  .then((m) => {
                    this._available[_] !== m &&
                      ((this._available[_] = m),
                      this.fire("available", _, m),
                      this.fire("available:" + _, m));
                  })
                  .catch((m) => {
                    this.fire("error", m);
                  });
              }
              _onSessionStart(_, m, g) {
                let T = !1;
                this._session = _;
                const E = () => {
                    this.fire("visibility:change", _.visibilityState);
                  },
                  M = () => {
                    this._setClipPlanes(
                      this._camera.nearClip,
                      this._camera.farClip
                    );
                  },
                  R = () => {
                    this._camera &&
                      (this._camera.off("set_nearClip", M),
                      this._camera.off("set_farClip", M),
                      (this._camera.camera.xr = null),
                      (this._camera = null)),
                      _.removeEventListener("end", R),
                      _.removeEventListener("visibilitychange", E),
                      T || this.fire("end"),
                      (this._session = null),
                      (this._referenceSpace = null),
                      (this.views = []),
                      (this._width = 0),
                      (this._height = 0),
                      (this._type = null),
                      (this._spaceType = null),
                      this.app.tick();
                  };
                _.addEventListener("end", R),
                  _.addEventListener("visibilitychange", E),
                  this._camera.on("set_nearClip", M),
                  this._camera.on("set_farClip", M);
                const P =
                  this.app.graphicsDevice.maxPixelRatio /
                  window.devicePixelRatio;
                (this._baseLayer = new XRWebGLLayer(
                  _,
                  this.app.graphicsDevice.gl,
                  {
                    alpha: !0,
                    depth: !0,
                    stencil: !0,
                    framebufferScaleFactor: P,
                  }
                )),
                  _.updateRenderState({
                    baseLayer: this._baseLayer,
                    depthNear: this._depthNear,
                    depthFar: this._depthFar,
                  }),
                  _.requestReferenceSpace(m)
                    .then((F) => {
                      (this._referenceSpace = F),
                        this.app.tick(),
                        g && g(null),
                        this.fire("start");
                    })
                    .catch((F) => {
                      (T = !0), _.end(), g && g(F), this.fire("error", F);
                    });
              }
              _setClipPlanes(_, m) {
                (this._depthNear === _ && this._depthFar === m) ||
                  ((this._depthNear = _),
                  (this._depthFar = m),
                  this._session &&
                    this._session.updateRenderState({
                      depthNear: this._depthNear,
                      depthFar: this._depthFar,
                    }));
              }
              update(_) {
                if (!this._session) return !1;
                const m = _.session.renderState.baseLayer.framebufferWidth,
                  g = _.session.renderState.baseLayer.framebufferHeight;
                (this._width !== m || this._height !== g) &&
                  ((this._width = m),
                  (this._height = g),
                  this.app.graphicsDevice.setResolution(m, g));
                const T = _.getViewerPose(this._referenceSpace);
                if (!T) return !1;
                const E = this.views.length,
                  M = T.views.length;
                for (; M > this.views.length; ) {
                  let b = this.viewsPool.pop();
                  b ||
                    (b = {
                      viewport: new f.Z(),
                      projMat: new c.$(),
                      viewMat: new c.$(),
                      viewOffMat: new c.$(),
                      viewInvMat: new c.$(),
                      viewInvOffMat: new c.$(),
                      projViewOffMat: new c.$(),
                      viewMat3: new y.U(),
                      position: new Float32Array(3),
                      rotation: new d.k(),
                    }),
                    this.views.push(b);
                }
                for (; M < this.views.length; )
                  this.viewsPool.push(this.views.pop());
                const R = T.transform.position,
                  P = T.transform.orientation;
                this._localPosition.set(R.x, R.y, R.z),
                  this._localRotation.set(P.x, P.y, P.z, P.w);
                const F = _.session.renderState.baseLayer;
                for (let b = 0; b < T.views.length; b++) {
                  const D = T.views[b],
                    G = this.views[b],
                    X = F.getViewport(D);
                  (G.viewport.x = X.x),
                    (G.viewport.y = X.y),
                    (G.viewport.z = X.width),
                    (G.viewport.w = X.height),
                    G.projMat.set(D.projectionMatrix),
                    G.viewMat.set(D.transform.inverse.matrix),
                    G.viewInvMat.set(D.transform.matrix);
                }
                if (E === 0 && this.views.length > 0) {
                  const b = new c.$(),
                    D = this.views[0];
                  b.copy(D.projMat);
                  const G = b.data,
                    X = (2 * Math.atan(1 / G[5]) * 180) / Math.PI,
                    ie = G[5] / G[0],
                    Q = G[14] / (G[10] + 1),
                    te = G[14] / (G[10] - 1);
                  this._camera.camera.setXrProperties({
                    aspectRatio: ie,
                    farClip: Q,
                    fov: X,
                    horizontalFov: !1,
                    nearClip: te,
                  });
                }
                return (
                  this._camera.camera._node.setLocalPosition(
                    this._localPosition
                  ),
                  this._camera.camera._node.setLocalRotation(
                    this._localRotation
                  ),
                  this.input.update(_),
                  this._type === s.p7 &&
                    (this.hitTest.supported && this.hitTest.update(_),
                    this.lightEstimation.supported &&
                      this.lightEstimation.update(_),
                    this.depthSensing.supported &&
                      this.depthSensing.update(_, T && T.views[0]),
                    this.imageTracking.supported &&
                      this.imageTracking.update(_),
                    this.planeDetection.supported &&
                      this.planeDetection.update(_)),
                  this.fire("update", _),
                  !0
                );
              }
              get supported() {
                return this._supported;
              }
              get active() {
                return !!this._session;
              }
              get type() {
                return this._type;
              }
              get spaceType() {
                return this._spaceType;
              }
              get session() {
                return this._session;
              }
              get camera() {
                return this._camera ? this._camera.entity : null;
              }
              get visibilityState() {
                return this._session ? this._session.visibilityState : null;
              }
            }
          },
          5638: (xe, V, a) => {
            "use strict";
            a.d(V, { y: () => c });
            var A = a(9222),
              x = a(8976),
              y = a(3112);
            class c extends x.J {
              constructor(h) {
                super(),
                  (this._manager = void 0),
                  (this._supported = A.i.browser && !!window.XRPlane),
                  (this._available = !1),
                  (this._planesIndex = new Map()),
                  (this._planes = null),
                  (this._manager = h),
                  this._supported &&
                    this._manager.on("end", this._onSessionEnd, this);
              }
              _onSessionEnd() {
                if (this._planes)
                  for (let h = 0; h < this._planes.length; h++)
                    this._planes[h].destroy();
                this._planesIndex.clear(),
                  (this._planes = null),
                  this._available &&
                    ((this._available = !1), this.fire("unavailable"));
              }
              update(h) {
                let f;
                if (this._available) f = h.detectedPlanes;
                else
                  try {
                    (f = h.detectedPlanes),
                      (this._planes = []),
                      (this._available = !0),
                      this.fire("available");
                  } catch (s) {
                    return;
                  }
                for (const [s, l] of this._planesIndex)
                  f.has(s) ||
                    (this._planesIndex.delete(s),
                    this._planes.splice(this._planes.indexOf(l), 1),
                    l.destroy(),
                    this.fire("remove", l));
                for (const s of f) {
                  let l = this._planesIndex.get(s);
                  l
                    ? l.update(h)
                    : ((l = new y.z(this, s)),
                      this._planesIndex.set(s, l),
                      this._planes.push(l),
                      l.update(h),
                      this.fire("add", l));
                }
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return this._available;
              }
              get planes() {
                return this._planes;
              }
            }
          },
          3112: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => d });
            var A = a(8976),
              x = a(3021),
              y = a(7481);
            let c = 0;
            class d extends A.J {
              constructor(f, s) {
                super(),
                  (this._id = void 0),
                  (this._planeDetection = void 0),
                  (this._xrPlane = void 0),
                  (this._lastChangedTime = void 0),
                  (this._orientation = void 0),
                  (this._position = new y.e()),
                  (this._rotation = new x.k()),
                  (this._id = ++c),
                  (this._planeDetection = f),
                  (this._xrPlane = s),
                  (this._lastChangedTime = s.lastChangedTime),
                  (this._orientation = s.orientation);
              }
              destroy() {
                this.fire("remove");
              }
              update(f) {
                const s = this._planeDetection._manager,
                  l = f.getPose(this._xrPlane.planeSpace, s._referenceSpace);
                l &&
                  (this._position.copy(l.transform.position),
                  this._rotation.copy(l.transform.orientation)),
                  this._lastChangedTime !== this._xrPlane.lastChangedTime &&
                    ((this._lastChangedTime = this._xrPlane.lastChangedTime),
                    this.fire("change"));
              }
              getPosition() {
                return this._position;
              }
              getRotation() {
                return this._rotation;
              }
              get id() {
                return this._id;
              }
              get orientation() {
                return this._orientation;
              }
              get points() {
                return this._xrPlane.polygon;
              }
            }
          },
          9700: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => c });
            var A = a(8976),
              x = a(7481),
              y = a(3021);
            class c extends A.J {
              constructor(h, f) {
                super(),
                  (this._image = void 0),
                  (this._width = void 0),
                  (this._bitmap = null),
                  (this._measuredWidth = 0),
                  (this._trackable = !1),
                  (this._tracking = !1),
                  (this._emulated = !1),
                  (this._pose = null),
                  (this._position = new x.e()),
                  (this._rotation = new y.k()),
                  (this._image = h),
                  (this._width = f);
              }
              get image() {
                return this._image;
              }
              set width(h) {
                this._width = h;
              }
              get width() {
                return this._width;
              }
              get trackable() {
                return this._trackable;
              }
              get tracking() {
                return this._tracking;
              }
              get emulated() {
                return this._emulated;
              }
              prepare() {
                return this._bitmap
                  ? { image: this._bitmap, widthInMeters: this._width }
                  : createImageBitmap(this._image).then(
                      (h) => (
                        (this._bitmap = h),
                        { image: this._bitmap, widthInMeters: this._width }
                      )
                    );
              }
              destroy() {
                (this._image = null),
                  (this._pose = null),
                  this._bitmap && (this._bitmap.close(), (this._bitmap = null));
              }
              getPosition() {
                return (
                  this._pose &&
                    this._position.copy(this._pose.transform.position),
                  this._position
                );
              }
              getRotation() {
                return (
                  this._pose &&
                    this._rotation.copy(this._pose.transform.orientation),
                  this._rotation
                );
              }
            }
          },
          9886: (xe, V, a) => {
            "use strict";
            a.r(V),
              a.d(V, {
                ABSOLUTE_URL: () => Bs._3,
                ACTION_GAMEPAD: () => Fe.xl,
                ACTION_KEYBOARD: () => Fe.NO,
                ACTION_MOUSE: () => Fe.Rz,
                ADDRESS_CLAMP_TO_EDGE: () => L.vq6,
                ADDRESS_MIRRORED_REPEAT: () => L.qoY,
                ADDRESS_REPEAT: () => L.x3I,
                ANIM_BLEND_1D: () => _s.m_,
                ANIM_BLEND_2D_CARTESIAN: () => _s.yP,
                ANIM_BLEND_2D_DIRECTIONAL: () => _s.sP,
                ANIM_BLEND_DIRECT: () => _s.Sq,
                ANIM_CONTROL_STATES: () => _s.BA,
                ANIM_EQUAL_TO: () => _s.HJ,
                ANIM_GREATER_THAN: () => _s.JO,
                ANIM_GREATER_THAN_EQUAL_TO: () => _s.Uk,
                ANIM_INTERRUPTION_NEXT: () => _s.a1,
                ANIM_INTERRUPTION_NEXT_PREV: () => _s.YA,
                ANIM_INTERRUPTION_NONE: () => _s.b1,
                ANIM_INTERRUPTION_PREV: () => _s.ez,
                ANIM_INTERRUPTION_PREV_NEXT: () => _s.Q2,
                ANIM_LAYER_ADDITIVE: () => _s.XY,
                ANIM_LAYER_OVERWRITE: () => _s.eU,
                ANIM_LESS_THAN: () => _s.O1,
                ANIM_LESS_THAN_EQUAL_TO: () => _s.XO,
                ANIM_NOT_EQUAL_TO: () => _s.R5,
                ANIM_PARAMETER_BOOLEAN: () => _s.dF,
                ANIM_PARAMETER_FLOAT: () => _s.h0,
                ANIM_PARAMETER_INTEGER: () => _s.nl,
                ANIM_PARAMETER_TRIGGER: () => _s.p$,
                ANIM_STATE_ANY: () => _s.JP,
                ANIM_STATE_END: () => _s.gF,
                ANIM_STATE_START: () => _s.NA,
                ASPECT_AUTO: () => Xe.LF,
                ASPECT_MANUAL: () => Xe.E5,
                ASSET_ANIMATION: () => Bs.St,
                ASSET_AUDIO: () => Bs.c4,
                ASSET_CONTAINER: () => Bs.Nd,
                ASSET_CSS: () => Bs.jS,
                ASSET_CUBEMAP: () => Bs.Jw,
                ASSET_HTML: () => Bs.bN,
                ASSET_IMAGE: () => Bs.fX,
                ASSET_JSON: () => Bs._z,
                ASSET_MATERIAL: () => Bs.Js,
                ASSET_MODEL: () => Bs.nD,
                ASSET_SCRIPT: () => Bs.Rx,
                ASSET_SHADER: () => Bs.rX,
                ASSET_TEXT: () => Bs.fA,
                ASSET_TEXTURE: () => Bs.Ps,
                ASSET_TEXTUREATLAS: () => Bs.Mc,
                AXIS_KEY: () => Fe.eU,
                AXIS_MOUSE_X: () => Fe.rE,
                AXIS_MOUSE_Y: () => Fe.yg,
                AXIS_PAD_L_X: () => Fe.e7,
                AXIS_PAD_L_Y: () => Fe.Zs,
                AXIS_PAD_R_X: () => Fe.K,
                AXIS_PAD_R_Y: () => Fe.Rt,
                AnimBinder: () => cr.E,
                AnimClip: () => Si.W,
                AnimClipHandler: () => Na.e,
                AnimComponent: () => Nn.H,
                AnimComponentLayer: () => zn.E,
                AnimComponentSystem: () => bi.k,
                AnimController: () => ba.o,
                AnimCurve: () => va.v,
                AnimData: () => Ea.C,
                AnimEvaluator: () => Sa.Z,
                AnimEvents: () => Aa.F,
                AnimSnapshot: () => Ta.g,
                AnimStateGraph: () => Ma.R,
                AnimStateGraphHandler: () => Wi.r,
                AnimTarget: () => xa.z,
                AnimTrack: () => Ca.z,
                Animation: () => $i.X5,
                AnimationComponent: () => Fn.C,
                AnimationComponentSystem: () => Un.X,
                AnimationHandler: () => Tn.T,
                AppBase: () => _n.v,
                AppOptions: () => Ln.q,
                Application: () => Bn.l,
                Asset: () => Ur.V,
                AssetListLoader: () => wa,
                AssetReference: () => Ia.Y,
                AssetRegistry: () => Da.k,
                AudioHandler: () => xn.z,
                AudioListenerComponent: () => sn.e,
                AudioListenerComponentSystem: () => kn.X,
                AudioSourceComponent: () => Wn.N,
                AudioSourceComponentSystem: () => Vn.o,
                BAKE_COLOR: () => Xe.gF,
                BAKE_COLORDIR: () => Xe.N9,
                BINDGROUP_MESH: () => L.pNk,
                BINDGROUP_VIEW: () => L.PyI,
                BLENDEQUATION_ADD: () => L.KLp,
                BLENDEQUATION_MAX: () => L.pJd,
                BLENDEQUATION_MIN: () => L.tAf,
                BLENDEQUATION_REVERSE_SUBTRACT: () => L.OgC,
                BLENDEQUATION_SUBTRACT: () => L.XwU,
                BLENDMODE_CONSTANT: () => L.IrR,
                BLENDMODE_CONSTANT_ALPHA: () => Yt.$I,
                BLENDMODE_CONSTANT_COLOR: () => Yt.s5,
                BLENDMODE_DST_ALPHA: () => L.OUj,
                BLENDMODE_DST_COLOR: () => L.FHY,
                BLENDMODE_ONE: () => L.qa5,
                BLENDMODE_ONE_MINUS_CONSTANT: () => L.iQ7,
                BLENDMODE_ONE_MINUS_CONSTANT_ALPHA: () => Yt.XA,
                BLENDMODE_ONE_MINUS_CONSTANT_COLOR: () => Yt.eW,
                BLENDMODE_ONE_MINUS_DST_ALPHA: () => L.u_5,
                BLENDMODE_ONE_MINUS_DST_COLOR: () => L.$Qt,
                BLENDMODE_ONE_MINUS_SRC_ALPHA: () => L.dIP,
                BLENDMODE_ONE_MINUS_SRC_COLOR: () => L.UCl,
                BLENDMODE_SRC_ALPHA: () => L.LDz,
                BLENDMODE_SRC_ALPHA_SATURATE: () => L.Jjv,
                BLENDMODE_SRC_COLOR: () => L.iRx,
                BLENDMODE_ZERO: () => L.seI,
                BLEND_ADDITIVE: () => Xe.dc,
                BLEND_ADDITIVEALPHA: () => Xe.HG,
                BLEND_MAX: () => Xe.HV,
                BLEND_MIN: () => Xe.Z7,
                BLEND_MULTIPLICATIVE: () => Xe.$M,
                BLEND_MULTIPLICATIVE2X: () => Xe.LL,
                BLEND_NONE: () => Xe.Rj,
                BLEND_NORMAL: () => Xe.i9,
                BLEND_PREMULTIPLIED: () => Xe.bY,
                BLEND_SCREEN: () => Xe.rZ,
                BLEND_SUBTRACTIVE: () => Xe.Ni,
                BLUR_BOX: () => Xe.WX,
                BLUR_GAUSSIAN: () => Xe.wA,
                BODYFLAG_KINEMATIC_OBJECT: () => rs.Fm,
                BODYFLAG_NORESPONSE_OBJECT: () => rs.ce,
                BODYFLAG_STATIC_OBJECT: () => rs.uU,
                BODYGROUP_DEFAULT: () => rs.md,
                BODYGROUP_DYNAMIC: () => rs.Um,
                BODYGROUP_ENGINE_1: () => rs.zK,
                BODYGROUP_ENGINE_2: () => rs.s8,
                BODYGROUP_ENGINE_3: () => rs.N6,
                BODYGROUP_KINEMATIC: () => rs.qX,
                BODYGROUP_NONE: () => rs.NH,
                BODYGROUP_STATIC: () => rs.JV,
                BODYGROUP_TRIGGER: () => rs.lB,
                BODYGROUP_USER_1: () => rs.k,
                BODYGROUP_USER_2: () => rs.rO,
                BODYGROUP_USER_3: () => rs.yq,
                BODYGROUP_USER_4: () => rs.rz,
                BODYGROUP_USER_5: () => rs.yb,
                BODYGROUP_USER_6: () => rs.rU,
                BODYGROUP_USER_7: () => rs.iU,
                BODYGROUP_USER_8: () => rs.r3,
                BODYMASK_ALL: () => rs.DD,
                BODYMASK_NONE: () => rs.Uh,
                BODYMASK_NOT_STATIC: () => rs.EE,
                BODYMASK_NOT_STATIC_KINEMATIC: () => rs.Er,
                BODYMASK_STATIC: () => rs.cn,
                BODYSTATE_ACTIVE_TAG: () => rs.UQ,
                BODYSTATE_DISABLE_DEACTIVATION: () => rs.dC,
                BODYSTATE_DISABLE_SIMULATION: () => rs.$5,
                BODYSTATE_ISLAND_SLEEPING: () => rs.oo,
                BODYSTATE_WANTS_DEACTIVATION: () => rs.kp,
                BODYTYPE_DYNAMIC: () => rs.DA,
                BODYTYPE_KINEMATIC: () => rs.LY,
                BODYTYPE_STATIC: () => rs.I3,
                BUFFER_DYNAMIC: () => L.pCO,
                BUFFER_GPUDYNAMIC: () => L.xHx,
                BUFFER_STATIC: () => L.y1K,
                BUFFER_STREAM: () => L.oDV,
                BUTTON_TRANSITION_MODE_SPRITE_CHANGE: () => mn.s,
                BUTTON_TRANSITION_MODE_TINT: () => mn.Z,
                BasicMaterial: () => bs.E,
                Batch: () => Ms.l,
                BatchGroup: () => Ts.w,
                BatchManager: () => Os.Y,
                BinaryHandler: () => kr._,
                BlendState: () => Pe.t,
                BoundingBox: () => D.I,
                BoundingSphere: () => G.i,
                Bundle: () => Ba.N,
                BundleHandler: () => yo.z,
                BundleRegistry: () => Fa.a,
                ButtonComponent: () => Gn.Q,
                ButtonComponentSystem: () => jn.z,
                CHUNKAPI_1_51: () => L.p6E,
                CHUNKAPI_1_55: () => L.paJ,
                CHUNKAPI_1_56: () => L.isr,
                CHUNKAPI_1_57: () => L.bQd,
                CHUNKAPI_1_58: () => L.idj,
                CHUNKAPI_1_60: () => L.JUn,
                CHUNKAPI_1_62: () => L.tBC,
                CHUNKAPI_1_65: () => L.Cvi,
                CLEARFLAG_COLOR: () => L.Sue,
                CLEARFLAG_DEPTH: () => L.YKI,
                CLEARFLAG_STENCIL: () => L.zwO,
                COMPUPDATED_BLEND: () => Xe.Fe,
                COMPUPDATED_CAMERAS: () => Xe.mJ,
                COMPUPDATED_INSTANCES: () => Xe.s0,
                COMPUPDATED_LIGHTS: () => Xe.DA,
                CUBEFACE_NEGX: () => L.sp4,
                CUBEFACE_NEGY: () => L.lNQ,
                CUBEFACE_NEGZ: () => L.IIP,
                CUBEFACE_POSX: () => L.EhU,
                CUBEFACE_POSY: () => L.LAV,
                CUBEFACE_POSZ: () => L.EYH,
                CUBEPROJ_BOX: () => Xe.fJ,
                CUBEPROJ_NONE: () => Xe.ip,
                CULLFACE_BACK: () => L.K1r,
                CULLFACE_FRONT: () => L.CWw,
                CULLFACE_FRONTANDBACK: () => L.AQ1,
                CULLFACE_NONE: () => L.pLF,
                CURVE_CARDINAL: () => v.vl,
                CURVE_CATMULL: () => v.vd,
                CURVE_LINEAR: () => v.io,
                CURVE_SMOOTHSTEP: () => v.tS,
                CURVE_SPLINE: () => v.WO,
                CURVE_STEP: () => v.RP,
                Camera: () => li.i,
                CameraComponent: () => gn.n,
                CameraComponentSystem: () => Tr.k,
                CanvasFont: () => La,
                ChunkBuilder: () => je.v,
                CollisionComponent: () => $n.I,
                CollisionComponentSystem: () => yn.v,
                Color: () => m.Q,
                Command: () => Bi.u,
                Component: () => xr.u,
                ComponentSystem: () => vn.r,
                ComponentSystemRegistry: () => Ar.S,
                ContactPoint: () => Sn.z8,
                ContactResult: () => Sn.Ic,
                ContainerHandler: () => wi.a,
                ContainerResource: () => wi.I,
                ContextCreationError: () => Yt.$n,
                Controller: () => Qt.x,
                CssHandler: () => An.C,
                CubemapHandler: () => vo.s,
                Curve: () => g.I,
                CurveSet: () => T.K,
                DETAILMODE_ADD: () => Xe.TE,
                DETAILMODE_MAX: () => Xe.yh,
                DETAILMODE_MIN: () => Xe.on,
                DETAILMODE_MUL: () => Xe.QK,
                DETAILMODE_OVERLAY: () => Xe.qK,
                DETAILMODE_SCREEN: () => Xe.Ww,
                DEVICETYPE_WEBGL1: () => L.ERE,
                DEVICETYPE_WEBGL2: () => L.Nwc,
                DEVICETYPE_WEBGPU: () => L.yK5,
                DISTANCE_EXPONENTIAL: () => _e.an,
                DISTANCE_INVERSE: () => _e.Jq,
                DISTANCE_LINEAR: () => _e.q9,
                DefaultAnimBinder: () => Pa.x,
                DepthState: () => ct.H,
                ELEMENTTYPE_FLOAT32: () => Yt.fQ,
                ELEMENTTYPE_GROUP: () => Ni.Dk,
                ELEMENTTYPE_IMAGE: () => Ni.b5,
                ELEMENTTYPE_INT16: () => Yt.s_,
                ELEMENTTYPE_INT32: () => Yt.W2,
                ELEMENTTYPE_INT8: () => Yt.Br,
                ELEMENTTYPE_TEXT: () => Ni.l$,
                ELEMENTTYPE_UINT16: () => Yt.lB,
                ELEMENTTYPE_UINT32: () => Yt.bl,
                ELEMENTTYPE_UINT8: () => Yt.WC,
                EMITTERSHAPE_BOX: () => Xe.Ql,
                EMITTERSHAPE_SPHERE: () => Xe.M2,
                EVENT_GAMEPADCONNECTED: () => Fe.mz,
                EVENT_GAMEPADDISCONNECTED: () => Fe.Ut,
                EVENT_KEYDOWN: () => Fe.Jn,
                EVENT_KEYUP: () => Fe.WT,
                EVENT_MOUSEDOWN: () => Fe.B$,
                EVENT_MOUSEMOVE: () => Fe.SV,
                EVENT_MOUSEUP: () => Fe.Ol,
                EVENT_MOUSEWHEEL: () => Fe.yX,
                EVENT_SELECT: () => Fe.Af,
                EVENT_SELECTEND: () => Fe.V0,
                EVENT_SELECTSTART: () => Fe.aI,
                EVENT_TOUCHCANCEL: () => Fe.pU,
                EVENT_TOUCHEND: () => Fe.OM,
                EVENT_TOUCHMOVE: () => Fe.OJ,
                EVENT_TOUCHSTART: () => Fe.n3,
                ElementComponent: () => Cr._,
                ElementComponentSystem: () => Pr.B,
                ElementDragHelper: () => br.h,
                ElementInput: () => an.FW,
                ElementInputEvent: () => an.B7,
                ElementMouseEvent: () => an.e5,
                ElementSelectEvent: () => an.z5,
                ElementTouchEvent: () => an.Oj,
                Entity: () => ns.w,
                EntityReference: () => qn.D,
                EnvLighting: () => qi.S,
                EventHandler: () => s.J,
                FILLMODE_FILL_WINDOW: () => ni.kY,
                FILLMODE_KEEP_ASPECT: () => ni.Wx,
                FILLMODE_NONE: () => ni.Ol,
                FILTER_LINEAR: () => L.DrA,
                FILTER_LINEAR_MIPMAP_LINEAR: () => L.qn_,
                FILTER_LINEAR_MIPMAP_NEAREST: () => L.reG,
                FILTER_NEAREST: () => L.uhC,
                FILTER_NEAREST_MIPMAP_LINEAR: () => L.hs2,
                FILTER_NEAREST_MIPMAP_NEAREST: () => L.GLw,
                FITMODE_CONTAIN: () => Ni.qW,
                FITMODE_COVER: () => Ni.Do,
                FITMODE_STRETCH: () => Ni.$B,
                FITTING_BOTH: () => zs.eF,
                FITTING_NONE: () => zs.Jb,
                FITTING_SHRINK: () => zs.g7,
                FITTING_STRETCH: () => zs.S3,
                FOG_EXP: () => Xe.hP,
                FOG_EXP2: () => Xe.RV,
                FOG_LINEAR: () => Xe.ZS,
                FOG_NONE: () => Xe.qX,
                FONT_BITMAP: () => Nr.M,
                FONT_MSDF: () => Nr.P,
                FRESNEL_NONE: () => Xe.hV,
                FRESNEL_SCHLICK: () => Xe.SU,
                FUNC_ALWAYS: () => L.vpx,
                FUNC_EQUAL: () => L.sTv,
                FUNC_GREATER: () => L.q3J,
                FUNC_GREATEREQUAL: () => L.wGs,
                FUNC_LESS: () => L.v1A,
                FUNC_LESSEQUAL: () => L.fsA,
                FUNC_NEVER: () => L.gaK,
                FUNC_NOTEQUAL: () => L.v_N,
                FolderHandler: () => za.p,
                Font: () => Oa.K,
                FontHandler: () => Eo.q,
                ForwardRenderer: () => fi.v,
                Frustum: () => X.P,
                GAMMA_NONE: () => Xe.hc,
                GAMMA_SRGB: () => Xe.Jd,
                GAMMA_SRGBFAST: () => Xe.t4,
                GAMMA_SRGBHDR: () => Xe.Rz,
                GamePads: () => zt.$1,
                GraphNode: () => pi.t,
                GraphicsDevice: () => ge.G,
                HierarchyHandler: () => So.u,
                HtmlHandler: () => ka.g,
                Http: () => ds.l,
                I18n: () => Za.F,
                INDEXFORMAT_UINT16: () => L.c02,
                INDEXFORMAT_UINT32: () => L.gpl,
                INDEXFORMAT_UINT8: () => L.zYw,
                INTERPOLATION_CUBIC: () => nn.yQ,
                INTERPOLATION_LINEAR: () => nn.tF,
                INTERPOLATION_STEP: () => nn.Un,
                ImageElement: () => er.C,
                IndexBuffer: () => ze.h,
                IndexedList: () => l.Q,
                JointComponent: () => tr.K,
                JointComponentSystem: () => Hn.X,
                JsonHandler: () => ri.F,
                JsonStandardMaterialParser: () => Ka.m,
                KEY_0: () => Fe.Pm,
                KEY_1: () => Fe.W0,
                KEY_2: () => Fe.bJ,
                KEY_3: () => Fe.IK,
                KEY_4: () => Fe.Ps,
                KEY_5: () => Fe.W6,
                KEY_6: () => Fe.P9,
                KEY_7: () => Fe.IQ,
                KEY_8: () => Fe.bS,
                KEY_9: () => Fe.Wy,
                KEY_A: () => Fe.W8,
                KEY_ADD: () => Fe.MN,
                KEY_ALT: () => Fe.cH,
                KEY_B: () => Fe.bR,
                KEY_BACKSPACE: () => Fe.ye,
                KEY_BACK_SLASH: () => Fe.C8,
                KEY_C: () => Fe.WN,
                KEY_CAPS_LOCK: () => Fe.QC,
                KEY_CLOSE_BRACKET: () => Fe.uS,
                KEY_COMMA: () => Fe.ao,
                KEY_CONTEXT_MENU: () => Fe.Y_,
                KEY_CONTROL: () => Fe.S$,
                KEY_D: () => Fe.bw,
                KEY_DECIMAL: () => Fe.yq,
                KEY_DELETE: () => Fe.Kb,
                KEY_DIVIDE: () => Fe.ov,
                KEY_DOWN: () => Fe.R,
                KEY_E: () => Fe.i_,
                KEY_END: () => Fe.u5,
                KEY_ENTER: () => Fe.Ri,
                KEY_EQUAL: () => Fe.v_,
                KEY_ESCAPE: () => Fe.s6,
                KEY_F: () => Fe.Pf,
                KEY_F1: () => Fe.sV,
                KEY_F10: () => Fe.rP,
                KEY_F11: () => Fe.iR,
                KEY_F12: () => Fe.Yw,
                KEY_F2: () => Fe.lY,
                KEY_F3: () => Fe.sA,
                KEY_F4: () => Fe.lb,
                KEY_F5: () => Fe.sP,
                KEY_F6: () => Fe.zx,
                KEY_F7: () => Fe.ez,
                KEY_F8: () => Fe.l7,
                KEY_F9: () => Fe.sJ,
                KEY_G: () => Fe.Dw,
                KEY_H: () => Fe.b0,
                KEY_HOME: () => Fe.iX,
                KEY_I: () => Fe.iC,
                KEY_INSERT: () => Fe.Ql,
                KEY_J: () => Fe.bF,
                KEY_K: () => Fe.ih,
                KEY_L: () => Fe.Po,
                KEY_LEFT: () => Fe.iU,
                KEY_M: () => Fe.W2,
                KEY_META: () => Fe.qI,
                KEY_MULTIPLY: () => Fe.TX,
                KEY_N: () => Fe.bL,
                KEY_NUMPAD_0: () => Fe.hr,
                KEY_NUMPAD_1: () => Fe.o5,
                KEY_NUMPAD_2: () => Fe.vN,
                KEY_NUMPAD_3: () => Fe.Cp,
                KEY_NUMPAD_4: () => Fe.v2,
                KEY_NUMPAD_5: () => Fe.CE,
                KEY_NUMPAD_6: () => Fe.vH,
                KEY_NUMPAD_7: () => Fe.Cj,
                KEY_NUMPAD_8: () => Fe.vy,
                KEY_NUMPAD_9: () => Fe.C,
                KEY_O: () => Fe.in,
                KEY_OPEN_BRACKET: () => Fe.I8,
                KEY_P: () => Fe.P8,
                KEY_PAGE_DOWN: () => Fe.dL,
                KEY_PAGE_UP: () => Fe.YY,
                KEY_PAUSE: () => Fe.jR,
                KEY_PERIOD: () => Fe.kP,
                KEY_PRINT_SCREEN: () => Fe.d6,
                KEY_Q: () => Fe.WK,
                KEY_R: () => Fe.bt,
                KEY_RETURN: () => Fe.XC,
                KEY_RIGHT: () => Fe.zh,
                KEY_S: () => Fe.Wp,
                KEY_SEMICOLON: () => Fe.mZ,
                KEY_SEPARATOR: () => Fe.sf,
                KEY_SHIFT: () => Fe.re,
                KEY_SLASH: () => Fe._X,
                KEY_SPACE: () => Fe.iy,
                KEY_SUBTRACT: () => Fe.Ny,
                KEY_T: () => Fe.b_,
                KEY_TAB: () => Fe.aW,
                KEY_U: () => Fe.WQ,
                KEY_UP: () => Fe.gf,
                KEY_V: () => Fe.PT,
                KEY_W: () => Fe.Wv,
                KEY_WINDOWS: () => Fe.cm,
                KEY_X: () => Fe.bC,
                KEY_Y: () => Fe.ie,
                KEY_Z: () => Fe.bh,
                Key: () => $i.Uz,
                Keyboard: () => Lt.s,
                KeyboardEvent: () => $t.k,
                LAYERID_DEPTH: () => Xe.$9,
                LAYERID_IMMEDIATE: () => Xe.t0,
                LAYERID_SKYBOX: () => Xe.CT,
                LAYERID_UI: () => Xe.Qe,
                LAYERID_WORLD: () => Xe.uE,
                LAYER_FX: () => Xe.Jo,
                LAYER_GIZMO: () => Xe.zW,
                LAYER_HUD: () => Xe.m2,
                LAYER_WORLD: () => Xe.$1,
                LIGHTFALLOFF_INVERSESQUARED: () => Xe.Nk,
                LIGHTFALLOFF_LINEAR: () => Xe.$7,
                LIGHTSHAPE_DISK: () => Xe.iU,
                LIGHTSHAPE_PUNCTUAL: () => Xe.j0,
                LIGHTSHAPE_RECT: () => Xe.tt,
                LIGHTSHAPE_SPHERE: () => Xe.SY,
                LIGHTTYPE_COUNT: () => Xe.rU,
                LIGHTTYPE_DIRECTIONAL: () => Xe.kx,
                LIGHTTYPE_OMNI: () => Xe.dG,
                LIGHTTYPE_POINT: () => Xe.ce,
                LIGHTTYPE_SPOT: () => Xe.Gy,
                LINEBATCH_GIZMO: () => Xe.WW,
                LINEBATCH_OVERLAY: () => Xe.On,
                LINEBATCH_WORLD: () => Xe.CD,
                Layer: () => _i.W,
                LayerComposition: () => mi.e,
                LayoutCalculator: () => Mr.b,
                LayoutChildComponent: () => sr.Y,
                LayoutChildComponentSystem: () => Kn.h,
                LayoutGroupComponent: () => zi.b,
                LayoutGroupComponentSystem: () => sa.K,
                Light: () => gi.v,
                LightComponent: () => ia.Mm,
                LightComponentSystem: () => na.t,
                LightingParams: () => yi.p,
                Lightmapper: () => ra.W,
                LitMaterial: () => Ls,
                LitOptions: () => Yt.cb,
                LitShaderOptions: () => Gs.n,
                LocalizedAsset: () => Ra.w,
                MASK_AFFECT_DYNAMIC: () => Xe.Xj,
                MASK_AFFECT_LIGHTMAPPED: () => Xe.be,
                MASK_BAKE: () => Xe.XE,
                MOTION_FREE: () => En.CH,
                MOTION_LIMITED: () => En.ko,
                MOTION_LOCKED: () => En.it,
                MOUSEBUTTON_LEFT: () => Fe.wB,
                MOUSEBUTTON_MIDDLE: () => Fe.aG,
                MOUSEBUTTON_NONE: () => Fe.Z5,
                MOUSEBUTTON_RIGHT: () => Fe.fR,
                Mat3: () => E.U,
                Mat4: () => M.$,
                Material: () => Cs.i,
                MaterialHandler: () => Wr.U,
                Mesh: () => Li.e,
                MeshInstance: () => Bi.F,
                Model: () => Ai.K,
                ModelComponent: () => ir.D,
                ModelComponentSystem: () => ps.a,
                ModelHandler: () => Wa.s,
                Morph: () => Xi.T,
                MorphInstance: () => Yi.q,
                MorphTarget: () => Mn.M,
                Mouse: () => Bt.K,
                MouseEvent: () => Nt.C,
                Node: () => $i.bP,
                ORIENTATION_HORIZONTAL: () => Xe.Sz,
                ORIENTATION_VERTICAL: () => Xe.Yn,
                OrientedBox: () => J,
                PAD_1: () => Fe.cQ,
                PAD_2: () => Fe.js,
                PAD_3: () => Fe.c$,
                PAD_4: () => Fe.jN,
                PAD_DOWN: () => Fe.Jf,
                PAD_FACE_1: () => Fe.ok,
                PAD_FACE_2: () => Fe.vY,
                PAD_FACE_3: () => Fe.oF,
                PAD_FACE_4: () => Fe.hO,
                PAD_LEFT: () => Fe.yV,
                PAD_L_SHOULDER_1: () => Fe.Wx,
                PAD_L_SHOULDER_2: () => Fe.b,
                PAD_L_STICK_BUTTON: () => Fe.JN,
                PAD_L_STICK_X: () => Fe.tc,
                PAD_L_STICK_Y: () => Fe.AQ,
                PAD_RIGHT: () => Fe.aD,
                PAD_R_SHOULDER_1: () => Fe.Ci,
                PAD_R_SHOULDER_2: () => Fe.vl,
                PAD_R_STICK_BUTTON: () => Fe.xA,
                PAD_R_STICK_X: () => Fe.fi,
                PAD_R_STICK_Y: () => Fe.mW,
                PAD_SELECT: () => Fe.ni,
                PAD_START: () => Fe.Rg,
                PAD_UP: () => Fe.Ct,
                PAD_VENDOR: () => Fe.LN,
                PARTICLEMODE_CPU: () => Xe.Hx,
                PARTICLEMODE_GPU: () => Xe.JQ,
                PARTICLEORIENTATION_EMITTER: () => Xe.YU,
                PARTICLEORIENTATION_SCREEN: () => Xe.gp,
                PARTICLEORIENTATION_WORLD: () => Xe.KQ,
                PARTICLESORT_DISTANCE: () => Xe.nc,
                PARTICLESORT_NEWER_FIRST: () => Xe.EB,
                PARTICLESORT_NONE: () => Xe.WL,
                PARTICLESORT_OLDER_FIRST: () => Xe.Zt,
                PIXELFORMAT_111110F: () => L.s_z,
                PIXELFORMAT_A8: () => L.SWx,
                PIXELFORMAT_ASTC_4x4: () => L.jYy,
                PIXELFORMAT_ATC_RGB: () => L.x8T,
                PIXELFORMAT_ATC_RGBA: () => L.qEN,
                PIXELFORMAT_BGRA8: () => L.$$M,
                PIXELFORMAT_DEPTH: () => L.Wbd,
                PIXELFORMAT_DEPTHSTENCIL: () => L.Mg$,
                PIXELFORMAT_DXT1: () => L.S$n,
                PIXELFORMAT_DXT3: () => L.EPU,
                PIXELFORMAT_DXT5: () => L.E_6,
                PIXELFORMAT_ETC1: () => L.G24,
                PIXELFORMAT_ETC2_RGB: () => L.ZyS,
                PIXELFORMAT_ETC2_RGBA: () => L.ArW,
                PIXELFORMAT_L8: () => L.RSt,
                PIXELFORMAT_L8_A8: () => Yt.B5,
                PIXELFORMAT_LA8: () => L._3,
                PIXELFORMAT_PVRTC_2BPP_RGBA_1: () => L.apD,
                PIXELFORMAT_PVRTC_2BPP_RGB_1: () => L.TyC,
                PIXELFORMAT_PVRTC_4BPP_RGBA_1: () => L.Ijy,
                PIXELFORMAT_PVRTC_4BPP_RGB_1: () => L.xyx,
                PIXELFORMAT_R32F: () => L.IQA,
                PIXELFORMAT_R4_G4_B4_A4: () => Yt.S9,
                PIXELFORMAT_R5_G5_B5_A1: () => Yt.Gd,
                PIXELFORMAT_R5_G6_B5: () => Yt.Ib,
                PIXELFORMAT_R8_G8_B8: () => Yt.A6,
                PIXELFORMAT_R8_G8_B8_A8: () => Yt._r,
                PIXELFORMAT_RGB16F: () => L.Nnq,
                PIXELFORMAT_RGB32F: () => L.FQW,
                PIXELFORMAT_RGB565: () => L.kqw,
                PIXELFORMAT_RGB8: () => L.akF,
                PIXELFORMAT_RGBA16F: () => L.WBN,
                PIXELFORMAT_RGBA32F: () => L.s7h,
                PIXELFORMAT_RGBA4: () => L.LDn,
                PIXELFORMAT_RGBA5551: () => L.zIz,
                PIXELFORMAT_RGBA8: () => L.Lxj,
                PIXELFORMAT_SRGB: () => L.lsY,
                PIXELFORMAT_SRGBA: () => L.Mzz,
                PRIMITIVE_LINELOOP: () => L.HsS,
                PRIMITIVE_LINES: () => L.EEU,
                PRIMITIVE_LINESTRIP: () => L.PTM,
                PRIMITIVE_POINTS: () => L._AA,
                PRIMITIVE_TRIANGLES: () => L.Qpk,
                PRIMITIVE_TRIFAN: () => L.zl$,
                PRIMITIVE_TRISTRIP: () => L.SF$,
                PROJECTION_ORTHOGRAPHIC: () => Xe.RD,
                PROJECTION_PERSPECTIVE: () => Xe.$J,
                ParticleEmitter: () => Ci.v,
                ParticleSystemComponent: () => wr.r,
                ParticleSystemComponentSystem: () => aa.s,
                PhongMaterial: () => Yt.o7,
                Picker: () => Ua.L,
                Plane: () => ve.Z,
                PostEffect: () => en.o,
                PostEffectQueue: () => oa.T,
                ProgramLibrary: () => tn.M,
                QuadRender: () => hn.o,
                Quat: () => R.k,
                RENDERSTYLE_POINTS: () => Xe.KM,
                RENDERSTYLE_SOLID: () => Xe.OZ,
                RENDERSTYLE_WIREFRAME: () => Xe.l3,
                RESOLUTION_AUTO: () => ni.hD,
                RESOLUTION_FIXED: () => ni.GL,
                RIGIDBODY_ACTIVE_TAG: () => Yt.k5,
                RIGIDBODY_CF_KINEMATIC_OBJECT: () => Yt.O_,
                RIGIDBODY_CF_NORESPONSE_OBJECT: () => Yt.Xt,
                RIGIDBODY_CF_STATIC_OBJECT: () => Yt.dt,
                RIGIDBODY_DISABLE_DEACTIVATION: () => Yt.lZ,
                RIGIDBODY_DISABLE_SIMULATION: () => Yt.B1,
                RIGIDBODY_ISLAND_SLEEPING: () => Yt.A$,
                RIGIDBODY_TYPE_DYNAMIC: () => Yt.rm,
                RIGIDBODY_TYPE_KINEMATIC: () => Yt.Hy,
                RIGIDBODY_TYPE_STATIC: () => Yt.YF,
                RIGIDBODY_WANTS_DEACTIVATION: () => Yt.Qe,
                Ray: () => ie.R,
                RaycastResult: () => Sn.DL,
                ReadStream: () => o.B,
                RenderComponent: () => la.y,
                RenderComponentSystem: () => Ir.J,
                RenderHandler: () => To.H,
                RenderTarget: () => k.O,
                ResourceHandler: () => Vr,
                ResourceLoader: () => xo.W,
                RigidBodyComponent: () => _o.H,
                RigidBodyComponentSystem: () => Sn.K1,
                SAMPLETYPE_DEPTH: () => L.pqC,
                SAMPLETYPE_FLOAT: () => L.CZm,
                SAMPLETYPE_UNFILTERABLE_FLOAT: () => L.cRA,
                SCALEMODE_BLEND: () => Or.G,
                SCALEMODE_NONE: () => Or.b,
                SCROLLBAR_VISIBILITY_SHOW_ALWAYS: () => ki.aZ,
                SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: () => ki.xS,
                SCROLL_MODE_BOUNCE: () => ki.nQ,
                SCROLL_MODE_CLAMP: () => ki.Gn,
                SCROLL_MODE_INFINITE: () => ki.ll,
                SEMANTIC_ATTR: () => L.pY7,
                SEMANTIC_ATTR0: () => L.NFm,
                SEMANTIC_ATTR1: () => L.UhA,
                SEMANTIC_ATTR10: () => L.yib,
                SEMANTIC_ATTR11: () => L.rGZ,
                SEMANTIC_ATTR12: () => L.yZ0,
                SEMANTIC_ATTR13: () => L.pov,
                SEMANTIC_ATTR14: () => L.yof,
                SEMANTIC_ATTR15: () => L.FHg,
                SEMANTIC_ATTR2: () => L.$1R,
                SEMANTIC_ATTR3: () => L.G3_,
                SEMANTIC_ATTR4: () => L.NLq,
                SEMANTIC_ATTR5: () => L.UnE,
                SEMANTIC_ATTR6: () => L.Nqe,
                SEMANTIC_ATTR7: () => L.G9c,
                SEMANTIC_ATTR8: () => L.$_V,
                SEMANTIC_ATTR9: () => L.URU,
                SEMANTIC_BLENDINDICES: () => L.aVd,
                SEMANTIC_BLENDWEIGHT: () => L.Hn_,
                SEMANTIC_COLOR: () => L.F8$,
                SEMANTIC_NORMAL: () => L.XF6,
                SEMANTIC_POSITION: () => L.JYe,
                SEMANTIC_TANGENT: () => L.h3u,
                SEMANTIC_TEXCOORD: () => L.CWz,
                SEMANTIC_TEXCOORD0: () => L.slc,
                SEMANTIC_TEXCOORD1: () => L.zEd,
                SEMANTIC_TEXCOORD2: () => L.GHH,
                SEMANTIC_TEXCOORD3: () => L.z5t,
                SEMANTIC_TEXCOORD4: () => L.GWP,
                SEMANTIC_TEXCOORD5: () => L.NdR,
                SEMANTIC_TEXCOORD6: () => L.GBD,
                SEMANTIC_TEXCOORD7: () => L.zZp,
                SHADERDEF_DIRLM: () => Xe.CO,
                SHADERDEF_INSTANCING: () => Xe.Q$,
                SHADERDEF_LM: () => Xe.tT,
                SHADERDEF_LMAMBIENT: () => Xe.tE,
                SHADERDEF_MORPH_NORMAL: () => Xe.ov,
                SHADERDEF_MORPH_POSITION: () => Xe.Ck,
                SHADERDEF_MORPH_TEXTURE_BASED: () => Xe.uJ,
                SHADERDEF_NOSHADOW: () => Xe.b2,
                SHADERDEF_SCREENSPACE: () => Xe.yr,
                SHADERDEF_SKIN: () => Xe.Df,
                SHADERDEF_TANGENTS: () => Xe.k,
                SHADERDEF_UV0: () => Xe.Jq,
                SHADERDEF_UV1: () => Xe.Cn,
                SHADERDEF_VCOLOR: () => Xe.L$,
                SHADERLANGUAGE_GLSL: () => L.BzK,
                SHADERLANGUAGE_WGSL: () => L.g80,
                SHADERPASS_ALBEDO: () => Xe.jy,
                SHADERPASS_AO: () => Xe.IY,
                SHADERPASS_EMISSION: () => Xe.zp,
                SHADERPASS_FORWARD: () => Xe.BV,
                SHADERPASS_GLOSS: () => Xe.Af,
                SHADERPASS_LIGHTING: () => Xe.As,
                SHADERPASS_METALNESS: () => Xe.uT,
                SHADERPASS_OPACITY: () => Xe.z8,
                SHADERPASS_SPECULARITY: () => Xe.hI,
                SHADERPASS_UV0: () => Xe.$2,
                SHADERPASS_WORLDNORMAL: () => Xe.z5,
                SHADERSTAGE_COMPUTE: () => L.ULN,
                SHADERSTAGE_FRAGMENT: () => L.Jnj,
                SHADERSTAGE_VERTEX: () => L.rXb,
                SHADERTAG_MATERIAL: () => L.EB8,
                SHADER_DEPTH: () => Xe.w8,
                SHADER_FORWARD: () => Xe.OP,
                SHADER_FORWARDHDR: () => Xe.Su,
                SHADER_PICK: () => Xe.cz,
                SHADER_SHADOW: () => Xe.vT,
                SHADOWUPDATE_NONE: () => Xe.Jb,
                SHADOWUPDATE_REALTIME: () => Xe.M5,
                SHADOWUPDATE_THISFRAME: () => Xe.e3,
                SHADOW_DEPTH: () => Xe.v2,
                SHADOW_PCF1: () => Xe.Mk,
                SHADOW_PCF3: () => Xe.MF,
                SHADOW_PCF5: () => Xe.Mq,
                SHADOW_PCSS: () => Xe.vJ,
                SHADOW_VSM16: () => Xe.xv,
                SHADOW_VSM32: () => Xe.DT,
                SHADOW_VSM8: () => Xe.oR,
                SORTKEY_DEPTH: () => Xe.pB,
                SORTKEY_FORWARD: () => Xe.Gn,
                SORTMODE_BACK2FRONT: () => Xe.PD,
                SORTMODE_CUSTOM: () => Xe.eQ,
                SORTMODE_FRONT2BACK: () => Xe.rG,
                SORTMODE_MANUAL: () => Xe.BE,
                SORTMODE_MATERIALMESH: () => Xe.R9,
                SORTMODE_NONE: () => Xe.lU,
                SPECOCC_AO: () => Xe.aP,
                SPECOCC_GLOSSDEPENDENT: () => Xe.Nt,
                SPECOCC_NONE: () => Xe.Av,
                SPECULAR_BLINN: () => Xe.SB,
                SPECULAR_PHONG: () => Xe.Tp,
                SPRITETYPE_ANIMATED: () => lr.s,
                SPRITETYPE_SIMPLE: () => lr.z,
                SPRITE_RENDERMODE_SIMPLE: () => Xe.hA,
                SPRITE_RENDERMODE_SLICED: () => Xe.FC,
                SPRITE_RENDERMODE_TILED: () => Xe.jZ,
                STENCILOP_DECREMENT: () => L.Srv,
                STENCILOP_DECREMENTWRAP: () => L.y9P,
                STENCILOP_INCREMENT: () => L.G1V,
                STENCILOP_INCREMENTWRAP: () => L.KbR,
                STENCILOP_INVERT: () => L.FqP,
                STENCILOP_KEEP: () => L.GU6,
                STENCILOP_REPLACE: () => L.L4b,
                STENCILOP_ZERO: () => L.LW2,
                Scene: () => Zi.Z,
                SceneHandler: () => Ao.f,
                SceneRegistry: () => Dr.C,
                SceneRegistryItem: () => Rr.j,
                SceneSettingsHandler: () => Ti,
                ScopeId: () => et.w,
                ScopeSpace: () => _t.D,
                ScreenComponent: () => ha.g,
                ScreenComponentSystem: () => Lr.R,
                ScriptAttributes: () => Gr.x,
                ScriptComponent: () => nr.d,
                ScriptComponentSystem: () => Br.k,
                ScriptHandler: () => Va.S,
                ScriptLegacyComponent: () => rr.u,
                ScriptLegacyComponentSystem: () => ar.B,
                ScriptRegistry: () => Xa.r,
                ScriptType: () => Ya.e,
                ScrollViewComponent: () => ua.I,
                ScrollViewComponentSystem: () => fa.D,
                ScrollbarComponent: () => ca.G,
                ScrollbarComponentSystem: () => da.z,
                Shader: () => $e.M,
                ShaderHandler: () => Co.e,
                ShaderPass: () => cn.p,
                SingleContactResult: () => Sn.KT,
                Skeleton: () => Dn.E,
                Skin: () => Qi.M,
                SkinBatchInstance: () => Js.D,
                SkinInstance: () => Ji.h,
                SortedLoopArray: () => i.B,
                Sound: () => ls.A,
                SoundComponent: () => Mi.F,
                SoundComponentSystem: () => or.m,
                SoundInstance: () => Ps.X,
                SoundInstance3d: () => us.S,
                SoundManager: () => os.x,
                SoundSlot: () => pa.a,
                Sprite: () => dn.k,
                SpriteAnimationClip: () => mo.u,
                SpriteComponent: () => _a.V,
                SpriteComponentSystem: () => ma.Y,
                SpriteHandler: () => Po.Q,
                StandardMaterial: () => un.F,
                StandardMaterialOptions: () => wn.l,
                StencilParameters: () => j.n,
                TEXHINT_ASSET: () => L.Y$N,
                TEXHINT_LIGHTMAP: () => L.cGo,
                TEXHINT_NONE: () => L.mfI,
                TEXHINT_SHADOWMAP: () => L.Odm,
                TEXTUREDIMENSION_1D: () => L.Kod,
                TEXTUREDIMENSION_2D: () => L.HeG,
                TEXTUREDIMENSION_2D_ARRAY: () => L.hwK,
                TEXTUREDIMENSION_3D: () => L.EuA,
                TEXTUREDIMENSION_CUBE: () => L.GGM,
                TEXTUREDIMENSION_CUBE_ARRAY: () => L.WhW,
                TEXTURELOCK_READ: () => L.odD,
                TEXTURELOCK_WRITE: () => L.$Q8,
                TEXTUREPROJECTION_CUBE: () => L.$mg,
                TEXTUREPROJECTION_EQUIRECT: () => L.CG0,
                TEXTUREPROJECTION_NONE: () => L.w7A,
                TEXTUREPROJECTION_OCTAHEDRAL: () => L.vct,
                TEXTURETYPE_DEFAULT: () => L.s64,
                TEXTURETYPE_RGBE: () => L.TOD,
                TEXTURETYPE_RGBM: () => L.fW0,
                TEXTURETYPE_RGBP: () => L.mEg,
                TEXTURETYPE_SWIZZLEGGGR: () => L.wmq,
                TONEMAP_ACES: () => Xe.c2,
                TONEMAP_ACES2: () => Xe.I1,
                TONEMAP_FILMIC: () => Xe.c1,
                TONEMAP_HEJL: () => Xe.hF,
                TONEMAP_LINEAR: () => Xe.ll,
                TRACEID_BINDGROUPFORMAT_ALLOC: () => A.DE,
                TRACEID_BINDGROUP_ALLOC: () => A.KO,
                TRACEID_GPU_TIMINGS: () => A.yR,
                TRACEID_PIPELINELAYOUT_ALLOC: () => A.Mu,
                TRACEID_RENDERPIPELINE_ALLOC: () => A.eq,
                TRACEID_RENDER_ACTION: () => A.rC,
                TRACEID_RENDER_FRAME: () => A.ed,
                TRACEID_RENDER_FRAME_TIME: () => A.oo,
                TRACEID_RENDER_PASS: () => A.sh,
                TRACEID_RENDER_PASS_DETAIL: () => A.sD,
                TRACEID_RENDER_QUEUE: () => A.OY,
                TRACEID_RENDER_TARGET_ALLOC: () => A.Mq,
                TRACEID_SHADER_ALLOC: () => A.ZF,
                TRACEID_SHADER_COMPILE: () => A.tV,
                TRACEID_TEXTURES: () => A.u8,
                TRACEID_TEXTURE_ALLOC: () => A.$p,
                TRACEID_VRAM_IB: () => A.IF,
                TRACEID_VRAM_TEXTURE: () => A.Kt,
                TRACEID_VRAM_VB: () => A.ZB,
                TRACE_ID_ELEMENT: () => A.PH,
                TYPE_FLOAT32: () => L.n$B,
                TYPE_INT16: () => L.kF,
                TYPE_INT32: () => L.uVx,
                TYPE_INT8: () => L.VSW,
                TYPE_UINT16: () => L.rvO,
                TYPE_UINT32: () => L.Bz3,
                TYPE_UINT8: () => L.EUX,
                Tags: () => e.Y,
                Template: () => hr.B,
                TemplateHandler: () => ja.R,
                TextElement: () => Fr.S,
                TextHandler: () => Ha.O,
                Texture: () => Qe.g,
                TextureAtlas: () => In.L,
                TextureAtlasHandler: () => dr.P,
                TextureHandler: () => rn.y,
                TextureParser: () => rn.H,
                TextureUtils: () => Ft.V,
                Touch: () => kt.Up,
                TouchDevice: () => es.a,
                TouchEvent: () => kt.sD,
                Tracing: () => u.l,
                TransformFeedback: () => Tt,
                UNIFORMTYPE_BOOL: () => L.MX7,
                UNIFORMTYPE_BVEC2: () => L.enT,
                UNIFORMTYPE_BVEC3: () => L.ZKF,
                UNIFORMTYPE_BVEC4: () => L.S8r,
                UNIFORMTYPE_FLOAT: () => L.GF5,
                UNIFORMTYPE_FLOATARRAY: () => L.Nv2,
                UNIFORMTYPE_INT: () => L.pG9,
                UNIFORMTYPE_IVEC2: () => L.dD6,
                UNIFORMTYPE_IVEC3: () => L.Yj5,
                UNIFORMTYPE_IVEC4: () => L.RsJ,
                UNIFORMTYPE_MAT2: () => L.Eb5,
                UNIFORMTYPE_MAT3: () => L.xzR,
                UNIFORMTYPE_MAT4: () => L.CPw,
                UNIFORMTYPE_MAT4ARRAY: () => L.TWL,
                UNIFORMTYPE_TEXTURE2D: () => L.rlY,
                UNIFORMTYPE_TEXTURE2D_SHADOW: () => L.yLH,
                UNIFORMTYPE_TEXTURE3D: () => L.q8s,
                UNIFORMTYPE_TEXTURECUBE: () => L.KpZ,
                UNIFORMTYPE_TEXTURECUBE_SHADOW: () => L.zYo,
                UNIFORMTYPE_VEC2: () => L.Qhq,
                UNIFORMTYPE_VEC2ARRAY: () => L.FEO,
                UNIFORMTYPE_VEC3: () => L.XAr,
                UNIFORMTYPE_VEC3ARRAY: () => L.iYc,
                UNIFORMTYPE_VEC4: () => L.cyR,
                UNIFORMTYPE_VEC4ARRAY: () => L.$Cd,
                UNIFORM_BUFFER_DEFAULT_SLOT_NAME: () => L.rb7,
                URI: () => r.r,
                UnsupportedBrowserError: () => Yt.mn,
                VIEW_CENTER: () => Xe._S,
                VIEW_LEFT: () => Xe.IT,
                VIEW_RIGHT: () => Xe.$x,
                Vec2: () => P.Z,
                Vec3: () => F.e,
                Vec4: () => b.Z,
                VertexBuffer: () => lt.R,
                VertexFormat: () => ft.y,
                VertexIterator: () => gt.P,
                WasmModule: () => n.F,
                WebglGraphicsDevice: () => nt.z,
                WebgpuGraphicsDevice: () => Ke,
                WorldClusters: () => js.q,
                XRDEPTHSENSINGFORMAT_F32: () => Ss.W9,
                XRDEPTHSENSINGFORMAT_L8A8: () => Ss.wg,
                XRDEPTHSENSINGUSAGE_CPU: () => Ss.Bk,
                XRDEPTHSENSINGUSAGE_GPU: () => Ss.nz,
                XRHAND_LEFT: () => Ss.uZ,
                XRHAND_NONE: () => Ss.VS,
                XRHAND_RIGHT: () => Ss.Di,
                XRPAD_A: () => Fe.io,
                XRPAD_B: () => Fe.br,
                XRPAD_SQUEEZE: () => Fe.Pw,
                XRPAD_STICK_BUTTON: () => Fe.WA,
                XRPAD_STICK_X: () => Fe.__,
                XRPAD_STICK_Y: () => Fe.Tw,
                XRPAD_TOUCHPAD_BUTTON: () => Fe.Mw,
                XRPAD_TOUCHPAD_X: () => Fe.az,
                XRPAD_TOUCHPAD_Y: () => Fe.VW,
                XRPAD_TRIGGER: () => Fe.LA,
                XRSPACE_BOUNDEDFLOOR: () => Ss.LF,
                XRSPACE_LOCAL: () => Ss.vi,
                XRSPACE_LOCALFLOOR: () => Ss.tf,
                XRSPACE_UNBOUNDED: () => Ss.wP,
                XRSPACE_VIEWER: () => Ss.EM,
                XRTARGETRAY_GAZE: () => Ss.Ew,
                XRTARGETRAY_POINTER: () => Ss.cX,
                XRTARGETRAY_SCREEN: () => Ss.dp,
                XRTRACKABLE_MESH: () => Ss.ux,
                XRTRACKABLE_PLANE: () => Ss.fC,
                XRTRACKABLE_POINT: () => Ss.xH,
                XRTYPE_AR: () => Ss.p7,
                XRTYPE_INLINE: () => Ss.h8,
                XRTYPE_VR: () => Ss.mk,
                XrDepthSensing: () => $a.t,
                XrDomOverlay: () => Xr.F,
                XrHitTest: () => eo._,
                XrHitTestSource: () => Hr.Z,
                XrImageTracking: () => ur.l,
                XrInput: () => Qa.$,
                XrInputSource: () => Ja.g,
                XrLightEstimation: () => jr.u,
                XrManager: () => qa.M,
                XrPlane: () => to.z,
                XrPlaneDetection: () => Yr.y,
                XrTrackedImage: () => Kr.A,
                ZoneComponent: () => ga.i,
                ZoneComponentSystem: () => ya.b,
                anim: () => Yt.A5,
                app: () => _n.y,
                apps: () => x.lA,
                asset: () => Yt.LY,
                audio: () => Yt.z7,
                basisInitialize: () => go.r,
                basisSetDownloadConfig: () => Yt.Rs,
                bindGroupNames: () => L.jK8,
                calculateNormals: () => vs.Tj,
                calculateTangents: () => vs.hS,
                common: () => x.sh,
                config: () => x.$W,
                createBox: () => vs.ge,
                createCapsule: () => vs.qY,
                createCone: () => vs.Eu,
                createCylinder: () => vs.T8,
                createGraphicsDevice: () => ot,
                createMesh: () => vs.qk,
                createPlane: () => vs.FK,
                createScript: () => Zn.so,
                createShader: () => Fi.gx,
                createShaderFromCode: () => Fi.$$,
                createSphere: () => vs.wh,
                createStyle: () => Yt.H6,
                createTorus: () => vs.s6,
                createURI: () => r.K,
                data: () => x.p,
                dracoInitialize: () => Yn.o,
                drawFullscreenQuad: () => Yt.xY,
                drawQuadWithShader: () => fs.l,
                drawTexture: () => fs._,
                events: () => y.A,
                extend: () => x.X$,
                getPixelFormatArrayType: () => L.FxX,
                getReservedScriptNames: () => Zn.Iz,
                getTouchTargetCoords: () => kt.rT,
                gfx: () => Yt._o,
                guid: () => c.O,
                http: () => ds.L,
                inherits: () => Yt.B,
                input: () => Yt.hF,
                isCompressedPixelFormat: () => L.Nvm,
                log: () => Yt.Rm,
                makeArray: () => Yt.gv,
                math: () => _.D,
                now: () => t.t,
                path: () => d.A,
                pixelFormatInfo: () => L.s7S,
                platform: () => h.i,
                posteffect: () => Yt.om,
                prefilterCubemap: () => Yt.R0,
                programlib: () => Yt.kQ,
                registerScript: () => Zn.tX,
                reprojectTexture: () => pn.Q,
                revision: () => x.QL,
                scene: () => Yt.JH,
                script: () => On.K,
                semanticToLocation: () => L.tJj,
                shFromCubemap: () => fn,
                shaderChunks: () => Ui.G,
                shaderChunksLightmapper: () => Rn.f,
                shadowTypeToString: () => Xe.BS,
                shape: () => Yt.cW,
                string: () => f.Y,
                time: () => Yt.kB,
                type: () => x.NW,
                typedArrayIndexFormats: () => L.SGA,
                typedArrayIndexFormatsByteSize: () => L.lBd,
                typedArrayToType: () => L.xcK,
                typedArrayTypes: () => L.B8J,
                typedArrayTypesByteSize: () => L.sYG,
                uniformTypeToName: () => L.nJN,
                version: () => x.rE,
                vertexTypesNames: () => L.qsh,
              });
            var A = a(6380),
              x = a(8506),
              y = a(9048),
              c = a(4172),
              d = a(1870),
              h = a(9222),
              f = a(8772),
              s = a(8976),
              l = a(4529),
              n = a(5562),
              o = a(9482),
              i = a(5767),
              e = a(244),
              t = a(9516),
              r = a(2079),
              u = a(27),
              v = a(4041),
              _ = a(8656),
              m = a(5227),
              g = a(5567),
              T = a(2358),
              E = a(2209),
              M = a(8484),
              R = a(3021),
              P = a(7994),
              F = a(7481),
              b = a(5596),
              D = a(7915),
              G = a(5145),
              X = a(3221),
              ie = a(9663);
            const Q = new ie.R(),
              te = new F.e(),
              ae = new G.i(),
              Z = new M.$();
            class J {
              constructor(oe = new M.$(), Ee = new F.e(0.5, 0.5, 0.5)) {
                (this.halfExtents = void 0),
                  (this._modelTransform = void 0),
                  (this._worldTransform = void 0),
                  (this._aabb = void 0),
                  (this.halfExtents = Ee),
                  (this._modelTransform = oe.clone().invert()),
                  (this._worldTransform = oe.clone()),
                  (this._aabb = new D.I(new F.e(), this.halfExtents));
              }
              set worldTransform(oe) {
                this._worldTransform.copy(oe),
                  this._modelTransform.copy(oe).invert();
              }
              get worldTransform() {
                return this._worldTransform;
              }
              intersectsRay(oe, Ee) {
                if (
                  (this._modelTransform.transformPoint(oe.origin, Q.origin),
                  this._modelTransform.transformVector(
                    oe.direction,
                    Q.direction
                  ),
                  Ee)
                ) {
                  const be = this._aabb._intersectsRay(Q, Ee);
                  return (
                    Z.copy(this._modelTransform)
                      .invert()
                      .transformPoint(Ee, Ee),
                    be
                  );
                }
                return this._aabb._fastIntersectsRay(Q);
              }
              containsPoint(oe) {
                return (
                  this._modelTransform.transformPoint(oe, te),
                  this._aabb.containsPoint(te)
                );
              }
              intersectsBoundingSphere(oe) {
                return (
                  this._modelTransform.transformPoint(oe.center, ae.center),
                  (ae.radius = oe.radius),
                  !!this._aabb.intersectsBoundingSphere(ae)
                );
              }
            }
            var ve = a(7337),
              _e = a(1145),
              L = a(1630),
              ge = a(4461),
              k = a(9061),
              j = a(2640);
            class B {
              constructor() {
                this.bindGroup = void 0;
              }
              update(oe) {
                this.destroy();
                const Ee = oe.device,
                  be = this.createDescriptor(Ee, oe);
                this.bindGroup = Ee.wgpu.createBindGroup(be);
              }
              destroy() {
                this.bindGroup = null;
              }
              createDescriptor(oe, Ee) {
                const be = [],
                  We = Ee.format;
                let He = 0;
                return (
                  Ee.uniformBuffers.forEach((dt) => {
                    const pt = dt.persistent
                      ? dt.impl.buffer
                      : dt.allocation.gpuBuffer.buffer;
                    be.push({
                      binding: He++,
                      resource: {
                        buffer: pt,
                        offset: 0,
                        size: dt.format.byteSize,
                      },
                    });
                  }),
                  Ee.textures.forEach((dt, pt) => {
                    const Mt = dt.impl,
                      It = We.textureFormats[pt],
                      Dt = Mt.getView(oe);
                    be.push({ binding: He++, resource: Dt });
                    const Gt = Mt.getSampler(oe, It.sampleType);
                    be.push({ binding: He++, resource: Gt });
                  }),
                  { layout: Ee.format.impl.bindGroupLayout, entries: be }
                );
              }
            }
            var $ = a(271);
            class le {
              static shaderStage(oe) {
                let Ee = 0;
                return (
                  oe & L.rXb && (Ee |= GPUShaderStage.VERTEX),
                  oe & L.Jnj && (Ee |= GPUShaderStage.FRAGMENT),
                  oe & L.ULN && (Ee |= GPUShaderStage.COMPUTE),
                  Ee
                );
              }
            }
            const O = [];
            (O[L.CZm] = "filtering"),
              (O[L.cRA] = "non-filtering"),
              (O[L.pqC] = "comparison");
            const Y = [];
            (Y[L.CZm] = "float"),
              (Y[L.cRA] = "unfilterable-float"),
              (Y[L.pqC] = "depth");
            const ne = new $.w();
            class de {
              constructor(oe) {
                const Ee = oe.device,
                  { key: be, descr: We } = this.createDescriptor(oe);
                (this.key = ne.get(be)),
                  (this.bindGroupLayout = Ee.wgpu.createBindGroupLayout(We));
              }
              destroy() {
                this.bindGroupLayout = null;
              }
              loseContext() {}
              getTextureSlot(oe, Ee) {
                return oe.bufferFormats.length + Ee * 2;
              }
              createDescriptor(oe) {
                const Ee = [];
                let be = "",
                  We = 0;
                return (
                  oe.bufferFormats.forEach((st) => {
                    const dt = le.shaderStage(st.visibility);
                    (be += `#${We}U:${dt}`),
                      Ee.push({
                        binding: We++,
                        visibility: dt,
                        buffer: { type: "uniform", hasDynamicOffset: !0 },
                      });
                  }),
                  oe.textureFormats.forEach((st) => {
                    const dt = le.shaderStage(st.visibility),
                      pt = st.sampleType,
                      Mt = st.textureDimension,
                      It = !1,
                      Dt = Y[pt];
                    (be += `#${We}T:${dt}-${Dt}-${Mt}-${It}`),
                      Ee.push({
                        binding: We++,
                        visibility: dt,
                        texture: {
                          sampleType: Dt,
                          viewDimension: Mt,
                          multisampled: It,
                        },
                      });
                    const Gt = O[pt];
                    (be += `#${We}S:${dt}-${Gt}`),
                      Ee.push({
                        binding: We++,
                        visibility: dt,
                        sampler: { type: Gt },
                      });
                  }),
                  { key: be, descr: { entries: Ee } }
                );
              }
            }
            class re {
              constructor() {
                this.buffer = null;
              }
              destroy(oe) {
                this.buffer && (this.buffer.destroy(), (this.buffer = null));
              }
              get initialized() {
                return !!this.buffer;
              }
              loseContext() {}
              unlock(oe, Ee, be, We) {
                var He, st;
                const dt = oe.wgpu;
                if (!this.buffer) {
                  const Dt = (We.byteLength + 3) & -4;
                  this.buffer = oe.wgpu.createBuffer({
                    size: Dt,
                    usage: be | GPUBufferUsage.COPY_DST,
                  });
                }
                const pt = (He = We.byteOffset) != null ? He : 0,
                  Mt = new Uint8Array(
                    (st = We.buffer) != null ? st : We,
                    pt,
                    We.byteLength
                  ),
                  It = new Uint8Array(this.buffer.size);
                It.set(Mt),
                  dt.queue.writeBuffer(this.buffer, 0, It, 0, It.length);
              }
            }
            class I extends re {
              constructor(oe) {
                super(),
                  (this.format = null),
                  (this.format = oe.format === L.c02 ? "uint16" : "uint32");
              }
              unlock(oe) {
                const Ee = oe.device;
                super.unlock(Ee, oe.usage, GPUBufferUsage.INDEX, oe.storage);
              }
            }
            var w = a(8981);
            const N = {
                equals: function (Wt, oe) {
                  if (Wt.size !== oe.size) return !1;
                  for (let Ee = 0; Ee < Wt.length; Ee++)
                    if (Wt[Ee] !== oe[Ee]) return !1;
                  return !0;
                },
              },
              W = [];
            (W[L.VSW] = "sint8"),
              (W[L.EUX] = "uint8"),
              (W[L.kF] = "sint16"),
              (W[L.rvO] = "uint16"),
              (W[L.uVx] = "sint32"),
              (W[L.Bz3] = "uint32"),
              (W[L.n$B] = "float32");
            const he = [];
            (he[L.VSW] = "snorm8"),
              (he[L.EUX] = "unorm8"),
              (he[L.kF] = "snorm16"),
              (he[L.rvO] = "unorm16"),
              (he[L.uVx] = "sint32"),
              (he[L.Bz3] = "uint32"),
              (he[L.n$B] = "float32");
            class ue {
              constructor() {
                this.cache = new Map();
              }
              get(oe, Ee = null) {
                const be = this.getKey(oe, Ee);
                let We = this.cache.get(be);
                return (
                  We || ((We = this.create(oe, Ee)), this.cache.set(be, We)), We
                );
              }
              getKey(oe, Ee = null) {
                return `${oe == null ? void 0 : oe.renderingHashString}-${
                  Ee == null ? void 0 : Ee.renderingHashString
                }`;
              }
              create(oe, Ee) {
                const be = [],
                  We = (He) => {
                    const st = He.interleaved,
                      dt = He.instancing ? "instance" : "vertex";
                    let pt = [];
                    const Mt = He.elements.length;
                    for (let It = 0; It < Mt; It++) {
                      const Dt = He.elements[It],
                        Gt = L.tJj[Dt.name],
                        Vt = Dt.normalize ? he : W;
                      pt.push({
                        shaderLocation: Gt,
                        offset: st ? Dt.offset : 0,
                        format: `${Vt[Dt.dataType]}${
                          Dt.numComponents > 1 ? "x" + Dt.numComponents : ""
                        }`,
                      }),
                        (!st || It === Mt - 1) &&
                          (be.push({
                            attributes: pt,
                            arrayStride: Dt.stride,
                            stepMode: dt,
                          }),
                          (pt = []));
                    }
                  };
                return oe && We(oe), Ee && We(Ee), be;
              }
            }
            const ye = [
                "point-list",
                "line-list",
                void 0,
                "line-strip",
                "triangle-list",
                "triangle-strip",
                void 0,
              ],
              Oe = ["add", "subtract", "reverse-subtract", "min", "max"],
              Ae = [
                "zero",
                "one",
                "src",
                "one-minus-src",
                "dst",
                "one-minus-dst",
                "src-alpha",
                "src-alpha-saturated",
                "one-minus-src-alpha",
                "dst-alpha",
                "one-minus-dst-alpha",
                "constant",
                "one-minus-constant",
              ],
              ke = [
                "never",
                "less",
                "equal",
                "less-equal",
                "greater",
                "not-equal",
                "greater-equal",
                "always",
              ],
              Ue = ["none", "back", "front"],
              Ge = [
                "keep",
                "zero",
                "replace",
                "increment-clamp",
                "increment-wrap",
                "decrement-clamp",
                "decrement-wrap",
                "invert",
              ],
              ht = [];
            class me {
              constructor() {
                (this.pipeline = void 0), (this.hashes = void 0);
              }
            }
            class z {
              constructor(oe) {
                (this.lookupHashes = new Uint32Array(13)),
                  (this.device = oe),
                  (this.vertexBufferLayout = new ue()),
                  (this.cache = new Map());
              }
              get(oe, Ee, be, We, He, st, dt, pt, Mt, It, Dt, Gt) {
                var Vt, Jt, ms, ks, Ds, qs, vi, di;
                const cs = this.lookupHashes;
                (cs[0] = oe.type),
                  (cs[1] = We.id),
                  (cs[2] = Mt),
                  (cs[3] = pt.key),
                  (cs[4] = dt.key),
                  (cs[5] =
                    (Vt = Ee == null ? void 0 : Ee.renderingHash) != null
                      ? Vt
                      : 0),
                  (cs[6] =
                    (Jt = be == null ? void 0 : be.renderingHash) != null
                      ? Jt
                      : 0),
                  (cs[7] = He.impl.key),
                  (cs[8] =
                    (ms = (ks = st[0]) == null ? void 0 : ks.key) != null
                      ? ms
                      : 0),
                  (cs[9] =
                    (Ds = (qs = st[1]) == null ? void 0 : qs.key) != null
                      ? Ds
                      : 0),
                  (cs[10] =
                    (vi = (di = st[2]) == null ? void 0 : di.key) != null
                      ? vi
                      : 0),
                  (cs[11] = It ? Dt.key : 0),
                  (cs[12] = It ? Gt.key : 0);
                const hs = (0, w.m)(cs);
                let as = this.cache.get(hs);
                if (as)
                  for (let ei = 0; ei < as.length; ei++) {
                    const Ws = as[ei];
                    if (N.equals(Ws.hashes, cs)) return Ws.pipeline;
                  }
                const Es = ye[oe.type],
                  ai = this.getPipelineLayout(st),
                  ws = this.vertexBufferLayout.get(Ee, be),
                  xs = new me();
                return (
                  (xs.hashes = new Uint32Array(cs)),
                  (xs.pipeline = this.create(
                    Es,
                    We,
                    He,
                    ai,
                    dt,
                    pt,
                    ws,
                    Mt,
                    It,
                    Dt,
                    Gt
                  )),
                  as ? as.push(xs) : (as = [xs]),
                  this.cache.set(hs, as),
                  xs.pipeline
                );
              }
              getPipelineLayout(oe) {
                oe.forEach((We) => {
                  ht.push(We.bindGroupLayout);
                });
                const Ee = { bindGroupLayouts: ht },
                  be = this.device.wgpu.createPipelineLayout(Ee);
                return (ht.length = 0), be;
              }
              getBlend(oe) {
                let Ee;
                return (
                  oe.blend &&
                    (Ee = {
                      color: {
                        operation: Oe[oe.colorOp],
                        srcFactor: Ae[oe.colorSrcFactor],
                        dstFactor: Ae[oe.colorDstFactor],
                      },
                      alpha: {
                        operation: Oe[oe.alphaOp],
                        srcFactor: Ae[oe.alphaSrcFactor],
                        dstFactor: Ae[oe.alphaDstFactor],
                      },
                    }),
                  Ee
                );
              }
              getDepthStencil(oe, Ee, be, We, He) {
                let st;
                const { depth: dt, stencil: pt } = Ee;
                return (
                  (dt || pt) &&
                    ((st = { format: Ee.impl.depthFormat }),
                    dt
                      ? ((st.depthWriteEnabled = oe.write),
                        (st.depthCompare = ke[oe.func]))
                      : ((st.depthWriteEnabled = !1),
                        (st.depthCompare = "always")),
                    pt &&
                      be &&
                      ((st.stencilReadMas = We.readMask),
                      (st.stencilWriteMask = We.writeMask),
                      (st.stencilFront = {
                        compare: ke[We.func],
                        failOp: Ge[We.fail],
                        passOp: Ge[We.zpass],
                        depthFailOp: Ge[We.zfail],
                      }),
                      (st.stencilBack = {
                        compare: ke[He.func],
                        failOp: Ge[He.fail],
                        passOp: Ge[He.zpass],
                        depthFailOp: Ge[He.zfail],
                      }))),
                  st
                );
              }
              create(oe, Ee, be, We, He, st, dt, pt, Mt, It, Dt) {
                const Gt = this.device.wgpu,
                  Vt = Ee.impl,
                  Jt = {
                    vertex: {
                      module: Vt.getVertexShaderModule(),
                      entryPoint: Vt.vertexEntryPoint,
                      buffers: dt,
                    },
                    fragment: {
                      module: Vt.getFragmentShaderModule(),
                      entryPoint: Vt.fragmentEntryPoint,
                      targets: [],
                    },
                    primitive: {
                      topology: oe,
                      frontFace: "ccw",
                      cullMode: Ue[pt],
                    },
                    depthStencil: this.getDepthStencil(st, be, Mt, It, Dt),
                    multisample: { count: be.samples },
                    layout: We,
                  },
                  ms = be.impl.colorAttachments;
                if (ms.length > 0) {
                  let Ds = 0;
                  He.redWrite && (Ds |= GPUColorWrite.RED),
                    He.greenWrite && (Ds |= GPUColorWrite.GREEN),
                    He.blueWrite && (Ds |= GPUColorWrite.BLUE),
                    He.alphaWrite && (Ds |= GPUColorWrite.ALPHA);
                  const qs = this.getBlend(He);
                  ms.forEach((vi) => {
                    Jt.fragment.targets.push({
                      format: vi.format,
                      writeMask: Ds,
                      blend: qs,
                    });
                  });
                }
                return Gt.createRenderPipeline(Jt);
              }
            }
            const K = new $.w();
            class Te {
              constructor() {
                (this.format = void 0), (this.multisampledBuffer = void 0);
              }
              destroy() {
                var oe;
                (oe = this.multisampledBuffer) == null || oe.destroy(),
                  (this.multisampledBuffer = null);
              }
            }
            class H {
              constructor(oe) {
                (this.initialized = !1),
                  (this.key = void 0),
                  (this.colorAttachments = []),
                  (this.depthFormat = void 0),
                  (this.hasStencil = void 0),
                  (this.depthTexture = null),
                  (this.depthTextureInternal = !1),
                  (this.assignedColorTexture = null),
                  (this.renderPassDescriptor = {}),
                  (this.renderTarget = oe),
                  oe._colorBuffers &&
                    oe._colorBuffers.forEach((Ee, be) => {
                      this.setColorAttachment(be, void 0, Ee.impl.format);
                    }),
                  this.updateKey();
              }
              destroy(oe) {
                if (((this.initialized = !1), this.depthTextureInternal)) {
                  var Ee;
                  (Ee = this.depthTexture) == null || Ee.destroy(),
                    (this.depthTexture = null);
                }
                (this.assignedColorTexture = null),
                  this.colorAttachments.forEach((be) => {
                    be.destroy();
                  }),
                  (this.colorAttachments.length = 0);
              }
              updateKey() {
                const oe = this.renderTarget;
                let Ee = `${oe.samples}:${
                  oe.depth ? this.depthFormat : "nodepth"
                }`;
                this.colorAttachments.forEach((be) => {
                  Ee += `:${be.format}`;
                }),
                  (this.key = K.get(Ee));
              }
              setDepthFormat(oe) {
                (this.depthFormat = oe),
                  (this.hasStencil = oe === "depth24plus-stencil8");
              }
              assignColorTexture(oe) {
                this.assignedColorTexture = oe;
                const Ee = oe.createView(),
                  be = this.renderPassDescriptor.colorAttachments[0];
                this.renderTarget.samples > 1
                  ? (be.resolveTarget = Ee)
                  : (be.view = Ee),
                  this.setColorAttachment(0, void 0, oe.format),
                  this.updateKey();
              }
              setColorAttachment(oe, Ee, be) {
                this.colorAttachments[oe] ||
                  (this.colorAttachments[oe] = new Te()),
                  Ee && (this.colorAttachments[oe].multisampledBuffer = Ee),
                  be && (this.colorAttachments[oe].format = be);
              }
              init(oe, Ee) {
                var be, We;
                const He = oe.wgpu;
                this.initDepthStencil(He, Ee),
                  (this.renderPassDescriptor.colorAttachments = []);
                const st =
                  (be = (We = Ee._colorBuffers) == null ? void 0 : We.length) !=
                  null
                    ? be
                    : 1;
                for (let pt = 0; pt < st; ++pt) {
                  var dt;
                  const Mt = this.initColor(He, Ee, pt),
                    It =
                      pt === 0 &&
                      ((dt = this.colorAttachments[0]) == null
                        ? void 0
                        : dt.format);
                  (Mt.view || It) &&
                    this.renderPassDescriptor.colorAttachments.push(Mt);
                }
                this.initialized = !0;
              }
              initDepthStencil(oe, Ee) {
                const {
                  samples: be,
                  width: We,
                  height: He,
                  depth: st,
                  depthBuffer: dt,
                } = Ee;
                if (st || dt) {
                  if (dt)
                    (this.depthTexture = dt.impl.gpuTexture),
                      this.setDepthFormat(dt.impl.format);
                  else {
                    this.setDepthFormat("depth24plus-stencil8");
                    const pt = {
                      size: [We, He, 1],
                      dimension: "2d",
                      sampleCount: be,
                      format: this.depthFormat,
                      usage: GPUTextureUsage.RENDER_ATTACHMENT,
                    };
                    be > 1
                      ? (pt.usage |= GPUTextureUsage.TEXTURE_BINDING)
                      : (pt.usage |= GPUTextureUsage.COPY_SRC),
                      (this.depthTexture = oe.createTexture(pt)),
                      (this.depthTextureInternal = !0);
                  }
                  this.renderPassDescriptor.depthStencilAttachment = {
                    view: this.depthTexture.createView(),
                  };
                }
              }
              initColor(oe, Ee, be) {
                const We = {},
                  { samples: He, width: st, height: dt } = Ee,
                  pt = Ee.getColorBuffer(be);
                let Mt = null;
                if (
                  (pt &&
                    (pt.cubemap
                      ? (Mt = pt.impl.createView({
                          dimension: "2d",
                          baseArrayLayer: Ee.face,
                          arrayLayerCount: 1,
                          mipLevelCount: 1,
                        }))
                      : (Mt = pt.impl.createView({ mipLevelCount: 1 }))),
                  He > 1)
                ) {
                  var It, Dt;
                  const Gt = {
                      size: [st, dt, 1],
                      dimension: "2d",
                      sampleCount: He,
                      format:
                        (It =
                          (Dt = this.colorAttachments[be]) == null
                            ? void 0
                            : Dt.format) != null
                          ? It
                          : pt.impl.format,
                      usage: GPUTextureUsage.RENDER_ATTACHMENT,
                    },
                    Vt = oe.createTexture(Gt);
                  this.setColorAttachment(be, Vt),
                    (We.view = Vt.createView()),
                    (We.resolveTarget = Mt);
                } else We.view = Mt;
                return We;
              }
              setupForRenderPass(oe) {
                var Ee, be;
                const We =
                  (Ee =
                    (be = this.renderPassDescriptor.colorAttachments) == null
                      ? void 0
                      : be.length) != null
                    ? Ee
                    : 0;
                for (let st = 0; st < We; ++st) {
                  const dt = this.renderPassDescriptor.colorAttachments[st],
                    pt = oe.colorArrayOps[st];
                  (dt.clearValue = pt.clearValue),
                    (dt.loadOp = pt.clear ? "clear" : "load"),
                    (dt.storeOp = pt.store ? "store" : "discard");
                }
                const He = this.renderPassDescriptor.depthStencilAttachment;
                He &&
                  ((He.depthClearValue = oe.depthStencilOps.clearDepthValue),
                  (He.depthLoadOp = oe.depthStencilOps.clearDepth
                    ? "clear"
                    : "load"),
                  (He.depthStoreOp = oe.depthStencilOps.storeDepth
                    ? "store"
                    : "discard"),
                  (He.depthReadOnly = !1),
                  this.hasStencil &&
                    ((He.stencilClearValue =
                      oe.depthStencilOps.clearStencilValue),
                    (He.stencilLoadOp = oe.depthStencilOps.clearStencil
                      ? "clear"
                      : "load"),
                    (He.stencilStoreOp = oe.depthStencilOps.storeStencil
                      ? "store"
                      : "discard"),
                    (He.stencilReadOnly = !1)));
              }
              loseContext() {
                this.initialized = !1;
              }
              resolve(oe, Ee, be, We) {}
            }
            var q = a(5224),
              se = a(6252);
            const Ce = /[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g,
              we =
                /(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)([;]+)/g,
              Me = "@@@",
              Ie = /([\w-]+)\[(.*?)\]/,
              Le = new Set(["highp", "mediump", "lowp"]),
              tt = new Set(["sampler2DShadow", "samplerCubeShadow"]),
              vt = {
                sampler2D: L.HeG,
                sampler3D: L.EuA,
                samplerCube: L.GGM,
                samplerCubeShadow: L.GGM,
                sampler2DShadow: L.HeG,
                sampler2DArray: L.hwK,
                sampler2DArrayShadow: L.hwK,
              };
            class it {
              constructor(oe, Ee) {
                this.line = oe;
                const be = oe.trim().split(/\s+/);
                if (
                  (Le.has(be[0]) && (this.precision = be.shift()),
                  (this.type = be.shift()),
                  oe.includes(","),
                  oe.includes("["))
                ) {
                  const We = be.join(" "),
                    He = Ie.exec(We);
                  (this.name = He[1]),
                    (this.arraySize = Number(He[2])),
                    isNaN(this.arraySize) && (Ee.failed = !0);
                } else (this.name = be.shift()), (this.arraySize = 0);
                this.isSampler = this.type.indexOf("sampler") !== -1;
              }
            }
            class At {
              static run(oe, Ee, be) {
                const We = new Map(),
                  He = At.extract(Ee.vshader),
                  st = At.extract(Ee.fshader),
                  dt = At.processAttributes(
                    He.attributes,
                    Ee.attributes,
                    Ee.processingOptions
                  ),
                  pt = At.processVaryings(He.varyings, We, !0),
                  Mt = At.processVaryings(st.varyings, We, !1),
                  It = At.processOuts(st.outs),
                  Dt = He.uniforms.concat(st.uniforms),
                  Vt = Array.from(new Set(Dt)).map((vi) => new it(vi, be)),
                  Jt = At.processUniforms(oe, Vt, Ee.processingOptions, be),
                  ms =
                    dt +
                    `
` +
                    pt +
                    `
` +
                    Jt.code,
                  ks = He.src.replace(Me, ms),
                  Ds =
                    Mt +
                    `
` +
                    It +
                    `
` +
                    Jt.code,
                  qs = st.src.replace(Me, Ds);
                return {
                  vshader: ks,
                  fshader: qs,
                  meshUniformBufferFormat: Jt.meshUniformBufferFormat,
                  meshBindGroupFormat: Jt.meshBindGroupFormat,
                };
              }
              static extract(oe) {
                const Ee = [],
                  be = [],
                  We = [],
                  He = [];
                let st = `${Me}
`,
                  dt;
                for (; (dt = Ce.exec(oe)) !== null; ) {
                  const pt = dt[1];
                  switch (pt) {
                    case "attribute":
                    case "varying":
                    case "uniform":
                    case "out": {
                      we.lastIndex = dt.index;
                      const Mt = we.exec(oe);
                      pt === "attribute"
                        ? Ee.push(Mt[2])
                        : pt === "varying"
                        ? be.push(Mt[2])
                        : pt === "out"
                        ? We.push(Mt[2])
                        : pt === "uniform" && He.push(Mt[2]),
                        (oe = At.cutOut(oe, dt.index, we.lastIndex, st)),
                        (Ce.lastIndex = dt.index + st.length),
                        (st = "");
                      break;
                    }
                  }
                }
                return {
                  src: oe,
                  attributes: Ee,
                  varyings: be,
                  outs: We,
                  uniforms: He,
                };
              }
              static processUniforms(oe, Ee, be, We) {
                const He = [],
                  st = [];
                Ee.forEach((Vt) => {
                  Vt.isSampler ? He.push(Vt) : st.push(Vt);
                });
                const dt = [];
                st.forEach((Vt) => {
                  if (!be.hasUniform(Vt.name)) {
                    const Jt = L.nJN.indexOf(Vt.type),
                      ms = new q.g(Vt.name, Jt, Vt.arraySize);
                    dt.push(ms);
                  }
                });
                const pt = dt.length ? new q.Q(oe, dt) : null,
                  Mt = [];
                pt && Mt.push(new se.Xq(L.rb7, L.rXb | L.Jnj));
                const It = [];
                He.forEach((Vt) => {
                  if (!be.hasTexture(Vt.name)) {
                    let Jt = L.CZm;
                    Vt.precision === "highp" && (Jt = L.cRA),
                      tt.has(Vt.type) && (Jt = L.pqC);
                    const ms = vt[Vt.type];
                    It.push(new se.GN(Vt.name, L.rXb | L.Jnj, ms, Jt));
                  }
                });
                const Dt = new se.a$(oe, Mt, It);
                let Gt = "";
                return (
                  be.uniformFormats.forEach((Vt, Jt) => {
                    Vt && (Gt += Vt.getShaderDeclaration(Jt, 0));
                  }),
                  pt && (Gt += pt.getShaderDeclaration(L.pNk, 0)),
                  be.bindGroupFormats.forEach((Vt, Jt) => {
                    Vt && (Gt += Vt.getShaderDeclarationTextures(Jt));
                  }),
                  (Gt += Dt.getShaderDeclarationTextures(L.pNk)),
                  {
                    code: Gt,
                    meshUniformBufferFormat: pt,
                    meshBindGroupFormat: Dt,
                  }
                );
              }
              static processVaryings(oe, Ee, be) {
                let We = "";
                const He = be ? "out" : "in";
                return (
                  oe.forEach((st, dt) => {
                    const pt = At.splitToWords(st),
                      Mt = pt[0],
                      It = pt[1];
                    be ? Ee.set(It, dt) : (dt = Ee.get(It)),
                      (We += `layout(location = ${dt}) ${He} ${Mt} ${It};
`);
                  }),
                  We
                );
              }
              static processOuts(oe) {
                let Ee = "";
                return (
                  oe.forEach((be, We) => {
                    Ee += `layout(location = ${We}) out ${be};
`;
                  }),
                  Ee
                );
              }
              static getTypeCount(oe) {
                const Ee = oe.substring(oe.length - 1),
                  be = parseInt(Ee, 10);
                return isNaN(be) ? 1 : be;
              }
              static processAttributes(oe, Ee, be) {
                let We = "";
                return (
                  oe.forEach((He) => {
                    const st = At.splitToWords(He);
                    let dt = st[0],
                      pt = st[1];
                    if (Ee.hasOwnProperty(pt)) {
                      const Mt = Ee[pt],
                        It = L.tJj[Mt];
                      let Dt;
                      const Gt = be.getVertexElement(Mt);
                      if (Gt) {
                        const Vt = Gt.dataType;
                        if (Vt !== L.n$B && !Gt.normalize) {
                          const Jt = At.getTypeCount(dt),
                            ms = `_private_${pt}`;
                          (Dt = `vec${Jt} ${pt} = vec${Jt}(${ms});
`),
                            (pt = ms);
                          const ks =
                            Vt === L.VSW || Vt === L.kF || Vt === L.uVx;
                          Jt === 1
                            ? (dt = ks ? "int" : "uint")
                            : (dt = ks ? `ivec${Jt}` : `uvec${Jt}`);
                        }
                      }
                      (We += `layout(location = ${It}) in ${dt} ${pt};
`),
                        Dt && (We += Dt);
                    }
                  }),
                  We
                );
              }
              static splitToWords(oe) {
                return (oe = oe.replace(/\s+/g, " ").trim()), oe.split(" ");
              }
              static cutOut(oe, Ee, be, We) {
                return oe.substring(0, Ee) + We + oe.substring(be);
              }
            }
            class Rt {
              constructor(oe) {
                (this._vertexCode = void 0),
                  (this._fragmentCode = void 0),
                  (this.vertexEntryPoint = "main"),
                  (this.fragmentEntryPoint = "main"),
                  (this.shader = oe);
                const Ee = oe.definition;
                Ee.shaderLanguage === L.g80
                  ? ((this._vertexCode = Ee.vshader),
                    (this._fragmentCode = Ee.fshader),
                    (this.vertexEntryPoint = "vertexMain"),
                    (this.fragmentEntryPoint = "fragmentMain"),
                    (oe.ready = !0))
                  : Ee.processingOptions && this.process();
              }
              destroy(oe) {
                (this._vertexCode = null), (this._fragmentCode = null);
              }
              createShaderModule(oe, Ee) {
                return this.shader.device.wgpu.createShaderModule({ code: oe });
              }
              getVertexShaderModule() {
                return this.createShaderModule(this._vertexCode, "Vertex");
              }
              getFragmentShaderModule() {
                return this.createShaderModule(this._fragmentCode, "Fragment");
              }
              process() {
                const oe = this.shader,
                  Ee = At.run(oe.device, oe.definition, oe);
                (this._vertexCode = this.transpile(
                  Ee.vshader,
                  "vertex",
                  oe.definition.vshader
                )),
                  (this._fragmentCode = this.transpile(
                    Ee.fshader,
                    "fragment",
                    oe.definition.fshader
                  )),
                  this._vertexCode && this._fragmentCode
                    ? (oe.ready = !0)
                    : (oe.failed = !0),
                  (oe.meshUniformBufferFormat = Ee.meshUniformBufferFormat),
                  (oe.meshBindGroupFormat = Ee.meshBindGroupFormat);
              }
              transpile(oe, Ee, be) {
                try {
                  const We = this.shader.device.glslang.compileGLSL(oe, Ee);
                  return this.shader.device.twgsl.convertSpirV2WGSL(We);
                } catch (We) {
                  console.error(
                    `Failed to transpile webgl ${Ee} shader [${this.shader.label}] to WebGPU: [${We.message}]`,
                    { processed: oe, original: be, shader: this.shader }
                  );
                }
              }
              get vertexCode() {
                return this._vertexCode;
              }
              get fragmentCode() {
                return this._fragmentCode;
              }
              loseContext() {}
              restoreContext(oe, Ee) {}
            }
            var Ft = a(7812);
            const ut = [];
            (ut[L.SWx] = ""),
              (ut[L.RSt] = "r8unorm"),
              (ut[L._3] = "rg8unorm"),
              (ut[L.kqw] = ""),
              (ut[L.zIz] = ""),
              (ut[L.LDn] = ""),
              (ut[L.akF] = "rgba8unorm"),
              (ut[L.Lxj] = "rgba8unorm"),
              (ut[L.S$n] = "bc1-rgba-unorm"),
              (ut[L.EPU] = "bc2-rgba-unorm"),
              (ut[L.E_6] = "bc3-rgba-unorm"),
              (ut[L.Nnq] = ""),
              (ut[L.WBN] = "rgba16float"),
              (ut[L.FQW] = ""),
              (ut[L.s7h] = "rgba32float"),
              (ut[L.IQA] = "r32float"),
              (ut[L.Wbd] = "depth32float"),
              (ut[L.Mg$] = "depth24plus-stencil8"),
              (ut[L.s_z] = "rg11b10ufloat"),
              (ut[L.lsY] = ""),
              (ut[L.Mzz] = ""),
              (ut[L.G24] = ""),
              (ut[L.ZyS] = "etc2-rgb8unorm"),
              (ut[L.ArW] = "etc2-rgba8unorm"),
              (ut[L.TyC] = ""),
              (ut[L.apD] = ""),
              (ut[L.xyx] = ""),
              (ut[L.Ijy] = ""),
              (ut[L.jYy] = "astc-4x4-unorm"),
              (ut[L.x8T] = ""),
              (ut[L.qEN] = ""),
              (ut[L.$$M] = "bgra8unorm");
            const Pt = [];
            (Pt[L.x3I] = "repeat"),
              (Pt[L.vq6] = "clamp-to-edge"),
              (Pt[L.qoY] = "mirror-repeat");
            const bt = [];
            (bt[L.uhC] = { level: "nearest", mip: "nearest" }),
              (bt[L.DrA] = { level: "linear", mip: "nearest" }),
              (bt[L.GLw] = { level: "nearest", mip: "nearest" }),
              (bt[L.hs2] = { level: "nearest", mip: "linear" }),
              (bt[L.reG] = { level: "linear", mip: "nearest" }),
              (bt[L.qn_] = { level: "linear", mip: "linear" });
            class Zt {
              constructor(oe) {
                (this.gpuTexture = void 0),
                  (this.view = void 0),
                  (this.samplers = []),
                  (this.descr = void 0),
                  (this.format = void 0),
                  (this.texture = oe),
                  (this.format = ut[oe.format]),
                  this.create(oe.device);
              }
              create(oe) {
                const Ee = this.texture,
                  be = oe.wgpu,
                  We = Ee.requiredMipLevels;
                (this.descr = {
                  size: {
                    width: Ee.width,
                    height: Ee.height,
                    depthOrArrayLayers: Ee.cubemap ? 6 : 1,
                  },
                  format: this.format,
                  mipLevelCount: We,
                  sampleCount: 1,
                  dimension: Ee.volume ? "3d" : "2d",
                  usage:
                    GPUTextureUsage.TEXTURE_BINDING |
                    GPUTextureUsage.COPY_DST |
                    GPUTextureUsage.RENDER_ATTACHMENT |
                    GPUTextureUsage.COPY_SRC,
                }),
                  (this.gpuTexture = be.createTexture(this.descr));
                let He;
                this.texture.format === L.Mg$ &&
                  (He = { format: "depth24plus", aspect: "depth-only" }),
                  (this.view = this.createView(He));
              }
              destroy(oe) {}
              propertyChanged(oe) {
                this.samplers.length = 0;
              }
              getView(oe) {
                return this.uploadImmediate(oe, this.texture), this.view;
              }
              createView(oe) {
                var Ee, be, We, He, st, dt, pt;
                const Mt = oe != null ? oe : {},
                  It = this.descr,
                  Dt = this.texture,
                  Gt = () => (Dt.cubemap ? "cube" : Dt.volume ? "3d" : "2d"),
                  Vt = {
                    format: (Ee = Mt.format) != null ? Ee : It.format,
                    dimension: (be = Mt.dimension) != null ? be : Gt(),
                    aspect: (We = Mt.aspect) != null ? We : "all",
                    baseMipLevel: (He = Mt.baseMipLevel) != null ? He : 0,
                    mipLevelCount:
                      (st = Mt.mipLevelCount) != null ? st : It.mipLevelCount,
                    baseArrayLayer: (dt = Mt.baseArrayLayer) != null ? dt : 0,
                    arrayLayerCount:
                      (pt = Mt.arrayLayerCount) != null
                        ? pt
                        : It.depthOrArrayLayers,
                  };
                return this.gpuTexture.createView(Vt);
              }
              getSampler(oe, Ee) {
                let be = this.samplers[Ee];
                if (!be) {
                  const We = this.texture,
                    He = {
                      addressModeU: Pt[We.addressU],
                      addressModeV: Pt[We.addressV],
                      addressModeW: Pt[We.addressW],
                      maxAnisotropy: _.D.clamp(
                        Math.round(We._anisotropy),
                        1,
                        oe.maxTextureAnisotropy
                      ),
                    };
                  !Ee && We.compareOnRead && (Ee = L.pqC),
                    Ee === L.pqC
                      ? ((He.compare = "less"),
                        (He.magFilter = "linear"),
                        (He.minFilter = "linear"))
                      : Ee === L.cRA ||
                        this.texture.format === L.s7h ||
                        this.texture.format === L.Mg$ ||
                        this.texture.format === L.WBN
                      ? ((He.magFilter = "nearest"),
                        (He.minFilter = "nearest"),
                        (He.mipmapFilter = "nearest"))
                      : ((He.magFilter = bt[We.magFilter].level),
                        (He.minFilter = bt[We.minFilter].level),
                        (He.mipmapFilter = bt[We.minFilter].mip)),
                    (be = oe.wgpu.createSampler(He)),
                    (this.samplers[Ee] = be);
                }
                return be;
              }
              loseContext() {}
              uploadImmediate(oe, Ee) {
                (Ee._needsUpload || Ee._needsMipmapsUpload) &&
                  (this.uploadData(oe),
                  (Ee._needsUpload = !1),
                  (Ee._needsMipmapsUpload = !1));
              }
              uploadData(oe) {
                const Ee = this.texture;
                if (Ee._levels) {
                  let be = !1;
                  const We = Ee.requiredMipLevels;
                  for (let He = 0; He < We; He++) {
                    const st = Ee._levels[He];
                    if (st)
                      if (Ee.cubemap)
                        for (let dt = 0; dt < 6; dt++) {
                          const pt = st[dt];
                          pt &&
                            (this.isExternalImage(pt)
                              ? (this.uploadExternalImage(oe, pt, He, dt),
                                (be = !0))
                              : ArrayBuffer.isView(pt) &&
                                (this.uploadTypedArrayData(oe, pt, He, dt),
                                (be = !0)));
                        }
                      else
                        Ee._volume ||
                          (this.isExternalImage(st)
                            ? (this.uploadExternalImage(oe, st, He, 0),
                              (be = !0))
                            : ArrayBuffer.isView(st) &&
                              (this.uploadTypedArrayData(oe, st, He, 0),
                              (be = !0)));
                  }
                  be && Ee.mipmaps && oe.mipmapRenderer.generate(this);
                }
              }
              isExternalImage(oe) {
                return (
                  oe instanceof ImageBitmap ||
                  oe instanceof HTMLVideoElement ||
                  oe instanceof HTMLCanvasElement ||
                  oe instanceof OffscreenCanvas
                );
              }
              uploadExternalImage(oe, Ee, be, We) {
                const He = { source: Ee, origin: [0, 0], flipY: !1 },
                  st = {
                    texture: this.gpuTexture,
                    mipLevel: be,
                    origin: [0, 0, We],
                    aspect: "all",
                  },
                  dt = {
                    width: this.descr.size.width,
                    height: this.descr.size.height,
                    depthOrArrayLayers: 1,
                  };
                oe.submit(),
                  oe.wgpu.queue.copyExternalImageToTexture(He, st, dt);
              }
              uploadTypedArrayData(oe, Ee, be, We) {
                var He;
                const st = this.texture,
                  dt = oe.wgpu,
                  pt = {
                    texture: this.gpuTexture,
                    origin: [0, 0, We],
                    mipLevel: be,
                  },
                  Mt = Ft.V.calcLevelDimension(st.width, be),
                  It = Ft.V.calcLevelDimension(st.height, be);
                Ft.V.calcLevelGpuSize(Mt, It, 1, st.format);
                const Jt = {
                    offset: 0,
                    bytesPerRow:
                      ((He = L.s7S.get(st.format).size) != null ? He : 0) * Mt,
                    rowsPerImage: It,
                  },
                  ms = { width: Mt, height: It, depthOrArrayLayers: 1 };
                oe.submit(), dt.queue.writeTexture(pt, Ee, Jt, ms);
              }
            }
            class Xt extends re {
              constructor(oe) {
                super();
              }
              destroy(oe) {
                super.destroy(oe);
              }
              unlock(oe) {
                const Ee = oe.device;
                super.unlock(Ee, void 0, GPUBufferUsage.UNIFORM, oe.storage);
              }
            }
            class yt extends re {
              constructor(oe, Ee) {
                super();
              }
              destroy(oe) {
                super.destroy(oe);
              }
              unlock(oe) {
                const Ee = oe.device;
                super.unlock(Ee, oe.usage, GPUBufferUsage.VERTEX, oe.storage);
              }
            }
            var Pe = a(1268),
              $e = a(8526),
              Je = a(2978),
              rt = a(5006),
              ct = a(4870);
            const Ve = { type: L.SF$, base: 0, count: 4, indexed: !1 };
            class wt {
              constructor(oe) {
                const Ee = `

						struct ub_mesh {
								color : vec4f,
								depth: f32
						}

						@group(0) @binding(0) var<uniform> ubMesh : ub_mesh;

						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f
						}

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
								var output : VertexOutput;
								output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);
								return output;
						}

						@fragment
						fn fragmentMain() -> @location(0) vec4f {
								return ubMesh.color;
						}
				`;
                (this.shader = new $e.M(oe, {
                  name: "WebGPUClearRendererShader",
                  shaderLanguage: L.g80,
                  vshader: Ee,
                  fshader: Ee,
                })),
                  (this.uniformBuffer = new rt.D(
                    oe,
                    new q.Q(oe, [
                      new q.g("color", L.cyR),
                      new q.g("depth", L.GF5),
                    ]),
                    !1
                  ));
                const be = new se.a$(oe, [new se.Xq(L.rb7, L.rXb | L.Jnj)]);
                (this.bindGroup = new Je.T(oe, be, this.uniformBuffer)),
                  (this.colorData = new Float32Array(4)),
                  (this.colorId = oe.scope.resolve("color")),
                  (this.depthId = oe.scope.resolve("depth"));
              }
              destroy() {
                this.shader.destroy(),
                  (this.shader = null),
                  this.uniformBuffer.destroy(),
                  (this.uniformBuffer = null),
                  this.bindGroup.destroy(),
                  (this.bindGroup = null);
              }
              clear(oe, Ee, be, We) {
                var He;
                be = be || We;
                const st = (He = be.flags) != null ? He : We.flags;
                if (st !== 0) {
                  if (st & L.Sue && Ee.colorBuffer) {
                    var dt;
                    const It = (dt = be.color) != null ? dt : We.color;
                    this.colorData.set(It), oe.setBlendState(Pe.t.NOBLEND);
                  } else oe.setBlendState(Pe.t.NOWRITE);
                  if (
                    (this.colorId.setValue(this.colorData),
                    st & L.YKI && Ee.depth)
                  ) {
                    var pt;
                    const It = (pt = be.depth) != null ? pt : We.depth;
                    this.depthId.setValue(It),
                      oe.setDepthState(ct.H.WRITEDEPTH);
                  } else
                    this.depthId.setValue(1), oe.setDepthState(ct.H.NODEPTH);
                  st & L.zwO && Ee.stencil,
                    oe.setCullMode(L.pLF),
                    oe.setShader(this.shader);
                  const Mt = this.bindGroup;
                  Mt.defaultUniformBuffer.update(),
                    Mt.update(),
                    oe.setBindGroup(L.pNk, Mt),
                    oe.draw(Ve);
                }
              }
            }
            class at {
              constructor(oe) {
                (this.device = void 0), (this.device = oe);
                const Ee = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
								@location(0) texCoord : vec2f
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var imgSampler : sampler;
						@group(0) @binding(1) var img : texture_2d<f32>;

						@fragment
						fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
							return textureSample(img, imgSampler, texCoord);
						}
				`;
                (this.shader = new $e.M(oe, {
                  name: "WebGPUMipmapRendererShader",
                  shaderLanguage: L.g80,
                  vshader: Ee,
                  fshader: Ee,
                })),
                  (this.minSampler = oe.wgpu.createSampler({
                    minFilter: "linear",
                  }));
              }
              destroy() {
                this.shader.destroy(), (this.shader = null);
              }
              generate(oe) {
                var Ee;
                const be = oe.descr;
                if (be.mipLevelCount <= 1 || oe.texture.volume) return;
                const We = this.device,
                  He = We.wgpu,
                  st = this.shader.impl,
                  dt = He.createRenderPipeline({
                    layout: "auto",
                    vertex: {
                      module: st.getVertexShaderModule(),
                      entryPoint: st.vertexEntryPoint,
                    },
                    fragment: {
                      module: st.getFragmentShaderModule(),
                      entryPoint: st.fragmentEntryPoint,
                      targets: [{ format: be.format }],
                    },
                    primitive: { topology: "triangle-strip" },
                  }),
                  pt = oe.texture.cubemap ? 6 : 1,
                  Mt = [];
                for (let Dt = 0; Dt < pt; Dt++)
                  Mt.push(
                    oe.createView({
                      dimension: "2d",
                      baseMipLevel: 0,
                      mipLevelCount: 1,
                      baseArrayLayer: Dt,
                    })
                  );
                const It =
                  (Ee = We.commandEncoder) != null
                    ? Ee
                    : He.createCommandEncoder();
                for (let Dt = 1; Dt < be.mipLevelCount; Dt++)
                  for (let Gt = 0; Gt < pt; Gt++) {
                    const Vt = oe.createView({
                        dimension: "2d",
                        baseMipLevel: Dt,
                        mipLevelCount: 1,
                        baseArrayLayer: Gt,
                      }),
                      Jt = It.beginRenderPass({
                        colorAttachments: [
                          { view: Vt, loadOp: "clear", storeOp: "store" },
                        ],
                      }),
                      ms = He.createBindGroup({
                        layout: dt.getBindGroupLayout(0),
                        entries: [
                          { binding: 0, resource: this.minSampler },
                          { binding: 1, resource: Mt[Gt] },
                        ],
                      });
                    Jt.setPipeline(dt),
                      Jt.setBindGroup(0, ms),
                      Jt.draw(4),
                      Jt.end(),
                      (Mt[Gt] = Vt);
                  }
                if (!We.commandEncoder) {
                  const Dt = It.finish();
                  We.addCommandBuffer(Dt);
                }
                We.pipeline = null;
              }
            }
            var ce = a(2948);
            class pe extends ce.kL {
              constructor(oe, Ee, be) {
                super(oe),
                  (this.buffer = null),
                  (this.mappedRange = null),
                  (this.buffer = oe.wgpu.createBuffer({
                    size: Ee,
                    usage: be
                      ? GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
                      : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: be,
                  })),
                  be && this.onAvailable(),
                  (oe._vram.ub += Ee);
              }
              destroy(oe) {
                (oe._vram.ub -= this.buffer.size),
                  this.buffer.destroy(),
                  (this.buffer = null);
              }
              onAvailable() {
                this.mappedRange = this.buffer.getMappedRange();
              }
              alloc(oe, Ee) {
                return new Int32Array(this.mappedRange, oe, Ee / 4);
              }
            }
            class De extends ce.pw {
              constructor(...oe) {
                super(...oe), (this.pendingStagingBuffers = []);
              }
              createBuffer(oe, Ee, be) {
                return new pe(oe, Ee, be);
              }
              submit() {
                super.submit();
                const oe = this.usedBuffers.length;
                if (oe) {
                  const Ee = this.device,
                    be = this.gpuBuffers,
                    We = Ee.wgpu.createCommandEncoder();
                  for (let st = oe - 1; st >= 0; st--) {
                    const dt = this.usedBuffers[st],
                      {
                        stagingBuffer: pt,
                        gpuBuffer: Mt,
                        offset: It,
                        size: Dt,
                      } = dt,
                      Gt = pt.buffer;
                    Gt.unmap(),
                      We.copyBufferToBuffer(Gt, It, Mt.buffer, It, Dt),
                      be.push(Mt);
                  }
                  const He = We.finish();
                  Ee.addCommandBuffer(He, !0);
                  for (let st = 0; st < oe; st++) {
                    const dt = this.usedBuffers[st].stagingBuffer;
                    this.pendingStagingBuffers.push(dt);
                  }
                  this.usedBuffers.length = 0;
                }
              }
              onCommandBuffersSubmitted() {
                const oe = this.pendingStagingBuffers.length;
                if (oe) {
                  for (let Ee = 0; Ee < oe; Ee++) {
                    const be = this.pendingStagingBuffers[Ee];
                    be.buffer.mapAsync(GPUMapMode.WRITE).then(() => {
                      be.onAvailable(), this.stagingBuffers.push(be);
                    });
                  }
                  this.pendingStagingBuffers.length = 0;
                }
              }
            }
            var fe = a(1735);
            class Ze {
              constructor(oe, Ee, be) {
                (this.querySet = void 0),
                  (this.stagingBuffers = []),
                  (this.activeStagingBuffer = null),
                  (this.bytesPerSlot = void 0),
                  (this.device = oe),
                  (this.capacity = be),
                  (this.bytesPerSlot = Ee ? 8 : 4);
                const We = oe.wgpu;
                (this.querySet = We.createQuerySet({
                  type: Ee ? "timestamp" : "occlusion",
                  count: be,
                })),
                  (this.queryBuffer = We.createBuffer({
                    size: this.bytesPerSlot * be,
                    usage:
                      GPUBufferUsage.QUERY_RESOLVE |
                      GPUBufferUsage.STORAGE |
                      GPUBufferUsage.COPY_SRC |
                      GPUBufferUsage.COPY_DST,
                  }));
              }
              destroy() {
                var oe, Ee;
                (oe = this.querySet) == null || oe.destroy(),
                  (this.querySet = null),
                  (Ee = this.queryBuffer) == null || Ee.destroy(),
                  (this.queryBuffer = null),
                  (this.activeStagingBuffer = null),
                  this.stagingBuffers.forEach((be) => {
                    be.destroy();
                  }),
                  (this.stagingBuffers = null);
              }
              getStagingBuffer() {
                let oe = this.stagingBuffers.pop();
                return (
                  oe ||
                    (oe = this.device.wgpu.createBuffer({
                      size: this.queryBuffer.size,
                      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                    })),
                  oe
                );
              }
              resolve(oe) {
                const Ee = this.device,
                  be = Ee.wgpu.createCommandEncoder();
                be.resolveQuerySet(this.querySet, 0, oe, this.queryBuffer, 0);
                const We = this.getStagingBuffer();
                (this.activeStagingBuffer = We),
                  be.copyBufferToBuffer(
                    this.queryBuffer,
                    0,
                    We,
                    0,
                    this.bytesPerSlot * oe
                  );
                const He = be.finish();
                Ee.addCommandBuffer(He);
              }
              request(oe, Ee) {
                const be = this.activeStagingBuffer;
                return (
                  (this.activeStagingBuffer = null),
                  be.mapAsync(GPUMapMode.READ).then(() => {
                    const We = new BigInt64Array(be.getMappedRange()),
                      He = [];
                    for (let st = 0; st < oe; st++)
                      He.push(Number(We[st * 2 + 1] - We[st * 2]) * 1e-6);
                    return (
                      be.unmap(),
                      this.stagingBuffers.push(be),
                      { renderVersion: Ee, timings: He }
                    );
                  })
                );
              }
            }
            class Ne extends fe.M {
              constructor(oe) {
                super(),
                  (this.device = void 0),
                  (this.frameGPUMarkerSlot = void 0),
                  (this.device = oe),
                  (this.timestampQueriesSet = oe.supportsTimestampQuery
                    ? new Ze(oe, !0, 512)
                    : null);
              }
              destroy() {
                var oe;
                (oe = this.timestampQueriesSet) == null || oe.destroy(),
                  (this.timestampQueriesSet = null);
              }
              frameMarker(oe) {
                if (this.timestampQueriesSet) {
                  const Ee = this.device.wgpu.createCommandEncoder();
                  (this.frameGPUMarkerSlot = oe
                    ? this.getSlot("GpuFrame")
                    : this.frameGPUMarkerSlot),
                    Ee.writeTimestamp(
                      this.timestampQueriesSet.querySet,
                      this.frameGPUMarkerSlot * 2 + (oe ? 0 : 1)
                    );
                  const be = Ee.finish();
                  this.device.addCommandBuffer(be, oe);
                }
              }
              frameStart() {
                this.processEnableRequest(),
                  this._enabled && this.frameMarker(!0);
              }
              frameEnd() {
                if (this._enabled) {
                  var oe;
                  this.frameMarker(!1),
                    (oe = this.timestampQueriesSet) == null ||
                      oe.resolve(this.slotCount * 2);
                }
              }
              request() {
                if (this._enabled) {
                  var oe;
                  const Ee = this.device.renderVersion;
                  (oe = this.timestampQueriesSet) == null ||
                    oe.request(this.slotCount, Ee).then((be) => {
                      this.report(be.renderVersion, be.timings);
                    }),
                    super.request(Ee);
                }
              }
            }
            class Ye {
              constructor(oe) {
                (this.device = void 0),
                  (this.pipelineCache = new Map()),
                  (this.device = oe);
                const Ee = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var img : texture_depth_multisampled_2d;

						@fragment
						fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {
								// load th depth value from sample index 0
								var depth = textureLoad(img, vec2i(fragColor.xy), 0u);
								return vec4<f32>(depth, 0.0, 0.0, 0.0);
						}
				`;
                this.shader = new $e.M(oe, {
                  name: "WebGPUResolverDepthShader",
                  shaderLanguage: L.g80,
                  vshader: Ee,
                  fshader: Ee,
                });
              }
              destroy() {
                this.shader.destroy(),
                  (this.shader = null),
                  (this.pipelineCache = null);
              }
              getPipeline(oe) {
                let Ee = this.pipelineCache.get(oe);
                return (
                  Ee ||
                    ((Ee = this.createPipeline(oe)),
                    this.pipelineCache.set(oe, Ee)),
                  Ee
                );
              }
              createPipeline(oe) {
                const Ee = this.shader.impl;
                return this.device.wgpu.createRenderPipeline({
                  layout: "auto",
                  vertex: {
                    module: Ee.getVertexShaderModule(),
                    entryPoint: Ee.vertexEntryPoint,
                  },
                  fragment: {
                    module: Ee.getFragmentShaderModule(),
                    entryPoint: Ee.fragmentEntryPoint,
                    targets: [{ format: oe }],
                  },
                  primitive: { topology: "triangle-strip" },
                });
              }
              resolveDepth(oe, Ee, be) {
                const We = this.device,
                  He = We.wgpu,
                  st = this.getPipeline(be.format),
                  dt = Ee.depthOrArrayLayers;
                for (let pt = 0; pt < dt; pt++) {
                  const Mt = Ee.createView({
                      dimension: "2d",
                      aspect: "depth-only",
                      baseMipLevel: 0,
                      mipLevelCount: 1,
                      baseArrayLayer: pt,
                    }),
                    It = be.createView({
                      dimension: "2d",
                      baseMipLevel: 0,
                      mipLevelCount: 1,
                      baseArrayLayer: pt,
                    }),
                    Dt = oe.beginRenderPass({
                      colorAttachments: [
                        { view: It, loadOp: "clear", storeOp: "store" },
                      ],
                    }),
                    Gt = He.createBindGroup({
                      layout: st.getBindGroupLayout(0),
                      entries: [{ binding: 0, resource: Mt }],
                    });
                  Dt.setPipeline(st),
                    Dt.setBindGroup(0, Gt),
                    Dt.draw(4),
                    Dt.end();
                }
                We.pipeline = null;
              }
            }
            class Ke extends ge.G {
              constructor(oe, Ee = {}) {
                super(oe, Ee),
                  (this.frameBuffer = void 0),
                  (this.renderPipeline = new z(this)),
                  (this.clearRenderer = void 0),
                  (this.mipmapRenderer = void 0),
                  (this.pipeline = void 0),
                  (this.bindGroupFormats = []),
                  (this.commandEncoder = void 0),
                  (this.commandBuffers = []),
                  (this.limits = void 0),
                  (Ee = this.initOptions),
                  (this.isWebGPU = !0),
                  (this._deviceType = L.yK5),
                  (this.samples = Ee.antialias ? 4 : 1),
                  this.setupPassEncoderDefaults();
              }
              destroy() {
                this.clearRenderer.destroy(),
                  (this.clearRenderer = null),
                  this.mipmapRenderer.destroy(),
                  (this.mipmapRenderer = null),
                  this.resolver.destroy(),
                  (this.resolver = null),
                  super.destroy();
              }
              initDeviceCaps() {
                this.disableParticleSystem = !0;
                const oe = this.gpuAdapter.limits;
                (this.limits = oe),
                  (this.precision = "highp"),
                  (this.maxPrecision = "highp"),
                  (this.maxSamples = 4),
                  (this.maxTextures = 16),
                  (this.maxTextureSize = oe.maxTextureDimension2D),
                  (this.maxCubeMapSize = oe.maxTextureDimension2D),
                  (this.maxVolumeSize = oe.maxTextureDimension3D),
                  (this.maxColorAttachments = oe.maxColorAttachments),
                  (this.maxPixelRatio = 1),
                  (this.maxAnisotropy = 16),
                  (this.supportsInstancing = !0),
                  (this.supportsUniformBuffers = !0),
                  (this.supportsVolumeTextures = !0),
                  (this.supportsBoneTextures = !0),
                  (this.supportsMorphTargetTexturesCore = !0),
                  (this.supportsAreaLights = !0),
                  (this.supportsDepthShadow = !0),
                  (this.supportsGpuParticles = !1),
                  (this.supportsMrt = !0),
                  (this.extUintElement = !0),
                  (this.extTextureFloat = !0),
                  (this.textureFloatRenderable = !0),
                  (this.extTextureHalfFloat = !0),
                  (this.textureHalfFloatRenderable = !0),
                  (this.textureHalfFloatUpdatable = !0),
                  (this.boneLimit = 1024),
                  (this.supportsImageBitmap = !0),
                  (this.extStandardDerivatives = !0),
                  (this.extBlendMinmax = !0),
                  (this.areaLightLutFormat = this.floatFilterable
                    ? L.s7h
                    : L.Lxj),
                  (this.supportsTextureFetch = !0);
              }
              initWebGpu(oe, Ee) {
                return Kt(this, null, function* () {
                  if (!window.navigator.gpu)
                    throw new Error(
                      "Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering."
                    );
                  const be = (It) =>
                    new Promise(function (Dt, Gt) {
                      const Vt = document.createElement("script");
                      (Vt.src = It),
                        (Vt.async = !1),
                        (Vt.onload = function () {
                          Dt(It);
                        }),
                        (Vt.onerror = function () {
                          Gt(new Error(`Failed to download script ${It}`));
                        }),
                        document.body.appendChild(Vt);
                    });
                  yield be(oe), yield be(Ee), (this.glslang = yield glslang());
                  const We = Ee.replace(".js", ".wasm");
                  this.twgsl = yield twgsl(We);
                  const He = {
                    powerPreference:
                      this.initOptions.powerPreference !== "default"
                        ? this.initOptions.powerPreference
                        : void 0,
                  };
                  this.gpuAdapter = yield window.navigator.gpu.requestAdapter(
                    He
                  );
                  const st = [],
                    dt = (It) => {
                      const Dt = this.gpuAdapter.features.has(It);
                      return Dt && st.push(It), Dt;
                    };
                  (this.floatFilterable = dt("float32-filterable")),
                    (this.extCompressedTextureS3TC = dt(
                      "texture-compression-bc"
                    )),
                    (this.extCompressedTextureETC = dt(
                      "texture-compression-etc2"
                    )),
                    (this.extCompressedTextureASTC = dt(
                      "texture-compression-astc"
                    )),
                    (this.supportsTimestampQuery = dt("timestamp-query"));
                  const pt = {
                    requiredFeatures: st,
                    requiredLimits: {},
                    defaultQueue: { label: "Default Queue" },
                  };
                  (this.wgpu = yield this.gpuAdapter.requestDevice(pt)),
                    this.initDeviceCaps(),
                    this.setResolution(window.innerWidth, window.innerHeight),
                    (this.gpuContext = this.canvas.getContext("webgpu"));
                  const Mt = navigator.gpu.getPreferredCanvasFormat();
                  return (
                    (this.framebufferFormat =
                      Mt === "rgba8unorm" ? L.Lxj : L.$$M),
                    (this.canvasConfig = {
                      device: this.wgpu,
                      colorSpace: "srgb",
                      alphaMode: "opaque",
                      format: Mt,
                      usage:
                        GPUTextureUsage.RENDER_ATTACHMENT |
                        GPUTextureUsage.COPY_SRC |
                        GPUTextureUsage.COPY_DST,
                      viewFormats: [],
                    }),
                    this.gpuContext.configure(this.canvasConfig),
                    this.createFramebuffer(),
                    (this.clearRenderer = new wt(this)),
                    (this.mipmapRenderer = new at(this)),
                    (this.resolver = new Ye(this)),
                    this.postInit(),
                    this
                  );
                });
              }
              postInit() {
                super.postInit(),
                  (this.gpuProfiler = new Ne(this)),
                  (this.dynamicBuffers = new De(
                    this,
                    1048576,
                    this.limits.minUniformBufferOffsetAlignment
                  ));
              }
              createFramebuffer() {
                (this.supportsStencil = this.initOptions.stencil),
                  (this.frameBufferDimensions = new P.Z()),
                  (this.frameBuffer = new k.O({
                    name: "WebgpuFramebuffer",
                    graphicsDevice: this,
                    depth: this.initOptions.depth,
                    stencil: this.supportsStencil,
                    samples: this.samples,
                  }));
              }
              resizeCanvas(oe, Ee) {
                (this._width = oe),
                  (this._height = Ee),
                  (this.canvas.width !== oe || this.canvas.height !== Ee) &&
                    ((this.canvas.width = oe),
                    (this.canvas.height = Ee),
                    this.fire(ge.G.EVENT_RESIZE, oe, Ee));
              }
              frameStart() {
                super.frameStart(),
                  this.gpuProfiler.frameStart(),
                  this.submit();
                const oe = this.gpuContext.getCurrentTexture();
                (this.frameBufferDimensions.x !== oe.width ||
                  this.frameBufferDimensions.y !== oe.height) &&
                  (this.frameBufferDimensions.set(oe.width, oe.height),
                  this.frameBuffer.destroy(),
                  (this.frameBuffer = null),
                  this.createFramebuffer());
                const Ee = this.frameBuffer,
                  be = Ee.impl;
                be.setColorAttachment(0, void 0, oe.format),
                  this.initRenderTarget(Ee),
                  be.assignColorTexture(oe);
              }
              frameEnd() {
                super.frameEnd(),
                  this.gpuProfiler.frameEnd(),
                  this.submit(),
                  this.gpuProfiler.request();
              }
              createUniformBufferImpl(oe) {
                return new Xt(oe);
              }
              createVertexBufferImpl(oe, Ee) {
                return new yt(oe, Ee);
              }
              createIndexBufferImpl(oe) {
                return new I(oe);
              }
              createShaderImpl(oe) {
                return new Rt(oe);
              }
              createTextureImpl(oe) {
                return new Zt(oe);
              }
              createRenderTargetImpl(oe) {
                return new H(oe);
              }
              createBindGroupFormatImpl(oe) {
                return new de(oe);
              }
              createBindGroupImpl(oe) {
                return new B();
              }
              setBindGroup(oe, Ee) {
                this.passEncoder &&
                  (this.passEncoder.setBindGroup(
                    oe,
                    Ee.impl.bindGroup,
                    Ee.uniformBufferOffsets
                  ),
                  (this.bindGroupFormats[oe] = Ee.format.impl));
              }
              submitVertexBuffer(oe, Ee) {
                const be = oe.format.elements,
                  We = be.length,
                  He = oe.impl.buffer;
                for (let st = 0; st < We; st++)
                  this.passEncoder.setVertexBuffer(Ee + st, He, be[st].offset);
                return We;
              }
              draw(oe, Ee = 1, be) {
                if (this.shader.ready && !this.shader.failed) {
                  const We = this.passEncoder,
                    He = this.vertexBuffers[0],
                    st = this.vertexBuffers[1];
                  if (((this.vertexBuffers.length = 0), He)) {
                    const Mt = this.submitVertexBuffer(He, 0);
                    st && this.submitVertexBuffer(st, Mt);
                  }
                  const dt = this.renderPipeline.get(
                    oe,
                    He == null ? void 0 : He.format,
                    st == null ? void 0 : st.format,
                    this.shader,
                    this.renderTarget,
                    this.bindGroupFormats,
                    this.blendState,
                    this.depthState,
                    this.cullMode,
                    this.stencilEnabled,
                    this.stencilFront,
                    this.stencilBack
                  );
                  this.pipeline !== dt &&
                    ((this.pipeline = dt), We.setPipeline(dt));
                  const pt = this.indexBuffer;
                  pt
                    ? ((this.indexBuffer = null),
                      We.setIndexBuffer(pt.impl.buffer, pt.impl.format),
                      We.drawIndexed(oe.count, Ee, 0, 0, 0))
                    : We.draw(oe.count, Ee, 0, 0);
                }
              }
              setShader(oe) {
                return (this.shader = oe), !0;
              }
              setBlendState(oe) {
                this.blendState.copy(oe);
              }
              setDepthState(oe) {
                this.depthState.copy(oe);
              }
              setStencilState(oe, Ee) {
                if (oe || Ee) {
                  (this.stencilEnabled = !0),
                    this.stencilFront.copy(oe != null ? oe : j.n.DEFAULT),
                    this.stencilBack.copy(Ee != null ? Ee : j.n.DEFAULT);
                  const be = this.stencilFront.ref;
                  this.stencilRef !== be &&
                    ((this.stencilRef = be),
                    this.passEncoder.setStencilReference(be));
                } else this.stencilEnabled = !1;
              }
              setBlendColor(oe, Ee, be, We) {}
              setCullMode(oe) {
                this.cullMode = oe;
              }
              setAlphaToCoverage(oe) {}
              initializeContextCaches() {
                super.initializeContextCaches();
              }
              setupPassEncoderDefaults() {
                this.stencilRef = 0;
              }
              startPass(oe) {
                const Ee = oe.renderTarget || this.frameBuffer;
                this.renderTarget = Ee;
                const be = Ee.impl;
                (this.commandEncoder = this.wgpu.createCommandEncoder()),
                  Ee !== this.frameBuffer && this.initRenderTarget(Ee),
                  be.setupForRenderPass(oe),
                  (this.pipeline = null);
                const We = be.renderPassDescriptor;
                if (
                  this.gpuProfiler._enabled &&
                  this.gpuProfiler.timestampQueriesSet
                ) {
                  const dt = this.gpuProfiler.getSlot(oe.name);
                  We.timestampWrites = {
                    querySet: this.gpuProfiler.timestampQueriesSet.querySet,
                    beginningOfPassWriteIndex: dt * 2,
                    endOfPassWriteIndex: dt * 2 + 1,
                  };
                }
                (this.passEncoder = this.commandEncoder.beginRenderPass(We)),
                  this.setupPassEncoderDefaults();
                const { width: He, height: st } = Ee;
                this.setViewport(0, 0, He, st),
                  this.setScissor(0, 0, He, st),
                  (this.insideRenderPass = !0);
              }
              endPass(oe) {
                this.passEncoder.end(),
                  (this.passEncoder = null),
                  (this.insideRenderPass = !1),
                  (this.bindGroupFormats.length = 0);
                for (let be = 0; be < oe.colorArrayOps.length; be++)
                  oe.colorArrayOps[be].mipmaps &&
                    this.mipmapRenderer.generate(
                      oe.renderTarget._colorBuffers[be].impl
                    );
                const Ee = this.commandEncoder.finish();
                this.addCommandBuffer(Ee), (this.commandEncoder = null);
              }
              addCommandBuffer(oe, Ee = !1) {
                Ee
                  ? this.commandBuffers.unshift(oe)
                  : this.commandBuffers.push(oe);
              }
              submit() {
                this.commandBuffers.length > 0 &&
                  (this.dynamicBuffers.submit(),
                  this.wgpu.queue.submit(this.commandBuffers),
                  (this.commandBuffers.length = 0),
                  this.dynamicBuffers.onCommandBuffersSubmitted());
              }
              clear(oe) {
                oe.flags &&
                  this.clearRenderer.clear(
                    this,
                    this.renderTarget,
                    oe,
                    this.defaultClearOptions
                  );
              }
              get width() {
                return this._width;
              }
              get height() {
                return this._height;
              }
              setDepthBias(oe) {}
              setDepthBiasValues(oe, Ee) {}
              setViewport(oe, Ee, be, We) {
                this.passEncoder &&
                  (this.renderTarget.flipY ||
                    (Ee = this.renderTarget.height - Ee - We),
                  (this.vx = oe),
                  (this.vy = Ee),
                  (this.vw = be),
                  (this.vh = We),
                  this.passEncoder.setViewport(oe, Ee, be, We, 0, 1));
              }
              setScissor(oe, Ee, be, We) {
                this.passEncoder &&
                  (this.renderTarget.flipY ||
                    (Ee = this.renderTarget.height - Ee - We),
                  (this.sx = oe),
                  (this.sy = Ee),
                  (this.sw = be),
                  (this.sh = We),
                  this.passEncoder.setScissorRect(oe, Ee, be, We));
              }
              copyRenderTarget(oe, Ee, be, We) {
                var He;
                const st = {
                    width: oe ? oe.width : Ee.width,
                    height: oe ? oe.height : Ee.height,
                    depthOrArrayLayers: 1,
                  },
                  dt =
                    (He = this.commandEncoder) != null
                      ? He
                      : this.wgpu.createCommandEncoder();
                if (be) {
                  const pt = {
                      texture: oe
                        ? oe.colorBuffer.impl.gpuTexture
                        : this.renderTarget.impl.assignedColorTexture,
                      mipLevel: 0,
                    },
                    Mt = {
                      texture: Ee
                        ? Ee.colorBuffer.impl.gpuTexture
                        : this.renderTarget.impl.assignedColorTexture,
                      mipLevel: 0,
                    };
                  dt.copyTextureToTexture(pt, Mt, st);
                }
                if (We) {
                  const Mt = (oe || this.renderTarget).impl.depthTexture;
                  if (oe.samples > 1) {
                    const It = Ee.colorBuffer.impl.gpuTexture;
                    this.resolver.resolveDepth(dt, Mt, It);
                  } else {
                    const It = Ee
                        ? Ee.depthBuffer.impl.gpuTexture
                        : this.renderTarget.impl.depthTexture,
                      Dt = { texture: Mt, mipLevel: 0 },
                      Gt = { texture: It, mipLevel: 0 };
                    dt.copyTextureToTexture(Dt, Gt, st);
                  }
                }
                if (!this.commandEncoder) {
                  const pt = dt.finish();
                  this.addCommandBuffer(pt);
                }
                return !0;
              }
            }
            var nt = a(3317);
            function ot(Wt, oe = {}) {
              var Ee;
              const be = (Ee = oe.deviceTypes) != null ? Ee : [];
              if (
                (be.includes(L.Nwc) || be.push(L.Nwc),
                be.includes(L.ERE) || be.push(L.ERE),
                h.i.browser && navigator.xr)
              ) {
                var We;
                (We = oe.xrCompatible) != null || (oe.xrCompatible = !0);
              }
              let He;
              for (let dt = 0; dt < be.length; dt++) {
                var st;
                const pt = be[dt];
                if (
                  pt === L.yK5 &&
                  (st = window) != null &&
                  (st = st.navigator) != null &&
                  st.gpu
                )
                  return (
                    (He = new Ke(Wt, oe)),
                    He.initWebGpu(oe.glslangUrl, oe.twgslUrl)
                  );
                if (pt !== L.yK5)
                  return (
                    (oe.preferWebGl2 = pt === L.Nwc),
                    (He = new nt.z(Wt, oe)),
                    Promise.resolve(He)
                  );
              }
              return Promise.reject(
                new Error("Failed to allocate graphics device")
              );
            }
            var ze = a(970),
              et = a(4113),
              _t = a(7348),
              Qe = a(1208),
              lt = a(5860),
              xt = a(9855);
            class Tt {
              constructor(oe, Ee = L.xHx) {
                this.device = oe.device;
                const be = this.device.gl;
                (this._inputBuffer = oe),
                  Ee === L.xHx &&
                    oe.usage !== Ee &&
                    (be.bindBuffer(be.ARRAY_BUFFER, oe.impl.bufferId),
                    be.bufferData(
                      be.ARRAY_BUFFER,
                      oe.storage,
                      be.DYNAMIC_COPY
                    )),
                  (this._outputBuffer = new lt.R(
                    oe.device,
                    oe.format,
                    oe.numVertices,
                    Ee,
                    oe.storage
                  ));
              }
              static createShader(oe, Ee, be) {
                return new $e.M(
                  oe,
                  xt.l.createDefinition(oe, {
                    name: be,
                    vertexCode: Ee,
                    useTransformFeedback: !0,
                  })
                );
              }
              destroy() {
                this._outputBuffer.destroy();
              }
              process(oe, Ee = !0) {
                const be = this.device,
                  We = be.getRenderTarget();
                if (
                  (be.setRenderTarget(null),
                  be.updateBegin(),
                  be.setVertexBuffer(this._inputBuffer, 0),
                  be.setRaster(!1),
                  be.setTransformFeedbackBuffer(this._outputBuffer),
                  be.setShader(oe),
                  be.draw({
                    type: L._AA,
                    base: 0,
                    count: this._inputBuffer.numVertices,
                    indexed: !1,
                  }),
                  be.setTransformFeedbackBuffer(null),
                  be.setRaster(!0),
                  be.updateEnd(),
                  be.setRenderTarget(We),
                  Ee)
                ) {
                  let He = this._inputBuffer.impl.bufferId;
                  (this._inputBuffer.impl.bufferId =
                    this._outputBuffer.impl.bufferId),
                    (this._outputBuffer.impl.bufferId = He),
                    (He = this._inputBuffer.impl.vao),
                    (this._inputBuffer.impl.vao = this._outputBuffer.impl.vao),
                    (this._outputBuffer.impl.vao = He);
                }
              }
              get inputBuffer() {
                return this._inputBuffer;
              }
              get outputBuffer() {
                return this._outputBuffer;
              }
            }
            var ft = a(6089),
              gt = a(1984),
              Fe = a(9939),
              Qt = a(5588),
              zt = a(2921),
              Lt = a(8789),
              $t = a(4967),
              Bt = a(9273),
              Nt = a(9800),
              es = a(8520),
              kt = a(7500),
              ds = a(8633),
              os = a(2378),
              ls = a(6122),
              Ps = a(6046),
              us = a(7365),
              Xe = a(9391),
              vs = a(8531),
              fs = a(8524),
              bs = a(597),
              Ms = a(4471),
              Ts = a(5041),
              Js = a(6367),
              Os = a(5833),
              li = a(5463),
              $s = a(8568),
              Cs = a(2658),
              Gs = a(8944);
            class hi {
              constructor() {
                (this.usedUvs = void 0),
                  (this.shaderChunk = void 0),
                  (this.litOptions = new Gs.n());
              }
            }
            var ci = a(7715),
              ii = a(783),
              je = a(7835),
              mt = a(1151),
              Ot = a(8342);
            const ss = [0, 1, 2, 3, 4, 5, 6, 7],
              qt = {
                generateKey: function (Wt) {
                  return (
                    "lit" +
                    ss.map((Ee, be) => (Wt.usedUvs[be] ? "1" : "0")).join("") +
                    Wt.shaderChunk +
                    Ot.Z.generateKey(Wt.litOptions)
                  );
                },
                createShaderDefinition: function (Wt, oe) {
                  const Ee = new mt.J(Wt, oe.litOptions),
                    be = new je.v(),
                    We = new je.v(),
                    He = new je.v();
                  be.append("uniform float textureBias;"),
                    be.append(Ee.chunks.litShaderArgsPS),
                    We.append(oe.shaderChunk),
                    (He.code = "evaluateFrontend();"),
                    (He.code = `
${He.code
  .split(
    `
`
  )
  .map((pt) => `    ${pt}`).join(`
`)}

`);
                  const st = oe.usedUvs || [!0],
                    dt = [];
                  return (
                    Ee.generateVertexShader(st, st, dt),
                    Ee.generateFragmentShader(
                      be.code,
                      We.code,
                      He.code,
                      "vUv0"
                    ),
                    Ee.getDefinition()
                  );
                },
              },
              is = new hi();
            class Ls extends Cs.i {
              constructor(...oe) {
                super(...oe),
                  (this.usedUvs = [!0]),
                  (this.shaderChunk = `void evaluateFrontend() {}
`),
                  (this.chunks = null),
                  (this.useLighting = !0),
                  (this.useFog = !0),
                  (this.useGammaTonemap = !0),
                  (this.useSkybox = !0),
                  (this.shadingModel = Xe.SB),
                  (this.ambientSH = null),
                  (this.pixelSnap = !1),
                  (this.nineSlicedMode = null),
                  (this.fastTbn = !1),
                  (this.twoSidedLighting = !1),
                  (this.occludeDirect = !1),
                  (this.occludeSpecular = Xe.aP),
                  (this.occludeSpecularIntensity = 1),
                  (this.opacityFadesSpecular = !0),
                  (this.conserveEnergy = !0),
                  (this.ggxSpecular = !1),
                  (this.fresnelModel = Xe.SU),
                  (this.dynamicRefraction = !1),
                  (this.hasAo = !1),
                  (this.hasSpecular = !1),
                  (this.hasSpecularityFactor = !1),
                  (this.hasLighting = !1),
                  (this.hasHeights = !1),
                  (this.hasNormals = !1),
                  (this.hasSheen = !1),
                  (this.hasRefraction = !1),
                  (this.hasIrridescence = !1),
                  (this.hasMetalness = !1),
                  (this.hasClearCoat = !1),
                  (this.hasClearCoatNormals = !1);
              }
              getShaderVariant(oe, Ee, be, We, He, st, dt, pt, Mt) {
                (is.usedUvs = this.usedUvs.slice()),
                  (is.shaderChunk = this.shaderChunk),
                  ci.K.update(is.litOptions, this, Ee, be, He, st);
                const It = new $s.c(dt, pt, Mt),
                  Dt = (0, ii.k)(oe);
                return (
                  Dt.register("lit", qt),
                  Dt.getProgram("lit", is, It, this.userId)
                );
              }
            }
            var js = a(7087),
              fi = a(600),
              pi = a(3035),
              _i = a(2223),
              mi = a(1232),
              gi = a(8026),
              yi = a(818),
              Li = a(7197),
              Bi = a(3637),
              Ai = a(9611),
              Xi = a(528),
              Yi = a(6414),
              Mn = a(1336),
              Ci = a(2863),
              hn = a(3936),
              Zi = a(1036),
              cn = a(4639),
              Qi = a(8097),
              Ji = a(8777),
              dn = a(8649),
              un = a(1369),
              wn = a(6261),
              In = a(2199),
              $i = a(5465),
              Dn = a(7284),
              qi = a(3362),
              en = a(4294),
              Fi = a(333),
              Ui = a(2910);
            function Hs(Wt, oe) {
              return Math.atan2(Wt * oe, Math.sqrt(Wt * Wt + oe * oe + 1));
            }
            function Pi(Wt, oe, Ee) {
              let be = (2 * (Wt + 0.5)) / Ee - 1,
                We = (2 * (oe + 0.5)) / Ee - 1;
              (be *= 1 - 1 / Ee), (We *= 1 - 1 / Ee);
              const He = 1 / Ee,
                st = be - He,
                dt = We - He,
                pt = be + He,
                Mt = We + He;
              let It = Hs(st, dt) - Hs(st, Mt) - Hs(pt, dt) + Hs(pt, Mt);
              return (
                (Wt === 0 && oe === 0) ||
                (Wt === Ee - 1 && oe === 0) ||
                (Wt === 0 && oe === Ee - 1) ||
                (Wt === Ee - 1 && oe === Ee - 1)
                  ? (It /= 3)
                  : (Wt === 0 || oe === 0 || Wt === Ee - 1 || oe === Ee - 1) &&
                    (It *= 0.5),
                It
              );
            }
            function fn(Wt, oe, Ee) {
              if (oe.format !== L.Lxj || !oe._levels[0] || !oe._levels[0][0])
                return null;
              const be = oe.width;
              if (!oe._levels[0][0].length)
                if (oe._levels[0][0] instanceof HTMLImageElement) {
                  const hs = (0, Fi.$$)(
                      Wt,
                      Ui.G.fullscreenQuadVS,
                      Ui.G.fullscreenQuadPS,
                      "fsQuadSimple"
                    ),
                    as = Wt.scope.resolve("source");
                  for (let Es = 0; Es < 6; Es++) {
                    const ai = oe._levels[0][Es],
                      ws = new Qe.g(Wt, {
                        name: "prefiltered-cube",
                        cubemap: !1,
                        type: L.s64,
                        format: oe.format,
                        width: be,
                        height: be,
                        mipmaps: !1,
                      });
                    (ws._levels[0] = ai), ws.upload();
                    const xs = new Qe.g(Wt, {
                        name: "prefiltered-cube",
                        cubemap: !1,
                        type: L.s64,
                        format: oe.format,
                        width: be,
                        height: be,
                        mipmaps: !1,
                      }),
                      ei = new k.O({ colorBuffer: xs, depth: !1 });
                    as.setValue(ws),
                      Wt.setBlendState(Pe.t.NOBLEND),
                      (0, fs.l)(Wt, ei, hs);
                    const Ws = Wt.gl;
                    Ws.bindFramebuffer(Ws.FRAMEBUFFER, ei.impl._glFrameBuffer);
                    const on = new Uint8Array(be * be * 4);
                    Ws.readPixels(
                      0,
                      0,
                      ws.width,
                      ws.height,
                      Ws.RGBA,
                      Ws.UNSIGNED_BYTE,
                      on
                    ),
                      (oe._levels[0][Es] = on);
                  }
                } else return null;
              const We = [];
              for (let hs = 0; hs < be; hs++)
                for (let as = 0; as < be; as++) {
                  const Es = (as / (be - 1)) * 2 - 1,
                    ai = (hs / (be - 1)) * 2 - 1;
                  We[hs * be + as] = new F.e(Es, ai, 1).normalize();
                }
              const He = new Float32Array(9 * 3),
                st = 0,
                dt = 1 * 3,
                pt = 2 * 3,
                Mt = 3 * 3,
                It = 4 * 3,
                Dt = 5 * 3,
                Gt = 6 * 3,
                Vt = 7 * 3,
                Jt = 8 * 3,
                ms = 0,
                ks = 1,
                Ds = 2,
                qs = 3,
                vi = 4,
                di = 5;
              let cs = 0;
              for (let hs = 0; hs < 6; hs++)
                for (let as = 0; as < be; as++)
                  for (let Es = 0; Es < be; Es++) {
                    const ai = as * be + Es,
                      ws = Pi(Es, as, be),
                      xs = (ws * 4) / 17,
                      ei = (ws * 8) / 17,
                      Ws = (ws * 15) / 17,
                      on = (ws * 5) / 68,
                      Ii = (ws * 15) / 68,
                      gs = We[ai];
                    let Vs, ti, Ks;
                    hs === ms
                      ? ((Vs = gs.z), (ti = -gs.y), (Ks = -gs.x))
                      : hs === ks
                      ? ((Vs = -gs.z), (ti = -gs.y), (Ks = gs.x))
                      : hs === Ds
                      ? ((Vs = gs.x), (ti = gs.z), (Ks = gs.y))
                      : hs === qs
                      ? ((Vs = gs.x), (ti = -gs.z), (Ks = -gs.y))
                      : hs === vi
                      ? ((Vs = gs.x), (ti = -gs.y), (Ks = gs.z))
                      : hs === di && ((Vs = -gs.x), (ti = -gs.y), (Ks = -gs.z)),
                      Ee || (Vs = -Vs);
                    const fr = oe._levels[0][hs][ai * 4 + 3] / 255;
                    for (let Fs = 0; Fs < 3; Fs++) {
                      let Us = oe._levels[0][hs][ai * 4 + Fs] / 255;
                      oe.type === L.fW0
                        ? ((Us *= fr * 8), (Us *= Us))
                        : (Us = Math.pow(Us, 2.2)),
                        (He[st + Fs] += Us * xs),
                        (He[dt + Fs] += Us * ei * Vs),
                        (He[pt + Fs] += Us * ei * ti),
                        (He[Mt + Fs] += Us * ei * Ks),
                        (He[It + Fs] += Us * Ws * Vs * Ks),
                        (He[Dt + Fs] += Us * Ws * Ks * ti),
                        (He[Gt + Fs] += Us * Ws * ti * Vs),
                        (He[Vt + Fs] += Us * on * (3 * Ks * Ks - 1)),
                        (He[Jt + Fs] += Us * Ii * (Vs * Vs - ti * ti)),
                        (cs += ws);
                    }
                  }
              for (let hs = 0; hs < He.length; hs++)
                He[hs] *= (4 * Math.PI) / cs;
              return He;
            }
            var pn = a(5490),
              tn = a(6874),
              Rn = a(7638),
              ni = a(8947),
              On = a(4595),
              _n = a(7788),
              Ln = a(3042),
              Bn = a(5616),
              Fn = a(377),
              Un = a(8974),
              Nn = a(5695),
              zn = a(7358),
              bi = a(4561),
              sn = a(5418),
              kn = a(6029),
              Wn = a(3527),
              Vn = a(392),
              mn = a(8593),
              Gn = a(5339),
              jn = a(6732),
              gn = a(2364),
              Tr = a(9619),
              $n = a(8751),
              yn = a(6686),
              xr = a(4124),
              vn = a(2930),
              Ar = a(972),
              Ni = a(9189),
              Cr = a(6543),
              Pr = a(6528),
              br = a(8219),
              ns = a(371),
              qn = a(1657),
              er = a(8596),
              En = a(5777),
              tr = a(3371),
              Hn = a(7436),
              Mr = a(1993),
              sr = a(906),
              Kn = a(1341),
              zs = a(9733),
              zi = a(7503),
              sa = a(5680),
              ia = a(9763),
              na = a(3188),
              ra = a(9686),
              ir = a(7654),
              ps = a(8441),
              wr = a(9803),
              aa = a(5580),
              oa = a(2205),
              la = a(8103),
              Ir = a(5080),
              rs = a(8379),
              _o = a(6225),
              Sn = a(1849),
              Dr = a(8576),
              Rr = a(7258),
              Or = a(2417),
              ha = a(11),
              Lr = a(3756),
              nr = a(9376),
              Br = a(8871),
              rr = a(8226),
              ar = a(8037),
              ca = a(393),
              da = a(5902),
              ki = a(3940),
              ua = a(406),
              fa = a(2281),
              pa = a(4963),
              Mi = a(5460),
              or = a(5003),
              lr = a(7288),
              mo = a(7562),
              _a = a(9882),
              ma = a(4237),
              hr = a(1626),
              Fr = a(4885),
              ga = a(1097),
              ya = a(6862),
              nn = a(871),
              cr = a(8635),
              Si = a(70),
              va = a(541),
              Ea = a(7448),
              Sa = a(7433),
              Ta = a(5745),
              xa = a(8265),
              Aa = a(7825),
              Ca = a(9645),
              Pa = a(7747),
              _s = a(4474),
              ba = a(2414),
              Ma = a(949),
              Bs = a(148),
              Ur = a(3953);
            class wa extends s.J {
              constructor(oe, Ee) {
                super(),
                  (this._assets = new Set()),
                  (this._loadingAssets = new Set()),
                  (this._waitingAssets = new Set()),
                  (this._registry = Ee),
                  (this._loading = !1),
                  (this._loaded = !1),
                  (this._failed = []),
                  oe.forEach((be) => {
                    if (be instanceof Ur.V)
                      be.registry || (be.registry = Ee), this._assets.add(be);
                    else {
                      const We = Ee.get(be);
                      We ? this._assets.add(We) : this._waitForAsset(be);
                    }
                  });
              }
              destroy() {
                const oe = this;
                this._registry.off("load", this._onLoad),
                  this._registry.off("error", this._onError),
                  this._waitingAssets.forEach(function (Ee) {
                    oe._registry.off("add:" + Ee, this._onAddAsset);
                  }),
                  this.off("progress"),
                  this.off("load");
              }
              _assetHasDependencies(oe) {
                var Ee;
                return (
                  oe.type === "model" &&
                  ((Ee = oe.file) == null ? void 0 : Ee.url) &&
                  oe.file.url &&
                  oe.file.url.match(/.json$/g)
                );
              }
              load(oe, Ee) {
                if (this._loading) return;
                (this._loading = !0),
                  (this._callback = oe),
                  (this._scope = Ee),
                  this._registry.on("load", this._onLoad, this),
                  this._registry.on("error", this._onError, this);
                let be = !1;
                this._assets.forEach((We) => {
                  We.loaded ||
                    ((be = !0),
                    this._assetHasDependencies(We) &&
                      this._registry.loadFromUrl(
                        We.file.url,
                        We.type,
                        (He, st) => {
                          if (He) {
                            this._onError(He, We);
                            return;
                          }
                          this._onLoad(We);
                        }
                      ),
                    this._loadingAssets.add(We),
                    this._registry.add(We));
                }),
                  this._loadingAssets.forEach((We) => {
                    this._assetHasDependencies(We) || this._registry.load(We);
                  }),
                  !be &&
                    this._waitingAssets.size === 0 &&
                    this._loadingComplete();
              }
              ready(oe, Ee = this) {
                this._loaded
                  ? oe.call(Ee, Array.from(this._assets))
                  : this.once("load", function (be) {
                      oe.call(Ee, be);
                    });
              }
              _loadingComplete() {
                this._loaded ||
                  ((this._loaded = !0),
                  this._registry.off("load", this._onLoad, this),
                  this._registry.off("error", this._onError, this),
                  this._failed.length
                    ? (this._callback &&
                        this._callback.call(
                          this._scope,
                          "Failed to load some assets",
                          this._failed
                        ),
                      this.fire("error", this._failed))
                    : (this._callback && this._callback.call(this._scope),
                      this.fire("load", Array.from(this._assets))));
              }
              _onLoad(oe) {
                this._loadingAssets.has(oe) &&
                  (this.fire("progress", oe), this._loadingAssets.delete(oe)),
                  this._loadingAssets.size === 0 &&
                    setTimeout(() => {
                      this._loadingComplete(this._failed);
                    }, 0);
              }
              _onError(oe, Ee) {
                this._loadingAssets.has(Ee) &&
                  (this._failed.push(Ee), this._loadingAssets.delete(Ee)),
                  this._loadingAssets.size === 0 &&
                    setTimeout(() => {
                      this._loadingComplete(this._failed);
                    }, 0);
              }
              _onAddAsset(oe) {
                this._waitingAssets.delete(oe),
                  this._assets.add(oe),
                  oe.loaded ||
                    (this._loadingAssets.add(oe), this._registry.load(oe));
              }
              _waitForAsset(oe) {
                this._waitingAssets.add(oe),
                  this._registry.once("add:" + oe, this._onAddAsset, this);
              }
            }
            var Ia = a(3029),
              Da = a(0),
              Ra = a(5853),
              Nr = a(2471),
              Oa = a(4289);
            const Xn = 4096,
              zr = 512;
            class La extends s.J {
              constructor(oe, Ee = {}) {
                super(),
                  (this.type = "bitmap"),
                  (this.app = oe),
                  (this.intensity = 0),
                  (this.fontWeight = Ee.fontWeight || "normal"),
                  (this.fontSize = parseInt(Ee.fontSize, 10)),
                  (this.glyphSize = this.fontSize),
                  (this.fontName = Ee.fontName || "Arial"),
                  (this.color = Ee.color || new m.Q(1, 1, 1)),
                  (this.padding = Ee.padding || 0);
                const be = Ee.width > Xn ? Xn : Ee.width || zr,
                  We = Ee.height > Xn ? Xn : Ee.height || zr,
                  He = document.createElement("canvas");
                (He.height = We), (He.width = be);
                const st = new Qe.g(this.app.graphicsDevice, {
                  name: "font",
                  format: L.Lxj,
                  minFilter: L.qn_,
                  magFilter: L.DrA,
                  addressU: L.vq6,
                  addressV: L.vq6,
                  mipmaps: !0,
                });
                st.setSource(He),
                  (this.textures = [st]),
                  (this.chars = ""),
                  (this.data = {});
              }
              createTextures(oe) {
                const Ee = this._normalizeCharsSet(oe);
                if (Ee.length !== this.chars.length) {
                  this._renderAtlas(Ee);
                  return;
                }
                for (let be = 0; be < Ee.length; be++)
                  if (Ee[be] !== this.chars[be]) {
                    this._renderAtlas(Ee);
                    return;
                  }
              }
              updateTextures(oe) {
                const Ee = this._normalizeCharsSet(oe),
                  be = [];
                for (let We = 0; We < Ee.length; We++) {
                  const He = Ee[We];
                  this.data.chars[He] || be.push(He);
                }
                be.length > 0 && this._renderAtlas(this.chars.concat(be));
              }
              destroy() {
                for (let oe = 0; oe < this.textures.length; oe++)
                  this.textures[oe].destroy();
                (this.chars = null),
                  (this.color = null),
                  (this.data = null),
                  (this.fontName = null),
                  (this.fontSize = null),
                  (this.glyphSize = null),
                  (this.intensity = null),
                  (this.textures = null),
                  (this.type = null),
                  (this.fontWeight = null);
              }
              _getAndClearContext(oe, Ee) {
                const be = oe.width,
                  We = oe.height,
                  He = oe.getContext("2d", { alpha: !0 });
                return (
                  He.clearRect(0, 0, be, We),
                  (He.fillStyle = Ee),
                  He.fillRect(0, 0, be, We),
                  He
                );
              }
              _colorToRgbString(oe, Ee) {
                let be;
                const We = Math.round(255 * oe.r),
                  He = Math.round(255 * oe.g),
                  st = Math.round(255 * oe.b);
                return (
                  Ee
                    ? (be = `rgba(${We}, ${He}, ${st}, ${oe.a})`)
                    : (be = `rgb(${We}, ${He}, ${st})`),
                  be
                );
              }
              renderCharacter(oe, Ee, be, We, He) {
                (oe.fillStyle = He), oe.fillText(Ee, be, We);
              }
              _renderAtlas(oe) {
                this.chars = oe;
                let Ee = 1,
                  be = this.textures[Ee - 1].getSource();
                const We = be.width,
                  He = be.height,
                  st = this._colorToRgbString(this.color, !1),
                  dt = this.color.a;
                this.color.a = 0.00392156862745098;
                const pt = this._colorToRgbString(this.color, !0);
                this.color.a = dt;
                const Mt = "center",
                  It = "alphabetic";
                let Dt = this._getAndClearContext(be, pt);
                (Dt.font =
                  this.fontWeight +
                  " " +
                  this.fontSize.toString() +
                  "px " +
                  this.fontName),
                  (Dt.textAlign = Mt),
                  (Dt.textBaseline = It),
                  (this.data = this._createJson(
                    this.chars,
                    this.fontName,
                    We,
                    He
                  ));
                const Gt = f.Y.getSymbols(this.chars.join("")),
                  Vt = this.textures.length;
                let Jt = 0,
                  ms = 0;
                const ks = {};
                for (let as = 0; as < Gt.length; as++) {
                  const Es = Gt[as];
                  (ks[Es] = this._getTextMetrics(Es)),
                    (Jt = Math.max(Jt, ks[Es].height)),
                    (ms = Math.max(ms, ks[Es].descent));
                }
                this.glyphSize = Math.max(this.glyphSize, Jt);
                const Ds = this.glyphSize + this.padding * 2,
                  qs = this.glyphSize + this.padding * 2,
                  vi = this.glyphSize / 2 + this.padding,
                  di = qs - ms - this.padding;
                let cs = 0,
                  hs = 0;
                for (let as = 0; as < Gt.length; as++) {
                  const Es = Gt[as],
                    ai = f.Y.getCodePoint(Gt[as]);
                  let ws = this.fontSize;
                  (Dt.font =
                    this.fontWeight +
                    " " +
                    ws.toString() +
                    "px " +
                    this.fontName),
                    (Dt.textAlign = Mt),
                    (Dt.textBaseline = It);
                  let xs = Dt.measureText(Es).width;
                  xs > ws &&
                    ((ws = (this.fontSize * this.fontSize) / xs),
                    (Dt.font =
                      this.fontWeight +
                      " " +
                      ws.toString() +
                      "px " +
                      this.fontName),
                    (xs = this.fontSize)),
                    this.renderCharacter(Dt, Es, cs + vi, hs + di, st);
                  const ei = this.padding + (this.glyphSize - xs) / 2,
                    Ws = -this.padding + ks[Es].descent - ms,
                    on = xs;
                  if (
                    (this._addChar(
                      this.data,
                      Es,
                      ai,
                      cs,
                      hs,
                      Ds,
                      qs,
                      ei,
                      Ws,
                      on,
                      Ee - 1,
                      We,
                      He
                    ),
                    (cs += Ds),
                    cs + Ds > We && ((cs = 0), (hs += qs), hs + qs > He))
                  )
                    if (
                      (this.textures[Ee - 1].upload(), Ee++, (hs = 0), Ee > Vt)
                    ) {
                      (be = document.createElement("canvas")),
                        (be.height = He),
                        (be.width = We),
                        (Dt = this._getAndClearContext(be, pt));
                      const Ii = new Qe.g(this.app.graphicsDevice, {
                        format: L.Lxj,
                        mipmaps: !0,
                        name: "font-atlas",
                      });
                      Ii.setSource(be),
                        (Ii.minFilter = L.qn_),
                        (Ii.magFilter = L.DrA),
                        (Ii.addressU = L.vq6),
                        (Ii.addressV = L.vq6),
                        this.textures.push(Ii);
                    } else
                      (be = this.textures[Ee - 1].getSource()),
                        (Dt = this._getAndClearContext(be, pt));
                }
                if ((this.textures[Ee - 1].upload(), Ee < Vt)) {
                  for (let as = Ee; as < Vt; as++) this.textures[as].destroy();
                  this.textures.splice(Ee);
                }
                this.fire("render");
              }
              _createJson(oe, Ee, be, We) {
                return {
                  version: 3,
                  intensity: this.intensity,
                  info: {
                    face: Ee,
                    width: be,
                    height: We,
                    maps: [{ width: be, height: We }],
                  },
                  chars: {},
                };
              }
              _addChar(oe, Ee, be, We, He, st, dt, pt, Mt, It, Dt, Gt, Vt) {
                oe.info.maps.length < Dt + 1 &&
                  oe.info.maps.push({ width: Gt, height: Vt });
                const Jt = this.fontSize / 32;
                oe.chars[Ee] = {
                  id: be,
                  letter: Ee,
                  x: We,
                  y: He,
                  width: st,
                  height: dt,
                  xadvance: It / Jt,
                  xoffset: pt / Jt,
                  yoffset: (Mt + this.padding) / Jt,
                  scale: Jt,
                  range: 1,
                  map: Dt,
                  bounds: [0, 0, st / Jt, dt / Jt],
                };
              }
              _normalizeCharsSet(oe) {
                const Ee = this.app.systems.element.getUnicodeConverter();
                Ee && (oe = Ee(oe));
                const be = {},
                  We = f.Y.getSymbols(oe);
                for (let st = 0; st < We.length; st++) {
                  const dt = We[st];
                  be[dt] || (be[dt] = dt);
                }
                return Object.keys(be).sort();
              }
              _getTextMetrics(oe) {
                const Ee = document.createElement("span");
                (Ee.id = "content-span"), (Ee.innerHTML = oe);
                const be = document.createElement("div");
                (be.id = "content-block"),
                  (be.style.display = "inline-block"),
                  (be.style.width = "1px"),
                  (be.style.height = "0px");
                const We = document.createElement("div");
                We.appendChild(Ee),
                  We.appendChild(be),
                  (We.style.font = this.fontSize + "px " + this.fontName),
                  document.body.appendChild(We);
                let st = -1,
                  dt = -1,
                  pt = -1;
                try {
                  (be.style["vertical-align"] = "baseline"),
                    (st = be.offsetTop - Ee.offsetTop),
                    (be.style["vertical-align"] = "bottom"),
                    (pt = be.offsetTop - Ee.offsetTop),
                    (dt = pt - st);
                } finally {
                  document.body.removeChild(We);
                }
                return { ascent: st, descent: dt, height: pt };
              }
            }
            var Ba = a(3259),
              Fa = a(5691),
              Ua = a(6306),
              go = a(7712),
              Yn = a(3664),
              Na = a(6348),
              Wi = a(2436),
              Tn = a(4060),
              xn = a(792),
              kr = a(2629),
              yo = a(6498),
              wi = a(3484),
              An = a(6341),
              vo = a(8363),
              za = a(1872),
              Eo = a(7369),
              So = a(3037),
              ka = a(2581),
              ri = a(4230),
              Wr = a(6153),
              Wa = a(2200),
              To = a(1552);
            class Vr {
              load(oe, Ee, be) {
                throw new Error("not implemented");
              }
              open(oe, Ee, be) {
                throw new Error("not implemented");
              }
              patch(oe, Ee) {}
            }
            var xo = a(9992),
              Va = a(7367),
              Ao = a(2489),
              Ga = a(7766);
            class Ti {
              constructor(oe) {
                (this._app = oe), (this.maxRetries = 0);
              }
              load(oe, Ee) {
                Ga.u.load(oe, this.maxRetries, Ee);
              }
              open(oe, Ee) {
                return Ee.settings;
              }
            }
            var Co = a(8501),
              Po = a(473),
              ja = a(8774),
              Ha = a(1351),
              rn = a(5676),
              dr = a(9319),
              an = a(7896),
              Ka = a(461),
              Zn = a(2633),
              Gr = a(6087),
              Xa = a(4277),
              Ya = a(714),
              Za = a(4446),
              Ss = a(184),
              Qa = a(1298),
              Ja = a(7223),
              jr = a(7408),
              $a = a(8839),
              qa = a(3205),
              eo = a(8076),
              Hr = a(4584),
              ur = a(7525),
              Kr = a(9700),
              Xr = a(7419),
              Yr = a(5638),
              to = a(3112),
              Yt = a(54);
          },
          9104: (xe, V, a) => {
            "use strict";
            a.d(V, { U: () => A });
            function A() {
              return (
                typeof AudioContext != "undefined" ||
                typeof webkitAudioContext != "undefined"
              );
            }
          },
          3231: (xe, V, a) => {
            "use strict";
            a.d(V, { c: () => y });
            var A = a(8656),
              x = a(9104);
            class y {
              constructor(d, h, f = {}) {
                var s, l, n;
                if (
                  ((this.volume = (s = f.volume) != null ? s : 1),
                  (this.loop = (l = f.loop) != null ? l : !1),
                  (this.pitch = (n = f.pitch) != null ? n : 1),
                  (this.sound = h),
                  (this.paused = !1),
                  (this.suspended = !1),
                  (this.manager = d),
                  (this.source = null),
                  (0, x.U)())
                ) {
                  (this.startTime = 0), (this.startOffset = 0);
                  const o = d.context;
                  this.gain = o.createGain();
                } else
                  h.audio &&
                    ((this.source = h.audio.cloneNode(!1)),
                    this.source.pause());
              }
              getVolume() {
                return this.volume;
              }
              getLoop() {
                return this.loop;
              }
              setLoop(d) {
                (this.loop = d), this.source && (this.source.loop = d);
              }
              getPitch() {
                return this.pitch;
              }
              onManagerVolumeChange() {
                this.setVolume(this.getVolume());
              }
              onManagerSuspend() {
                this.isPlaying() &&
                  !this.suspended &&
                  ((this.suspended = !0), this.pause());
              }
              onManagerResume() {
                this.suspended && ((this.suspended = !1), this.unpause());
              }
              play() {
                if (this.source)
                  throw new Error("Call stop() before calling play()");
                this._createSource(),
                  this.source &&
                    ((this.startTime = this.manager.context.currentTime),
                    this.source.start(
                      0,
                      this.startOffset % this.source.buffer.duration
                    ),
                    this.setVolume(this.volume),
                    this.setLoop(this.loop),
                    this.setPitch(this.pitch),
                    this.manager.on(
                      "volumechange",
                      this.onManagerVolumeChange,
                      this
                    ),
                    this.manager.on("suspend", this.onManagerSuspend, this),
                    this.manager.on("resume", this.onManagerResume, this),
                    this.manager.suspended && this.onManagerSuspend());
              }
              pause() {
                this.source &&
                  ((this.paused = !0),
                  (this.startOffset +=
                    this.manager.context.currentTime - this.startTime),
                  this.source.stop(0),
                  (this.source = null));
              }
              unpause() {
                if (this.source || !this.paused) {
                  console.warn("Call pause() before unpausing.");
                  return;
                }
                this._createSource(),
                  this.source &&
                    ((this.startTime = this.manager.context.currentTime),
                    this.source.start(
                      0,
                      this.startOffset % this.source.buffer.duration
                    ),
                    this.setVolume(this.volume),
                    this.setLoop(this.loop),
                    this.setPitch(this.pitch),
                    (this.paused = !1));
              }
              stop() {
                this.source && (this.source.stop(0), (this.source = null)),
                  this.manager.off(
                    "volumechange",
                    this.onManagerVolumeChange,
                    this
                  ),
                  this.manager.off("suspend", this.onManagerSuspend, this),
                  this.manager.off("resume", this.onManagerResume, this);
              }
              setVolume(d) {
                (d = A.D.clamp(d, 0, 1)),
                  (this.volume = d),
                  this.gain && (this.gain.gain.value = d * this.manager.volume);
              }
              setPitch(d) {
                (this.pitch = d),
                  this.source && (this.source.playbackRate.value = d);
              }
              isPlaying() {
                return (
                  !this.paused &&
                  this.source.playbackState === this.source.PLAYING_STATE
                );
              }
              getDuration() {
                return this.source ? this.source.buffer.duration : 0;
              }
              _createSource() {
                const d = this.manager.context;
                this.sound.buffer &&
                  ((this.source = d.createBufferSource()),
                  (this.source.buffer = this.sound.buffer),
                  this.source.connect(this.gain),
                  this.gain.connect(d.destination),
                  this.loop || (this.source.onended = this.pause.bind(this)));
              }
            }
            (0, x.U)() ||
              Object.assign(y.prototype, {
                play: function () {
                  this.source &&
                    ((this.paused = !1),
                    this.setVolume(this.volume),
                    this.setLoop(this.loop),
                    this.setPitch(this.pitch),
                    this.source.play()),
                    this.manager.on(
                      "volumechange",
                      this.onManagerVolumeChange,
                      this
                    ),
                    this.manager.on("suspend", this.onManagerSuspend, this),
                    this.manager.on("resume", this.onManagerResume, this),
                    this.manager.suspended && this.onManagerSuspend();
                },
                pause: function () {
                  this.source && ((this.paused = !0), this.source.pause());
                },
                unpause: function () {
                  this.source && ((this.paused = !1), this.source.play());
                },
                stop: function () {
                  this.source && this.source.pause(),
                    this.manager.off(
                      "volumechange",
                      this.onManagerVolumeChange,
                      this
                    ),
                    this.manager.off("suspend", this.onManagerSuspend, this),
                    this.manager.off("resume", this.onManagerResume, this);
                },
                setVolume: function (c) {
                  (c = A.D.clamp(c, 0, 1)),
                    (this.volume = c),
                    this.source &&
                      (this.source.volume = c * this.manager.volume);
                },
                setPitch: function (c) {
                  (this.pitch = c),
                    this.source && (this.source.playbackRate = c);
                },
                getDuration: function () {
                  return this.source && !isNaN(this.source.duration)
                    ? this.source.duration
                    : 0;
                },
                isPlaying: function () {
                  return !this.source.paused;
                },
              });
          },
          8844: (xe, V, a) => {
            "use strict";
            a.d(V, { j: () => f });
            var A = a(8656),
              x = a(7481),
              y = a(1145),
              c = a(9104),
              d = a(3231);
            const h = 1e4;
            class f extends d.c {
              constructor(l, n, o) {
                super(l, n, o),
                  (this.position = new x.e()),
                  (this.velocity = new x.e()),
                  (0, c.U)()
                    ? (this.panner = l.context.createPanner())
                    : ((this.maxDistance = h),
                      (this.minDistance = 1),
                      (this.rollOffFactor = 1),
                      (this.distanceModel = y.Jq));
              }
              getPosition() {
                return this.position;
              }
              setPosition(l) {
                this.position.copy(l);
                const n = this.panner;
                "positionX" in n
                  ? ((n.positionX.value = l.x),
                    (n.positionY.value = l.y),
                    (n.positionZ.value = l.z))
                  : n.setPosition && n.setPosition(l.x, l.y, l.z);
              }
              getVelocity() {
                return this.velocity;
              }
              setVelocity(l) {
                this.velocity.copy(l);
              }
              getMaxDistance() {
                return this.panner.maxDistance;
              }
              setMaxDistance(l) {
                this.panner.maxDistance = l;
              }
              getMinDistance() {
                return this.panner.refDistance;
              }
              setMinDistance(l) {
                this.panner.refDistance = l;
              }
              getRollOffFactor() {
                return this.panner.rolloffFactor;
              }
              setRollOffFactor(l) {
                this.panner.rolloffFactor = l;
              }
              getDistanceModel() {
                return this.panner.distanceModel;
              }
              setDistanceModel(l) {
                this.panner.distanceModel = l;
              }
              _createSource() {
                const l = this.manager.context;
                (this.source = l.createBufferSource()),
                  (this.source.buffer = this.sound.buffer),
                  this.source.connect(this.panner),
                  this.panner.connect(this.gain),
                  this.gain.connect(l.destination),
                  this.loop || (this.source.onended = this.pause.bind(this));
              }
            }
            if (!(0, c.U)()) {
              let s = new x.e();
              const l = function (o, i, e, t, r, u) {
                s = s.sub2(o, i);
                const v = s.length();
                if (v < e) return 1;
                if (v > t) return 0;
                let _ = 0;
                return (
                  u === y.q9
                    ? (_ = 1 - (r * (v - e)) / (t - e))
                    : u === y.Jq
                    ? (_ = e / (e + r * (v - e)))
                    : u === y.an && (_ = Math.pow(v / e, -r)),
                  A.D.clamp(_, 0, 1)
                );
              };
              Object.assign(f.prototype, {
                setPosition: function (n) {
                  if ((this.position.copy(n), this.source)) {
                    const i = this.manager.listener.getPosition(),
                      e = l(
                        i,
                        this.position,
                        this.minDistance,
                        this.maxDistance,
                        this.rollOffFactor,
                        this.distanceModel
                      ),
                      t = this.getVolume();
                    this.source.volume = t * e;
                  }
                },
                getMaxDistance: function () {
                  return this.maxDistance;
                },
                setMaxDistance: function (n) {
                  this.maxDistance = n;
                },
                getMinDistance: function () {
                  return this.minDistance;
                },
                setMinDistance: function (n) {
                  this.minDistance = n;
                },
                getRollOffFactor: function () {
                  return this.rollOffFactor;
                },
                setRollOffFactor: function (n) {
                  this.rollOffFactor = n;
                },
                getDistanceModel: function () {
                  return this.distanceModel;
                },
                setDistanceModel: function (n) {
                  this.distanceModel = n;
                },
              });
            }
          },
          1145: (xe, V, a) => {
            "use strict";
            a.d(V, { Jq: () => x, an: () => y, q9: () => A });
            const A = "linear",
              x = "inverse",
              y = "exponential";
          },
          6252: (xe, V, a) => {
            "use strict";
            a.d(V, { GN: () => d, Xq: () => c, a$: () => h });
            var A = a(1630);
            let x = 0;
            const y = {
              [A.HeG]: "texture2D",
              [A.GGM]: "textureCube",
              [A.EuA]: "texture3D",
            };
            class c {
              constructor(s, l) {
                (this.name = s), (this.visibility = l);
              }
            }
            class d {
              constructor(s, l, n = A.HeG, o = A.CZm) {
                (this.scopeId = void 0),
                  (this.name = s),
                  (this.visibility = l),
                  (this.textureDimension = n),
                  (this.sampleType = o);
              }
            }
            class h {
              constructor(s, l = [], n = []) {
                (this.id = x++),
                  (this.device = s),
                  (this.bufferFormats = l),
                  (this.bufferFormatsMap = new Map()),
                  l.forEach((i, e) => this.bufferFormatsMap.set(i.name, e)),
                  (this.textureFormats = n);
                const o = s.scope;
                (this.textureFormatsMap = new Map()),
                  n.forEach((i, e) => {
                    this.textureFormatsMap.set(i.name, e),
                      (i.scopeId = o.resolve(i.name));
                  }),
                  (this.impl = s.createBindGroupFormatImpl(this));
              }
              destroy() {
                this.impl.destroy();
              }
              getTexture(s) {
                const l = this.textureFormatsMap.get(s);
                return l !== void 0 ? this.textureFormats[l] : null;
              }
              getShaderDeclarationTextures(s) {
                let l = "",
                  n = this.bufferFormats.length;
                return (
                  this.textureFormats.forEach((o) => {
                    const i = y[o.textureDimension];
                    l += `layout(set = ${s}, binding = ${n++}) uniform ${i} ${
                      o.name
                    };
layout(set = ${s}, binding = ${n++}) uniform sampler ${o.name}_sampler;
`;
                  }),
                  l
                );
              }
              loseContext() {}
            }
          },
          2978: (xe, V, a) => {
            "use strict";
            a.d(V, { T: () => y });
            var A = a(1630);
            let x = 0;
            class y {
              constructor(d, h, f) {
                (this.renderVersionUpdated = -1),
                  (this.uniformBuffers = void 0),
                  (this.uniformBufferOffsets = []),
                  (this.id = x++),
                  (this.device = d),
                  (this.format = h),
                  (this.dirty = !0),
                  (this.impl = d.createBindGroupImpl(this)),
                  (this.textures = []),
                  (this.uniformBuffers = []),
                  (this.defaultUniformBuffer = f),
                  f && this.setUniformBuffer(A.rb7, f);
              }
              destroy() {
                this.impl.destroy(),
                  (this.impl = null),
                  (this.format = null),
                  (this.defaultUniformBuffer = null);
              }
              setUniformBuffer(d, h) {
                const f = this.format.bufferFormatsMap.get(d);
                this.uniformBuffers[f] !== h &&
                  ((this.uniformBuffers[f] = h), (this.dirty = !0));
              }
              setTexture(d, h) {
                const f = this.format.textureFormatsMap.get(d);
                this.textures[f] !== h
                  ? ((this.textures[f] = h), (this.dirty = !0))
                  : this.renderVersionUpdated < h.renderVersionDirty &&
                    (this.dirty = !0);
              }
              update() {
                const d = this.format.textureFormats;
                for (let h = 0; h < d.length; h++) {
                  const f = d[h],
                    s = f.scopeId.value;
                  this.setTexture(f.name, s);
                }
                this.uniformBufferOffsets.length = this.uniformBuffers.length;
                for (let h = 0; h < this.uniformBuffers.length; h++) {
                  const f = this.uniformBuffers[h];
                  (this.uniformBufferOffsets[h] = f.offset),
                    this.renderVersionUpdated < f.renderVersionDirty &&
                      (this.dirty = !0);
                }
                this.dirty &&
                  ((this.dirty = !1),
                  (this.renderVersionUpdated = this.device.renderVersion),
                  this.impl.update(this));
              }
            }
          },
          1268: (xe, V, a) => {
            "use strict";
            a.d(V, { t: () => _ });
            var A = a(5917),
              x = a(1630);
            const y = 7,
              c = 15,
              d = 0,
              h = 3,
              f = 7,
              s = 11,
              l = 14,
              n = 18,
              o = 22,
              i = 23,
              e = 24,
              t = 25,
              r = 26,
              u = 15,
              v = o;
            class _ {
              constructor(
                g = !1,
                T = x.KLp,
                E = x.qa5,
                M = x.seI,
                R,
                P,
                F,
                b = !0,
                D = !0,
                G = !0,
                X = !0
              ) {
                (this.target0 = 0),
                  this.setColorBlend(T, E, M),
                  this.setAlphaBlend(
                    R != null ? R : T,
                    P != null ? P : E,
                    F != null ? F : M
                  ),
                  this.setColorWrite(b, D, G, X),
                  (this.blend = g);
              }
              set blend(g) {
                this.target0 = A.p.set(this.target0, g ? 1 : 0, r);
              }
              get blend() {
                return A.p.all(this.target0, r);
              }
              setColorBlend(g, T, E) {
                (this.target0 = A.p.set(this.target0, g, d, y)),
                  (this.target0 = A.p.set(this.target0, T, h, c)),
                  (this.target0 = A.p.set(this.target0, E, f, c));
              }
              setAlphaBlend(g, T, E) {
                (this.target0 = A.p.set(this.target0, g, s, y)),
                  (this.target0 = A.p.set(this.target0, T, l, c)),
                  (this.target0 = A.p.set(this.target0, E, n, c));
              }
              setColorWrite(g, T, E, M) {
                (this.redWrite = g),
                  (this.greenWrite = T),
                  (this.blueWrite = E),
                  (this.alphaWrite = M);
              }
              get colorOp() {
                return A.p.get(this.target0, d, y);
              }
              get colorSrcFactor() {
                return A.p.get(this.target0, h, c);
              }
              get colorDstFactor() {
                return A.p.get(this.target0, f, c);
              }
              get alphaOp() {
                return A.p.get(this.target0, s, y);
              }
              get alphaSrcFactor() {
                return A.p.get(this.target0, l, c);
              }
              get alphaDstFactor() {
                return A.p.get(this.target0, n, c);
              }
              set redWrite(g) {
                this.target0 = A.p.set(this.target0, g ? 1 : 0, o);
              }
              get redWrite() {
                return A.p.all(this.target0, o);
              }
              set greenWrite(g) {
                this.target0 = A.p.set(this.target0, g ? 1 : 0, i);
              }
              get greenWrite() {
                return A.p.all(this.target0, i);
              }
              set blueWrite(g) {
                this.target0 = A.p.set(this.target0, g ? 1 : 0, e);
              }
              get blueWrite() {
                return A.p.all(this.target0, e);
              }
              set alphaWrite(g) {
                this.target0 = A.p.set(this.target0, g ? 1 : 0, t);
              }
              get alphaWrite() {
                return A.p.all(this.target0, t);
              }
              get allWrite() {
                return A.p.get(this.target0, v, u);
              }
              copy(g) {
                return (this.target0 = g.target0), this;
              }
              clone() {
                return new this.constructor().copy(this);
              }
              get key() {
                return this.target0;
              }
              equals(g) {
                return this.target0 === g.target0;
              }
            }
            (_.NOBLEND = Object.freeze(new _())),
              (_.NOWRITE = Object.freeze(
                new _(
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  !1,
                  !1,
                  !1,
                  !1
                )
              )),
              (_.ALPHABLEND = Object.freeze(new _(!0, x.KLp, x.LDz, x.dIP)));
          },
          1630: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $$M: () => yt,
              $1R: () => Qt,
              $Cd: () => bi,
              $Q8: () => Gs,
              $Qt: () => l,
              $_V: () => es,
              $mg: () => Ai,
              AQ1: () => _e,
              ArW: () => At,
              B8J: () => vn,
              Bz3: () => dn,
              BzK: () => Mn,
              CG0: () => Xi,
              CPw: () => ni,
              CWw: () => ve,
              CWz: () => nt,
              CZm: () => gi,
              Cvi: () => Kn,
              DrA: () => ge,
              EB8: () => vs,
              EEU: () => ct,
              EPU: () => z,
              ERE: () => Wn,
              EUX: () => Zi,
              EYH: () => te,
              E_6: () => K,
              Eb5: () => tn,
              EhU: () => G,
              EuA: () => mi,
              F8$: () => Ke,
              FEO: () => Nn,
              FHY: () => s,
              FHg: () => Xe,
              FQW: () => q,
              FqP: () => $s,
              FxX: () => Je,
              G1V: () => Ts,
              G24: () => vt,
              G3_: () => zt,
              G9c: () => Nt,
              GBD: () => xt,
              GF5: () => $i,
              GGM: () => pi,
              GHH: () => et,
              GLw: () => k,
              GU6: () => fs,
              GWP: () => Qe,
              HeG: () => js,
              Hn_: () => Ne,
              HsS: () => Ve,
              IIP: () => ae,
              IQA: () => Ce,
              Ijy: () => Pt,
              IrR: () => r,
              JUn: () => Mr,
              JYe: () => De,
              Jjv: () => o,
              Jnj: () => jn,
              K1r: () => J,
              KLp: () => v,
              KbR: () => Js,
              Kod: () => Ls,
              KpZ: () => _n,
              L4b: () => Ms,
              LAV: () => ie,
              LDn: () => Ue,
              LDz: () => n,
              LW2: () => bs,
              Lxj: () => ht,
              MX7: () => wn,
              Mg$: () => Me,
              Mzz: () => tt,
              NFm: () => gt,
              NLq: () => Lt,
              NdR: () => lt,
              Nnq: () => Te,
              Nqe: () => Bt,
              Nv2: () => Ln,
              Nvm: () => $e,
              Nwc: () => Vn,
              OUj: () => e,
              Odm: () => ss,
              OgC: () => m,
              PTM: () => wt,
              PyI: () => $n,
              Qhq: () => Dn,
              Qpk: () => at,
              RSt: () => ye,
              RsJ: () => Hs,
              S$n: () => me,
              S8r: () => pn,
              SF$: () => ce,
              SGA: () => Pr,
              SWx: () => ue,
              Srv: () => Os,
              Sue: () => F,
              TOD: () => ii,
              TWL: () => sn,
              TyC: () => Rt,
              UCl: () => f,
              ULN: () => gn,
              URU: () => kt,
              UhA: () => Fe,
              UnE: () => $t,
              VSW: () => hn,
              WBN: () => H,
              Wbd: () => we,
              WhW: () => _i,
              XAr: () => qi,
              XF6: () => fe,
              XwU: () => _,
              Y$N: () => qt,
              YKI: () => b,
              Yj5: () => Ui,
              ZKF: () => fn,
              ZyS: () => it,
              _3: () => Oe,
              _AA: () => rt,
              aVd: () => Ye,
              akF: () => Ge,
              apD: () => Ft,
              bQd: () => tr,
              c02: () => W,
              cGo: () => is,
              cRA: () => yi,
              cyR: () => en,
              dD6: () => Fi,
              dIP: () => i,
              enT: () => Pi,
              fW0: () => ci,
              fsA: () => ne,
              g80: () => Ci,
              gaK: () => le,
              gpl: () => he,
              h3u: () => Ze,
              hs2: () => j,
              hwK: () => fi,
              iQ7: () => u,
              iRx: () => h,
              iYc: () => zn,
              idj: () => Hn,
              isr: () => En,
              jK8: () => yn,
              jYy: () => bt,
              kF: () => cn,
              kqw: () => Ae,
              lBd: () => br,
              lNQ: () => Q,
              lsY: () => Le,
              mEg: () => je,
              mfI: () => Ot,
              n$B: () => un,
              nJN: () => kn,
              oDV: () => R,
              odD: () => Cs,
              p6E: () => qn,
              pCO: () => M,
              pG9: () => In,
              pJd: () => T,
              pLF: () => Z,
              pNk: () => Tr,
              pY7: () => ft,
              paJ: () => er,
              pov: () => Ps,
              pqC: () => Li,
              q3J: () => de,
              q8s: () => Un,
              qEN: () => Xt,
              qa5: () => d,
              qn_: () => $,
              qoY: () => y,
              qsh: () => Ni,
              rGZ: () => os,
              rXb: () => Gn,
              rb7: () => xr,
              reG: () => B,
              rlY: () => On,
              rvO: () => Qi,
              s64: () => hi,
              s7S: () => Pe,
              s7h: () => se,
              sTv: () => Y,
              sYG: () => Ar,
              s_z: () => Ie,
              seI: () => c,
              slc: () => ot,
              sp4: () => X,
              tAf: () => g,
              tBC: () => sr,
              tJj: () => ns,
              uVx: () => Ji,
              u_5: () => t,
              uhC: () => L,
              v1A: () => O,
              v_N: () => re,
              vct: () => Yi,
              vpx: () => w,
              vq6: () => x,
              w7A: () => Bi,
              wGs: () => I,
              wmq: () => mt,
              x3I: () => A,
              x8T: () => Zt,
              xHx: () => P,
              xcK: () => Cr,
              xyx: () => ut,
              xzR: () => Rn,
              y1K: () => E,
              y9P: () => li,
              yK5: () => mn,
              yLH: () => Bn,
              yZ0: () => ls,
              yib: () => ds,
              yof: () => us,
              z5t: () => _t,
              zEd: () => ze,
              zIz: () => ke,
              zYo: () => Fn,
              zYw: () => N,
              zZp: () => Tt,
              zl$: () => pe,
              zwO: () => D,
            });
            const A = 0,
              x = 1,
              y = 2,
              c = 0,
              d = 1,
              h = 2,
              f = 3,
              s = 4,
              l = 5,
              n = 6,
              o = 7,
              i = 8,
              e = 9,
              t = 10,
              r = 11,
              u = 12,
              v = 0,
              _ = 1,
              m = 2,
              g = 3,
              T = 4,
              E = 0,
              M = 1,
              R = 2,
              P = 3,
              F = 1,
              b = 2,
              D = 4,
              G = 0,
              X = 1,
              ie = 2,
              Q = 3,
              te = 4,
              ae = 5,
              Z = 0,
              J = 1,
              ve = 2,
              _e = 3,
              L = 0,
              ge = 1,
              k = 2,
              j = 3,
              B = 4,
              $ = 5,
              le = 0,
              O = 1,
              Y = 2,
              ne = 3,
              de = 4,
              re = 5,
              I = 6,
              w = 7,
              N = 0,
              W = 1,
              he = 2,
              ue = 0,
              ye = 1,
              Oe = 2,
              Ae = 3,
              ke = 4,
              Ue = 5,
              Ge = 6,
              ht = 7,
              me = 8,
              z = 9,
              K = 10,
              Te = 11,
              H = 12,
              q = 13,
              se = 14,
              Ce = 15,
              we = 16,
              Me = 17,
              Ie = 18,
              Le = 19,
              tt = 20,
              vt = 21,
              it = 22,
              At = 23,
              Rt = 24,
              Ft = 25,
              ut = 26,
              Pt = 27,
              bt = 28,
              Zt = 29,
              Xt = 30,
              yt = 31,
              Pe = new Map([
                [ue, { name: "A8", size: 1 }],
                [ye, { name: "L8", size: 1 }],
                [Oe, { name: "LA8", size: 2 }],
                [Ae, { name: "RGB565", size: 2 }],
                [ke, { name: "RGBA5551", size: 2 }],
                [Ue, { name: "RGBA4", size: 2 }],
                [Ge, { name: "RGB8", size: 4 }],
                [ht, { name: "RGBA8", size: 4 }],
                [Te, { name: "RGB16F", size: 8 }],
                [H, { name: "RGBA16F", size: 8 }],
                [q, { name: "RGB32F", size: 16 }],
                [se, { name: "RGBA32F", size: 16 }],
                [Ce, { name: "R32F", size: 4 }],
                [we, { name: "DEPTH", size: 4 }],
                [Me, { name: "DEPTHSTENCIL", size: 4 }],
                [Ie, { name: "111110F", size: 4 }],
                [Le, { name: "SRGB", size: 4 }],
                [tt, { name: "SRGBA", size: 4 }],
                [yt, { name: "BGRA8", size: 4 }],
                [me, { name: "DXT1", blockSize: 8 }],
                [z, { name: "DXT3", blockSize: 16 }],
                [K, { name: "DXT5", blockSize: 16 }],
                [vt, { name: "ETC1", blockSize: 8 }],
                [it, { name: "ETC2_RGB", blockSize: 8 }],
                [At, { name: "ETC2_RGBA", blockSize: 16 }],
                [Rt, { name: "PVRTC_2BPP_RGB_1", blockSize: 8 }],
                [Ft, { name: "PVRTC_2BPP_RGBA_1", blockSize: 8 }],
                [ut, { name: "PVRTC_4BPP_RGB_1", blockSize: 8 }],
                [Pt, { name: "PVRTC_4BPP_RGBA_1", blockSize: 8 }],
                [bt, { name: "ASTC_4x4", blockSize: 16 }],
                [Zt, { name: "ATC_RGB", blockSize: 8 }],
                [Xt, { name: "ATC_RGBA", blockSize: 16 }],
              ]),
              $e = (zs) => Pe.get(zs).blockSize !== void 0,
              Je = (zs) => {
                switch (zs) {
                  case q:
                  case se:
                    return Float32Array;
                  case Ae:
                  case ke:
                  case Ue:
                  case Te:
                  case H:
                    return Uint16Array;
                  default:
                    return Uint8Array;
                }
              },
              rt = 0,
              ct = 1,
              Ve = 2,
              wt = 3,
              at = 4,
              ce = 5,
              pe = 6,
              De = "POSITION",
              fe = "NORMAL",
              Ze = "TANGENT",
              Ne = "BLENDWEIGHT",
              Ye = "BLENDINDICES",
              Ke = "COLOR",
              nt = "TEXCOORD",
              ot = "TEXCOORD0",
              ze = "TEXCOORD1",
              et = "TEXCOORD2",
              _t = "TEXCOORD3",
              Qe = "TEXCOORD4",
              lt = "TEXCOORD5",
              xt = "TEXCOORD6",
              Tt = "TEXCOORD7",
              ft = "ATTR",
              gt = "ATTR0",
              Fe = "ATTR1",
              Qt = "ATTR2",
              zt = "ATTR3",
              Lt = "ATTR4",
              $t = "ATTR5",
              Bt = "ATTR6",
              Nt = "ATTR7",
              es = "ATTR8",
              kt = "ATTR9",
              ds = "ATTR10",
              os = "ATTR11",
              ls = "ATTR12",
              Ps = "ATTR13",
              us = "ATTR14",
              Xe = "ATTR15",
              vs = 1,
              fs = 0,
              bs = 1,
              Ms = 2,
              Ts = 3,
              Js = 4,
              Os = 5,
              li = 6,
              $s = 7,
              Cs = 1,
              Gs = 2,
              hi = "default",
              ci = "rgbm",
              ii = "rgbe",
              je = "rgbp",
              mt = "swizzleGGGR",
              Ot = 0,
              ss = 1,
              qt = 2,
              is = 3,
              Ls = "1d",
              js = "2d",
              fi = "2d-array",
              pi = "cube",
              _i = "cube-array",
              mi = "3d",
              gi = 0,
              yi = 1,
              Li = 2,
              Bi = "none",
              Ai = "cube",
              Xi = "equirect",
              Yi = "octahedral",
              Mn = "glsl",
              Ci = "wgsl",
              hn = 0,
              Zi = 1,
              cn = 2,
              Qi = 3,
              Ji = 4,
              dn = 5,
              un = 6,
              wn = 0,
              In = 1,
              $i = 2,
              Dn = 3,
              qi = 4,
              en = 5,
              Fi = 6,
              Ui = 7,
              Hs = 8,
              Pi = 9,
              fn = 10,
              pn = 11,
              tn = 12,
              Rn = 13,
              ni = 14,
              On = 15,
              _n = 16,
              Ln = 17,
              Bn = 18,
              Fn = 19,
              Un = 20,
              Nn = 21,
              zn = 22,
              bi = 23,
              sn = 24,
              kn = [
                "bool",
                "int",
                "float",
                "vec2",
                "vec3",
                "vec4",
                "ivec2",
                "ivec3",
                "ivec4",
                "bec2",
                "bec3",
                "bec4",
                "mat2",
                "mat3",
                "mat4",
                "sampler2D",
                "samplerCube",
                "",
                "sampler2DShadow",
                "samplerCubeShadow",
                "sampler3D",
                "",
                "",
                "",
              ],
              Wn = "webgl1",
              Vn = "webgl2",
              mn = "webgpu",
              Gn = 1,
              jn = 2,
              gn = 4,
              Tr = 0,
              $n = 1,
              yn = ["mesh", "view"],
              xr = "default",
              vn = [
                Int8Array,
                Uint8Array,
                Int16Array,
                Uint16Array,
                Int32Array,
                Uint32Array,
                Float32Array,
              ],
              Ar = [1, 1, 2, 2, 4, 4, 4],
              Ni = [
                "INT8",
                "UINT8",
                "INT16",
                "UINT16",
                "INT32",
                "UINT32",
                "FLOAT32",
              ],
              Cr = {
                Int8Array: hn,
                Uint8Array: Zi,
                Int16Array: cn,
                Uint16Array: Qi,
                Int32Array: Ji,
                Uint32Array: dn,
                Float32Array: un,
              },
              Pr = [Uint8Array, Uint16Array, Uint32Array],
              br = [1, 2, 4],
              ns = {};
            (ns[De] = 0),
              (ns[fe] = 1),
              (ns[Ne] = 2),
              (ns[Ye] = 3),
              (ns[Ke] = 4),
              (ns[ot] = 5),
              (ns[ze] = 6),
              (ns[et] = 7),
              (ns[_t] = 8),
              (ns[Qe] = 9),
              (ns[lt] = 10),
              (ns[xt] = 11),
              (ns[Tt] = 12),
              (ns[Ze] = 13),
              (ns[gt] = 0),
              (ns[Fe] = 1),
              (ns[Qt] = 2),
              (ns[zt] = 3),
              (ns[Lt] = 4),
              (ns[$t] = 5),
              (ns[Bt] = 6),
              (ns[Nt] = 7),
              (ns[es] = 8),
              (ns[kt] = 9),
              (ns[ds] = 10),
              (ns[os] = 11),
              (ns[ls] = 12),
              (ns[Ps] = 13),
              (ns[us] = 14),
              (ns[Xe] = 15);
            const qn = "1.51",
              er = "1.55",
              En = "1.56",
              tr = "1.57",
              Hn = "1.58",
              Mr = "1.60",
              sr = "1.62",
              Kn = "1.65";
          },
          4870: (xe, V, a) => {
            "use strict";
            a.d(V, { H: () => h });
            var A = a(5917),
              x = a(1630);
            const y = 7,
              c = 0,
              d = 3;
            class h {
              constructor(s = x.fsA, l = !0) {
                (this.data = 0), (this.func = s), (this.write = l);
              }
              set test(s) {
                this.func = s ? x.fsA : x.vpx;
              }
              get test() {
                return this.func !== x.vpx;
              }
              set write(s) {
                this.data = A.p.set(this.data, s ? 1 : 0, d);
              }
              get write() {
                return A.p.all(this.data, d);
              }
              set func(s) {
                this.data = A.p.set(this.data, s, c, y);
              }
              get func() {
                return A.p.get(this.data, c, y);
              }
              copy(s) {
                return (this.data = s.data), this;
              }
              clone() {
                return new this.constructor().copy(this);
              }
              get key() {
                return this.data;
              }
              equals(s) {
                return this.data === s.data;
              }
            }
            (h.DEFAULT = Object.freeze(new h())),
              (h.NODEPTH = Object.freeze(new h(x.vpx, !1))),
              (h.WRITEDEPTH = Object.freeze(new h(x.vpx, !0)));
          },
          5950: (xe, V, a) => {
            "use strict";
            a.d(V, { N: () => A });
            class A {
              constructor() {
                this._cache = new Map();
              }
              get(y, c) {
                return (
                  this._cache.has(y) ||
                    (this._cache.set(y, c()),
                    y.on("destroy", () => {
                      this.remove(y);
                    }),
                    y.on("devicelost", () => {
                      var d;
                      (d = this._cache.get(y)) == null ||
                        d.loseContext == null ||
                        d.loseContext(y);
                    })),
                  this._cache.get(y)
                );
              }
              remove(y) {
                var c;
                (c = this._cache.get(y)) == null ||
                  c.destroy == null ||
                  c.destroy(y),
                  this._cache.delete(y);
              }
            }
          },
          2948: (xe, V, a) => {
            "use strict";
            a.d(V, { I4: () => c, kL: () => x, pw: () => d });
            var A = a(8656);
            class x {
              constructor(f) {
                (this.device = void 0), (this.device = f);
              }
            }
            class y {
              constructor() {
                (this.gpuBuffer = void 0),
                  (this.stagingBuffer = void 0),
                  (this.offset = void 0),
                  (this.size = void 0);
              }
            }
            class c {
              constructor() {
                (this.storage = void 0),
                  (this.gpuBuffer = void 0),
                  (this.offset = void 0);
              }
            }
            class d {
              constructor(f, s, l) {
                (this.bufferSize = void 0),
                  (this.gpuBuffers = []),
                  (this.stagingBuffers = []),
                  (this.usedBuffers = []),
                  (this.activeBuffer = null),
                  (this.device = f),
                  (this.bufferSize = s),
                  (this.bufferAlignment = l);
              }
              destroy() {
                this.gpuBuffers.forEach((f) => {
                  f.destroy(this.device);
                }),
                  (this.gpuBuffers = null),
                  this.stagingBuffers.forEach((f) => {
                    f.destroy(this.device);
                  }),
                  (this.stagingBuffers = null),
                  (this.usedBuffers = null),
                  (this.activeBuffer = null);
              }
              alloc(f, s) {
                if (this.activeBuffer) {
                  const o = A.D.roundUp(
                    this.activeBuffer.size,
                    this.bufferAlignment
                  );
                  this.bufferSize - o < s && this.scheduleSubmit();
                }
                if (!this.activeBuffer) {
                  let o = this.gpuBuffers.pop();
                  o ||
                    (o = this.createBuffer(this.device, this.bufferSize, !1));
                  let i = this.stagingBuffers.pop();
                  i ||
                    (i = this.createBuffer(this.device, this.bufferSize, !0)),
                    (this.activeBuffer = new y()),
                    (this.activeBuffer.stagingBuffer = i),
                    (this.activeBuffer.gpuBuffer = o),
                    (this.activeBuffer.offset = 0),
                    (this.activeBuffer.size = 0);
                }
                const l = this.activeBuffer,
                  n = A.D.roundUp(l.size, this.bufferAlignment);
                (f.gpuBuffer = l.gpuBuffer),
                  (f.offset = n),
                  (f.storage = l.stagingBuffer.alloc(n, s)),
                  (l.size = n + s);
              }
              scheduleSubmit() {
                this.activeBuffer &&
                  (this.usedBuffers.push(this.activeBuffer),
                  (this.activeBuffer = null));
              }
              submit() {
                this.scheduleSubmit();
              }
            }
          },
          1735: (xe, V, a) => {
            "use strict";
            a.d(V, { M: () => y });
            var A = a(6380),
              x = a(27);
            class y {
              constructor() {
                (this.frameAllocations = []),
                  (this.pastFrameAllocations = new Map()),
                  (this._enabled = !1),
                  (this._enableRequest = !1),
                  (this._frameTime = 0);
              }
              loseContext() {
                this.pastFrameAllocations.clear();
              }
              set enabled(d) {
                this._enableRequest = d;
              }
              get enabled() {
                return this._enableRequest;
              }
              processEnableRequest() {
                this._enableRequest !== this._enabled &&
                  ((this._enabled = this._enableRequest),
                  this._enabled || (this._frameTime = 0));
              }
              request(d) {
                this.pastFrameAllocations.set(d, this.frameAllocations),
                  (this.frameAllocations = []);
              }
              report(d, h) {
                if (h) {
                  const f = this.pastFrameAllocations.get(d);
                  if ((h.length > 0 && (this._frameTime = h[0]), x.l.get(A.yR)))
                    for (let s = 0; s < f.length; ++s) f[s];
                }
                this.pastFrameAllocations.delete(d);
              }
              getSlot(d) {
                const h = this.frameAllocations.length;
                return this.frameAllocations.push(d), h;
              }
              get slotCount() {
                return this.frameAllocations.length;
              }
            }
          },
          8136: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            class A {
              static set(y) {
                A._graphicsDevice = y;
              }
              static get() {
                return A._graphicsDevice;
              }
            }
            A._graphicsDevice = null;
          },
          4461: (xe, V, a) => {
            "use strict";
            a.d(V, { G: () => o });
            var A = a(4751),
              x = a(8976),
              y = a(9222),
              c = a(1630),
              d = a(1268),
              h = a(4870),
              f = a(7348),
              s = a(5860),
              l = a(6089),
              n = a(2640);
            class o extends x.J {
              constructor(e, t) {
                var r, u, v, _, m, g, T, E;
                super(),
                  (this.canvas = void 0),
                  (this.isWebGPU = !1),
                  (this.scope = void 0),
                  (this.boneLimit = void 0),
                  (this.maxAnisotropy = void 0),
                  (this.maxCubeMapSize = void 0),
                  (this.maxTextureSize = void 0),
                  (this.maxVolumeSize = void 0),
                  (this.maxColorAttachments = 1),
                  (this.precision = void 0),
                  (this.samples = void 0),
                  (this.supportsStencil = void 0),
                  (this.supportsMrt = !1),
                  (this.supportsVolumeTextures = !1),
                  (this.renderTarget = null),
                  (this.renderVersion = 0),
                  (this.renderPassIndex = void 0),
                  (this.insideRenderPass = !1),
                  (this.supportsInstancing = void 0),
                  (this.supportsUniformBuffers = !1),
                  (this.textureFloatRenderable = void 0),
                  (this.textureHalfFloatRenderable = void 0),
                  (this.quadVertexBuffer = void 0),
                  (this.blendState = new d.t()),
                  (this.depthState = new h.H()),
                  (this.stencilEnabled = !1),
                  (this.stencilFront = new n.n()),
                  (this.stencilBack = new n.n()),
                  (this.dynamicBuffers = void 0),
                  (this.gpuProfiler = void 0),
                  (this.defaultClearOptions = {
                    color: [0, 0, 0, 1],
                    depth: 1,
                    stencil: 0,
                    flags: c.Sue | c.YKI,
                  }),
                  (this.canvas = e),
                  (this.initOptions = (0, A._)({}, t)),
                  (u = (r = this.initOptions).depth) != null || (r.depth = !0),
                  (_ = (v = this.initOptions).stencil) != null ||
                    (v.stencil = !0),
                  (g = (m = this.initOptions).antialias) != null ||
                    (m.antialias = !0),
                  (E = (T = this.initOptions).powerPreference) != null ||
                    (T.powerPreference = "high-performance"),
                  (this._width = 0),
                  (this._height = 0),
                  (this._maxPixelRatio = y.i.browser
                    ? Math.min(1, window.devicePixelRatio)
                    : 1),
                  (this.shaders = []),
                  (this.buffers = []),
                  (this.textures = []),
                  (this.targets = []),
                  (this._vram = { tex: 0, vb: 0, ib: 0, ub: 0 }),
                  (this._shaderStats = {
                    vsCompiled: 0,
                    fsCompiled: 0,
                    linked: 0,
                    materialShaders: 0,
                    compileTime: 0,
                  }),
                  this.initializeContextCaches(),
                  (this._drawCallsPerFrame = 0),
                  (this._shaderSwitchesPerFrame = 0),
                  (this._primsPerFrame = []);
                for (let M = c._AA; M <= c.zl$; M++) this._primsPerFrame[M] = 0;
                (this._renderTargetCreationTime = 0),
                  (this.scope = new f.D("Device")),
                  (this.textureBias = this.scope.resolve("textureBias")),
                  this.textureBias.setValue(0);
              }
              postInit() {
                const e = new l.y(this, [
                    { semantic: c.JYe, components: 2, type: c.n$B },
                  ]),
                  t = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                this.quadVertexBuffer = new s.R(this, e, 4, c.y1K, t);
              }
              destroy() {
                var e, t, r;
                this.fire("destroy"),
                  (e = this.quadVertexBuffer) == null || e.destroy(),
                  (this.quadVertexBuffer = null),
                  (t = this.dynamicBuffers) == null || t.destroy(),
                  (this.dynamicBuffers = null),
                  (r = this.gpuProfiler) == null || r.destroy(),
                  (this.gpuProfiler = null);
              }
              onDestroyShader(e) {
                this.fire("destroy:shader", e);
                const t = this.shaders.indexOf(e);
                t !== -1 && this.shaders.splice(t, 1);
              }
              postDestroy() {
                (this.scope = null), (this.canvas = null);
              }
              toJSON(e) {}
              initializeContextCaches() {
                (this.indexBuffer = null),
                  (this.vertexBuffers = []),
                  (this.shader = null),
                  (this.renderTarget = null);
              }
              initializeRenderState() {
                (this.blendState = new d.t()),
                  (this.depthState = new h.H()),
                  (this.cullMode = c.K1r),
                  (this.vx = this.vy = this.vw = this.vh = 0),
                  (this.sx = this.sy = this.sw = this.sh = 0);
              }
              setStencilState(e, t) {}
              setBlendState(e) {}
              setDepthState(e) {}
              setCullMode(e) {}
              setRenderTarget(e) {
                this.renderTarget = e;
              }
              setIndexBuffer(e) {
                this.indexBuffer = e;
              }
              setVertexBuffer(e) {
                e && this.vertexBuffers.push(e);
              }
              getRenderTarget() {
                return this.renderTarget;
              }
              initRenderTarget(e) {
                e.initialized || (e.init(), this.targets.push(e));
              }
              _isBrowserInterface(e) {
                return (
                  this._isImageBrowserInterface(e) ||
                  this._isImageCanvasInterface(e) ||
                  this._isImageVideoInterface(e)
                );
              }
              _isImageBrowserInterface(e) {
                return (
                  (typeof ImageBitmap != "undefined" &&
                    e instanceof ImageBitmap) ||
                  (typeof HTMLImageElement != "undefined" &&
                    e instanceof HTMLImageElement)
                );
              }
              _isImageCanvasInterface(e) {
                return (
                  typeof HTMLCanvasElement != "undefined" &&
                  e instanceof HTMLCanvasElement
                );
              }
              _isImageVideoInterface(e) {
                return (
                  typeof HTMLVideoElement != "undefined" &&
                  e instanceof HTMLVideoElement
                );
              }
              resizeCanvas(e, t) {}
              setResolution(e, t) {
                (this._width = e),
                  (this._height = t),
                  (this.canvas.width = e),
                  (this.canvas.height = t),
                  this.fire(o.EVENT_RESIZE, e, t);
              }
              updateClientRect() {
                this.clientRect = this.canvas.getBoundingClientRect();
              }
              get width() {
                return this.canvas.width;
              }
              get height() {
                return this.canvas.height;
              }
              set fullscreen(e) {}
              get fullscreen() {
                return !1;
              }
              set maxPixelRatio(e) {
                this._maxPixelRatio !== e &&
                  ((this._maxPixelRatio = e),
                  this.resizeCanvas(this._width, this._height));
              }
              get maxPixelRatio() {
                return this._maxPixelRatio;
              }
              get deviceType() {
                return this._deviceType;
              }
              getBoneLimit() {
                return this.boneLimit;
              }
              setBoneLimit(e) {
                this.boneLimit = e;
              }
              frameStart() {
                (this.renderPassIndex = 0), this.renderVersion++;
              }
              frameEnd() {}
            }
            o.EVENT_RESIZE = "resizecanvas";
          },
          970: (xe, V, a) => {
            "use strict";
            a.d(V, { h: () => y });
            var A = a(1630);
            let x = 0;
            class y {
              constructor(d, h, f, s = A.y1K, l) {
                (this.device = d),
                  (this.format = h),
                  (this.numIndices = f),
                  (this.usage = s),
                  (this.id = x++),
                  (this.impl = d.createIndexBufferImpl(this));
                const n = A.lBd[h];
                (this.bytesPerIndex = n),
                  (this.numBytes = this.numIndices * n),
                  l
                    ? this.setData(l)
                    : (this.storage = new ArrayBuffer(this.numBytes)),
                  this.adjustVramSizeTracking(d._vram, this.numBytes),
                  this.device.buffers.push(this);
              }
              destroy() {
                const d = this.device,
                  h = d.buffers.indexOf(this);
                h !== -1 && d.buffers.splice(h, 1),
                  this.device.indexBuffer === this &&
                    (this.device.indexBuffer = null),
                  this.impl.initialized &&
                    (this.impl.destroy(d),
                    this.adjustVramSizeTracking(
                      d._vram,
                      -this.storage.byteLength
                    ));
              }
              adjustVramSizeTracking(d, h) {
                d.ib += h;
              }
              loseContext() {
                this.impl.loseContext();
              }
              getFormat() {
                return this.format;
              }
              getNumIndices() {
                return this.numIndices;
              }
              lock() {
                return this.storage;
              }
              unlock() {
                this.impl.unlock(this);
              }
              setData(d) {
                return d.byteLength !== this.numBytes
                  ? !1
                  : ((this.storage = d), this.unlock(), !0);
              }
              _lockTypedArray() {
                const d = this.lock();
                return this.format === A.gpl
                  ? new Uint32Array(d)
                  : this.format === A.c02
                  ? new Uint16Array(d)
                  : new Uint8Array(d);
              }
              writeData(d, h) {
                const f = this._lockTypedArray();
                if (d.length > h)
                  if (ArrayBuffer.isView(d)) (d = d.subarray(0, h)), f.set(d);
                  else for (let s = 0; s < h; s++) f[s] = d[s];
                else f.set(d);
                this.unlock();
              }
              readData(d) {
                const h = this._lockTypedArray(),
                  f = this.numIndices;
                if (ArrayBuffer.isView(d)) d.set(h);
                else {
                  d.length = 0;
                  for (let s = 0; s < f; s++) d[s] = h[s];
                }
                return f;
              }
            }
          },
          2485: (xe, V, a) => {
            "use strict";
            a.d(V, { AH: () => c });
            var A = a(5227);
            class x {
              constructor() {
                (this.clearValue = new A.Q(0, 0, 0, 1)),
                  (this.clear = !1),
                  (this.store = !1),
                  (this.resolve = !0),
                  (this.mipmaps = !1);
              }
            }
            class y {
              constructor() {
                (this.clearDepthValue = 1),
                  (this.clearStencilValue = 0),
                  (this.clearDepth = !1),
                  (this.clearStencil = !1),
                  (this.storeDepth = !1),
                  (this.storeStencil = !1);
              }
            }
            class c {
              get colorOps() {
                return this.colorArrayOps[0];
              }
              constructor(h, f) {
                (this.name = void 0),
                  (this.renderTarget = void 0),
                  (this.samples = 0),
                  (this.colorArrayOps = []),
                  (this.depthStencilOps = void 0),
                  (this.requiresCubemaps = !0),
                  (this.fullSizeClearRect = !0),
                  (this.execute = void 0),
                  (this.before = void 0),
                  (this.after = void 0),
                  (this.device = h),
                  (this.execute = f);
              }
              init(h) {
                var f;
                (this.renderTarget = h || null),
                  (this.samples = Math.max(
                    this.renderTarget
                      ? this.renderTarget.samples
                      : this.device.samples,
                    1
                  )),
                  (this.depthStencilOps = new y());
                const s = h
                  ? (f = h._colorBuffers) == null
                    ? void 0
                    : f.length
                  : 1;
                for (let n = 0; n < s; n++) {
                  var l;
                  const o = new x();
                  (this.colorArrayOps[n] = o),
                    this.samples === 1 && ((o.store = !0), (o.resolve = !1)),
                    (l = this.renderTarget) != null &&
                      (l = l._colorBuffers) != null &&
                      l[n].mipmaps &&
                      (o.mipmaps = !0);
                }
              }
              setClearColor(h) {
                const f = this.colorArrayOps.length;
                for (let s = 0; s < f; s++) {
                  const l = this.colorArrayOps[s];
                  l.clearValue.copy(h), (l.clear = !0);
                }
              }
              setClearDepth(h) {
                (this.depthStencilOps.clearDepthValue = h),
                  (this.depthStencilOps.clearDepth = !0);
              }
              setClearStencil(h) {
                (this.depthStencilOps.clearStencilValue = h),
                  (this.depthStencilOps.clearStencil = !0);
              }
              render() {
                var h, f, s;
                const l = this.device,
                  n = this.renderTarget !== void 0;
                (h = this.before) == null || h.call(this),
                  n && l.startPass(this),
                  (f = this.execute) == null || f.call(this),
                  n && l.endPass(this),
                  (s = this.after) == null || s.call(this),
                  l.renderPassIndex++;
              }
            }
          },
          9061: (xe, V, a) => {
            "use strict";
            a.d(V, { O: () => c });
            var A = a(1630),
              x = a(4461);
            let y = 0;
            class c {
              constructor(h = {}) {
                var f, s, l, n, o, i, e;
                (this.name = void 0),
                  (this._device = void 0),
                  (this._colorBuffer = void 0),
                  (this._colorBuffers = void 0),
                  (this._depthBuffer = void 0),
                  (this._depth = void 0),
                  (this._stencil = void 0),
                  (this._samples = void 0),
                  (this.autoResolve = void 0),
                  (this._face = void 0),
                  (this.flipY = void 0),
                  (this.id = y++);
                const t = arguments[1],
                  r = arguments[2];
                if (
                  (h instanceof x.G
                    ? ((this._colorBuffer = t), (h = r))
                    : (this._colorBuffer = h.colorBuffer),
                  this._colorBuffer &&
                    (this._colorBuffers = [this._colorBuffer]),
                  (this._depthBuffer = h.depthBuffer),
                  (this._face = (f = h.face) != null ? f : 0),
                  this._depthBuffer)
                ) {
                  const E = this._depthBuffer._format;
                  E === A.Wbd
                    ? ((this._depth = !0), (this._stencil = !1))
                    : E === A.Mg$
                    ? ((this._depth = !0), (this._stencil = !0))
                    : ((this._depth = !1), (this._stencil = !1));
                } else {
                  var u, v;
                  (this._depth = (u = h.depth) != null ? u : !0),
                    (this._stencil = (v = h.stencil) != null ? v : !1);
                }
                h.colorBuffers &&
                  (this._colorBuffers ||
                    ((this._colorBuffers = [...h.colorBuffers]),
                    (this._colorBuffer = h.colorBuffers[0])));
                const _ =
                  ((s = this._colorBuffer) == null ? void 0 : s.device) ||
                  ((l = this._depthBuffer) == null ? void 0 : l.device) ||
                  h.graphicsDevice;
                (this._device = _),
                  (n = this._colorBuffers) == null ||
                    n.forEach((E) => {
                      E._isRenderTarget = !0;
                    });
                const { maxSamples: m } = this._device;
                if (
                  ((this._samples = Math.min(
                    (o = h.samples) != null ? o : 1,
                    m
                  )),
                  _.isWebGPU && (this._samples = this._samples > 1 ? m : 1),
                  (this.autoResolve = (i = h.autoResolve) != null ? i : !0),
                  (this.name = h.name),
                  !this.name)
                ) {
                  var g;
                  this.name = (g = this._colorBuffer) == null ? void 0 : g.name;
                }
                if (!this.name) {
                  var T;
                  this.name = (T = this._depthBuffer) == null ? void 0 : T.name;
                }
                this.name || (this.name = "Untitled"),
                  (this.flipY = (e = h.flipY) != null ? e : !1),
                  this.validateMrt(),
                  (this.impl = _.createRenderTargetImpl(this));
              }
              destroy() {
                const h = this._device;
                if (h) {
                  const f = h.targets.indexOf(this);
                  f !== -1 && h.targets.splice(f, 1),
                    h.renderTarget === this && h.setRenderTarget(null),
                    this.destroyFrameBuffers();
                }
              }
              destroyFrameBuffers() {
                const h = this._device;
                h && this.impl.destroy(h);
              }
              destroyTextureBuffers() {
                var h, f;
                (h = this._depthBuffer) == null || h.destroy(),
                  (this._depthBuffer = null),
                  (f = this._colorBuffers) == null ||
                    f.forEach((s) => {
                      s.destroy();
                    }),
                  (this._colorBuffers = null),
                  (this._colorBuffer = null);
              }
              validateMrt() {}
              init() {
                this.impl.init(this._device, this);
              }
              get initialized() {
                return this.impl.initialized;
              }
              loseContext() {
                this.impl.loseContext();
              }
              resolve(h = !0, f = !!this._depthBuffer) {
                this._device &&
                  this._samples > 1 &&
                  this.impl.resolve(this._device, this, h, f);
              }
              copy(h, f, s) {
                if (!this._device)
                  if (h._device) this._device = h._device;
                  else return !1;
                return this._device.copyRenderTarget(h, this, f, s);
              }
              get samples() {
                return this._samples;
              }
              get depth() {
                return this._depth;
              }
              get stencil() {
                return this._stencil;
              }
              get colorBuffer() {
                return this._colorBuffer;
              }
              getColorBuffer(h) {
                var f;
                return (f = this._colorBuffers) == null ? void 0 : f[h];
              }
              get depthBuffer() {
                return this._depthBuffer;
              }
              get face() {
                return this._face;
              }
              get width() {
                var h, f;
                return (
                  ((h = this._colorBuffer) == null ? void 0 : h.width) ||
                  ((f = this._depthBuffer) == null ? void 0 : f.width) ||
                  this._device.width
                );
              }
              get height() {
                var h, f;
                return (
                  ((h = this._colorBuffer) == null ? void 0 : h.height) ||
                  ((f = this._depthBuffer) == null ? void 0 : f.height) ||
                  this._device.height
                );
              }
            }
          },
          4113: (xe, V, a) => {
            "use strict";
            a.d(V, { w: () => c });
            var A = a(5811);
            let x = 0;
            class y {
              constructor() {
                x++, (this.version = new A.R()), (this.version.globalId = x);
              }
              increment() {
                this.version.revision++;
              }
            }
            class c {
              constructor(h) {
                (this.name = h),
                  (this.value = null),
                  (this.versionObject = new y());
              }
              toJSON(h) {}
              setValue(h) {
                (this.value = h), this.versionObject.increment();
              }
              getValue() {
                return this.value;
              }
            }
          },
          7348: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => x });
            var A = a(4113);
            class x {
              constructor(c) {
                (this.name = c), (this.variables = new Map());
              }
              resolve(c) {
                return (
                  this.variables.has(c) || this.variables.set(c, new A.w(c)),
                  this.variables.get(c)
                );
              }
              removeValue(c) {
                for (const d in this.variables) {
                  const h = this.variables[d];
                  h.value === c && (h.value = null);
                }
              }
            }
          },
          120: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            var A = `

#define pcFragColor0 gl_FragData[0]

#if COLOR_ATTACHMENT_1
#define pcFragColor1 gl_FragData[1]
#endif

#if COLOR_ATTACHMENT_2
#define pcFragColor2 gl_FragData[2]
#endif

#if COLOR_ATTACHMENT_3
#define pcFragColor3 gl_FragData[3]
#endif

#if COLOR_ATTACHMENT_4
#define pcFragColor4 gl_FragData[4]
#endif

#if COLOR_ATTACHMENT_5
#define pcFragColor5 gl_FragData[5]
#endif

#if COLOR_ATTACHMENT_6
#define pcFragColor6 gl_FragData[6]
#endif

#if COLOR_ATTACHMENT_7
#define pcFragColor7 gl_FragData[7]
#endif

#define texture2DBias texture2D

// pass / accept shadow map or texture as a function parameter, on webgl this is simply passed as is
// but this is needed for WebGPU
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2D name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name

#ifndef SUPPORTS_TEXLOD

		// fallback for lod instructions
		#define texture2DLodEXT texture2D
		#define texture2DProjLodEXT textureProj
		#define textureCubeLodEXT textureCube
		#define textureShadow texture2D

#else

		#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))

#endif

#ifdef SUPPORTS_MRT
		#define gl_FragColor pcFragColor0
#endif

`;
          },
          4047: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            var A = `
layout(location = 0) out highp vec4 pc_fragColor;

#ifndef REMOVE_COLOR_ATTACHMENT_1
#if COLOR_ATTACHMENT_1
layout(location = 1) out highp vec4 pc_fragColor1;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_2
#if COLOR_ATTACHMENT_2
layout(location = 2) out highp vec4 pc_fragColor2;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_3
#if COLOR_ATTACHMENT_3
layout(location = 3) out highp vec4 pc_fragColor3;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_4
#if COLOR_ATTACHMENT_4
layout(location = 4) out highp vec4 pc_fragColor4;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_5
#if COLOR_ATTACHMENT_5
layout(location = 5) out highp vec4 pc_fragColor5;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_6
#if COLOR_ATTACHMENT_6
layout(location = 6) out highp vec4 pc_fragColor6;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_7
#if COLOR_ATTACHMENT_7
layout(location = 7) out highp vec4 pc_fragColor7;
#endif
#endif

#define gl_FragColor pc_fragColor

#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7

#define varying in

#define texture2D texture
#define texture2DBias texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad

// sample shadows using textureGrad to remove derivatives in the dynamic loops (which are used by
// clustered lighting) - as DirectX shader compiler tries to unroll the loops and takes long time
// to compile the shader. Using textureLod would be even better, but WebGl does not translate it to
// lod instruction for DirectX correctly and uses SampleCmp instead of SampleCmpLevelZero or similar.
#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))

// pass / accept shadow map or texture as a function parameter, on webgl this is simply passed as is
// but this is needed for WebGPU
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2DShadow name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name

#define GL2
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`;
          },
          6003: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            var A = `

// texelFetch support and others
#extension GL_EXT_samplerless_texture_functions : require

layout(location = 0) out highp vec4 pc_fragColor;
layout(location = 1) out highp vec4 pc_fragColor1;
layout(location = 2) out highp vec4 pc_fragColor2;
layout(location = 3) out highp vec4 pc_fragColor3;
layout(location = 4) out highp vec4 pc_fragColor4;
layout(location = 5) out highp vec4 pc_fragColor5;
layout(location = 6) out highp vec4 pc_fragColor6;
layout(location = 7) out highp vec4 pc_fragColor7;

#define gl_FragColor pc_fragColor

#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7

#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)
#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)
#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)
#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)
#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)

// TODO: implement other texture sampling macros
// #define texture2DProj textureProj
// #define texture2DProjLodEXT textureProjLod
// #define texture2DGradEXT textureGrad
// #define texture2DProjGradEXT textureProjGrad
// #define textureCubeGradEXT textureGrad

// pass / accept shadow map as a function parameter, passes both the texture as well as sampler
// as the combined sampler can be only created at a point of use
#define SHADOWMAP_PASS(name) name, name ## _sampler
#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler

#define GL2
#define WEBGPU
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`;
          },
          9812: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            var A = `
#define attribute in
#define varying out
#define texture2D texture
#define GL2
#define VERTEXSHADER
`;
          },
          7210: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            var A = `

// texelFetch support and others
#extension GL_EXT_samplerless_texture_functions : require

#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)

#define GL2
#define WEBGPU
#define VERTEXSHADER
`;
          },
          8568: (xe, V, a) => {
            "use strict";
            a.d(V, { c: () => x });
            var A = a(1630);
            class x {
              constructor(c, d, h) {
                (this.uniformFormats = []),
                  (this.bindGroupFormats = []),
                  (this.vertexFormat = void 0),
                  (this.uniformFormats[A.PyI] = c),
                  (this.bindGroupFormats[A.PyI] = d),
                  (this.vertexFormat = h);
              }
              hasUniform(c) {
                for (let d = 0; d < this.uniformFormats.length; d++) {
                  const h = this.uniformFormats[d];
                  if (h != null && h.get(c)) return !0;
                }
                return !1;
              }
              hasTexture(c) {
                for (let d = 0; d < this.bindGroupFormats.length; d++) {
                  const h = this.bindGroupFormats[d];
                  if (h != null && h.getTexture(c)) return !0;
                }
                return !1;
              }
              getVertexElement(c) {
                var d;
                return (d = this.vertexFormat) == null
                  ? void 0
                  : d.elements.find((h) => h.name === c);
              }
              generateKey(c) {
                let d =
                  JSON.stringify(this.uniformFormats) +
                  JSON.stringify(this.bindGroupFormats);
                if (c.isWebGPU) {
                  var h;
                  d +=
                    (h = this.vertexFormat) == null
                      ? void 0
                      : h.renderingHashString;
                }
                return d;
              }
            }
          },
          9855: (xe, V, a) => {
            "use strict";
            a.d(V, { l: () => l });
            var A = a(1630),
              x = a(120),
              y = a(4047),
              c = a(9812),
              d = a(6003),
              h = a(7210),
              f = `

// convert clip space position into texture coordinates to sample scene grab textures
vec2 getGrabScreenPos(vec4 clipPos) {
		vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;

		#ifdef WEBGPU
				uv.y = 1.0 - uv.y;
		#endif

		return uv;
}

// convert uv coordinates to sample image effect texture (render target texture rendered without
// forward renderer which does the flip in the projection matrix)
vec2 getImageEffectUV(vec2 uv) {
		#ifdef WEBGPU
				uv.y = 1.0 - uv.y;
		#endif

		return uv;
}
`;
            const s = {
              vertex_position: A.JYe,
              vertex_normal: A.XF6,
              vertex_tangent: A.h3u,
              vertex_texCoord0: A.slc,
              vertex_texCoord1: A.zEd,
              vertex_texCoord2: A.GHH,
              vertex_texCoord3: A.z5t,
              vertex_texCoord4: A.GWP,
              vertex_texCoord5: A.NdR,
              vertex_texCoord6: A.GBD,
              vertex_texCoord7: A.zZp,
              vertex_color: A.F8$,
              vertex_boneIndices: A.aVd,
              vertex_boneWeights: A.Hn_,
            };
            class l {
              static createDefinition(o, i) {
                var e, t;
                const r = (E, M, R, P) => {
                    const F = o.isWebGPU
                      ? E
                      : o.webgl2
                      ? M
                      : l.gl1Extensions(o, i) + R;
                    let b = "";
                    for (let D = 0; D < o.maxColorAttachments; D++)
                      b += `#define COLOR_ATTACHMENT_${D}
`;
                    return b + F;
                  },
                  u = (e = i.name) != null ? e : "Untitled",
                  v = i.vertexDefines || r(h.A, c.A, ""),
                  _ =
                    l.versionCode(o) +
                    v +
                    f +
                    l.getShaderNameCode(u) +
                    i.vertexCode,
                  m = i.fragmentDefines || r(d.A, y.A, x.A),
                  g =
                    (i.fragmentPreamble || "") +
                    l.versionCode(o) +
                    m +
                    l.precisionCode(o) +
                    `
` +
                    f +
                    l.getShaderNameCode(u) +
                    (i.fragmentCode || l.dummyFragmentCode()),
                  T =
                    (t = i.attributes) != null
                      ? t
                      : l.collectAttributes(i.vertexCode);
                return {
                  name: u,
                  attributes: T,
                  vshader: _,
                  fshader: g,
                  useTransformFeedback: i.useTransformFeedback,
                };
              }
              static getShaderNameCode(o) {
                return `#define SHADER_NAME ${o}
`;
              }
              static gl1Extensions(o, i, e) {
                let t;
                return (
                  e
                    ? (t = i.vertexExtensions
                        ? `${i.vertexExtensions}
`
                        : "")
                    : ((t = i.fragmentExtensions
                        ? `${i.fragmentExtensions}
`
                        : ""),
                      o.extStandardDerivatives &&
                        (t += `#extension GL_OES_standard_derivatives : enable
`),
                      o.extTextureLod &&
                        ((t += `#extension GL_EXT_shader_texture_lod : enable
`),
                        (t += `#define SUPPORTS_TEXLOD
`)),
                      o.extDrawBuffers &&
                        ((t += `#extension GL_EXT_draw_buffers : require
`),
                        (t += `#define SUPPORTS_MRT
`))),
                  t
                );
              }
              static dummyFragmentCode() {
                return "void main(void) {gl_FragColor = vec4(0.0);}";
              }
              static versionCode(o) {
                return o.isWebGPU
                  ? `#version 450
`
                  : o.webgl2
                  ? `#version 300 es
`
                  : "";
              }
              static precisionCode(o, i) {
                let e = "";
                i &&
                  i !== "highp" &&
                  i !== "mediump" &&
                  i !== "lowp" &&
                  (i = null),
                  i &&
                    (i === "highp" &&
                      o.maxPrecision !== "highp" &&
                      (i = "mediump"),
                    i === "mediump" &&
                      o.maxPrecision === "lowp" &&
                      (i = "lowp"));
                const t = i || o.precision;
                return (
                  o.isWebGPU
                    ? (e = `precision ${t} float;
precision ${t} int;
`)
                    : ((e = `precision ${t} float;
`),
                      o.webgl2 &&
                        (e += `precision ${t} sampler2DShadow;
`)),
                  e
                );
              }
              static collectAttributes(o) {
                const i = {};
                let e = 0,
                  t = o.indexOf("attribute");
                for (; t >= 0 && !(t > 0 && o[t - 1] === "/"); ) {
                  const r = o.indexOf(";", t),
                    u = o.lastIndexOf(" ", r),
                    v = o.substring(u + 1, r),
                    _ = s[v];
                  _ !== void 0 ? (i[v] = _) : ((i[v] = "ATTR" + e), e++),
                    (t = o.indexOf("attribute", t + 1));
                }
                return i;
              }
            }
          },
          8526: (xe, V, a) => {
            "use strict";
            a.d(V, { M: () => i });
            const A =
                /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g,
              x = /define[ \t]+([^\n]+)\r?(?:\n|$)/g,
              y = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g,
              c = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g,
              d = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g,
              h = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g,
              f = /([\w-]+)/,
              s = /(!|\s)?defined\(([\w-]+)\)/,
              l = /[><=|&+-]/g;
            class n {
              static run(t, r = !1) {
                (t = t.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1")),
                  (t = t.split(/\r?\n/).map((_) => _.trimEnd()).join(`
`));
                const u = new Map();
                if (r) {
                  const _ = new Map(),
                    m = /(pcFragColor[1-8])\b/g,
                    g = t.match(m);
                  g == null ||
                    g.forEach((T) => {
                      var E;
                      const M = parseInt(T.charAt(T.length - 1), 10);
                      _.set(M, ((E = _.get(M)) != null ? E : 0) + 1);
                    }),
                    _.forEach((T, E) => {
                      T === 1 && u.set(`REMOVE_COLOR_ATTACHMENT_${E}`, "");
                    });
                }
                t = this._preprocess(t, u);
                const v = new Map();
                return (
                  u.forEach((_, m) => {
                    Number.isInteger(parseFloat(_)) &&
                      !_.includes(".") &&
                      v.set(m, _);
                  }),
                  t !== null &&
                    ((t = t
                      .split(/\r?\n/)
                      .map((_) => (_.trim() === "" ? "" : _))
                      .map(
                        (_) => (
                          v.forEach((m, g) => {
                            _ = _.replace(
                              new RegExp(`\\[${g}\\]`, "g"),
                              `[${m}]`
                            );
                          }),
                          _
                        )
                      ).join(`
`)),
                    (t = t.replace(
                      /(\n\n){3,}/gm,
                      `

`
                    ))),
                  t
                );
              }
              static _preprocess(t, r = new Map()) {
                const u = t,
                  v = [];
                let _ = !1,
                  m;
                for (; (m = A.exec(t)) !== null; ) {
                  const g = m[1];
                  switch (g) {
                    case "define": {
                      x.lastIndex = m.index;
                      const T = x.exec(t);
                      _ || (_ = T === null);
                      const E = T[1];
                      f.lastIndex = T.index;
                      const R = f.exec(E)[1];
                      let P = E.substring(R.length).trim();
                      P === "" && (P = "true"),
                        n._keep(v) && r.set(R, P),
                        (A.lastIndex = T.index + T[0].length);
                      break;
                    }
                    case "undef": {
                      c.lastIndex = m.index;
                      const T = c.exec(t),
                        E = T[1].trim();
                      n._keep(v) && r.delete(E),
                        (A.lastIndex = T.index + T[0].length);
                      break;
                    }
                    case "extension": {
                      y.lastIndex = m.index;
                      const T = y.exec(t);
                      if ((_ || (_ = T === null), T)) {
                        const E = T[1];
                        n._keep(v) && r.set(E, "true");
                      }
                      A.lastIndex = T.index + T[0].length;
                      break;
                    }
                    case "ifdef":
                    case "ifndef":
                    case "if": {
                      d.lastIndex = m.index;
                      const T = d.exec(t),
                        E = T[2],
                        M = n.evaluate(E, r);
                      _ || (_ = M.error);
                      let R = M.result;
                      g === "ifndef" && (R = !R),
                        v.push({
                          anyKeep: R,
                          keep: R,
                          start: m.index,
                          end: d.lastIndex,
                        }),
                        (A.lastIndex = T.index + T[0].length);
                      break;
                    }
                    case "endif":
                    case "else":
                    case "elif": {
                      h.lastIndex = m.index;
                      const T = h.exec(t),
                        E = v.pop(),
                        M = E.keep ? t.substring(E.end, m.index) : "";
                      (t =
                        t.substring(0, E.start) + M + t.substring(h.lastIndex)),
                        (A.lastIndex = E.start + M.length);
                      const R = T[1];
                      if (R === "else" || R === "elif") {
                        let P = !1;
                        if (!E.anyKeep)
                          if (R === "else") P = !E.keep;
                          else {
                            const F = n.evaluate(T[2], r);
                            (P = F.result), _ || (_ = F.error);
                          }
                        v.push({
                          anyKeep: E.anyKeep || P,
                          keep: P,
                          start: A.lastIndex,
                          end: A.lastIndex,
                        });
                      }
                      break;
                    }
                  }
                }
                return _
                  ? (console.warn("Failed to preprocess shader: ", {
                      source: u,
                    }),
                    u)
                  : t;
              }
              static _keep(t) {
                for (let r = 0; r < t.length; r++) if (!t[r].keep) return !1;
                return !0;
              }
              static evaluate(t, r) {
                const u = l.exec(t) === null;
                let v = !1;
                const _ = s.exec(t);
                _ && ((v = _[1] === "!"), (t = _[2])), (t = t.trim());
                let m = r.has(t);
                return v && (m = !m), { result: m, error: !u };
              }
            }
            let o = 0;
            class i {
              constructor(t, r) {
                (this.meshUniformBufferFormat = void 0),
                  (this.meshBindGroupFormat = void 0),
                  (this.id = o++),
                  (this.device = t),
                  (this.definition = r),
                  (this.name = r.name || "Untitled"),
                  (r.vshader = n.run(r.vshader)),
                  (r.fshader = n.run(r.fshader, t.webgl2)),
                  this.init(),
                  (this.impl = t.createShaderImpl(this));
              }
              init() {
                (this.ready = !1), (this.failed = !1);
              }
              get label() {
                return `Shader Id ${this.id} ${this.name}`;
              }
              destroy() {
                this.device.onDestroyShader(this), this.impl.destroy(this);
              }
              loseContext() {
                this.init(), this.impl.loseContext();
              }
              restoreContext() {
                this.impl.restoreContext(this.device, this);
              }
            }
          },
          2640: (xe, V, a) => {
            "use strict";
            a.d(V, { n: () => c });
            var A = a(1630),
              x = a(271);
            const y = new x.w();
            class c {
              set func(h) {
                (this._func = h), (this._dirty = !0);
              }
              get func() {
                return this._func;
              }
              set ref(h) {
                (this._ref = h), (this._dirty = !0);
              }
              get ref() {
                return this._ref;
              }
              set fail(h) {
                (this._fail = h), (this._dirty = !0);
              }
              get fail() {
                return this._fail;
              }
              set zfail(h) {
                (this._zfail = h), (this._dirty = !0);
              }
              get zfail() {
                return this._zfail;
              }
              set zpass(h) {
                (this._zpass = h), (this._dirty = !0);
              }
              get zpass() {
                return this._zpass;
              }
              set readMask(h) {
                (this._readMask = h), (this._dirty = !0);
              }
              get readMask() {
                return this._readMask;
              }
              set writeMask(h) {
                (this._writeMask = h), (this._dirty = !0);
              }
              get writeMask() {
                return this._writeMask;
              }
              constructor(h = {}) {
                var f, s, l, n, o, i, e;
                (this._func = void 0),
                  (this._ref = void 0),
                  (this._fail = void 0),
                  (this._zfail = void 0),
                  (this._zpass = void 0),
                  (this._readMask = void 0),
                  (this._writeMask = void 0),
                  (this._dirty = !0),
                  (this._key = void 0),
                  (this._func = (f = h.func) != null ? f : A.vpx),
                  (this._ref = (s = h.ref) != null ? s : 0),
                  (this._readMask = (l = h.readMask) != null ? l : 255),
                  (this._writeMask = (n = h.writeMask) != null ? n : 255),
                  (this._fail = (o = h.fail) != null ? o : A.GU6),
                  (this._zfail = (i = h.zfail) != null ? i : A.GU6),
                  (this._zpass = (e = h.zpass) != null ? e : A.GU6),
                  this._evalKey();
              }
              _evalKey() {
                const {
                    _func: h,
                    _ref: f,
                    _fail: s,
                    _zfail: l,
                    _zpass: n,
                    _readMask: o,
                    _writeMask: i,
                  } = this,
                  e = `${h},${f},${s},${l},${n},${o},${i}`;
                (this._key = y.get(e)), (this._dirty = !1);
              }
              get key() {
                return this._dirty && this._evalKey(), this._key;
              }
              copy(h) {
                return (
                  (this._func = h._func),
                  (this._ref = h._ref),
                  (this._readMask = h._readMask),
                  (this._writeMask = h._writeMask),
                  (this._fail = h._fail),
                  (this._zfail = h._zfail),
                  (this._zpass = h._zpass),
                  (this._dirty = h._dirty),
                  (this._key = h._key),
                  this
                );
              }
              clone() {
                return new this.constructor().copy(this);
              }
            }
            c.DEFAULT = Object.freeze(new c());
          },
          7812: (xe, V, a) => {
            "use strict";
            a.d(V, { V: () => x });
            var A = a(1630);
            class x {
              static calcLevelDimension(c, d) {
                return Math.max(c >> d, 1);
              }
              static calcLevelGpuSize(c, d, h, f) {
                var s, l, n;
                const o = A.s7S.get(f),
                  i =
                    (s = (l = A.s7S.get(f)) == null ? void 0 : l.size) != null
                      ? s
                      : 0;
                if (i > 0) return c * d * h * i;
                const e = (n = o.blockSize) != null ? n : 0;
                let t = Math.floor((c + 3) / 4);
                const r = Math.floor((d + 3) / 4),
                  u = Math.floor((h + 3) / 4);
                return (
                  (f === A.TyC || f === A.apD) &&
                    (t = Math.max(Math.floor(t / 2), 1)),
                  t * r * u * e
                );
              }
              static calcGpuSize(c, d, h, f, s, l) {
                let n = 0;
                for (
                  ;
                  (n += x.calcLevelGpuSize(c, d, h, f)),
                    !(!s || (c === 1 && d === 1 && h === 1));

                )
                  (c = Math.max(c >> 1, 1)),
                    (d = Math.max(d >> 1, 1)),
                    (h = Math.max(h >> 1, 1));
                return n * (l ? 6 : 1);
              }
            }
          },
          1208: (xe, V, a) => {
            "use strict";
            a.d(V, { g: () => h });
            var A = a(8656),
              x = a(9061),
              y = a(7812),
              c = a(1630);
            let d = 0;
            class h {
              constructor(s, l = {}) {
                var n, o, i, e, t, r, u, v, _, m, g, T, E, M, R, P, F, b;
                if (
                  ((this.name = void 0),
                  (this._isRenderTarget = !1),
                  (this._gpuSize = 0),
                  (this.id = d++),
                  (this._invalid = !1),
                  (this._lockedLevel = -1),
                  (this.renderVersionDirty = 0),
                  (this.device = s),
                  (this.name = (n = l.name) != null ? n : null),
                  (this._width = (o = l.width) != null ? o : 4),
                  (this._height = (i = l.height) != null ? i : 4),
                  (this._format = (e = l.format) != null ? e : c.Lxj),
                  (this._compressed = (0, c.Nvm)(this._format)),
                  s.supportsVolumeTextures)
                ) {
                  var D, G;
                  (this._volume = (D = l.volume) != null ? D : !1),
                    (this._depth = (G = l.depth) != null ? G : 1);
                } else (this._volume = !1), (this._depth = 1);
                (this._cubemap = (t = l.cubemap) != null ? t : !1),
                  (this.fixCubemapSeams =
                    (r = l.fixCubemapSeams) != null ? r : !1),
                  (this._flipY = (u = l.flipY) != null ? u : !1),
                  (this._premultiplyAlpha =
                    (v = l.premultiplyAlpha) != null ? v : !1),
                  (this._mipmaps =
                    (_ = (m = l.mipmaps) != null ? m : l.autoMipmap) != null
                      ? _
                      : !0),
                  (this._minFilter = (g = l.minFilter) != null ? g : c.qn_),
                  (this._magFilter = (T = l.magFilter) != null ? T : c.DrA),
                  (this._anisotropy = (E = l.anisotropy) != null ? E : 1),
                  (this._addressU = (M = l.addressU) != null ? M : c.x3I),
                  (this._addressV = (R = l.addressV) != null ? R : c.x3I),
                  (this._addressW = (P = l.addressW) != null ? P : c.x3I),
                  (this._compareOnRead =
                    (F = l.compareOnRead) != null ? F : !1),
                  (this._compareFunc = (b = l.compareFunc) != null ? b : c.v1A),
                  (this.type = c.s64),
                  l.hasOwnProperty("type")
                    ? (this.type = l.type)
                    : l.hasOwnProperty("rgbm")
                    ? (this.type = l.rgbm ? c.fW0 : c.s64)
                    : l.hasOwnProperty("swizzleGGGR") &&
                      (this.type = l.swizzleGGGR ? c.wmq : c.s64),
                  (this.projection = c.w7A),
                  this._cubemap
                    ? (this.projection = c.$mg)
                    : l.projection &&
                      l.projection !== c.$mg &&
                      (this.projection = l.projection),
                  (this.impl = s.createTextureImpl(this)),
                  this.dirtyAll(),
                  (this._levels = l.levels),
                  this._levels
                    ? this.upload()
                    : (this._levels = this._cubemap
                        ? [[null, null, null, null, null, null]]
                        : [null]),
                  s.textures.push(this);
              }
              destroy() {
                if (this.device) {
                  const s = this.device,
                    l = s.textures.indexOf(this);
                  l !== -1 && s.textures.splice(l, 1),
                    s.scope.removeValue(this),
                    this.impl.destroy(s),
                    this.adjustVramSizeTracking(s._vram, -this._gpuSize),
                    (this._levels = null),
                    (this.device = null);
                }
              }
              loseContext() {
                this.impl.loseContext(), this.dirtyAll();
              }
              adjustVramSizeTracking(s, l) {
                s.tex += l;
              }
              propertyChanged(s) {
                this.impl.propertyChanged(s),
                  (this.renderVersionDirty = this.device.renderVersion);
              }
              get requiredMipLevels() {
                return this.mipmaps
                  ? Math.floor(Math.log2(Math.max(this.width, this.height))) + 1
                  : 1;
              }
              set minFilter(s) {
                this._minFilter !== s &&
                  ((this._minFilter = s), this.propertyChanged(1));
              }
              get minFilter() {
                return this._minFilter;
              }
              set magFilter(s) {
                this._magFilter !== s &&
                  ((this._magFilter = s), this.propertyChanged(2));
              }
              get magFilter() {
                return this._magFilter;
              }
              set addressU(s) {
                this._addressU !== s &&
                  ((this._addressU = s), this.propertyChanged(4));
              }
              get addressU() {
                return this._addressU;
              }
              set addressV(s) {
                this._addressV !== s &&
                  ((this._addressV = s), this.propertyChanged(8));
              }
              get addressV() {
                return this._addressV;
              }
              set addressW(s) {
                this.device.supportsVolumeTextures &&
                  this._volume &&
                  s !== this._addressW &&
                  ((this._addressW = s), this.propertyChanged(16));
              }
              get addressW() {
                return this._addressW;
              }
              set compareOnRead(s) {
                this._compareOnRead !== s &&
                  ((this._compareOnRead = s), this.propertyChanged(32));
              }
              get compareOnRead() {
                return this._compareOnRead;
              }
              set compareFunc(s) {
                this._compareFunc !== s &&
                  ((this._compareFunc = s), this.propertyChanged(64));
              }
              get compareFunc() {
                return this._compareFunc;
              }
              set anisotropy(s) {
                this._anisotropy !== s &&
                  ((this._anisotropy = s), this.propertyChanged(128));
              }
              get anisotropy() {
                return this._anisotropy;
              }
              set mipmaps(s) {
                this._mipmaps !== s &&
                  ((this._mipmaps = s),
                  this.device.isWebGPU,
                  s && (this._needsMipmapsUpload = !0));
              }
              get mipmaps() {
                return this._mipmaps;
              }
              get width() {
                return this._width;
              }
              get height() {
                return this._height;
              }
              get depth() {
                return this._depth;
              }
              get format() {
                return this._format;
              }
              get cubemap() {
                return this._cubemap;
              }
              get gpuSize() {
                const s =
                  this.pot &&
                  this._mipmaps &&
                  !(this._compressed && this._levels.length === 1);
                return y.V.calcGpuSize(
                  this._width,
                  this._height,
                  this._depth,
                  this._format,
                  s,
                  this._cubemap
                );
              }
              get volume() {
                return this._volume;
              }
              set flipY(s) {
                this._flipY !== s &&
                  ((this._flipY = s), (this._needsUpload = !0));
              }
              get flipY() {
                return this._flipY;
              }
              set premultiplyAlpha(s) {
                this._premultiplyAlpha !== s &&
                  ((this._premultiplyAlpha = s), (this._needsUpload = !0));
              }
              get premultiplyAlpha() {
                return this._premultiplyAlpha;
              }
              get pot() {
                return (
                  A.D.powerOfTwo(this._width) && A.D.powerOfTwo(this._height)
                );
              }
              get encoding() {
                switch (this.type) {
                  case c.fW0:
                    return "rgbm";
                  case c.TOD:
                    return "rgbe";
                  case c.mEg:
                    return "rgbp";
                  default:
                    return this.format === c.Nnq ||
                      this.format === c.FQW ||
                      this.format === c.WBN ||
                      this.format === c.s7h
                      ? "linear"
                      : "srgb";
                }
              }
              dirtyAll() {
                (this._levelsUpdated = this._cubemap
                  ? [[!0, !0, !0, !0, !0, !0]]
                  : [!0]),
                  (this._needsUpload = !0),
                  (this._needsMipmapsUpload = this._mipmaps),
                  (this._mipmapsUploaded = !1),
                  this.propertyChanged(255);
              }
              lock(s = {}) {
                s.level === void 0 && (s.level = 0),
                  s.face === void 0 && (s.face = 0),
                  s.mode === void 0 && (s.mode = c.$Q8),
                  (this._lockedLevel = s.level);
                const l = this.cubemap ? this._levels[s.face] : this._levels;
                if (l[s.level] === null) {
                  const n = Math.max(1, this._width >> s.level),
                    o = Math.max(1, this._height >> s.level),
                    i = Math.max(1, this._depth >> s.level),
                    e = new ArrayBuffer(
                      y.V.calcLevelGpuSize(n, o, i, this._format)
                    );
                  l[s.level] = new ((0, c.FxX)(this._format))(e);
                }
                return l[s.level];
              }
              setSource(s, l = 0) {
                let n = !1,
                  o,
                  i;
                if (this._cubemap) {
                  if (s[0]) {
                    (o = s[0].width || 0), (i = s[0].height || 0);
                    for (let e = 0; e < 6; e++) {
                      const t = s[e];
                      if (
                        !t ||
                        t.width !== o ||
                        t.height !== i ||
                        !this.device._isBrowserInterface(t)
                      ) {
                        n = !0;
                        break;
                      }
                    }
                  } else n = !0;
                  if (!n)
                    for (let e = 0; e < 6; e++)
                      this._levels[l][e] !== s[e] &&
                        (this._levelsUpdated[l][e] = !0);
                } else
                  this.device._isBrowserInterface(s) || (n = !0),
                    n ||
                      (s !== this._levels[l] && (this._levelsUpdated[l] = !0),
                      (o = s.width),
                      (i = s.height));
                if (n)
                  if (((this._width = 4), (this._height = 4), this._cubemap))
                    for (let e = 0; e < 6; e++)
                      (this._levels[l][e] = null),
                        (this._levelsUpdated[l][e] = !0);
                  else (this._levels[l] = null), (this._levelsUpdated[l] = !0);
                else
                  l === 0 && ((this._width = o), (this._height = i)),
                    (this._levels[l] = s);
                (this._invalid !== n || !n) &&
                  ((this._invalid = n), this.upload());
              }
              getSource(s = 0) {
                return this._levels[s];
              }
              unlock() {
                this._lockedLevel, this.upload(), (this._lockedLevel = -1);
              }
              upload() {
                var s, l;
                (this._needsUpload = !0),
                  (this._needsMipmapsUpload = this._mipmaps),
                  (s = (l = this.impl).uploadImmediate) == null ||
                    s.call(l, this.device, this);
              }
              downloadAsync() {
                return Kt(this, null, function* () {
                  const s = [];
                  for (let o = 0; o < (this.cubemap ? 6 : 1); o++) {
                    var l, n;
                    const i = new x.O({
                      colorBuffer: this,
                      depth: !1,
                      face: o,
                    });
                    this.device.setRenderTarget(i),
                      this.device.initRenderTarget(i);
                    const e = this.cubemap ? this._levels[o] : this._levels;
                    let t = e[0];
                    e[0] &&
                      this.device._isBrowserInterface(e[0]) &&
                      (e[0] = null),
                      (t = this.lock({ face: o }));
                    const r =
                      (l = (n = this.device).readPixelsAsync) == null
                        ? void 0
                        : l
                            .call(n, 0, 0, this.width, this.height, t)
                            .then(() => i.destroy());
                    s.push(r);
                  }
                  yield Promise.all(s);
                });
              }
              getDds() {
                let s = 128,
                  l = 0;
                for (; this._levels[l]; ) {
                  if (this.cubemap)
                    for (let F = 0; F < 6; F++) {
                      if (!this._levels[l][F]) return;
                      const b = this._levels[l][F].length;
                      if (!b) return;
                      s += b;
                    }
                  else {
                    const F = this._levels[l].length;
                    if (!F) return;
                    s += F;
                  }
                  (s += this._levels[l].length), l++;
                }
                const n = new ArrayBuffer(s),
                  o = new Uint32Array(n, 0, 128 / 4),
                  i = 542327876,
                  e = 124,
                  t = 528391,
                  r = 131072,
                  u = 32,
                  v = 65,
                  _ = 4096,
                  m = 4194304,
                  g = 8,
                  T = 65024;
                let E = t;
                this._levels.length > 1 && (E |= r);
                let M = _;
                this._levels.length > 1 && (M |= m),
                  (this._levels.length > 1 || this.cubemap) && (M |= g);
                const R = this.cubemap ? T : 0;
                (o[0] = i),
                  (o[1] = e),
                  (o[2] = E),
                  (o[3] = this.height),
                  (o[4] = this.width),
                  (o[5] = this.width * this.height * 4),
                  (o[6] = 0),
                  (o[7] = this._levels.length);
                for (let F = 0; F < 11; F++) o[8 + F] = 0;
                (o[19] = u),
                  (o[20] = v),
                  (o[21] = 0),
                  (o[22] = 32),
                  (o[23] = 16711680),
                  (o[24] = 65280),
                  (o[25] = 255),
                  (o[26] = 4278190080),
                  (o[27] = M),
                  (o[28] = R),
                  (o[29] = 0),
                  (o[30] = 0),
                  (o[31] = 0);
                let P = 128;
                if (this.cubemap)
                  for (let F = 0; F < 6; F++)
                    for (let b = 0; b < this._levels.length; b++) {
                      const D = this._levels[b][F],
                        G = new Uint8Array(n, P, D.length);
                      for (let X = 0; X < D.length; X++) G[X] = D[X];
                      P += D.length;
                    }
                else
                  for (let F = 0; F < this._levels.length; F++) {
                    const b = this._levels[F],
                      D = new Uint8Array(n, P, b.length);
                    for (let G = 0; G < b.length; G++) D[G] = b[G];
                    P += b.length;
                  }
                return n;
              }
            }
          },
          5224: (xe, V, a) => {
            "use strict";
            a.d(V, { Q: () => d, g: () => c });
            var A = a(8656),
              x = a(1630);
            const y = [];
            (y[x.GF5] = 1),
              (y[x.Qhq] = 2),
              (y[x.XAr] = 3),
              (y[x.cyR] = 4),
              (y[x.pG9] = 1),
              (y[x.dD6] = 2),
              (y[x.Yj5] = 3),
              (y[x.RsJ] = 4),
              (y[x.MX7] = 1),
              (y[x.enT] = 2),
              (y[x.ZKF] = 3),
              (y[x.S8r] = 4),
              (y[x.Eb5] = 8),
              (y[x.xzR] = 12),
              (y[x.CPw] = 16);
            class c {
              constructor(f, s, l = 0) {
                if (
                  ((this.name = void 0),
                  (this.type = void 0),
                  (this.byteSize = void 0),
                  (this.offset = void 0),
                  (this.scopeId = void 0),
                  (this.count = void 0),
                  (this.shortName = f),
                  (this.name = l ? `${f}[0]` : f),
                  (this.type = s),
                  (this.updateType = s),
                  l)
                )
                  switch (s) {
                    case x.GF5:
                      this.updateType = x.Nv2;
                      break;
                    case x.Qhq:
                      this.updateType = x.FEO;
                      break;
                    case x.XAr:
                      this.updateType = x.iYc;
                      break;
                    case x.cyR:
                      this.updateType = x.$Cd;
                      break;
                    case x.CPw:
                      this.updateType = x.TWL;
                      break;
                  }
                this.count = l;
                let n = y[s];
                l && (n = A.D.roundUp(n, 4)),
                  (this.byteSize = n * 4),
                  l && (this.byteSize *= l);
              }
              calculateOffset(f) {
                let s = this.byteSize <= 8 ? this.byteSize : 16;
                this.count && (s = 16),
                  (f = A.D.roundUp(f, s)),
                  (this.offset = f / 4);
              }
            }
            class d {
              constructor(f, s) {
                (this.byteSize = 0),
                  (this.map = new Map()),
                  (this.scope = f.scope),
                  (this.uniforms = s);
                let l = 0;
                for (let n = 0; n < s.length; n++) {
                  const o = s[n];
                  o.calculateOffset(l),
                    (l = o.offset * 4 + o.byteSize),
                    (o.scopeId = this.scope.resolve(o.name)),
                    this.map.set(o.name, o);
                }
                this.byteSize = A.D.roundUp(l, 16);
              }
              get(f) {
                return this.map.get(f);
              }
              getShaderDeclaration(f, s) {
                const l = x.jK8[f];
                let n = `layout(set = ${f}, binding = ${s}, std140) uniform ub_${l} {
`;
                return (
                  this.uniforms.forEach((o) => {
                    const i = x.nJN[o.type];
                    n += `    ${i} ${o.shortName}${
                      o.count ? `[${o.count}]` : ""
                    };
`;
                  }),
                  n +
                    `};
`
                );
              }
            }
          },
          5006: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => c });
            var A = a(1630),
              x = a(2948);
            const y = [];
            (y[A.GF5] = function (d, h, f) {
              const s = d.storageFloat32;
              s[f] = h;
            }),
              (y[A.Qhq] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]), (s[f + 1] = h[1]);
              }),
              (y[A.XAr] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]), (s[f + 1] = h[1]), (s[f + 2] = h[2]);
              }),
              (y[A.cyR] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 2] = h[2]),
                  (s[f + 3] = h[3]);
              }),
              (y[A.pG9] = function (d, h, f) {
                const s = d.storageInt32;
                s[f] = h;
              }),
              (y[A.dD6] = function (d, h, f) {
                const s = d.storageInt32;
                (s[f] = h[0]), (s[f + 1] = h[1]);
              }),
              (y[A.Yj5] = function (d, h, f) {
                const s = d.storageInt32;
                (s[f] = h[0]), (s[f + 1] = h[1]), (s[f + 2] = h[2]);
              }),
              (y[A.RsJ] = function (d, h, f) {
                const s = d.storageInt32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 2] = h[2]),
                  (s[f + 3] = h[3]);
              }),
              (y[A.Eb5] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 4] = h[2]),
                  (s[f + 5] = h[3]),
                  (s[f + 8] = h[4]),
                  (s[f + 9] = h[5]);
              }),
              (y[A.xzR] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 2] = h[2]),
                  (s[f + 4] = h[3]),
                  (s[f + 5] = h[4]),
                  (s[f + 6] = h[5]),
                  (s[f + 8] = h[6]),
                  (s[f + 9] = h[7]),
                  (s[f + 10] = h[8]);
              }),
              (y[A.Nv2] = function (d, h, f, s) {
                const l = d.storageFloat32;
                for (let n = 0; n < s; n++) l[f + n * 4] = h[n];
              }),
              (y[A.FEO] = (d, h, f, s) => {
                const l = d.storageFloat32;
                for (let n = 0; n < s; n++)
                  (l[f + n * 4] = h[n * 2]), (l[f + n * 4 + 1] = h[n * 2 + 1]);
              }),
              (y[A.iYc] = (d, h, f, s) => {
                const l = d.storageFloat32;
                for (let n = 0; n < s; n++)
                  (l[f + n * 4] = h[n * 3]),
                    (l[f + n * 4 + 1] = h[n * 3 + 1]),
                    (l[f + n * 4 + 2] = h[n * 3 + 2]);
              });
            class c {
              constructor(h, f, s = !0) {
                if (
                  ((this.device = void 0),
                  (this.persistent = void 0),
                  (this.allocation = void 0),
                  (this.storageFloat32 = void 0),
                  (this.storageInt32 = void 0),
                  (this.renderVersionDirty = 0),
                  (this.device = h),
                  (this.format = f),
                  (this.persistent = s),
                  s)
                ) {
                  this.impl = h.createUniformBufferImpl(this);
                  const l = new ArrayBuffer(f.byteSize);
                  this.assignStorage(new Int32Array(l)),
                    (h._vram.ub += this.format.byteSize);
                } else this.allocation = new x.I4();
              }
              destroy() {
                if (this.persistent) {
                  const h = this.device;
                  this.impl.destroy(h), (h._vram.ub -= this.format.byteSize);
                }
              }
              get offset() {
                return this.persistent ? 0 : this.allocation.offset;
              }
              assignStorage(h) {
                (this.storageInt32 = h),
                  (this.storageFloat32 = new Float32Array(
                    h.buffer,
                    h.byteOffset,
                    h.byteLength / 4
                  ));
              }
              loseContext() {
                var h;
                (h = this.impl) == null || h.loseContext();
              }
              setUniform(h) {
                const f = h.offset,
                  s = h.scopeId.value;
                if (s != null) {
                  const l = y[h.updateType];
                  l ? l(this, s, f, h.count) : this.storageFloat32.set(s, f);
                }
              }
              set(h) {
                const f = this.format.map.get(h);
                f && this.setUniform(f);
              }
              update() {
                const h = this.persistent;
                if (!h) {
                  const s = this.allocation,
                    l = s.gpuBuffer;
                  this.device.dynamicBuffers.alloc(s, this.format.byteSize),
                    this.assignStorage(s.storage),
                    l !== s.gpuBuffer &&
                      (this.renderVersionDirty = this.device.renderVersion);
                }
                const f = this.format.uniforms;
                for (let s = 0; s < f.length; s++) this.setUniform(f[s]);
                h
                  ? this.impl.unlock(this)
                  : ((this.storageFloat32 = null), (this.storageInt32 = null));
              }
            }
          },
          5811: (xe, V, a) => {
            "use strict";
            a.d(V, { R: () => A });
            class A {
              constructor() {
                (this.globalId = 0), (this.revision = 0);
              }
              equals(y) {
                return (
                  this.globalId === y.globalId && this.revision === y.revision
                );
              }
              copy(y) {
                (this.globalId = y.globalId), (this.revision = y.revision);
              }
              reset() {
                (this.globalId = 0), (this.revision = 0);
              }
            }
          },
          5860: (xe, V, a) => {
            "use strict";
            a.d(V, { R: () => y });
            var A = a(1630);
            let x = 0;
            class y {
              constructor(d, h, f, s = A.y1K, l) {
                (this.device = d),
                  (this.format = h),
                  (this.numVertices = f),
                  (this.usage = s),
                  (this.id = x++),
                  (this.impl = d.createVertexBufferImpl(this, h)),
                  (this.numBytes = h.verticesByteSize
                    ? h.verticesByteSize
                    : h.size * f),
                  this.adjustVramSizeTracking(d._vram, this.numBytes),
                  l
                    ? this.setData(l)
                    : (this.storage = new ArrayBuffer(this.numBytes)),
                  this.device.buffers.push(this);
              }
              destroy() {
                const d = this.device,
                  h = d.buffers.indexOf(this);
                h !== -1 && d.buffers.splice(h, 1),
                  this.impl.initialized &&
                    (this.impl.destroy(d),
                    this.adjustVramSizeTracking(
                      d._vram,
                      -this.storage.byteLength
                    ));
              }
              adjustVramSizeTracking(d, h) {
                d.vb += h;
              }
              loseContext() {
                this.impl.loseContext();
              }
              getFormat() {
                return this.format;
              }
              getUsage() {
                return this.usage;
              }
              getNumVertices() {
                return this.numVertices;
              }
              lock() {
                return this.storage;
              }
              unlock() {
                this.impl.unlock(this);
              }
              setData(d) {
                return d.byteLength !== this.numBytes
                  ? !1
                  : ((this.storage = d), this.unlock(), !0);
              }
            }
          },
          6089: (xe, V, a) => {
            "use strict";
            a.d(V, { y: () => h });
            var A = a(8981),
              x = a(8656),
              y = a(271),
              c = a(1630);
            const d = new y.w();
            class h {
              constructor(s, l, n) {
                (this.device = s),
                  (this._elements = []),
                  (this.hasUv0 = !1),
                  (this.hasUv1 = !1),
                  (this.hasColor = !1),
                  (this.hasTangents = !1),
                  (this.verticesByteSize = 0),
                  (this.vertexCount = n),
                  (this.interleaved = n === void 0),
                  (this.instancing = !1),
                  (this.size = l.reduce(
                    (t, r) =>
                      t + Math.ceil((r.components * c.sYG[r.type]) / 4) * 4,
                    0
                  ));
                let o = 0,
                  i;
                for (let t = 0, r = l.length; t < r; t++) {
                  var e;
                  const u = l[t];
                  (i = u.components * c.sYG[u.type]),
                    n && (o = x.D.roundUp(o, i));
                  const v = {
                    name: u.semantic,
                    offset: n ? o : u.hasOwnProperty("offset") ? u.offset : o,
                    stride: n
                      ? i
                      : u.hasOwnProperty("stride")
                      ? u.stride
                      : this.size,
                    dataType: u.type,
                    numComponents: u.components,
                    normalize: (e = u.normalize) != null ? e : !1,
                    size: i,
                  };
                  this._elements.push(v),
                    n ? (o += i * n) : (o += Math.ceil(i / 4) * 4),
                    u.semantic === c.slc
                      ? (this.hasUv0 = !0)
                      : u.semantic === c.zEd
                      ? (this.hasUv1 = !0)
                      : u.semantic === c.F8$
                      ? (this.hasColor = !0)
                      : u.semantic === c.h3u && (this.hasTangents = !0);
                }
                n && (this.verticesByteSize = o), this._evaluateHash();
              }
              get elements() {
                return this._elements;
              }
              static getDefaultInstancingFormat(s) {
                return (
                  h._defaultInstancingFormat ||
                    (h._defaultInstancingFormat = new h(s, [
                      { semantic: c.yZ0, components: 4, type: c.n$B },
                      { semantic: c.pov, components: 4, type: c.n$B },
                      { semantic: c.yof, components: 4, type: c.n$B },
                      { semantic: c.FHg, components: 4, type: c.n$B },
                    ])),
                  h._defaultInstancingFormat
                );
              }
              update() {
                this._evaluateHash();
              }
              _evaluateHash() {
                let s;
                const l = [];
                let n;
                const o = [],
                  i = this._elements.length;
                for (let e = 0; e < i; e++) {
                  const t = this._elements[e];
                  (s = t.name),
                    (s += t.dataType),
                    (s += t.numComponents),
                    (s += t.normalize),
                    l.push(s),
                    (n = s),
                    (n += t.offset),
                    (n += t.stride),
                    (n += t.size),
                    o.push(n);
                }
                l.sort(),
                  (this.batchingHash = (0, A.s)(l.join())),
                  (this.renderingHashString = o.join("_")),
                  (this.renderingHash = d.get(this.renderingHashString));
              }
            }
            h._defaultInstancingFormat = null;
          },
          1984: (xe, V, a) => {
            "use strict";
            a.d(V, { P: () => r });
            var A = a(1630);
            function x(u) {
              this.array[this.index] = u;
            }
            function y(u, v) {
              (this.array[this.index] = u), (this.array[this.index + 1] = v);
            }
            function c(u, v, _) {
              (this.array[this.index] = u),
                (this.array[this.index + 1] = v),
                (this.array[this.index + 2] = _);
            }
            function d(u, v, _, m) {
              (this.array[this.index] = u),
                (this.array[this.index + 1] = v),
                (this.array[this.index + 2] = _),
                (this.array[this.index + 3] = m);
            }
            function h(u, v, _) {
              this.array[u] = v[_];
            }
            function f(u, v, _) {
              (this.array[u] = v[_]), (this.array[u + 1] = v[_ + 1]);
            }
            function s(u, v, _) {
              (this.array[u] = v[_]),
                (this.array[u + 1] = v[_ + 1]),
                (this.array[u + 2] = v[_ + 2]);
            }
            function l(u, v, _) {
              (this.array[u] = v[_]),
                (this.array[u + 1] = v[_ + 1]),
                (this.array[u + 2] = v[_ + 2]),
                (this.array[u + 3] = v[_ + 3]);
            }
            function n(u, v, _) {
              v[_] = this.array[u];
            }
            function o(u, v, _) {
              (v[_] = this.array[u]), (v[_ + 1] = this.array[u + 1]);
            }
            function i(u, v, _) {
              (v[_] = this.array[u]),
                (v[_ + 1] = this.array[u + 1]),
                (v[_ + 2] = this.array[u + 2]);
            }
            function e(u, v, _) {
              (v[_] = this.array[u]),
                (v[_ + 1] = this.array[u + 1]),
                (v[_ + 2] = this.array[u + 2]),
                (v[_ + 3] = this.array[u + 3]);
            }
            class t {
              constructor(v, _, m) {
                switch (
                  ((this.index = 0),
                  (this.numComponents = _.numComponents),
                  m.interleaved
                    ? (this.array = new A.B8J[_.dataType](v, _.offset))
                    : (this.array = new A.B8J[_.dataType](
                        v,
                        _.offset,
                        m.vertexCount * _.numComponents
                      )),
                  (this.stride =
                    _.stride / this.array.constructor.BYTES_PER_ELEMENT),
                  _.numComponents)
                ) {
                  case 1:
                    (this.set = x),
                      (this.getToArray = n),
                      (this.setFromArray = h);
                    break;
                  case 2:
                    (this.set = y),
                      (this.getToArray = o),
                      (this.setFromArray = f);
                    break;
                  case 3:
                    (this.set = c),
                      (this.getToArray = i),
                      (this.setFromArray = s);
                    break;
                  case 4:
                    (this.set = d),
                      (this.getToArray = e),
                      (this.setFromArray = l);
                    break;
                }
              }
              get(v) {
                return this.array[this.index + v];
              }
              set(v, _, m, g) {}
              getToArray(v, _, m) {}
              setFromArray(v, _, m) {}
            }
            class r {
              constructor(v) {
                (this.vertexBuffer = v),
                  (this.vertexFormatSize = v.getFormat().size),
                  (this.buffer = this.vertexBuffer.lock()),
                  (this.accessors = []),
                  (this.element = {});
                const _ = this.vertexBuffer.getFormat();
                for (let m = 0; m < _.elements.length; m++) {
                  const g = _.elements[m];
                  (this.accessors[m] = new t(this.buffer, g, _)),
                    (this.element[g.name] = this.accessors[m]);
                }
              }
              next(v = 1) {
                let _ = 0;
                const m = this.accessors,
                  g = this.accessors.length;
                for (; _ < g; ) {
                  const T = m[_++];
                  T.index += v * T.stride;
                }
              }
              end() {
                this.vertexBuffer.unlock();
              }
              writeData(v, _, m) {
                const g = this.element[v];
                if (g) {
                  m > this.vertexBuffer.numVertices &&
                    (m = this.vertexBuffer.numVertices);
                  const T = g.numComponents;
                  if (this.vertexBuffer.getFormat().interleaved) {
                    let E = 0;
                    for (let M = 0; M < m; M++)
                      g.setFromArray(E, _, M * T), (E += g.stride);
                  } else if (_.length > m * T) {
                    const E = m * T;
                    if (ArrayBuffer.isView(_))
                      (_ = _.subarray(0, E)), g.array.set(_);
                    else for (let M = 0; M < E; M++) g.array[M] = _[M];
                  } else g.array.set(_);
                }
              }
              readData(v, _) {
                const m = this.element[v];
                let g = 0;
                if (m) {
                  g = this.vertexBuffer.numVertices;
                  let T;
                  const E = m.numComponents;
                  if (this.vertexBuffer.getFormat().interleaved) {
                    Array.isArray(_) && (_.length = 0), (m.index = 0);
                    let M = 0;
                    for (T = 0; T < g; T++)
                      m.getToArray(M, _, T * E), (M += m.stride);
                  } else if (ArrayBuffer.isView(_)) _.set(m.array);
                  else {
                    _.length = 0;
                    const M = g * E;
                    for (T = 0; T < M; T++) _[T] = m.array[T];
                  }
                }
                return g;
              }
            }
          },
          3317: (xe, V, a) => {
            "use strict";
            a.d(V, { z: () => de });
            var A = {};
            function x(re) {
              window.console &&
                window.console.error &&
                window.console.error(re);
            }
            function y(re) {
              window.console && window.console.log && window.console.log(re);
            }
            function c(re, I) {
              (A[re] = !0), I !== void 0 && x(I);
            }
            function d(re) {
              var I = re.getError;
              re.getError = function () {
                var w;
                do (w = I.apply(re)), w != re.NO_ERROR && (A[w] = !0);
                while (w != re.NO_ERROR);
                for (var w in A) if (A[w]) return delete A[w], parseInt(w);
                return re.NO_ERROR;
              };
            }
            var h = function re(I) {
              var w = I.gl;
              (this.ext = I),
                (this.isAlive = !0),
                (this.hasBeenBound = !1),
                (this.elementArrayBuffer = null),
                (this.attribs = new Array(I.maxVertexAttribs));
              for (var N = 0; N < this.attribs.length; N++) {
                var W = new re.VertexAttrib(w);
                this.attribs[N] = W;
              }
              this.maxAttrib = 0;
            };
            (h.VertexAttrib = function (I) {
              (this.enabled = !1),
                (this.buffer = null),
                (this.size = 4),
                (this.type = I.FLOAT),
                (this.normalized = !1),
                (this.stride = 16),
                (this.offset = 0),
                (this.cached = ""),
                this.recache();
            }),
              (h.VertexAttrib.prototype.recache = function () {
                this.cached = [
                  this.size,
                  this.type,
                  this.normalized,
                  this.stride,
                  this.offset,
                ].join(":");
              });
            var f = function (I) {
              var w = this;
              (this.gl = I), d(I);
              var N = (this.original = {
                getParameter: I.getParameter,
                enableVertexAttribArray: I.enableVertexAttribArray,
                disableVertexAttribArray: I.disableVertexAttribArray,
                bindBuffer: I.bindBuffer,
                getVertexAttrib: I.getVertexAttrib,
                vertexAttribPointer: I.vertexAttribPointer,
              });
              (I.getParameter = function (he) {
                return he == w.VERTEX_ARRAY_BINDING_OES
                  ? w.currentVertexArrayObject == w.defaultVertexArrayObject
                    ? null
                    : w.currentVertexArrayObject
                  : N.getParameter.apply(this, arguments);
              }),
                (I.enableVertexAttribArray = function (he) {
                  var ue = w.currentVertexArrayObject;
                  ue.maxAttrib = Math.max(ue.maxAttrib, he);
                  var ye = ue.attribs[he];
                  return (
                    (ye.enabled = !0),
                    N.enableVertexAttribArray.apply(this, arguments)
                  );
                }),
                (I.disableVertexAttribArray = function (he) {
                  var ue = w.currentVertexArrayObject;
                  ue.maxAttrib = Math.max(ue.maxAttrib, he);
                  var ye = ue.attribs[he];
                  return (
                    (ye.enabled = !1),
                    N.disableVertexAttribArray.apply(this, arguments)
                  );
                }),
                (I.bindBuffer = function (he, ue) {
                  switch (he) {
                    case I.ARRAY_BUFFER:
                      w.currentArrayBuffer = ue;
                      break;
                    case I.ELEMENT_ARRAY_BUFFER:
                      w.currentVertexArrayObject.elementArrayBuffer = ue;
                      break;
                  }
                  return N.bindBuffer.apply(this, arguments);
                }),
                (I.getVertexAttrib = function (he, ue) {
                  var ye = w.currentVertexArrayObject,
                    Oe = ye.attribs[he];
                  switch (ue) {
                    case I.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                      return Oe.buffer;
                    case I.VERTEX_ATTRIB_ARRAY_ENABLED:
                      return Oe.enabled;
                    case I.VERTEX_ATTRIB_ARRAY_SIZE:
                      return Oe.size;
                    case I.VERTEX_ATTRIB_ARRAY_STRIDE:
                      return Oe.stride;
                    case I.VERTEX_ATTRIB_ARRAY_TYPE:
                      return Oe.type;
                    case I.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                      return Oe.normalized;
                    default:
                      return N.getVertexAttrib.apply(this, arguments);
                  }
                }),
                (I.vertexAttribPointer = function (he, ue, ye, Oe, Ae, ke) {
                  var Ue = w.currentVertexArrayObject;
                  Ue.maxAttrib = Math.max(Ue.maxAttrib, he);
                  var Ge = Ue.attribs[he];
                  return (
                    (Ge.buffer = w.currentArrayBuffer),
                    (Ge.size = ue),
                    (Ge.type = ye),
                    (Ge.normalized = Oe),
                    (Ge.stride = Ae),
                    (Ge.offset = ke),
                    Ge.recache(),
                    N.vertexAttribPointer.apply(this, arguments)
                  );
                }),
                I.instrumentExtension &&
                  I.instrumentExtension(this, "OES_vertex_array_object"),
                I.canvas.addEventListener(
                  "webglcontextrestored",
                  function () {
                    y(
                      "OESVertexArrayObject emulation library context restored"
                    ),
                      w.reset_();
                  },
                  !0
                ),
                this.reset_();
            };
            (f.prototype.VERTEX_ARRAY_BINDING_OES = 34229),
              (f.prototype.reset_ = function () {
                var I = this.vertexArrayObjects !== void 0;
                if (I)
                  for (var w = 0; w < this.vertexArrayObjects.length; ++w)
                    this.vertexArrayObjects.isAlive = !1;
                var N = this.gl;
                (this.maxVertexAttribs = N.getParameter(N.MAX_VERTEX_ATTRIBS)),
                  (this.defaultVertexArrayObject = new h(this)),
                  (this.currentVertexArrayObject = null),
                  (this.currentArrayBuffer = null),
                  (this.vertexArrayObjects = [this.defaultVertexArrayObject]),
                  this.bindVertexArrayOES(null);
              }),
              (f.prototype.createVertexArrayOES = function () {
                var I = new h(this);
                return this.vertexArrayObjects.push(I), I;
              }),
              (f.prototype.deleteVertexArrayOES = function (I) {
                (I.isAlive = !1),
                  this.vertexArrayObjects.splice(
                    this.vertexArrayObjects.indexOf(I),
                    1
                  ),
                  this.currentVertexArrayObject == I &&
                    this.bindVertexArrayOES(null);
              }),
              (f.prototype.isVertexArrayOES = function (I) {
                return !!(
                  I &&
                  I instanceof h &&
                  I.hasBeenBound &&
                  I.ext == this
                );
              }),
              (f.prototype.bindVertexArrayOES = function (I) {
                var w = this.gl;
                if (I && !I.isAlive) {
                  c(
                    w.INVALID_OPERATION,
                    "bindVertexArrayOES: attempt to bind deleted arrayObject"
                  );
                  return;
                }
                var N = this.original,
                  W = this.currentVertexArrayObject;
                (this.currentVertexArrayObject =
                  I || this.defaultVertexArrayObject),
                  (this.currentVertexArrayObject.hasBeenBound = !0);
                var he = this.currentVertexArrayObject;
                if (W != he) {
                  (!W || he.elementArrayBuffer != W.elementArrayBuffer) &&
                    N.bindBuffer.call(
                      w,
                      w.ELEMENT_ARRAY_BUFFER,
                      he.elementArrayBuffer
                    );
                  for (
                    var ue = this.currentArrayBuffer,
                      ye = Math.max(W ? W.maxAttrib : 0, he.maxAttrib),
                      Oe = 0;
                    Oe <= ye;
                    Oe++
                  ) {
                    var Ae = he.attribs[Oe],
                      ke = W ? W.attribs[Oe] : null;
                    if (
                      ((!W || Ae.enabled != ke.enabled) &&
                        (Ae.enabled
                          ? N.enableVertexAttribArray.call(w, Oe)
                          : N.disableVertexAttribArray.call(w, Oe)),
                      Ae.enabled)
                    ) {
                      var Ue = !1;
                      (!W || Ae.buffer != ke.buffer) &&
                        (ue != Ae.buffer &&
                          (N.bindBuffer.call(w, w.ARRAY_BUFFER, Ae.buffer),
                          (ue = Ae.buffer)),
                        (Ue = !0)),
                        (Ue || Ae.cached != ke.cached) &&
                          N.vertexAttribPointer.call(
                            w,
                            Oe,
                            Ae.size,
                            Ae.type,
                            Ae.normalized,
                            Ae.stride,
                            Ae.offset
                          );
                    }
                  }
                  this.currentArrayBuffer != ue &&
                    N.bindBuffer.call(
                      w,
                      w.ARRAY_BUFFER,
                      this.currentArrayBuffer
                    );
                }
              });
            const s = function (I) {
              if (I.getSupportedExtensions) {
                var w = I.getSupportedExtensions();
                if (w.indexOf("OES_vertex_array_object") != -1) return;
              } else if (I.getExtension) {
                var N = I.getExtension("OES_vertex_array_object");
                if (N) return;
              }
              if (I.getSupportedExtensions) {
                var W = I.getSupportedExtensions;
                I.getSupportedExtensions = function () {
                  var ye = W.call(this) || [];
                  return ye.push("OES_vertex_array_object"), ye;
                };
              }
              var he = I.getExtension;
              I.getExtension = function (ye) {
                return ye == "OES_vertex_array_object"
                  ? (I.__OESVertexArrayObject ||
                      (I.__OESVertexArrayObject = new f(I)),
                    I.__OESVertexArrayObject)
                  : he
                  ? he.call(this, ye)
                  : null;
              };
            };
            var l = a(8656),
              n = a(9222),
              o = a(5227),
              i = a(1630),
              e = a(4461),
              t = a(9061),
              r = a(1208);
            class u {
              constructor() {
                this.bufferId = null;
              }
              destroy(I) {
                this.bufferId &&
                  (I.gl.deleteBuffer(this.bufferId), (this.bufferId = null));
              }
              get initialized() {
                return !!this.bufferId;
              }
              loseContext() {
                this.bufferId = null;
              }
              unlock(I, w, N, W) {
                const he = I.gl;
                this.bufferId || (this.bufferId = he.createBuffer());
                let ue;
                switch (w) {
                  case i.y1K:
                    ue = he.STATIC_DRAW;
                    break;
                  case i.pCO:
                    ue = he.DYNAMIC_DRAW;
                    break;
                  case i.oDV:
                    ue = he.STREAM_DRAW;
                    break;
                  case i.xHx:
                    I.webgl2 ? (ue = he.DYNAMIC_COPY) : (ue = he.STATIC_DRAW);
                    break;
                }
                he.bindBuffer(N, this.bufferId), he.bufferData(N, W, ue);
              }
            }
            class v extends u {
              constructor(...I) {
                super(...I), (this.vao = null);
              }
              destroy(I) {
                super.destroy(I),
                  (I.boundVao = null),
                  I.gl.bindVertexArray(null);
              }
              loseContext() {
                super.loseContext(), (this.vao = null);
              }
              unlock(I) {
                const w = I.device;
                super.unlock(w, I.usage, w.gl.ARRAY_BUFFER, I.storage);
              }
            }
            class _ extends u {
              constructor(I) {
                super();
                const w = I.device.gl,
                  N = I.format;
                N === i.zYw
                  ? (this.glFormat = w.UNSIGNED_BYTE)
                  : N === i.c02
                  ? (this.glFormat = w.UNSIGNED_SHORT)
                  : N === i.gpl && (this.glFormat = w.UNSIGNED_INT);
              }
              unlock(I) {
                const w = I.device;
                super.unlock(w, I.usage, w.gl.ELEMENT_ARRAY_BUFFER, I.storage);
              }
            }
            var m = a(5321),
              g = a(5950);
            const T = [
              "gl_VertexID",
              "gl_InstanceID",
              "gl_DrawID",
              "gl_BaseVertex",
              "gl_BaseInstance",
            ];
            class E {
              constructor() {
                this.map = new Map();
              }
              destroy(I) {
                this.map.forEach((w) => {
                  I.gl.deleteShader(w);
                });
              }
              loseContext(I) {
                this.map.clear();
              }
            }
            class M {
              constructor() {
                this.shaders = [];
              }
              loseContext(I) {
                this.shaders = [];
              }
            }
            const R = new g.N(),
              P = new g.N(),
              F = new g.N();
            class b {
              constructor(I) {
                (this.compileDuration = 0),
                  this.init(),
                  this.compile(I.device, I),
                  b.getBatchShaders(I.device).push(I),
                  I.device.shaders.push(I);
              }
              destroy(I) {
                this.glProgram &&
                  (I.device.gl.deleteProgram(this.glProgram),
                  (this.glProgram = null));
              }
              init() {
                (this.uniforms = []),
                  (this.samplers = []),
                  (this.attributes = []),
                  (this.glProgram = null),
                  (this.glVertexShader = null),
                  (this.glFragmentShader = null);
              }
              static getBatchShaders(I) {
                return F.get(I, () => new M()).shaders;
              }
              static endShaderBatch(I) {
                const w = b.getBatchShaders(I);
                w.forEach((N) => N.impl.link(I, N)), (w.length = 0);
              }
              loseContext() {
                this.init();
              }
              restoreContext(I, w) {
                this.compile(I, w);
              }
              compile(I, w) {
                const N = w.definition;
                (this.glVertexShader = this._compileShaderSource(
                  I,
                  N.vshader,
                  !0
                )),
                  (this.glFragmentShader = this._compileShaderSource(
                    I,
                    N.fshader,
                    !1
                  ));
              }
              link(I, w) {
                if (this.glProgram) return;
                const N = I.gl,
                  W = N.createProgram();
                (this.glProgram = W),
                  N.attachShader(W, this.glVertexShader),
                  N.attachShader(W, this.glFragmentShader);
                const he = w.definition,
                  ue = he.attributes;
                if (I.webgl2 && he.useTransformFeedback) {
                  const ye = [];
                  for (const Oe in ue)
                    ue.hasOwnProperty(Oe) && ye.push("out_" + Oe);
                  N.transformFeedbackVaryings(W, ye, N.INTERLEAVED_ATTRIBS);
                }
                for (const ye in ue)
                  if (ue.hasOwnProperty(ye)) {
                    const Oe = ue[ye],
                      Ae = i.tJj[Oe];
                    N.bindAttribLocation(W, Ae, ye);
                  }
                N.linkProgram(W);
              }
              _compileShaderSource(I, w, N) {
                const W = I.gl,
                  ue = (N ? R : P).get(I, () => new E());
                let ye = ue.map.get(w);
                return (
                  ye ||
                    ((ye = W.createShader(
                      N ? W.VERTEX_SHADER : W.FRAGMENT_SHADER
                    )),
                    W.shaderSource(ye, w),
                    W.compileShader(ye),
                    ue.map.set(w, ye)),
                  ye
                );
              }
              finalize(I, w) {
                this.glProgram || this.link(I, w);
                const N = I.gl,
                  W = this.glProgram,
                  he = w.definition;
                if (!N.getProgramParameter(W, N.LINK_STATUS)) {
                  if (
                    !this._isCompiled(
                      I,
                      w,
                      this.glVertexShader,
                      he.vshader,
                      "vertex"
                    ) ||
                    !this._isCompiled(
                      I,
                      w,
                      this.glFragmentShader,
                      he.fshader,
                      "fragment"
                    )
                  )
                    return !1;
                  const ke =
                    "Failed to link shader program. Error: " +
                    N.getProgramInfoLog(W);
                  return console.error(ke), !1;
                }
                let ye = 0;
                const Oe = N.getProgramParameter(W, N.ACTIVE_ATTRIBUTES);
                for (; ye < Oe; ) {
                  const ke = N.getActiveAttrib(W, ye++),
                    Ue = N.getAttribLocation(W, ke.name);
                  if (T.indexOf(ke.name) !== -1) continue;
                  he.attributes[ke.name] === void 0 &&
                    (console.error(
                      `Vertex shader attribute "${ke.name}" is not mapped to a semantic in shader definition, shader [${w.label}]`,
                      w
                    ),
                    (w.failed = !0));
                  const Ge = new m.j(
                    I,
                    he.attributes[ke.name],
                    I.pcUniformType[ke.type],
                    Ue
                  );
                  this.attributes.push(Ge);
                }
                ye = 0;
                const Ae = N.getProgramParameter(W, N.ACTIVE_UNIFORMS);
                for (; ye < Ae; ) {
                  const ke = N.getActiveUniform(W, ye++),
                    Ue = N.getUniformLocation(W, ke.name),
                    Ge = new m.j(I, ke.name, I.pcUniformType[ke.type], Ue);
                  ke.type === N.SAMPLER_2D ||
                  ke.type === N.SAMPLER_CUBE ||
                  (I.webgl2 &&
                    (ke.type === N.SAMPLER_2D_SHADOW ||
                      ke.type === N.SAMPLER_CUBE_SHADOW ||
                      ke.type === N.SAMPLER_3D))
                    ? this.samplers.push(Ge)
                    : this.uniforms.push(Ge);
                }
                return (w.ready = !0), !0;
              }
              _isCompiled(I, w, N, W, he) {
                const ue = I.gl;
                if (!ue.getShaderParameter(N, ue.COMPILE_STATUS)) {
                  const ye = ue.getShaderInfoLog(N),
                    [Oe, Ae] = this._processError(W, ye),
                    ke = `Failed to compile ${he} shader:

${ye}
${Oe}`;
                  return console.error(ke), !1;
                }
                return !0;
              }
              _processError(I, w) {
                const N = {};
                let W = "";
                if (I) {
                  const he = I.split(`
`);
                  let ue = 0,
                    ye = he.length;
                  if (w && w.startsWith("ERROR:")) {
                    const Oe = w.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);
                    Oe &&
                      ((N.message = Oe[3]),
                      (N.line = parseInt(Oe[2], 10)),
                      (ue = Math.max(0, N.line - 6)),
                      (ye = Math.min(he.length, N.line + 5)));
                  }
                  for (let Oe = ue; Oe < ye; Oe++)
                    W +=
                      Oe +
                      1 +
                      ":	" +
                      he[Oe] +
                      `
`;
                  N.source = I;
                }
                return [W, N];
              }
            }
            function D(re, I) {
              const w = re.width,
                N = re.height;
              if (w > I || N > I) {
                const W = I / Math.max(w, N),
                  he = Math.floor(w * W),
                  ue = Math.floor(N * W),
                  ye = document.createElement("canvas");
                return (
                  (ye.width = he),
                  (ye.height = ue),
                  ye.getContext("2d").drawImage(re, 0, 0, w, N, 0, 0, he, ue),
                  ye
                );
              }
              return re;
            }
            class G {
              constructor() {
                (this._glTexture = null),
                  (this._glTarget = void 0),
                  (this._glFormat = void 0),
                  (this._glInternalFormat = void 0),
                  (this._glPixelType = void 0),
                  (this.dirtyParameterFlags = 0);
              }
              destroy(I) {
                if (this._glTexture) {
                  for (let w = 0; w < I.textureUnits.length; w++) {
                    const N = I.textureUnits[w];
                    for (let W = 0; W < N.length; W++)
                      N[W] === this._glTexture && (N[W] = null);
                  }
                  I.gl.deleteTexture(this._glTexture), (this._glTexture = null);
                }
              }
              loseContext() {
                this._glTexture = null;
              }
              propertyChanged(I) {
                this.dirtyParameterFlags |= I;
              }
              initialize(I, w) {
                const N = I.gl;
                switch (
                  ((this._glTexture = N.createTexture()),
                  (this._glTarget = w._cubemap
                    ? N.TEXTURE_CUBE_MAP
                    : w._volume
                    ? N.TEXTURE_3D
                    : N.TEXTURE_2D),
                  w._format)
                ) {
                  case i.SWx:
                    (this._glFormat = N.ALPHA),
                      (this._glInternalFormat = N.ALPHA),
                      (this._glPixelType = N.UNSIGNED_BYTE);
                    break;
                  case i.RSt:
                    (this._glFormat = N.LUMINANCE),
                      (this._glInternalFormat = N.LUMINANCE),
                      (this._glPixelType = N.UNSIGNED_BYTE);
                    break;
                  case i._3:
                    (this._glFormat = N.LUMINANCE_ALPHA),
                      (this._glInternalFormat = N.LUMINANCE_ALPHA),
                      (this._glPixelType = N.UNSIGNED_BYTE);
                    break;
                  case i.kqw:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat = N.RGB),
                      (this._glPixelType = N.UNSIGNED_SHORT_5_6_5);
                    break;
                  case i.zIz:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat = N.RGBA),
                      (this._glPixelType = N.UNSIGNED_SHORT_5_5_5_1);
                    break;
                  case i.LDn:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat = N.RGBA),
                      (this._glPixelType = N.UNSIGNED_SHORT_4_4_4_4);
                    break;
                  case i.akF:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat = I.webgl2 ? N.RGB8 : N.RGB),
                      (this._glPixelType = N.UNSIGNED_BYTE);
                    break;
                  case i.Lxj:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat = I.webgl2 ? N.RGBA8 : N.RGBA),
                      (this._glPixelType = N.UNSIGNED_BYTE);
                    break;
                  case i.S$n:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat =
                        I.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT);
                    break;
                  case i.EPU:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat =
                        I.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT);
                    break;
                  case i.E_6:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat =
                        I.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT);
                    break;
                  case i.G24:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat =
                        I.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL);
                    break;
                  case i.TyC:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat =
                        I.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG);
                    break;
                  case i.apD:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat =
                        I.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG);
                    break;
                  case i.xyx:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat =
                        I.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG);
                    break;
                  case i.Ijy:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat =
                        I.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG);
                    break;
                  case i.ZyS:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat =
                        I.extCompressedTextureETC.COMPRESSED_RGB8_ETC2);
                    break;
                  case i.ArW:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat =
                        I.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC);
                    break;
                  case i.jYy:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat =
                        I.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR);
                    break;
                  case i.x8T:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat =
                        I.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL);
                    break;
                  case i.qEN:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat =
                        I.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL);
                    break;
                  case i.Nnq:
                    (this._glFormat = N.RGB),
                      I.webgl2
                        ? ((this._glInternalFormat = N.RGB16F),
                          (this._glPixelType = N.HALF_FLOAT))
                        : ((this._glInternalFormat = N.RGB),
                          (this._glPixelType =
                            I.extTextureHalfFloat.HALF_FLOAT_OES));
                    break;
                  case i.WBN:
                    (this._glFormat = N.RGBA),
                      I.webgl2
                        ? ((this._glInternalFormat = N.RGBA16F),
                          (this._glPixelType = N.HALF_FLOAT))
                        : ((this._glInternalFormat = N.RGBA),
                          (this._glPixelType =
                            I.extTextureHalfFloat.HALF_FLOAT_OES));
                    break;
                  case i.FQW:
                    (this._glFormat = N.RGB),
                      I.webgl2
                        ? (this._glInternalFormat = N.RGB32F)
                        : (this._glInternalFormat = N.RGB),
                      (this._glPixelType = N.FLOAT);
                    break;
                  case i.s7h:
                    (this._glFormat = N.RGBA),
                      I.webgl2
                        ? (this._glInternalFormat = N.RGBA32F)
                        : (this._glInternalFormat = N.RGBA),
                      (this._glPixelType = N.FLOAT);
                    break;
                  case i.IQA:
                    (this._glFormat = N.RED),
                      (this._glInternalFormat = N.R32F),
                      (this._glPixelType = N.FLOAT);
                    break;
                  case i.Wbd:
                    I.webgl2
                      ? ((this._glFormat = N.DEPTH_COMPONENT),
                        (this._glInternalFormat = N.DEPTH_COMPONENT32F),
                        (this._glPixelType = N.FLOAT))
                      : ((this._glFormat = N.DEPTH_COMPONENT),
                        (this._glInternalFormat = N.DEPTH_COMPONENT),
                        (this._glPixelType = N.UNSIGNED_SHORT));
                    break;
                  case i.Mg$:
                    (this._glFormat = N.DEPTH_STENCIL),
                      I.webgl2
                        ? ((this._glInternalFormat = N.DEPTH24_STENCIL8),
                          (this._glPixelType = N.UNSIGNED_INT_24_8))
                        : ((this._glInternalFormat = N.DEPTH_STENCIL),
                          (this._glPixelType =
                            I.extDepthTexture.UNSIGNED_INT_24_8_WEBGL));
                    break;
                  case i.s_z:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat = N.R11F_G11F_B10F),
                      (this._glPixelType = N.UNSIGNED_INT_10F_11F_11F_REV);
                    break;
                  case i.lsY:
                    (this._glFormat = N.RGB),
                      (this._glInternalFormat = N.SRGB8),
                      (this._glPixelType = N.UNSIGNED_BYTE);
                    break;
                  case i.Mzz:
                    (this._glFormat = N.RGBA),
                      (this._glInternalFormat = N.SRGB8_ALPHA8),
                      (this._glPixelType = N.UNSIGNED_BYTE);
                    break;
                }
              }
              upload(I, w) {
                const N = I.gl;
                if (
                  !w._needsUpload &&
                  ((w._needsMipmapsUpload && w._mipmapsUploaded) || !w.pot)
                )
                  return;
                let W = 0,
                  he,
                  ue;
                const ye = w.requiredMipLevels;
                for (; w._levels[W] || W === 0; ) {
                  if (!w._needsUpload && W === 0) {
                    W++;
                    continue;
                  } else if (W && (!w._needsMipmapsUpload || !w._mipmaps))
                    break;
                  if (
                    ((he = w._levels[W]),
                    W === 1 &&
                      !w._compressed &&
                      w._levels.length < ye &&
                      (N.generateMipmap(this._glTarget),
                      (w._mipmapsUploaded = !0)),
                    w._cubemap)
                  ) {
                    let Oe;
                    if (I._isBrowserInterface(he[0]))
                      for (Oe = 0; Oe < 6; Oe++) {
                        if (!w._levelsUpdated[0][Oe]) continue;
                        let Ae = he[Oe];
                        I._isImageBrowserInterface(Ae) &&
                          (Ae.width > I.maxCubeMapSize ||
                            Ae.height > I.maxCubeMapSize) &&
                          ((Ae = D(Ae, I.maxCubeMapSize)),
                          W === 0 &&
                            ((w._width = Ae.width), (w._height = Ae.height))),
                          I.setUnpackFlipY(!1),
                          I.setUnpackPremultiplyAlpha(w._premultiplyAlpha),
                          N.texImage2D(
                            N.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                            W,
                            this._glInternalFormat,
                            this._glFormat,
                            this._glPixelType,
                            Ae
                          );
                      }
                    else
                      for (ue = 1 / Math.pow(2, W), Oe = 0; Oe < 6; Oe++) {
                        if (!w._levelsUpdated[0][Oe]) continue;
                        const Ae = he[Oe];
                        w._compressed
                          ? N.compressedTexImage2D(
                              N.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                              W,
                              this._glInternalFormat,
                              Math.max(w._width * ue, 1),
                              Math.max(w._height * ue, 1),
                              0,
                              Ae
                            )
                          : (I.setUnpackFlipY(!1),
                            I.setUnpackPremultiplyAlpha(w._premultiplyAlpha),
                            N.texImage2D(
                              N.TEXTURE_CUBE_MAP_POSITIVE_X + Oe,
                              W,
                              this._glInternalFormat,
                              Math.max(w._width * ue, 1),
                              Math.max(w._height * ue, 1),
                              0,
                              this._glFormat,
                              this._glPixelType,
                              Ae
                            ));
                      }
                  } else
                    w._volume
                      ? ((ue = 1 / Math.pow(2, W)),
                        w._compressed
                          ? N.compressedTexImage3D(
                              N.TEXTURE_3D,
                              W,
                              this._glInternalFormat,
                              Math.max(w._width * ue, 1),
                              Math.max(w._height * ue, 1),
                              Math.max(w._depth * ue, 1),
                              0,
                              he
                            )
                          : (I.setUnpackFlipY(!1),
                            I.setUnpackPremultiplyAlpha(w._premultiplyAlpha),
                            N.texImage3D(
                              N.TEXTURE_3D,
                              W,
                              this._glInternalFormat,
                              Math.max(w._width * ue, 1),
                              Math.max(w._height * ue, 1),
                              Math.max(w._depth * ue, 1),
                              0,
                              this._glFormat,
                              this._glPixelType,
                              he
                            )))
                      : (I._isBrowserInterface(he)
                          ? (I._isImageBrowserInterface(he) &&
                              (he.width > I.maxTextureSize ||
                                he.height > I.maxTextureSize) &&
                              ((he = D(he, I.maxTextureSize)),
                              W === 0 &&
                                ((w._width = he.width),
                                (w._height = he.height))),
                            I.setUnpackFlipY(w._flipY),
                            I.setUnpackPremultiplyAlpha(w._premultiplyAlpha),
                            N.texImage2D(
                              N.TEXTURE_2D,
                              W,
                              this._glInternalFormat,
                              this._glFormat,
                              this._glPixelType,
                              he
                            ))
                          : ((ue = 1 / Math.pow(2, W)),
                            w._compressed
                              ? N.compressedTexImage2D(
                                  N.TEXTURE_2D,
                                  W,
                                  this._glInternalFormat,
                                  Math.max(Math.floor(w._width * ue), 1),
                                  Math.max(Math.floor(w._height * ue), 1),
                                  0,
                                  he
                                )
                              : (I.setUnpackFlipY(!1),
                                I.setUnpackPremultiplyAlpha(
                                  w._premultiplyAlpha
                                ),
                                N.texImage2D(
                                  N.TEXTURE_2D,
                                  W,
                                  this._glInternalFormat,
                                  Math.max(w._width * ue, 1),
                                  Math.max(w._height * ue, 1),
                                  0,
                                  this._glFormat,
                                  this._glPixelType,
                                  he
                                ))),
                        W === 0
                          ? (w._mipmapsUploaded = !1)
                          : (w._mipmapsUploaded = !0));
                  W++;
                }
                if (w._needsUpload)
                  if (w._cubemap)
                    for (let Oe = 0; Oe < 6; Oe++) w._levelsUpdated[0][Oe] = !1;
                  else w._levelsUpdated[0] = !1;
                !w._compressed &&
                  w._mipmaps &&
                  w._needsMipmapsUpload &&
                  (w.pot || I.webgl2) &&
                  w._levels.length === 1 &&
                  (N.generateMipmap(this._glTarget), (w._mipmapsUploaded = !0)),
                  w._gpuSize && w.adjustVramSizeTracking(I._vram, -w._gpuSize),
                  (w._gpuSize = w.gpuSize),
                  w.adjustVramSizeTracking(I._vram, w._gpuSize);
              }
            }
            class X {
              constructor(I, w) {
                (this.msaaFB = void 0),
                  (this.resolveFB = void 0),
                  (this.msaaFB = I),
                  (this.resolveFB = w);
              }
              destroy(I) {
                this.msaaFB &&
                  (I.deleteRenderbuffer(this.msaaFB), (this.msaaFB = null)),
                  this.resolveFB &&
                    (I.deleteRenderbuffer(this.resolveFB),
                    (this.resolveFB = null));
              }
            }
            class ie {
              constructor() {
                (this._glFrameBuffer = null),
                  (this._glDepthBuffer = null),
                  (this._glResolveFrameBuffer = null),
                  (this.colorMrtFramebuffers = null),
                  (this._glMsaaColorBuffers = []),
                  (this._glMsaaDepthBuffer = null);
              }
              destroy(I) {
                var w;
                const N = I.gl;
                this._glFrameBuffer &&
                  (N.deleteFramebuffer(this._glFrameBuffer),
                  (this._glFrameBuffer = null)),
                  this._glDepthBuffer &&
                    (N.deleteRenderbuffer(this._glDepthBuffer),
                    (this._glDepthBuffer = null)),
                  this._glResolveFrameBuffer &&
                    (N.deleteFramebuffer(this._glResolveFrameBuffer),
                    (this._glResolveFrameBuffer = null)),
                  this._glMsaaColorBuffers.forEach((W) => {
                    N.deleteRenderbuffer(W);
                  }),
                  (this._glMsaaColorBuffers.length = 0),
                  (w = this.colorMrtFramebuffers) == null ||
                    w.forEach((W) => {
                      W.destroy(N);
                    }),
                  (this.colorMrtFramebuffers = null),
                  this._glMsaaDepthBuffer &&
                    (N.deleteRenderbuffer(this._glMsaaDepthBuffer),
                    (this._glMsaaDepthBuffer = null));
              }
              get initialized() {
                return this._glFrameBuffer !== null;
              }
              init(I, w) {
                var N, W, he, ue;
                const ye = I.gl;
                (this._glFrameBuffer = ye.createFramebuffer()),
                  I.setFramebuffer(this._glFrameBuffer);
                const Oe =
                    (N = (W = w._colorBuffers) == null ? void 0 : W.length) !=
                    null
                      ? N
                      : 0,
                  Ae = I.webgl2
                    ? ye.COLOR_ATTACHMENT0
                    : (he =
                        (ue = I.extDrawBuffers) == null
                          ? void 0
                          : ue.COLOR_ATTACHMENT0_WEBGL) != null
                    ? he
                    : ye.COLOR_ATTACHMENT0,
                  ke = [];
                for (let me = 0; me < Oe; ++me) {
                  const z = w.getColorBuffer(me);
                  z &&
                    (z.impl._glTexture ||
                      ((z._width = Math.min(z.width, I.maxRenderBufferSize)),
                      (z._height = Math.min(z.height, I.maxRenderBufferSize)),
                      I.setTexture(z, 0)),
                    ye.framebufferTexture2D(
                      ye.FRAMEBUFFER,
                      Ae + me,
                      z._cubemap
                        ? ye.TEXTURE_CUBE_MAP_POSITIVE_X + w._face
                        : ye.TEXTURE_2D,
                      z.impl._glTexture,
                      0
                    ),
                    ke.push(Ae + me));
                }
                I.drawBuffers && I.drawBuffers(ke);
                const Ue = w._depthBuffer;
                if (Ue)
                  Ue.impl._glTexture ||
                    ((Ue._width = Math.min(Ue.width, I.maxRenderBufferSize)),
                    (Ue._height = Math.min(Ue.height, I.maxRenderBufferSize)),
                    I.setTexture(Ue, 0)),
                    w._stencil
                      ? ye.framebufferTexture2D(
                          ye.FRAMEBUFFER,
                          ye.DEPTH_STENCIL_ATTACHMENT,
                          Ue._cubemap
                            ? ye.TEXTURE_CUBE_MAP_POSITIVE_X + w._face
                            : ye.TEXTURE_2D,
                          w._depthBuffer.impl._glTexture,
                          0
                        )
                      : ye.framebufferTexture2D(
                          ye.FRAMEBUFFER,
                          ye.DEPTH_ATTACHMENT,
                          Ue._cubemap
                            ? ye.TEXTURE_CUBE_MAP_POSITIVE_X + w._face
                            : ye.TEXTURE_2D,
                          w._depthBuffer.impl._glTexture,
                          0
                        );
                else if (w._depth && !(w._samples > 1 && I.webgl2)) {
                  if (
                    (this._glDepthBuffer ||
                      (this._glDepthBuffer = ye.createRenderbuffer()),
                    ye.bindRenderbuffer(ye.RENDERBUFFER, this._glDepthBuffer),
                    w._stencil)
                  )
                    ye.renderbufferStorage(
                      ye.RENDERBUFFER,
                      ye.DEPTH_STENCIL,
                      w.width,
                      w.height
                    ),
                      ye.framebufferRenderbuffer(
                        ye.FRAMEBUFFER,
                        ye.DEPTH_STENCIL_ATTACHMENT,
                        ye.RENDERBUFFER,
                        this._glDepthBuffer
                      );
                  else {
                    const z = I.webgl2
                      ? ye.DEPTH_COMPONENT32F
                      : ye.DEPTH_COMPONENT16;
                    ye.renderbufferStorage(
                      ye.RENDERBUFFER,
                      z,
                      w.width,
                      w.height
                    ),
                      ye.framebufferRenderbuffer(
                        ye.FRAMEBUFFER,
                        ye.DEPTH_ATTACHMENT,
                        ye.RENDERBUFFER,
                        this._glDepthBuffer
                      );
                  }
                  ye.bindRenderbuffer(ye.RENDERBUFFER, null);
                }
                if (I.webgl2 && w._samples > 1) {
                  var Ge, ht;
                  (this._glResolveFrameBuffer = this._glFrameBuffer),
                    (this._glFrameBuffer = ye.createFramebuffer()),
                    I.setFramebuffer(this._glFrameBuffer);
                  const me =
                    (Ge =
                      (ht = w._colorBuffers) == null ? void 0 : ht.length) !=
                    null
                      ? Ge
                      : 0;
                  for (let z = 0; z < me; ++z) {
                    const K = w.getColorBuffer(z);
                    if (K) {
                      const Te = ye.createRenderbuffer();
                      this._glMsaaColorBuffers.push(Te),
                        ye.bindRenderbuffer(ye.RENDERBUFFER, Te),
                        ye.renderbufferStorageMultisample(
                          ye.RENDERBUFFER,
                          w._samples,
                          K.impl._glInternalFormat,
                          w.width,
                          w.height
                        ),
                        ye.framebufferRenderbuffer(
                          ye.FRAMEBUFFER,
                          ye.COLOR_ATTACHMENT0 + z,
                          ye.RENDERBUFFER,
                          Te
                        );
                    }
                  }
                  w._depth &&
                    (this._glMsaaDepthBuffer ||
                      (this._glMsaaDepthBuffer = ye.createRenderbuffer()),
                    ye.bindRenderbuffer(
                      ye.RENDERBUFFER,
                      this._glMsaaDepthBuffer
                    ),
                    w._stencil
                      ? (ye.renderbufferStorageMultisample(
                          ye.RENDERBUFFER,
                          w._samples,
                          ye.DEPTH24_STENCIL8,
                          w.width,
                          w.height
                        ),
                        ye.framebufferRenderbuffer(
                          ye.FRAMEBUFFER,
                          ye.DEPTH_STENCIL_ATTACHMENT,
                          ye.RENDERBUFFER,
                          this._glMsaaDepthBuffer
                        ))
                      : (ye.renderbufferStorageMultisample(
                          ye.RENDERBUFFER,
                          w._samples,
                          ye.DEPTH_COMPONENT32F,
                          w.width,
                          w.height
                        ),
                        ye.framebufferRenderbuffer(
                          ye.FRAMEBUFFER,
                          ye.DEPTH_ATTACHMENT,
                          ye.RENDERBUFFER,
                          this._glMsaaDepthBuffer
                        ))),
                    me > 1 &&
                      (this._createMsaaMrtFramebuffers(I, w, me),
                      I.setFramebuffer(this._glFrameBuffer),
                      I.drawBuffers(ke));
                }
              }
              _createMsaaMrtFramebuffers(I, w, N) {
                const W = I.gl;
                this.colorMrtFramebuffers = [];
                for (let he = 0; he < N; ++he) {
                  const ue = w.getColorBuffer(he),
                    ye = W.createFramebuffer();
                  I.setFramebuffer(ye);
                  const Oe = this._glMsaaColorBuffers[he];
                  W.bindRenderbuffer(W.RENDERBUFFER, Oe),
                    W.renderbufferStorageMultisample(
                      W.RENDERBUFFER,
                      w._samples,
                      ue.impl._glInternalFormat,
                      w.width,
                      w.height
                    ),
                    W.framebufferRenderbuffer(
                      W.FRAMEBUFFER,
                      W.COLOR_ATTACHMENT0,
                      W.RENDERBUFFER,
                      Oe
                    ),
                    I.drawBuffers([W.COLOR_ATTACHMENT0]);
                  const Ae = W.createFramebuffer();
                  I.setFramebuffer(Ae),
                    W.framebufferTexture2D(
                      W.FRAMEBUFFER,
                      W.COLOR_ATTACHMENT0,
                      ue._cubemap
                        ? W.TEXTURE_CUBE_MAP_POSITIVE_X + w._face
                        : W.TEXTURE_2D,
                      ue.impl._glTexture,
                      0
                    ),
                    (this.colorMrtFramebuffers[he] = new X(ye, Ae));
                }
              }
              _checkFbo(I, w, N = "") {
                const W = I.gl;
                switch (W.checkFramebufferStatus(W.FRAMEBUFFER)) {
                  case W.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    break;
                  case W.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    break;
                  case W.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    break;
                  case W.FRAMEBUFFER_UNSUPPORTED:
                    break;
                }
              }
              loseContext() {
                (this._glFrameBuffer = null),
                  (this._glDepthBuffer = null),
                  (this._glResolveFrameBuffer = null),
                  (this._glMsaaColorBuffers.length = 0),
                  (this._glMsaaDepthBuffer = null),
                  (this.colorMrtFramebuffers = null);
              }
              internalResolve(I, w, N, W, he) {
                const ue = I.gl;
                ue.bindFramebuffer(ue.READ_FRAMEBUFFER, w),
                  ue.bindFramebuffer(ue.DRAW_FRAMEBUFFER, N),
                  ue.blitFramebuffer(
                    0,
                    0,
                    W.width,
                    W.height,
                    0,
                    0,
                    W.width,
                    W.height,
                    he,
                    ue.NEAREST
                  );
              }
              resolve(I, w, N, W) {
                if (I.webgl2) {
                  const he = I.gl;
                  if (this.colorMrtFramebuffers) {
                    if (N)
                      for (
                        let ue = 0;
                        ue < this.colorMrtFramebuffers.length;
                        ue++
                      ) {
                        const ye = this.colorMrtFramebuffers[ue];
                        this.internalResolve(
                          I,
                          ye.msaaFB,
                          ye.resolveFB,
                          w,
                          he.COLOR_BUFFER_BIT
                        );
                      }
                    W &&
                      this.internalResolve(
                        I,
                        this._glFrameBuffer,
                        this._glResolveFrameBuffer,
                        w,
                        he.DEPTH_BUFFER_BIT
                      );
                  } else
                    this.internalResolve(
                      I,
                      this._glFrameBuffer,
                      this._glResolveFrameBuffer,
                      w,
                      (N ? he.COLOR_BUFFER_BIT : 0) |
                        (W ? he.DEPTH_BUFFER_BIT : 0)
                    );
                  he.bindFramebuffer(he.FRAMEBUFFER, this._glFrameBuffer);
                }
              }
            }
            var Q = a(9855),
              te = a(8526),
              ae = a(1268),
              Z = a(4870),
              J = a(2640),
              ve = a(1735);
            class _e {
              constructor() {
                (this.renderVersion = void 0), (this.queries = []);
              }
              destroy(I) {
                this.queries.forEach((w) => I.deleteQuery(w)),
                  (this.queries = null);
              }
            }
            class L extends ve.M {
              constructor(I) {
                super(),
                  (this.device = void 0),
                  (this.freeQueries = []),
                  (this.frameQueries = []),
                  (this.previousFrameQueries = []),
                  (this.timings = []),
                  (this.device = I),
                  (this.ext = I.extDisjointTimerQuery);
              }
              destroy() {
                this.freeQueries.forEach((I) => this.device.gl.deleteQuery(I)),
                  this.frameQueries.forEach((I) =>
                    this.device.gl.deleteQuery(I)
                  ),
                  this.previousFrameQueries.forEach((I) =>
                    I.destroy(this.device.gl)
                  ),
                  (this.freeQueries = null),
                  (this.frameQueries = null),
                  (this.previousFrameQueries = null);
              }
              loseContext() {
                super.loseContext(),
                  (this.freeQueries = []),
                  (this.frameQueries = []),
                  (this.previousFrameQueries = []);
              }
              restoreContext() {
                this.ext = this.device.extDisjointTimerQuery;
              }
              getQuery() {
                var I;
                return (I = this.freeQueries.pop()) != null
                  ? I
                  : this.device.gl.createQuery();
              }
              start(I) {
                if (this.ext) {
                  const w = this.getSlot(I),
                    N = this.getQuery();
                  return (
                    (this.frameQueries[w] = N),
                    this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, N),
                    w
                  );
                }
              }
              end(I) {
                I !== void 0 &&
                  this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
              }
              frameStart() {
                this.processEnableRequest(),
                  this._enabled &&
                    (this.frameGPUMarkerSlot = this.start("GpuFrame"));
              }
              frameEnd() {
                this._enabled && this.end(this.frameGPUMarkerSlot);
              }
              request() {
                if (this._enabled) {
                  const I = this.ext,
                    w = this.device.gl,
                    N = this.device.renderVersion,
                    W = this.frameQueries;
                  if (W.length > 0) {
                    this.frameQueries = [];
                    const he = new _e();
                    (he.queries = W),
                      (he.renderVersion = N),
                      this.previousFrameQueries.push(he);
                  }
                  if (this.previousFrameQueries.length > 0) {
                    const he = this.previousFrameQueries[0],
                      ue = he.queries,
                      ye = ue[ue.length - 1],
                      Oe = w.getQueryParameter(ye, w.QUERY_RESULT_AVAILABLE),
                      Ae = w.getParameter(I.GPU_DISJOINT_EXT);
                    if (Oe && !Ae) {
                      this.previousFrameQueries.shift();
                      const ke = this.timings;
                      ke.length = 0;
                      for (let Ue = 0; Ue < ue.length; Ue++) {
                        const Ge = ue[Ue],
                          ht = w.getQueryParameter(Ge, w.QUERY_RESULT);
                        (ke[Ue] = ht * 1e-6), this.freeQueries.push(Ge);
                      }
                      this.report(he.renderVersion, ke);
                    }
                    Ae &&
                      (this.previousFrameQueries.forEach((ke) => {
                        this.report(ke.renderVersion, null), ke.destroy(w);
                      }),
                      (this.previousFrameQueries.length = 0));
                  }
                  super.request(N);
                }
              }
            }
            const ge = [],
              k = `
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = vertex_position.xy*0.5+0.5;
}
`,
              j = `
void main(void) { 
		gl_FragColor = vec4(2147483648.0);
}
`,
              B = `
uniform sampler2D source;
vec4 packFloat(float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
		vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
		res -= res.xxyz * bit_mask;
		return res;
}
void main(void) {
		float c = texture2D(source, vec2(0.0)).r;
		float diff = abs(c - 2147483648.0) / 2147483648.0;
		gl_FragColor = packFloat(diff);
}
`,
              $ = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`;
            function le(re, I, w) {
              const N = re.renderTarget;
              re.setRenderTarget(I),
                re.updateBegin(),
                re.setCullMode(i.pLF),
                re.setBlendState(ae.t.NOBLEND),
                re.setDepthState(Z.H.NODEPTH),
                re.setStencilState(null, null),
                re.setVertexBuffer(re.quadVertexBuffer, 0),
                re.setShader(w),
                re.draw({ type: i.SF$, base: 0, count: 4, indexed: !1 }),
                re.updateEnd(),
                re.setRenderTarget(N),
                re.updateBegin();
            }
            function O(re, I) {
              let w = !0;
              const N = re.createTexture();
              re.bindTexture(re.TEXTURE_2D, N),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_MIN_FILTER,
                  re.NEAREST
                ),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_MAG_FILTER,
                  re.NEAREST
                ),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_WRAP_S,
                  re.CLAMP_TO_EDGE
                ),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_WRAP_T,
                  re.CLAMP_TO_EDGE
                ),
                re.texImage2D(
                  re.TEXTURE_2D,
                  0,
                  re.RGBA,
                  2,
                  2,
                  0,
                  re.RGBA,
                  I,
                  null
                );
              const W = re.createFramebuffer();
              return (
                re.bindFramebuffer(re.FRAMEBUFFER, W),
                re.framebufferTexture2D(
                  re.FRAMEBUFFER,
                  re.COLOR_ATTACHMENT0,
                  re.TEXTURE_2D,
                  N,
                  0
                ),
                re.checkFramebufferStatus(re.FRAMEBUFFER) !==
                  re.FRAMEBUFFER_COMPLETE && (w = !1),
                re.bindTexture(re.TEXTURE_2D, null),
                re.deleteTexture(N),
                re.bindFramebuffer(re.FRAMEBUFFER, null),
                re.deleteFramebuffer(W),
                w
              );
            }
            function Y(re, I) {
              let w = !0;
              const N = re.createTexture();
              re.bindTexture(re.TEXTURE_2D, N),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_MIN_FILTER,
                  re.NEAREST
                ),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_MAG_FILTER,
                  re.NEAREST
                ),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_WRAP_S,
                  re.CLAMP_TO_EDGE
                ),
                re.texParameteri(
                  re.TEXTURE_2D,
                  re.TEXTURE_WRAP_T,
                  re.CLAMP_TO_EDGE
                );
              const W = new Uint16Array(4 * 2 * 2);
              return (
                re.texImage2D(
                  re.TEXTURE_2D,
                  0,
                  re.RGBA,
                  2,
                  2,
                  0,
                  re.RGBA,
                  I,
                  W
                ),
                re.getError() !== re.NO_ERROR &&
                  ((w = !1),
                  console.log(
                    "Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support"
                  )),
                re.bindTexture(re.TEXTURE_2D, null),
                re.deleteTexture(N),
                w
              );
            }
            function ne(re) {
              if (!re.textureFloatRenderable) return !1;
              const I = new te.M(
                  re,
                  Q.l.createDefinition(re, {
                    name: "ptest1",
                    vertexCode: k,
                    fragmentCode: j,
                  })
                ),
                w = new te.M(
                  re,
                  Q.l.createDefinition(re, {
                    name: "ptest2",
                    vertexCode: k,
                    fragmentCode: B,
                  })
                ),
                N = {
                  format: i.s7h,
                  width: 1,
                  height: 1,
                  mipmaps: !1,
                  minFilter: i.uhC,
                  magFilter: i.uhC,
                  name: "testFHP",
                },
                W = new r.g(re, N),
                he = new t.O({ colorBuffer: W, depth: !1 });
              le(re, he, I), (N.format = i.Lxj);
              const ue = new r.g(re, N),
                ye = new t.O({ colorBuffer: ue, depth: !1 });
              re.constantTexSource.setValue(W), le(re, ye, w);
              const Oe = re.activeFramebuffer;
              re.setFramebuffer(ye.impl._glFrameBuffer);
              const Ae = new Uint8Array(4);
              re.readPixels(0, 0, 1, 1, Ae), re.setFramebuffer(Oe);
              const ke = Ae[0] / 255,
                Ue = Ae[1] / 255,
                Ge = Ae[2] / 255,
                ht = Ae[3] / 255,
                me = ke / (256 * 256 * 256) + Ue / (256 * 256) + Ge / 256 + ht;
              return (
                W.destroy(),
                he.destroy(),
                ue.destroy(),
                ye.destroy(),
                I.destroy(),
                w.destroy(),
                me === 0
              );
            }
            class de extends e.G {
              constructor(I, w = {}) {
                super(I, w),
                  (this.gl = void 0),
                  (this.webgl2 = void 0),
                  (w = this.initOptions),
                  (this.defaultFramebuffer = null),
                  this.updateClientRect(),
                  (this.contextLost = !1),
                  (this._contextLostHandler = (z) => {
                    z.preventDefault(),
                      (this.contextLost = !0),
                      this.loseContext(),
                      this.fire("devicelost");
                  }),
                  (this._contextRestoredHandler = () => {
                    this.restoreContext(),
                      (this.contextLost = !1),
                      this.fire("devicerestored");
                  });
                const N =
                  typeof navigator != "undefined" && navigator.userAgent;
                (this.forceDisableMultisampling =
                  N &&
                  N.includes("AppleWebKit") &&
                  (N.includes("15.4") || N.includes("15_4"))),
                  this.forceDisableMultisampling && (w.antialias = !1);
                let W = null;
                if (w.gl) W = w.gl;
                else {
                  const K = (w.preferWebGl2 !== void 0 ? w.preferWebGl2 : !0)
                    ? ["webgl2", "webgl", "experimental-webgl"]
                    : ["webgl", "experimental-webgl"];
                  for (
                    let Te = 0;
                    Te < K.length && ((W = I.getContext(K[Te], w)), !W);
                    Te++
                  );
                }
                if (!W) throw new Error("WebGL not supported");
                (this.gl = W),
                  (this.webgl2 =
                    typeof WebGL2RenderingContext != "undefined" &&
                    W instanceof WebGL2RenderingContext),
                  (this._deviceType = this.webgl2 ? i.Nwc : i.ERE);
                const he = W.getParameter(W.ALPHA_BITS);
                this.framebufferFormat = he ? i.Lxj : i.akF;
                const ue = n.i.browserName === "chrome",
                  ye = n.i.browserName === "safari",
                  Oe =
                    n.i.browser && navigator.appVersion.indexOf("Mac") !== -1;
                (this._tempEnableSafariTextureUnitWorkaround = ye),
                  (this._tempMacChromeBlitFramebufferWorkaround =
                    Oe && ue && !w.alpha),
                  this.webgl2 || s(W),
                  I.addEventListener(
                    "webglcontextlost",
                    this._contextLostHandler,
                    !1
                  ),
                  I.addEventListener(
                    "webglcontextrestored",
                    this._contextRestoredHandler,
                    !1
                  ),
                  this.initializeExtensions(),
                  this.initializeCapabilities(),
                  this.initializeRenderState(),
                  this.initializeContextCaches(),
                  (this.supportsImageBitmap =
                    !ye && typeof ImageBitmap != "undefined"),
                  (this.glAddress = [
                    W.REPEAT,
                    W.CLAMP_TO_EDGE,
                    W.MIRRORED_REPEAT,
                  ]),
                  (this.glBlendEquation = [
                    W.FUNC_ADD,
                    W.FUNC_SUBTRACT,
                    W.FUNC_REVERSE_SUBTRACT,
                    this.webgl2
                      ? W.MIN
                      : this.extBlendMinmax
                      ? this.extBlendMinmax.MIN_EXT
                      : W.FUNC_ADD,
                    this.webgl2
                      ? W.MAX
                      : this.extBlendMinmax
                      ? this.extBlendMinmax.MAX_EXT
                      : W.FUNC_ADD,
                  ]),
                  (this.glBlendFunctionColor = [
                    W.ZERO,
                    W.ONE,
                    W.SRC_COLOR,
                    W.ONE_MINUS_SRC_COLOR,
                    W.DST_COLOR,
                    W.ONE_MINUS_DST_COLOR,
                    W.SRC_ALPHA,
                    W.SRC_ALPHA_SATURATE,
                    W.ONE_MINUS_SRC_ALPHA,
                    W.DST_ALPHA,
                    W.ONE_MINUS_DST_ALPHA,
                    W.CONSTANT_COLOR,
                    W.ONE_MINUS_CONSTANT_COLOR,
                  ]),
                  (this.glBlendFunctionAlpha = [
                    W.ZERO,
                    W.ONE,
                    W.SRC_COLOR,
                    W.ONE_MINUS_SRC_COLOR,
                    W.DST_COLOR,
                    W.ONE_MINUS_DST_COLOR,
                    W.SRC_ALPHA,
                    W.SRC_ALPHA_SATURATE,
                    W.ONE_MINUS_SRC_ALPHA,
                    W.DST_ALPHA,
                    W.ONE_MINUS_DST_ALPHA,
                    W.CONSTANT_ALPHA,
                    W.ONE_MINUS_CONSTANT_ALPHA,
                  ]),
                  (this.glComparison = [
                    W.NEVER,
                    W.LESS,
                    W.EQUAL,
                    W.LEQUAL,
                    W.GREATER,
                    W.NOTEQUAL,
                    W.GEQUAL,
                    W.ALWAYS,
                  ]),
                  (this.glStencilOp = [
                    W.KEEP,
                    W.ZERO,
                    W.REPLACE,
                    W.INCR,
                    W.INCR_WRAP,
                    W.DECR,
                    W.DECR_WRAP,
                    W.INVERT,
                  ]),
                  (this.glClearFlag = [
                    0,
                    W.COLOR_BUFFER_BIT,
                    W.DEPTH_BUFFER_BIT,
                    W.COLOR_BUFFER_BIT | W.DEPTH_BUFFER_BIT,
                    W.STENCIL_BUFFER_BIT,
                    W.STENCIL_BUFFER_BIT | W.COLOR_BUFFER_BIT,
                    W.STENCIL_BUFFER_BIT | W.DEPTH_BUFFER_BIT,
                    W.STENCIL_BUFFER_BIT |
                      W.COLOR_BUFFER_BIT |
                      W.DEPTH_BUFFER_BIT,
                  ]),
                  (this.glCull = [0, W.BACK, W.FRONT, W.FRONT_AND_BACK]),
                  (this.glFilter = [
                    W.NEAREST,
                    W.LINEAR,
                    W.NEAREST_MIPMAP_NEAREST,
                    W.NEAREST_MIPMAP_LINEAR,
                    W.LINEAR_MIPMAP_NEAREST,
                    W.LINEAR_MIPMAP_LINEAR,
                  ]),
                  (this.glPrimitive = [
                    W.POINTS,
                    W.LINES,
                    W.LINE_LOOP,
                    W.LINE_STRIP,
                    W.TRIANGLES,
                    W.TRIANGLE_STRIP,
                    W.TRIANGLE_FAN,
                  ]),
                  (this.glType = [
                    W.BYTE,
                    W.UNSIGNED_BYTE,
                    W.SHORT,
                    W.UNSIGNED_SHORT,
                    W.INT,
                    W.UNSIGNED_INT,
                    W.FLOAT,
                  ]),
                  (this.pcUniformType = {}),
                  (this.pcUniformType[W.BOOL] = i.MX7),
                  (this.pcUniformType[W.INT] = i.pG9),
                  (this.pcUniformType[W.FLOAT] = i.GF5),
                  (this.pcUniformType[W.FLOAT_VEC2] = i.Qhq),
                  (this.pcUniformType[W.FLOAT_VEC3] = i.XAr),
                  (this.pcUniformType[W.FLOAT_VEC4] = i.cyR),
                  (this.pcUniformType[W.INT_VEC2] = i.dD6),
                  (this.pcUniformType[W.INT_VEC3] = i.Yj5),
                  (this.pcUniformType[W.INT_VEC4] = i.RsJ),
                  (this.pcUniformType[W.BOOL_VEC2] = i.enT),
                  (this.pcUniformType[W.BOOL_VEC3] = i.ZKF),
                  (this.pcUniformType[W.BOOL_VEC4] = i.S8r),
                  (this.pcUniformType[W.FLOAT_MAT2] = i.Eb5),
                  (this.pcUniformType[W.FLOAT_MAT3] = i.xzR),
                  (this.pcUniformType[W.FLOAT_MAT4] = i.CPw),
                  (this.pcUniformType[W.SAMPLER_2D] = i.rlY),
                  (this.pcUniformType[W.SAMPLER_CUBE] = i.KpZ),
                  this.webgl2 &&
                    ((this.pcUniformType[W.SAMPLER_2D_SHADOW] = i.yLH),
                    (this.pcUniformType[W.SAMPLER_CUBE_SHADOW] = i.zYo),
                    (this.pcUniformType[W.SAMPLER_3D] = i.q8s)),
                  (this.targetToSlot = {}),
                  (this.targetToSlot[W.TEXTURE_2D] = 0),
                  (this.targetToSlot[W.TEXTURE_CUBE_MAP] = 1),
                  (this.targetToSlot[W.TEXTURE_3D] = 2);
                let Ae, ke, Ue, Ge, ht;
                (this.commitFunction = []),
                  (this.commitFunction[i.MX7] = function (z, K) {
                    z.value !== K &&
                      (W.uniform1i(z.locationId, K), (z.value = K));
                  }),
                  (this.commitFunction[i.pG9] = this.commitFunction[i.MX7]),
                  (this.commitFunction[i.GF5] = function (z, K) {
                    z.value !== K &&
                      (W.uniform1f(z.locationId, K), (z.value = K));
                  }),
                  (this.commitFunction[i.Qhq] = function (z, K) {
                    (ht = z.value),
                      (Ae = K[0]),
                      (ke = K[1]),
                      (ht[0] !== Ae || ht[1] !== ke) &&
                        (W.uniform2fv(z.locationId, K),
                        (ht[0] = Ae),
                        (ht[1] = ke));
                  }),
                  (this.commitFunction[i.XAr] = function (z, K) {
                    (ht = z.value),
                      (Ae = K[0]),
                      (ke = K[1]),
                      (Ue = K[2]),
                      (ht[0] !== Ae || ht[1] !== ke || ht[2] !== Ue) &&
                        (W.uniform3fv(z.locationId, K),
                        (ht[0] = Ae),
                        (ht[1] = ke),
                        (ht[2] = Ue));
                  }),
                  (this.commitFunction[i.cyR] = function (z, K) {
                    (ht = z.value),
                      (Ae = K[0]),
                      (ke = K[1]),
                      (Ue = K[2]),
                      (Ge = K[3]),
                      (ht[0] !== Ae ||
                        ht[1] !== ke ||
                        ht[2] !== Ue ||
                        ht[3] !== Ge) &&
                        (W.uniform4fv(z.locationId, K),
                        (ht[0] = Ae),
                        (ht[1] = ke),
                        (ht[2] = Ue),
                        (ht[3] = Ge));
                  }),
                  (this.commitFunction[i.dD6] = function (z, K) {
                    (ht = z.value),
                      (Ae = K[0]),
                      (ke = K[1]),
                      (ht[0] !== Ae || ht[1] !== ke) &&
                        (W.uniform2iv(z.locationId, K),
                        (ht[0] = Ae),
                        (ht[1] = ke));
                  }),
                  (this.commitFunction[i.enT] = this.commitFunction[i.dD6]),
                  (this.commitFunction[i.Yj5] = function (z, K) {
                    (ht = z.value),
                      (Ae = K[0]),
                      (ke = K[1]),
                      (Ue = K[2]),
                      (ht[0] !== Ae || ht[1] !== ke || ht[2] !== Ue) &&
                        (W.uniform3iv(z.locationId, K),
                        (ht[0] = Ae),
                        (ht[1] = ke),
                        (ht[2] = Ue));
                  }),
                  (this.commitFunction[i.ZKF] = this.commitFunction[i.Yj5]),
                  (this.commitFunction[i.RsJ] = function (z, K) {
                    (ht = z.value),
                      (Ae = K[0]),
                      (ke = K[1]),
                      (Ue = K[2]),
                      (Ge = K[3]),
                      (ht[0] !== Ae ||
                        ht[1] !== ke ||
                        ht[2] !== Ue ||
                        ht[3] !== Ge) &&
                        (W.uniform4iv(z.locationId, K),
                        (ht[0] = Ae),
                        (ht[1] = ke),
                        (ht[2] = Ue),
                        (ht[3] = Ge));
                  }),
                  (this.commitFunction[i.S8r] = this.commitFunction[i.RsJ]),
                  (this.commitFunction[i.Eb5] = function (z, K) {
                    W.uniformMatrix2fv(z.locationId, !1, K);
                  }),
                  (this.commitFunction[i.xzR] = function (z, K) {
                    W.uniformMatrix3fv(z.locationId, !1, K);
                  }),
                  (this.commitFunction[i.CPw] = function (z, K) {
                    W.uniformMatrix4fv(z.locationId, !1, K);
                  }),
                  (this.commitFunction[i.Nv2] = function (z, K) {
                    W.uniform1fv(z.locationId, K);
                  }),
                  (this.commitFunction[i.FEO] = function (z, K) {
                    W.uniform2fv(z.locationId, K);
                  }),
                  (this.commitFunction[i.iYc] = function (z, K) {
                    W.uniform3fv(z.locationId, K);
                  }),
                  (this.commitFunction[i.$Cd] = function (z, K) {
                    W.uniform4fv(z.locationId, K);
                  }),
                  (this.supportsBoneTextures =
                    this.extTextureFloat && this.maxVertexTextures > 0);
                let me = this.vertexUniformsCount;
                (me -= 16),
                  (me -= 8),
                  (me -= 1),
                  (me -= 16),
                  (this.boneLimit = Math.floor(me / 3)),
                  (this.boneLimit = Math.min(this.boneLimit, 128)),
                  this.unmaskedRenderer === "Mali-450 MP" &&
                    (this.boneLimit = 34),
                  (this.constantTexSource = this.scope.resolve("source")),
                  this.extTextureFloat
                    ? this.webgl2
                      ? (this.textureFloatRenderable =
                          !!this.extColorBufferFloat)
                      : (this.textureFloatRenderable = O(W, W.FLOAT))
                    : (this.textureFloatRenderable = !1),
                  this.extColorBufferHalfFloat
                    ? (this.textureHalfFloatRenderable =
                        !!this.extColorBufferHalfFloat)
                    : this.extTextureHalfFloat
                    ? this.webgl2
                      ? (this.textureHalfFloatRenderable =
                          !!this.extColorBufferFloat)
                      : (this.textureHalfFloatRenderable = O(
                          W,
                          this.extTextureHalfFloat.HALF_FLOAT_OES
                        ))
                    : (this.textureHalfFloatRenderable = !1),
                  (this.supportsMorphTargetTexturesCore =
                    this.maxPrecision === "highp" &&
                    this.maxVertexTextures >= 2),
                  (this.supportsDepthShadow = this.webgl2),
                  (this._textureFloatHighPrecision = void 0),
                  (this._textureHalfFloatUpdatable = void 0),
                  (this.areaLightLutFormat = i.Lxj),
                  this.extTextureHalfFloat &&
                  this.textureHalfFloatUpdatable &&
                  this.extTextureHalfFloatLinear
                    ? (this.areaLightLutFormat = i.WBN)
                    : this.extTextureFloat &&
                      this.extTextureFloatLinear &&
                      (this.areaLightLutFormat = i.s7h),
                  this.postInit();
              }
              postInit() {
                super.postInit(), (this.gpuProfiler = new L(this));
              }
              destroy() {
                super.destroy();
                const I = this.gl;
                this.webgl2 &&
                  this.feedback &&
                  I.deleteTransformFeedback(this.feedback),
                  this.clearVertexArrayObjectCache(),
                  this.canvas.removeEventListener(
                    "webglcontextlost",
                    this._contextLostHandler,
                    !1
                  ),
                  this.canvas.removeEventListener(
                    "webglcontextrestored",
                    this._contextRestoredHandler,
                    !1
                  ),
                  (this._contextLostHandler = null),
                  (this._contextRestoredHandler = null),
                  (this.gl = null),
                  super.postDestroy();
              }
              createVertexBufferImpl(I, w) {
                return new v();
              }
              createIndexBufferImpl(I) {
                return new _(I);
              }
              createShaderImpl(I) {
                return new b(I);
              }
              createTextureImpl(I) {
                return new G();
              }
              createRenderTargetImpl(I) {
                return new ie();
              }
              getPrecision() {
                const I = this.gl;
                let w = "highp";
                if (I.getShaderPrecisionFormat) {
                  const N = I.getShaderPrecisionFormat(
                      I.VERTEX_SHADER,
                      I.HIGH_FLOAT
                    ),
                    W = I.getShaderPrecisionFormat(
                      I.VERTEX_SHADER,
                      I.MEDIUM_FLOAT
                    ),
                    he = I.getShaderPrecisionFormat(
                      I.FRAGMENT_SHADER,
                      I.HIGH_FLOAT
                    ),
                    ue = I.getShaderPrecisionFormat(
                      I.FRAGMENT_SHADER,
                      I.MEDIUM_FLOAT
                    );
                  if (N && W && he && ue) {
                    const ye = N.precision > 0 && he.precision > 0,
                      Oe = W.precision > 0 && ue.precision > 0;
                    ye || (Oe ? (w = "mediump") : (w = "lowp"));
                  }
                }
                return w;
              }
              getExtension() {
                for (let I = 0; I < arguments.length; I++)
                  if (this.supportedExtensions.indexOf(arguments[I]) !== -1)
                    return this.gl.getExtension(arguments[I]);
                return null;
              }
              get extDisjointTimerQuery() {
                return (
                  this._extDisjointTimerQuery ||
                    (this.webgl2 &&
                      (this._extDisjointTimerQuery = this.getExtension(
                        "EXT_disjoint_timer_query_webgl2",
                        "EXT_disjoint_timer_query"
                      ))),
                  this._extDisjointTimerQuery
                );
              }
              initializeExtensions() {
                var I;
                const w = this.gl;
                if (
                  ((this.supportedExtensions =
                    (I = w.getSupportedExtensions()) != null ? I : []),
                  (this._extDisjointTimerQuery = null),
                  this.webgl2)
                )
                  (this.extBlendMinmax = !0),
                    (this.extDrawBuffers = !0),
                    (this.drawBuffers = w.drawBuffers.bind(w)),
                    (this.extInstancing = !0),
                    (this.extStandardDerivatives = !0),
                    (this.extTextureFloat = !0),
                    (this.extTextureHalfFloat = !0),
                    (this.extTextureLod = !0),
                    (this.extUintElement = !0),
                    (this.extVertexArrayObject = !0),
                    (this.extColorBufferFloat = this.getExtension(
                      "EXT_color_buffer_float"
                    )),
                    (this.extDepthTexture = !0);
                else {
                  var N;
                  if (
                    ((this.extBlendMinmax =
                      this.getExtension("EXT_blend_minmax")),
                    (this.extDrawBuffers =
                      this.getExtension("WEBGL_draw_buffers")),
                    (this.extInstancing = this.getExtension(
                      "ANGLE_instanced_arrays"
                    )),
                    (this.drawBuffers =
                      (N = this.extDrawBuffers) == null
                        ? void 0
                        : N.drawBuffersWEBGL.bind(this.extDrawBuffers)),
                    this.extInstancing)
                  ) {
                    const W = this.extInstancing;
                    (w.drawArraysInstanced =
                      W.drawArraysInstancedANGLE.bind(W)),
                      (w.drawElementsInstanced =
                        W.drawElementsInstancedANGLE.bind(W)),
                      (w.vertexAttribDivisor =
                        W.vertexAttribDivisorANGLE.bind(W));
                  }
                  if (
                    ((this.extStandardDerivatives = this.getExtension(
                      "OES_standard_derivatives"
                    )),
                    (this.extTextureFloat =
                      this.getExtension("OES_texture_float")),
                    (this.extTextureHalfFloat = this.getExtension(
                      "OES_texture_half_float"
                    )),
                    (this.extTextureLod = this.getExtension(
                      "EXT_shader_texture_lod"
                    )),
                    (this.extUintElement = this.getExtension(
                      "OES_element_index_uint"
                    )),
                    (this.extVertexArrayObject = this.getExtension(
                      "OES_vertex_array_object"
                    )),
                    this.extVertexArrayObject)
                  ) {
                    const W = this.extVertexArrayObject;
                    (w.createVertexArray = W.createVertexArrayOES.bind(W)),
                      (w.deleteVertexArray = W.deleteVertexArrayOES.bind(W)),
                      (w.isVertexArray = W.isVertexArrayOES.bind(W)),
                      (w.bindVertexArray = W.bindVertexArrayOES.bind(W));
                  }
                  (this.extColorBufferFloat = null),
                    (this.extDepthTexture = w.getExtension(
                      "WEBGL_depth_texture"
                    ));
                }
                (this.extDebugRendererInfo = this.getExtension(
                  "WEBGL_debug_renderer_info"
                )),
                  (this.extTextureFloatLinear = this.getExtension(
                    "OES_texture_float_linear"
                  )),
                  (this.extTextureHalfFloatLinear = this.getExtension(
                    "OES_texture_half_float_linear"
                  )),
                  (this.extFloatBlend = this.getExtension("EXT_float_blend")),
                  (this.extTextureFilterAnisotropic = this.getExtension(
                    "EXT_texture_filter_anisotropic",
                    "WEBKIT_EXT_texture_filter_anisotropic"
                  )),
                  (this.extCompressedTextureETC1 = this.getExtension(
                    "WEBGL_compressed_texture_etc1"
                  )),
                  (this.extCompressedTextureETC = this.getExtension(
                    "WEBGL_compressed_texture_etc"
                  )),
                  (this.extCompressedTexturePVRTC = this.getExtension(
                    "WEBGL_compressed_texture_pvrtc",
                    "WEBKIT_WEBGL_compressed_texture_pvrtc"
                  )),
                  (this.extCompressedTextureS3TC = this.getExtension(
                    "WEBGL_compressed_texture_s3tc",
                    "WEBKIT_WEBGL_compressed_texture_s3tc"
                  )),
                  (this.extCompressedTextureATC = this.getExtension(
                    "WEBGL_compressed_texture_atc"
                  )),
                  (this.extCompressedTextureASTC = this.getExtension(
                    "WEBGL_compressed_texture_astc"
                  )),
                  (this.extParallelShaderCompile = this.getExtension(
                    "KHR_parallel_shader_compile"
                  )),
                  (this.extColorBufferHalfFloat = this.getExtension(
                    "EXT_color_buffer_half_float"
                  ));
              }
              initializeCapabilities() {
                const I = this.gl;
                let w;
                const N =
                  typeof navigator != "undefined" ? navigator.userAgent : "";
                this.maxPrecision = this.precision = this.getPrecision();
                const W = I.getContextAttributes();
                (this.supportsMsaa = W.antialias),
                  (this.supportsStencil = W.stencil),
                  (this.supportsInstancing = !!this.extInstancing),
                  (this.maxTextureSize = I.getParameter(I.MAX_TEXTURE_SIZE)),
                  (this.maxCubeMapSize = I.getParameter(
                    I.MAX_CUBE_MAP_TEXTURE_SIZE
                  )),
                  (this.maxRenderBufferSize = I.getParameter(
                    I.MAX_RENDERBUFFER_SIZE
                  )),
                  (this.maxTextures = I.getParameter(
                    I.MAX_TEXTURE_IMAGE_UNITS
                  )),
                  (this.maxCombinedTextures = I.getParameter(
                    I.MAX_COMBINED_TEXTURE_IMAGE_UNITS
                  )),
                  (this.maxVertexTextures = I.getParameter(
                    I.MAX_VERTEX_TEXTURE_IMAGE_UNITS
                  )),
                  (this.vertexUniformsCount = I.getParameter(
                    I.MAX_VERTEX_UNIFORM_VECTORS
                  )),
                  (this.fragmentUniformsCount = I.getParameter(
                    I.MAX_FRAGMENT_UNIFORM_VECTORS
                  )),
                  this.webgl2
                    ? ((this.maxDrawBuffers = I.getParameter(
                        I.MAX_DRAW_BUFFERS
                      )),
                      (this.maxColorAttachments = I.getParameter(
                        I.MAX_COLOR_ATTACHMENTS
                      )),
                      (this.maxVolumeSize = I.getParameter(
                        I.MAX_3D_TEXTURE_SIZE
                      )),
                      (this.supportsMrt = !0),
                      (this.supportsVolumeTextures = !0))
                    : ((w = this.extDrawBuffers),
                      (this.supportsMrt = !!w),
                      (this.maxDrawBuffers = w
                        ? I.getParameter(w.MAX_DRAW_BUFFERS_WEBGL)
                        : 1),
                      (this.maxColorAttachments = w
                        ? I.getParameter(w.MAX_COLOR_ATTACHMENTS_WEBGL)
                        : 1),
                      (this.maxVolumeSize = 1)),
                  (w = this.extDebugRendererInfo),
                  (this.unmaskedRenderer = w
                    ? I.getParameter(w.UNMASKED_RENDERER_WEBGL)
                    : ""),
                  (this.unmaskedVendor = w
                    ? I.getParameter(w.UNMASKED_VENDOR_WEBGL)
                    : "");
                const he = /\bMali-G52+/,
                  ue = /SM-[a-zA-Z0-9]+/;
                (this.supportsGpuParticles =
                  !(this.unmaskedVendor === "ARM" && N.match(ue)) &&
                  !this.unmaskedRenderer.match(he)),
                  (w = this.extTextureFilterAnisotropic),
                  (this.maxAnisotropy = w
                    ? I.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    : 1),
                  (this.samples = I.getParameter(I.SAMPLES)),
                  (this.maxSamples =
                    this.webgl2 && !this.forceDisableMultisampling
                      ? I.getParameter(I.MAX_SAMPLES)
                      : 1),
                  (this.supportsAreaLights = this.webgl2 || !n.i.android),
                  (this.supportsTextureFetch = this.webgl2),
                  this.maxTextures <= 8 && (this.supportsAreaLights = !1);
              }
              initializeRenderState() {
                super.initializeRenderState();
                const I = this.gl;
                I.disable(I.BLEND),
                  I.blendFunc(I.ONE, I.ZERO),
                  I.blendEquation(I.FUNC_ADD),
                  I.colorMask(!0, !0, !0, !0),
                  (this.blendColor = new o.Q(0, 0, 0, 0)),
                  I.blendColor(0, 0, 0, 0),
                  I.enable(I.CULL_FACE),
                  I.cullFace(I.BACK),
                  I.enable(I.DEPTH_TEST),
                  I.depthFunc(I.LEQUAL),
                  I.depthMask(!0),
                  (this.stencil = !1),
                  I.disable(I.STENCIL_TEST),
                  (this.stencilFuncFront = this.stencilFuncBack = i.vpx),
                  (this.stencilRefFront = this.stencilRefBack = 0),
                  (this.stencilMaskFront = this.stencilMaskBack = 255),
                  I.stencilFunc(I.ALWAYS, 0, 255),
                  (this.stencilFailFront = this.stencilFailBack = i.GU6),
                  (this.stencilZfailFront = this.stencilZfailBack = i.GU6),
                  (this.stencilZpassFront = this.stencilZpassBack = i.GU6),
                  (this.stencilWriteMaskFront = 255),
                  (this.stencilWriteMaskBack = 255),
                  I.stencilOp(I.KEEP, I.KEEP, I.KEEP),
                  I.stencilMask(255),
                  (this.alphaToCoverage = !1),
                  (this.raster = !0),
                  this.webgl2 &&
                    (I.disable(I.SAMPLE_ALPHA_TO_COVERAGE),
                    I.disable(I.RASTERIZER_DISCARD)),
                  (this.depthBiasEnabled = !1),
                  I.disable(I.POLYGON_OFFSET_FILL),
                  (this.clearDepth = 1),
                  I.clearDepth(1),
                  (this.clearColor = new o.Q(0, 0, 0, 0)),
                  I.clearColor(0, 0, 0, 0),
                  (this.clearStencil = 0),
                  I.clearStencil(0),
                  this.webgl2
                    ? I.hint(I.FRAGMENT_SHADER_DERIVATIVE_HINT, I.NICEST)
                    : this.extStandardDerivatives &&
                      I.hint(
                        this.extStandardDerivatives
                          .FRAGMENT_SHADER_DERIVATIVE_HINT_OES,
                        I.NICEST
                      ),
                  I.enable(I.SCISSOR_TEST),
                  I.pixelStorei(I.UNPACK_COLORSPACE_CONVERSION_WEBGL, I.NONE),
                  (this.unpackFlipY = !1),
                  I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, !1),
                  (this.unpackPremultiplyAlpha = !1),
                  I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                  I.pixelStorei(I.UNPACK_ALIGNMENT, 1);
              }
              initializeContextCaches() {
                super.initializeContextCaches(),
                  (this._vaoMap = new Map()),
                  (this.boundVao = null),
                  (this.activeFramebuffer = null),
                  (this.feedback = null),
                  (this.transformFeedbackBuffer = null),
                  (this.textureUnit = 0),
                  (this.textureUnits = []);
                for (let I = 0; I < this.maxCombinedTextures; I++)
                  this.textureUnits.push([null, null, null]);
              }
              loseContext() {
                var I;
                for (const w of this.shaders) w.loseContext();
                for (const w of this.textures) w.loseContext();
                for (const w of this.buffers) w.loseContext();
                for (const w of this.targets) w.loseContext();
                (I = this.gpuProfiler) == null || I.loseContext();
              }
              restoreContext() {
                var I;
                this.initializeExtensions(),
                  this.initializeCapabilities(),
                  this.initializeRenderState(),
                  this.initializeContextCaches();
                for (const w of this.shaders) w.restoreContext();
                for (const w of this.buffers) w.unlock();
                (I = this.gpuProfiler) == null || I.restoreContext();
              }
              endShaderBatch() {
                b.endShaderBatch(this);
              }
              setViewport(I, w, N, W) {
                (this.vx !== I ||
                  this.vy !== w ||
                  this.vw !== N ||
                  this.vh !== W) &&
                  (this.gl.viewport(I, w, N, W),
                  (this.vx = I),
                  (this.vy = w),
                  (this.vw = N),
                  (this.vh = W));
              }
              setScissor(I, w, N, W) {
                (this.sx !== I ||
                  this.sy !== w ||
                  this.sw !== N ||
                  this.sh !== W) &&
                  (this.gl.scissor(I, w, N, W),
                  (this.sx = I),
                  (this.sy = w),
                  (this.sw = N),
                  (this.sh = W));
              }
              setFramebuffer(I) {
                if (this.activeFramebuffer !== I) {
                  const w = this.gl;
                  w.bindFramebuffer(w.FRAMEBUFFER, I),
                    (this.activeFramebuffer = I);
                }
              }
              copyRenderTarget(I, w, N, W) {
                const he = this.gl;
                if (!this.webgl2 && W) return !1;
                if (N) {
                  if (w) {
                    if (
                      I &&
                      (!I._colorBuffer ||
                        !w._colorBuffer ||
                        I._colorBuffer._format !== w._colorBuffer._format)
                    )
                      return !1;
                  } else if (!I._colorBuffer) return !1;
                }
                if (
                  W &&
                  I &&
                  !I._depth &&
                  (!I._depthBuffer ||
                    !w._depthBuffer ||
                    I._depthBuffer._format !== w._depthBuffer._format)
                )
                  return !1;
                if (this.webgl2 && w) {
                  const ue = this.renderTarget;
                  (this.renderTarget = w),
                    this.updateBegin(),
                    he.bindFramebuffer(
                      he.READ_FRAMEBUFFER,
                      I ? I.impl._glFrameBuffer : null
                    ),
                    he.bindFramebuffer(
                      he.DRAW_FRAMEBUFFER,
                      w.impl._glFrameBuffer
                    );
                  const ye = I ? I.width : w.width,
                    Oe = I ? I.height : w.height;
                  he.blitFramebuffer(
                    0,
                    0,
                    ye,
                    Oe,
                    0,
                    0,
                    ye,
                    Oe,
                    (N ? he.COLOR_BUFFER_BIT : 0) |
                      (W ? he.DEPTH_BUFFER_BIT : 0),
                    he.NEAREST
                  ),
                    (this.renderTarget = ue),
                    he.bindFramebuffer(
                      he.FRAMEBUFFER,
                      ue ? ue.impl._glFrameBuffer : null
                    );
                } else {
                  const ue = this.getCopyShader();
                  this.constantTexSource.setValue(I._colorBuffer),
                    le(this, w, ue);
                }
                return !0;
              }
              getCopyShader() {
                return (
                  this._copyShader ||
                    (this._copyShader = new te.M(
                      this,
                      Q.l.createDefinition(this, {
                        name: "outputTex2D",
                        vertexCode: k,
                        fragmentCode: $,
                      })
                    )),
                  this._copyShader
                );
              }
              frameStart() {
                super.frameStart(), this.gpuProfiler.frameStart();
              }
              frameEnd() {
                super.frameEnd(),
                  this.gpuProfiler.frameEnd(),
                  this.gpuProfiler.request();
              }
              startPass(I) {
                this.setRenderTarget(I.renderTarget), this.updateBegin();
                const w = I.colorOps,
                  N = I.depthStencilOps;
                if ((w != null && w.clear) || N.clearDepth || N.clearStencil) {
                  const W = I.renderTarget,
                    he = W ? W.width : this.width,
                    ue = W ? W.height : this.height;
                  this.setViewport(0, 0, he, ue), this.setScissor(0, 0, he, ue);
                  let ye = 0;
                  const Oe = {};
                  w != null &&
                    w.clear &&
                    ((ye |= i.Sue),
                    (Oe.color = [
                      w.clearValue.r,
                      w.clearValue.g,
                      w.clearValue.b,
                      w.clearValue.a,
                    ])),
                    N.clearDepth &&
                      ((ye |= i.YKI), (Oe.depth = N.clearDepthValue)),
                    N.clearStencil &&
                      ((ye |= i.zwO), (Oe.stencil = N.clearStencilValue)),
                    (Oe.flags = ye),
                    this.clear(Oe);
                }
                this.insideRenderPass = !0;
              }
              endPass(I) {
                this.unbindVertexArray();
                const w = this.renderTarget,
                  N = I.colorArrayOps.length;
                if (w) {
                  var W;
                  if (this.webgl2) {
                    ge.length = 0;
                    const he = this.gl;
                    for (let ue = 0; ue < N; ue++) {
                      const ye = I.colorArrayOps[ue];
                      ye.store ||
                        ye.resolve ||
                        ge.push(he.COLOR_ATTACHMENT0 + ue);
                    }
                    I.depthStencilOps.storeDepth ||
                      ge.push(he.DEPTH_ATTACHMENT),
                      I.depthStencilOps.storeStencil ||
                        ge.push(he.STENCIL_ATTACHMENT),
                      ge.length > 0 &&
                        I.fullSizeClearRect &&
                        he.invalidateFramebuffer(he.DRAW_FRAMEBUFFER, ge);
                  }
                  (W = I.colorOps) != null &&
                    W.resolve &&
                    this.webgl2 &&
                    I.samples > 1 &&
                    w.autoResolve &&
                    w.resolve(!0, !1);
                  for (let he = 0; he < N; he++)
                    if (I.colorArrayOps[he].mipmaps) {
                      const ye = w._colorBuffers[he];
                      ye &&
                        ye.impl._glTexture &&
                        ye.mipmaps &&
                        (ye.pot || this.webgl2) &&
                        (this.activeTexture(this.maxCombinedTextures - 1),
                        this.bindTexture(ye),
                        this.gl.generateMipmap(ye.impl._glTarget));
                    }
                }
                this.insideRenderPass = !1;
              }
              updateBegin() {
                if (
                  ((this.boundVao = null),
                  this._tempEnableSafariTextureUnitWorkaround)
                )
                  for (let w = 0; w < this.textureUnits.length; ++w)
                    for (let N = 0; N < 3; ++N) this.textureUnits[w][N] = null;
                const I = this.renderTarget;
                I
                  ? I.impl.initialized
                    ? this.setFramebuffer(I.impl._glFrameBuffer)
                    : this.initRenderTarget(I)
                  : this.setFramebuffer(this.defaultFramebuffer);
              }
              updateEnd() {
                this.unbindVertexArray();
                const I = this.renderTarget;
                if (I) {
                  this.webgl2 && I._samples > 1 && I.autoResolve && I.resolve();
                  const w = I._colorBuffer;
                  w &&
                    w.impl._glTexture &&
                    w.mipmaps &&
                    (w.pot || this.webgl2) &&
                    (this.activeTexture(this.maxCombinedTextures - 1),
                    this.bindTexture(w),
                    this.gl.generateMipmap(w.impl._glTarget));
                }
              }
              setUnpackFlipY(I) {
                if (this.unpackFlipY !== I) {
                  this.unpackFlipY = I;
                  const w = this.gl;
                  w.pixelStorei(w.UNPACK_FLIP_Y_WEBGL, I);
                }
              }
              setUnpackPremultiplyAlpha(I) {
                if (this.unpackPremultiplyAlpha !== I) {
                  this.unpackPremultiplyAlpha = I;
                  const w = this.gl;
                  w.pixelStorei(w.UNPACK_PREMULTIPLY_ALPHA_WEBGL, I);
                }
              }
              activeTexture(I) {
                this.textureUnit !== I &&
                  (this.gl.activeTexture(this.gl.TEXTURE0 + I),
                  (this.textureUnit = I));
              }
              bindTexture(I) {
                const w = I.impl,
                  N = w._glTarget,
                  W = w._glTexture,
                  he = this.textureUnit,
                  ue = this.targetToSlot[N];
                this.textureUnits[he][ue] !== W &&
                  (this.gl.bindTexture(N, W), (this.textureUnits[he][ue] = W));
              }
              bindTextureOnUnit(I, w) {
                const N = I.impl,
                  W = N._glTarget,
                  he = N._glTexture,
                  ue = this.targetToSlot[W];
                this.textureUnits[w][ue] !== he &&
                  (this.activeTexture(w),
                  this.gl.bindTexture(W, he),
                  (this.textureUnits[w][ue] = he));
              }
              setTextureParameters(I) {
                const w = this.gl,
                  N = I.impl.dirtyParameterFlags,
                  W = I.impl._glTarget;
                if (N & 1) {
                  let he = I._minFilter;
                  ((!I.pot && !this.webgl2) ||
                    !I._mipmaps ||
                    (I._compressed && I._levels.length === 1)) &&
                    (he === i.GLw || he === i.hs2
                      ? (he = i.uhC)
                      : (he === i.reG || he === i.qn_) && (he = i.DrA)),
                    w.texParameteri(W, w.TEXTURE_MIN_FILTER, this.glFilter[he]);
                }
                if (
                  (N & 2 &&
                    w.texParameteri(
                      W,
                      w.TEXTURE_MAG_FILTER,
                      this.glFilter[I._magFilter]
                    ),
                  N & 4 &&
                    (this.webgl2
                      ? w.texParameteri(
                          W,
                          w.TEXTURE_WRAP_S,
                          this.glAddress[I._addressU]
                        )
                      : w.texParameteri(
                          W,
                          w.TEXTURE_WRAP_S,
                          this.glAddress[I.pot ? I._addressU : i.vq6]
                        )),
                  N & 8 &&
                    (this.webgl2
                      ? w.texParameteri(
                          W,
                          w.TEXTURE_WRAP_T,
                          this.glAddress[I._addressV]
                        )
                      : w.texParameteri(
                          W,
                          w.TEXTURE_WRAP_T,
                          this.glAddress[I.pot ? I._addressV : i.vq6]
                        )),
                  N & 16 &&
                    this.webgl2 &&
                    w.texParameteri(
                      W,
                      w.TEXTURE_WRAP_R,
                      this.glAddress[I._addressW]
                    ),
                  N & 32 &&
                    this.webgl2 &&
                    w.texParameteri(
                      W,
                      w.TEXTURE_COMPARE_MODE,
                      I._compareOnRead ? w.COMPARE_REF_TO_TEXTURE : w.NONE
                    ),
                  N & 64 &&
                    this.webgl2 &&
                    w.texParameteri(
                      W,
                      w.TEXTURE_COMPARE_FUNC,
                      this.glComparison[I._compareFunc]
                    ),
                  N & 128)
                ) {
                  const he = this.extTextureFilterAnisotropic;
                  he &&
                    w.texParameterf(
                      W,
                      he.TEXTURE_MAX_ANISOTROPY_EXT,
                      l.D.clamp(
                        Math.round(I._anisotropy),
                        1,
                        this.maxAnisotropy
                      )
                    );
                }
              }
              setTexture(I, w) {
                const N = I.impl;
                N._glTexture || N.initialize(this, I),
                  N.dirtyParameterFlags > 0 ||
                  I._needsUpload ||
                  I._needsMipmapsUpload
                    ? (this.activeTexture(w),
                      this.bindTexture(I),
                      N.dirtyParameterFlags &&
                        (this.setTextureParameters(I),
                        (N.dirtyParameterFlags = 0)),
                      (I._needsUpload || I._needsMipmapsUpload) &&
                        (N.upload(this, I),
                        (I._needsUpload = !1),
                        (I._needsMipmapsUpload = !1)))
                    : this.bindTextureOnUnit(I, w);
              }
              createVertexArray(I) {
                let w, N;
                const W = I.length > 1;
                if (W) {
                  w = "";
                  for (let he = 0; he < I.length; he++) {
                    const ue = I[he];
                    w += ue.id + ue.format.renderingHash;
                  }
                  N = this._vaoMap.get(w);
                }
                if (!N) {
                  const he = this.gl;
                  (N = he.createVertexArray()),
                    he.bindVertexArray(N),
                    he.bindBuffer(he.ELEMENT_ARRAY_BUFFER, null);
                  for (let ue = 0; ue < I.length; ue++) {
                    const ye = I[ue];
                    he.bindBuffer(he.ARRAY_BUFFER, ye.impl.bufferId);
                    const Oe = ye.format.elements;
                    for (let Ae = 0; Ae < Oe.length; Ae++) {
                      const ke = Oe[Ae],
                        Ue = i.tJj[ke.name];
                      he.vertexAttribPointer(
                        Ue,
                        ke.numComponents,
                        this.glType[ke.dataType],
                        ke.normalize,
                        ke.stride,
                        ke.offset
                      ),
                        he.enableVertexAttribArray(Ue),
                        ye.format.instancing && he.vertexAttribDivisor(Ue, 1);
                    }
                  }
                  he.bindVertexArray(null),
                    he.bindBuffer(he.ARRAY_BUFFER, null),
                    W && this._vaoMap.set(w, N);
                }
                return N;
              }
              unbindVertexArray() {
                this.boundVao &&
                  ((this.boundVao = null), this.gl.bindVertexArray(null));
              }
              setBuffers() {
                const I = this.gl;
                let w;
                if (this.vertexBuffers.length === 1) {
                  const W = this.vertexBuffers[0];
                  W.impl.vao ||
                    (W.impl.vao = this.createVertexArray(this.vertexBuffers)),
                    (w = W.impl.vao);
                } else w = this.createVertexArray(this.vertexBuffers);
                this.boundVao !== w &&
                  ((this.boundVao = w), I.bindVertexArray(w)),
                  (this.vertexBuffers.length = 0);
                const N = this.indexBuffer
                  ? this.indexBuffer.impl.bufferId
                  : null;
                I.bindBuffer(I.ELEMENT_ARRAY_BUFFER, N);
              }
              draw(I, w, N) {
                const W = this.gl;
                let he, ue, ye, Oe, Ae, ke, Ue, Ge;
                const ht = this.shader;
                if (!ht) return;
                const me = ht.impl.samplers,
                  z = ht.impl.uniforms;
                N || this.setBuffers();
                let K = 0;
                for (let q = 0, se = me.length; q < se; q++) {
                  if (((he = me[q]), (ue = he.scopeId.value), !ue)) return;
                  if (ue instanceof r.g)
                    (ye = ue),
                      this.setTexture(ye, K),
                      he.slot !== K &&
                        (W.uniform1i(he.locationId, K), (he.slot = K)),
                      K++;
                  else {
                    (he.array.length = 0), (Oe = ue.length);
                    for (let Ce = 0; Ce < Oe; Ce++)
                      (ye = ue[Ce]),
                        this.setTexture(ye, K),
                        (he.array[Ce] = K),
                        K++;
                    W.uniform1iv(he.locationId, he.array);
                  }
                }
                for (let q = 0, se = z.length; q < se; q++)
                  (Ae = z[q]),
                    (ke = Ae.scopeId),
                    (Ue = Ae.version),
                    (Ge = ke.versionObject.version),
                    (Ue.globalId !== Ge.globalId ||
                      Ue.revision !== Ge.revision) &&
                      ((Ue.globalId = Ge.globalId),
                      (Ue.revision = Ge.revision),
                      ke.value !== null &&
                        this.commitFunction[Ae.dataType](Ae, ke.value));
                this.webgl2 &&
                  this.transformFeedbackBuffer &&
                  (W.bindBufferBase(
                    W.TRANSFORM_FEEDBACK_BUFFER,
                    0,
                    this.transformFeedbackBuffer.impl.bufferId
                  ),
                  W.beginTransformFeedback(W.POINTS));
                const Te = this.glPrimitive[I.type],
                  H = I.count;
                if (I.indexed) {
                  const q = this.indexBuffer,
                    se = q.impl.glFormat,
                    Ce = I.base * q.bytesPerIndex;
                  w > 0
                    ? W.drawElementsInstanced(Te, H, se, Ce, w)
                    : W.drawElements(Te, H, se, Ce);
                } else {
                  const q = I.base;
                  w > 0
                    ? W.drawArraysInstanced(Te, q, H, w)
                    : W.drawArrays(Te, q, H);
                }
                this.webgl2 &&
                  this.transformFeedbackBuffer &&
                  (W.endTransformFeedback(),
                  W.bindBufferBase(W.TRANSFORM_FEEDBACK_BUFFER, 0, null)),
                  this._drawCallsPerFrame++;
              }
              clear(I) {
                var w;
                const N = this.defaultClearOptions;
                I = I || N;
                const W = (w = I.flags) != null ? w : N.flags;
                if (W !== 0) {
                  const Oe = this.gl;
                  if (W & i.Sue) {
                    var he;
                    const Ae = (he = I.color) != null ? he : N.color,
                      ke = Ae[0],
                      Ue = Ae[1],
                      Ge = Ae[2],
                      ht = Ae[3],
                      me = this.clearColor;
                    (ke !== me.r ||
                      Ue !== me.g ||
                      Ge !== me.b ||
                      ht !== me.a) &&
                      (this.gl.clearColor(ke, Ue, Ge, ht),
                      this.clearColor.set(ke, Ue, Ge, ht)),
                      this.setBlendState(ae.t.NOBLEND);
                  }
                  if (W & i.YKI) {
                    var ue;
                    const Ae = (ue = I.depth) != null ? ue : N.depth;
                    Ae !== this.clearDepth &&
                      (this.gl.clearDepth(Ae), (this.clearDepth = Ae)),
                      this.setDepthState(Z.H.WRITEDEPTH);
                  }
                  if (W & i.zwO) {
                    var ye;
                    const Ae = (ye = I.stencil) != null ? ye : N.stencil;
                    Ae !== this.clearStencil &&
                      (this.gl.clearStencil(Ae), (this.clearStencil = Ae));
                  }
                  Oe.clear(this.glClearFlag[W]);
                }
              }
              submit() {
                this.gl.flush();
              }
              readPixels(I, w, N, W, he) {
                const ue = this.gl;
                ue.readPixels(I, w, N, W, ue.RGBA, ue.UNSIGNED_BYTE, he);
              }
              readPixelsAsync(I, w, N, W, he) {
                return Kt(this, null, function* () {
                  var ue, ye, Oe;
                  const Ae = this.gl;
                  if (!this.webgl2) return this.readPixels(I, w, N, W, he);
                  const ke = (z, K) => {
                      const Te = Ae.fenceSync(Ae.SYNC_GPU_COMMANDS_COMPLETE, 0);
                      return (
                        this.submit(),
                        new Promise((H, q) => {
                          function se() {
                            const Ce = Ae.clientWaitSync(Te, z, 0);
                            Ce === Ae.WAIT_FAILED
                              ? (Ae.deleteSync(Te),
                                q(
                                  new Error("webgl clientWaitSync sync failed")
                                ))
                              : Ce === Ae.TIMEOUT_EXPIRED
                              ? setTimeout(se, K)
                              : (Ae.deleteSync(Te), H());
                          }
                          se();
                        })
                      );
                    },
                    Ue =
                      (ue = this.renderTarget.colorBuffer) == null
                        ? void 0
                        : ue.impl,
                    Ge =
                      (ye = Ue == null ? void 0 : Ue._glFormat) != null
                        ? ye
                        : Ae.RGBA,
                    ht =
                      (Oe = Ue == null ? void 0 : Ue._glPixelType) != null
                        ? Oe
                        : Ae.UNSIGNED_BYTE,
                    me = Ae.createBuffer();
                  Ae.bindBuffer(Ae.PIXEL_PACK_BUFFER, me),
                    Ae.bufferData(
                      Ae.PIXEL_PACK_BUFFER,
                      he.byteLength,
                      Ae.STREAM_READ
                    ),
                    Ae.readPixels(I, w, N, W, Ge, ht, 0),
                    Ae.bindBuffer(Ae.PIXEL_PACK_BUFFER, null),
                    yield ke(0, 20),
                    Ae.bindBuffer(Ae.PIXEL_PACK_BUFFER, me),
                    Ae.getBufferSubData(Ae.PIXEL_PACK_BUFFER, 0, he),
                    Ae.bindBuffer(Ae.PIXEL_PACK_BUFFER, null),
                    Ae.deleteBuffer(me);
                });
              }
              setAlphaToCoverage(I) {
                this.webgl2 &&
                  this.alphaToCoverage !== I &&
                  ((this.alphaToCoverage = I),
                  I
                    ? this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE)
                    : this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE));
              }
              setTransformFeedbackBuffer(I) {
                if (
                  this.transformFeedbackBuffer !== I &&
                  ((this.transformFeedbackBuffer = I), this.webgl2)
                ) {
                  const w = this.gl;
                  I
                    ? (this.feedback ||
                        (this.feedback = w.createTransformFeedback()),
                      w.bindTransformFeedback(
                        w.TRANSFORM_FEEDBACK,
                        this.feedback
                      ))
                    : w.bindTransformFeedback(w.TRANSFORM_FEEDBACK, null);
                }
              }
              setRaster(I) {
                this.raster !== I &&
                  ((this.raster = I),
                  this.webgl2 &&
                    (I
                      ? this.gl.disable(this.gl.RASTERIZER_DISCARD)
                      : this.gl.enable(this.gl.RASTERIZER_DISCARD)));
              }
              setDepthBias(I) {
                this.depthBiasEnabled !== I &&
                  ((this.depthBiasEnabled = I),
                  I
                    ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL)
                    : this.gl.disable(this.gl.POLYGON_OFFSET_FILL));
              }
              setDepthBiasValues(I, w) {
                this.gl.polygonOffset(w, I);
              }
              setStencilTest(I) {
                if (this.stencil !== I) {
                  const w = this.gl;
                  I ? w.enable(w.STENCIL_TEST) : w.disable(w.STENCIL_TEST),
                    (this.stencil = I);
                }
              }
              setStencilFunc(I, w, N) {
                (this.stencilFuncFront !== I ||
                  this.stencilRefFront !== w ||
                  this.stencilMaskFront !== N ||
                  this.stencilFuncBack !== I ||
                  this.stencilRefBack !== w ||
                  this.stencilMaskBack !== N) &&
                  (this.gl.stencilFunc(this.glComparison[I], w, N),
                  (this.stencilFuncFront = this.stencilFuncBack = I),
                  (this.stencilRefFront = this.stencilRefBack = w),
                  (this.stencilMaskFront = this.stencilMaskBack = N));
              }
              setStencilFuncFront(I, w, N) {
                if (
                  this.stencilFuncFront !== I ||
                  this.stencilRefFront !== w ||
                  this.stencilMaskFront !== N
                ) {
                  const W = this.gl;
                  W.stencilFuncSeparate(W.FRONT, this.glComparison[I], w, N),
                    (this.stencilFuncFront = I),
                    (this.stencilRefFront = w),
                    (this.stencilMaskFront = N);
                }
              }
              setStencilFuncBack(I, w, N) {
                if (
                  this.stencilFuncBack !== I ||
                  this.stencilRefBack !== w ||
                  this.stencilMaskBack !== N
                ) {
                  const W = this.gl;
                  W.stencilFuncSeparate(W.BACK, this.glComparison[I], w, N),
                    (this.stencilFuncBack = I),
                    (this.stencilRefBack = w),
                    (this.stencilMaskBack = N);
                }
              }
              setStencilOperation(I, w, N, W) {
                (this.stencilFailFront !== I ||
                  this.stencilZfailFront !== w ||
                  this.stencilZpassFront !== N ||
                  this.stencilFailBack !== I ||
                  this.stencilZfailBack !== w ||
                  this.stencilZpassBack !== N) &&
                  (this.gl.stencilOp(
                    this.glStencilOp[I],
                    this.glStencilOp[w],
                    this.glStencilOp[N]
                  ),
                  (this.stencilFailFront = this.stencilFailBack = I),
                  (this.stencilZfailFront = this.stencilZfailBack = w),
                  (this.stencilZpassFront = this.stencilZpassBack = N)),
                  (this.stencilWriteMaskFront !== W ||
                    this.stencilWriteMaskBack !== W) &&
                    (this.gl.stencilMask(W),
                    (this.stencilWriteMaskFront = W),
                    (this.stencilWriteMaskBack = W));
              }
              setStencilOperationFront(I, w, N, W) {
                (this.stencilFailFront !== I ||
                  this.stencilZfailFront !== w ||
                  this.stencilZpassFront !== N) &&
                  (this.gl.stencilOpSeparate(
                    this.gl.FRONT,
                    this.glStencilOp[I],
                    this.glStencilOp[w],
                    this.glStencilOp[N]
                  ),
                  (this.stencilFailFront = I),
                  (this.stencilZfailFront = w),
                  (this.stencilZpassFront = N)),
                  this.stencilWriteMaskFront !== W &&
                    (this.gl.stencilMaskSeparate(this.gl.FRONT, W),
                    (this.stencilWriteMaskFront = W));
              }
              setStencilOperationBack(I, w, N, W) {
                (this.stencilFailBack !== I ||
                  this.stencilZfailBack !== w ||
                  this.stencilZpassBack !== N) &&
                  (this.gl.stencilOpSeparate(
                    this.gl.BACK,
                    this.glStencilOp[I],
                    this.glStencilOp[w],
                    this.glStencilOp[N]
                  ),
                  (this.stencilFailBack = I),
                  (this.stencilZfailBack = w),
                  (this.stencilZpassBack = N)),
                  this.stencilWriteMaskBack !== W &&
                    (this.gl.stencilMaskSeparate(this.gl.BACK, W),
                    (this.stencilWriteMaskBack = W));
              }
              setBlendState(I) {
                const w = this.blendState;
                if (!w.equals(I)) {
                  const N = this.gl,
                    {
                      blend: W,
                      colorOp: he,
                      alphaOp: ue,
                      colorSrcFactor: ye,
                      colorDstFactor: Oe,
                      alphaSrcFactor: Ae,
                      alphaDstFactor: ke,
                    } = I;
                  if (
                    (w.blend !== W &&
                      (W ? N.enable(N.BLEND) : N.disable(N.BLEND)),
                    w.colorOp !== he || w.alphaOp !== ue)
                  ) {
                    const Ue = this.glBlendEquation;
                    N.blendEquationSeparate(Ue[he], Ue[ue]);
                  }
                  (w.colorSrcFactor !== ye ||
                    w.colorDstFactor !== Oe ||
                    w.alphaSrcFactor !== Ae ||
                    w.alphaDstFactor !== ke) &&
                    N.blendFuncSeparate(
                      this.glBlendFunctionColor[ye],
                      this.glBlendFunctionColor[Oe],
                      this.glBlendFunctionAlpha[Ae],
                      this.glBlendFunctionAlpha[ke]
                    ),
                    w.allWrite !== I.allWrite &&
                      this.gl.colorMask(
                        I.redWrite,
                        I.greenWrite,
                        I.blueWrite,
                        I.alphaWrite
                      ),
                    w.copy(I);
                }
              }
              setBlendColor(I, w, N, W) {
                const he = this.blendColor;
                (I !== he.r || w !== he.g || N !== he.b || W !== he.a) &&
                  (this.gl.blendColor(I, w, N, W), he.set(I, w, N, W));
              }
              setStencilState(I, w) {
                if (I || w)
                  if ((this.setStencilTest(!0), I === w))
                    this.setStencilFunc(I.func, I.ref, I.readMask),
                      this.setStencilOperation(
                        I.fail,
                        I.zfail,
                        I.zpass,
                        I.writeMask
                      );
                  else {
                    var N, W;
                    (N = I) != null || (I = J.n.DEFAULT),
                      this.setStencilFuncFront(I.func, I.ref, I.readMask),
                      this.setStencilOperationFront(
                        I.fail,
                        I.zfail,
                        I.zpass,
                        I.writeMask
                      ),
                      (W = w) != null || (w = J.n.DEFAULT),
                      this.setStencilFuncBack(w.func, w.ref, w.readMask),
                      this.setStencilOperationBack(
                        w.fail,
                        w.zfail,
                        w.zpass,
                        w.writeMask
                      );
                  }
                else this.setStencilTest(!1);
              }
              setDepthState(I) {
                const w = this.depthState;
                if (!w.equals(I)) {
                  const N = this.gl,
                    W = I.write;
                  w.write !== W && N.depthMask(W);
                  let { func: he, test: ue } = I;
                  !ue && W && ((ue = !0), (he = i.vpx)),
                    w.func !== he && N.depthFunc(this.glComparison[he]),
                    w.test !== ue &&
                      (ue ? N.enable(N.DEPTH_TEST) : N.disable(N.DEPTH_TEST)),
                    w.copy(I);
                }
              }
              setCullMode(I) {
                if (this.cullMode !== I) {
                  if (I === i.pLF) this.gl.disable(this.gl.CULL_FACE);
                  else {
                    this.cullMode === i.pLF &&
                      this.gl.enable(this.gl.CULL_FACE);
                    const w = this.glCull[I];
                    this.cullFace !== w &&
                      (this.gl.cullFace(w), (this.cullFace = w));
                  }
                  this.cullMode = I;
                }
              }
              setShader(I) {
                if (I !== this.shader) {
                  if (I.failed) return !1;
                  if (!I.ready && !I.impl.finalize(this, I))
                    return (I.failed = !0), !1;
                  (this.shader = I),
                    this.gl.useProgram(I.impl.glProgram),
                    (this.attributesInvalidated = !0);
                }
                return !0;
              }
              getHdrFormat(I, w, N, W) {
                const he =
                    this.extTextureHalfFloat &&
                    (!w || this.textureHalfFloatRenderable) &&
                    (!N || this.textureHalfFloatUpdatable) &&
                    (!W || this.extTextureHalfFloatLinear),
                  ue =
                    this.extTextureFloat &&
                    (!w || this.textureFloatRenderable) &&
                    (!W || this.extTextureFloatLinear);
                return he && ue
                  ? I
                    ? i.s7h
                    : i.WBN
                  : he
                  ? i.WBN
                  : ue
                  ? i.s7h
                  : null;
              }
              clearVertexArrayObjectCache() {
                const I = this.gl;
                this._vaoMap.forEach((w, N, W) => {
                  I.deleteVertexArray(w);
                }),
                  this._vaoMap.clear();
              }
              resizeCanvas(I, w) {
                (this._width = I), (this._height = w);
                const N = Math.min(
                  this._maxPixelRatio,
                  n.i.browser ? window.devicePixelRatio : 1
                );
                (I = Math.floor(I * N)),
                  (w = Math.floor(w * N)),
                  (this.canvas.width !== I || this.canvas.height !== w) &&
                    ((this.canvas.width = I),
                    (this.canvas.height = w),
                    this.fire(e.G.EVENT_RESIZE, I, w));
              }
              get width() {
                return this.gl.drawingBufferWidth || this.canvas.width;
              }
              get height() {
                return this.gl.drawingBufferHeight || this.canvas.height;
              }
              set fullscreen(I) {
                I
                  ? this.gl.canvas.requestFullscreen()
                  : document.exitFullscreen();
              }
              get fullscreen() {
                return !!document.fullscreenElement;
              }
              get textureFloatHighPrecision() {
                return (
                  this._textureFloatHighPrecision === void 0 &&
                    (this._textureFloatHighPrecision = ne(this)),
                  this._textureFloatHighPrecision
                );
              }
              get textureHalfFloatUpdatable() {
                return (
                  this._textureHalfFloatUpdatable === void 0 &&
                    (this.webgl2
                      ? (this._textureHalfFloatUpdatable = !0)
                      : (this._textureHalfFloatUpdatable = Y(
                          this.gl,
                          this.extTextureHalfFloat.HALF_FLOAT_OES
                        ))),
                  this._textureHalfFloatUpdatable
                );
              }
            }
          },
          5321: (xe, V, a) => {
            "use strict";
            a.d(V, { j: () => y });
            var A = a(1630),
              x = a(5811);
            class y {
              constructor(d, h, f, s) {
                if (
                  ((this.locationId = s),
                  (this.scopeId = d.scope.resolve(h)),
                  (this.version = new x.R()),
                  h.substring(h.length - 3) === "[0]")
                )
                  switch (f) {
                    case A.GF5:
                      f = A.Nv2;
                      break;
                    case A.Qhq:
                      f = A.FEO;
                      break;
                    case A.XAr:
                      f = A.iYc;
                      break;
                    case A.cyR:
                      f = A.$Cd;
                      break;
                  }
                (this.dataType = f),
                  (this.value = [null, null, null, null]),
                  (this.array = []);
              }
            }
          },
          9939: (xe, V, a) => {
            "use strict";
            a.d(V, {
              AQ: () => ss,
              Af: () => T,
              B$: () => e,
              C: () => at,
              C8: () => Lt,
              CE: () => rt,
              Ci: () => Ts,
              Cj: () => Ve,
              Cp: () => $e,
              Ct: () => hi,
              Dw: () => me,
              I8: () => zt,
              IK: () => de,
              IQ: () => N,
              JN: () => Cs,
              Jf: () => ci,
              Jn: () => o,
              K: () => s,
              Kb: () => le,
              LA: () => yi,
              LN: () => mt,
              MN: () => pe,
              Mw: () => gi,
              NO: () => x,
              Ny: () => fe,
              OJ: () => m,
              OM: () => _,
              Ol: () => r,
              P8: () => Me,
              P9: () => w,
              PT: () => At,
              Pf: () => ht,
              Pm: () => O,
              Po: () => q,
              Ps: () => re,
              Pw: () => Li,
              QC: () => Q,
              Ql: () => $,
              R: () => j,
              Rg: () => $s,
              Ri: () => b,
              Rt: () => l,
              Rz: () => A,
              S$: () => G,
              SV: () => t,
              TX: () => ce,
              Tw: () => mi,
              Ut: () => js,
              V0: () => M,
              VW: () => pi,
              W0: () => Y,
              W2: () => se,
              W6: () => I,
              W8: () => Oe,
              WA: () => Bi,
              WK: () => Ie,
              WN: () => ke,
              WQ: () => it,
              WT: () => i,
              Wp: () => tt,
              Wv: () => Rt,
              Wx: () => Ms,
              Wy: () => he,
              XC: () => F,
              YY: () => Z,
              Y_: () => Zt,
              Yw: () => ft,
              Z5: () => Nt,
              Zs: () => f,
              _X: () => Qt,
              __: () => _i,
              aD: () => je,
              aG: () => kt,
              aI: () => E,
              aW: () => P,
              ao: () => gt,
              az: () => fi,
              b: () => Js,
              b0: () => z,
              bC: () => Ft,
              bF: () => Te,
              bJ: () => ne,
              bL: () => Ce,
              bR: () => Ae,
              bS: () => W,
              b_: () => vt,
              bh: () => Pt,
              br: () => Xi,
              bt: () => Le,
              bw: () => Ue,
              c$: () => Ps,
              cH: () => X,
              cQ: () => os,
              cm: () => bt,
              d6: () => B,
              dL: () => J,
              e7: () => h,
              eU: () => n,
              ez: () => _t,
              fR: () => ds,
              fi: () => qt,
              gf: () => ge,
              hO: () => bs,
              hr: () => Xt,
              iC: () => K,
              iR: () => Tt,
              iU: () => L,
              iX: () => _e,
              i_: () => Ge,
              ie: () => ut,
              ih: () => H,
              in: () => we,
              io: () => Ai,
              iy: () => ae,
              jN: () => us,
              jR: () => ie,
              js: () => ls,
              kP: () => Fe,
              l7: () => Qe,
              lY: () => Ke,
              lb: () => ot,
              mW: () => is,
              mZ: () => ue,
              mz: () => Ls,
              n3: () => v,
              ni: () => li,
              o5: () => yt,
              oF: () => fs,
              ok: () => Xe,
              ov: () => Ne,
              pU: () => g,
              qI: () => Bt,
              rE: () => c,
              rP: () => xt,
              re: () => D,
              s6: () => te,
              sA: () => nt,
              sJ: () => lt,
              sP: () => ze,
              sV: () => Ye,
              sf: () => De,
              tc: () => Ot,
              u5: () => ve,
              uS: () => $t,
              v2: () => Je,
              vH: () => ct,
              vN: () => Pe,
              vY: () => vs,
              v_: () => ye,
              vl: () => Os,
              vy: () => wt,
              wB: () => es,
              xA: () => Gs,
              xl: () => y,
              yV: () => ii,
              yX: () => u,
              ye: () => R,
              yg: () => d,
              yq: () => Ze,
              zh: () => k,
              zx: () => et,
            });
            const A = "mouse",
              x = "keyboard",
              y = "gamepad",
              c = "mousex",
              d = "mousey",
              h = "padlx",
              f = "padly",
              s = "padrx",
              l = "padry",
              n = "key",
              o = "keydown",
              i = "keyup",
              e = "mousedown",
              t = "mousemove",
              r = "mouseup",
              u = "mousewheel",
              v = "touchstart",
              _ = "touchend",
              m = "touchmove",
              g = "touchcancel",
              T = "select",
              E = "selectstart",
              M = "selectend",
              R = 8,
              P = 9,
              F = 13,
              b = 13,
              D = 16,
              G = 17,
              X = 18,
              ie = 19,
              Q = 20,
              te = 27,
              ae = 32,
              Z = 33,
              J = 34,
              ve = 35,
              _e = 36,
              L = 37,
              ge = 38,
              k = 39,
              j = 40,
              B = 44,
              $ = 45,
              le = 46,
              O = 48,
              Y = 49,
              ne = 50,
              de = 51,
              re = 52,
              I = 53,
              w = 54,
              N = 55,
              W = 56,
              he = 57,
              ue = 59,
              ye = 61,
              Oe = 65,
              Ae = 66,
              ke = 67,
              Ue = 68,
              Ge = 69,
              ht = 70,
              me = 71,
              z = 72,
              K = 73,
              Te = 74,
              H = 75,
              q = 76,
              se = 77,
              Ce = 78,
              we = 79,
              Me = 80,
              Ie = 81,
              Le = 82,
              tt = 83,
              vt = 84,
              it = 85,
              At = 86,
              Rt = 87,
              Ft = 88,
              ut = 89,
              Pt = 90,
              bt = 91,
              Zt = 93,
              Xt = 96,
              yt = 97,
              Pe = 98,
              $e = 99,
              Je = 100,
              rt = 101,
              ct = 102,
              Ve = 103,
              wt = 104,
              at = 105,
              ce = 106,
              pe = 107,
              De = 108,
              fe = 109,
              Ze = 110,
              Ne = 111,
              Ye = 112,
              Ke = 113,
              nt = 114,
              ot = 115,
              ze = 116,
              et = 117,
              _t = 118,
              Qe = 119,
              lt = 120,
              xt = 121,
              Tt = 122,
              ft = 123,
              gt = 188,
              Fe = 190,
              Qt = 191,
              zt = 219,
              Lt = 220,
              $t = 221,
              Bt = 224,
              Nt = -1,
              es = 0,
              kt = 1,
              ds = 2,
              os = 0,
              ls = 1,
              Ps = 2,
              us = 3,
              Xe = 0,
              vs = 1,
              fs = 2,
              bs = 3,
              Ms = 4,
              Ts = 5,
              Js = 6,
              Os = 7,
              li = 8,
              $s = 9,
              Cs = 10,
              Gs = 11,
              hi = 12,
              ci = 13,
              ii = 14,
              je = 15,
              mt = 16,
              Ot = 0,
              ss = 1,
              qt = 2,
              is = 3,
              Ls = "gamepadconnected",
              js = "gamepaddisconnected",
              fi = 0,
              pi = 1,
              _i = 2,
              mi = 3,
              gi = 2,
              yi = 0,
              Li = 1,
              Bi = 3,
              Ai = 4,
              Xi = 5;
          },
          5588: (xe, V, a) => {
            "use strict";
            a.d(V, { x: () => d });
            var A = a(8506),
              x = a(9939),
              y = a(8789),
              c = a(9273);
            class d {
              constructor(f, s = {}) {
                (this._keyboard = s.keyboard || null),
                  (this._mouse = s.mouse || null),
                  (this._gamepads = s.gamepads || null),
                  (this._element = null),
                  (this._actions = {}),
                  (this._axes = {}),
                  (this._axesValues = {}),
                  f && this.attach(f);
              }
              attach(f) {
                (this._element = f),
                  this._keyboard && this._keyboard.attach(f),
                  this._mouse && this._mouse.attach(f);
              }
              detach() {
                this._keyboard && this._keyboard.detach(),
                  this._mouse && this._mouse.detach(),
                  (this._element = null);
              }
              disableContextMenu() {
                this._mouse || this._enableMouse(),
                  this._mouse.disableContextMenu();
              }
              enableContextMenu() {
                this._mouse || this._enableMouse(),
                  this._mouse.enableContextMenu();
              }
              update(f) {
                this._keyboard && this._keyboard.update(),
                  this._mouse && this._mouse.update(),
                  this._gamepads && this._gamepads.update(),
                  (this._axesValues = {});
                for (const s in this._axes) this._axesValues[s] = [];
              }
              appendAction(f, s) {
                (this._actions[f] = this._actions[f] || []),
                  this._actions[f].push(s);
              }
              registerKeys(f, s) {
                if (
                  (this._keyboard || this._enableKeyboard(), this._actions[f])
                )
                  throw new Error(`Action: ${f} already registered`);
                if (s === void 0) throw new Error("Invalid button");
                s.length || (s = [s]),
                  this.appendAction(f, { type: x.NO, keys: s });
              }
              registerMouse(f, s) {
                if ((this._mouse || this._enableMouse(), s === void 0))
                  throw new Error("Invalid button");
                this.appendAction(f, { type: x.Rz, button: s });
              }
              registerPadButton(f, s, l) {
                if (l === void 0) throw new Error("Invalid button");
                this.appendAction(f, { type: x.xl, button: l, pad: s });
              }
              registerAxis(f) {
                const s = f.name;
                this._axes[s] || (this._axes[s] = []);
                const l = this._axes[s].push(s);
                (f = f || {}), (f.pad = f.pad || x.cQ);
                const n = function (i, e, t, r) {
                  switch (e) {
                    case "mousex":
                      i._mouse.on(x.SV, function (u) {
                        i._axesValues[s][l] = u.dx / 10;
                      });
                      break;
                    case "mousey":
                      i._mouse.on(x.SV, function (u) {
                        i._axesValues[s][l] = u.dy / 10;
                      });
                      break;
                    case "key":
                      i._axes[s].push(function () {
                        return i._keyboard.isPressed(r) ? t : 0;
                      });
                      break;
                    case "padrx":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, x.fi);
                      });
                      break;
                    case "padry":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, x.mW);
                      });
                      break;
                    case "padlx":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, x.tc);
                      });
                      break;
                    case "padly":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, x.AQ);
                      });
                      break;
                    default:
                      throw new Error("Unknown axis");
                  }
                };
                n(this, f.positive, 1, f.positiveKey),
                  (f.negativeKey || f.negative !== f.positive) &&
                    n(this, f.negative, -1, f.negativeKey);
              }
              isPressed(f) {
                if (!this._actions[f]) return !1;
                const s = this._actions[f].length;
                for (let l = 0; l < s; ++l) {
                  const n = this._actions[f][l];
                  switch (n.type) {
                    case x.NO:
                      if (this._keyboard) {
                        const o = n.keys.length;
                        for (let i = 0; i < o; i++)
                          if (this._keyboard.isPressed(n.keys[i])) return !0;
                      }
                      break;
                    case x.Rz:
                      if (this._mouse && this._mouse.isPressed(n.button))
                        return !0;
                      break;
                    case x.xl:
                      if (
                        this._gamepads &&
                        this._gamepads.isPressed(n.pad, n.button)
                      )
                        return !0;
                      break;
                  }
                }
                return !1;
              }
              wasPressed(f) {
                if (!this._actions[f]) return !1;
                const s = this._actions[f].length;
                for (let l = 0; l < s; ++l) {
                  const n = this._actions[f][l];
                  switch (n.type) {
                    case x.NO:
                      if (this._keyboard) {
                        const o = n.keys.length;
                        for (let i = 0; i < o; i++)
                          if (this._keyboard.wasPressed(n.keys[i])) return !0;
                      }
                      break;
                    case x.Rz:
                      if (this._mouse && this._mouse.wasPressed(n.button))
                        return !0;
                      break;
                    case x.xl:
                      if (
                        this._gamepads &&
                        this._gamepads.wasPressed(n.pad, n.button)
                      )
                        return !0;
                      break;
                  }
                }
                return !1;
              }
              getAxis(f) {
                let s = 0;
                if (this._axes[f]) {
                  const l = this._axes[f].length;
                  for (let n = 0; n < l; n++)
                    if ((0, A.NW)(this._axes[f][n]) === "function") {
                      const o = this._axes[f][n]();
                      Math.abs(o) > Math.abs(s) && (s = o);
                    } else
                      this._axesValues[f] &&
                        Math.abs(this._axesValues[f][n]) > Math.abs(s) &&
                        (s = this._axesValues[f][n]);
                }
                return s;
              }
              _enableMouse() {
                if (((this._mouse = new c.K()), !this._element))
                  throw new Error("Controller must be attached to an Element");
                this._mouse.attach(this._element);
              }
              _enableKeyboard() {
                if (((this._keyboard = new y.s()), !this._element))
                  throw new Error("Controller must be attached to an Element");
                this._keyboard.attach(this._element);
              }
            }
          },
          2921: (xe, V, a) => {
            "use strict";
            a.d(V, { $1: () => v });
            var A = a(8976),
              x = a(9939),
              y = a(8656),
              c = a(9222);
            const d = Object.freeze([]);
            let h = function () {
              return d;
            };
            typeof navigator != "undefined" &&
              (h = (
                navigator.getGamepads ||
                navigator.webkitGetGamepads ||
                h
              ).bind(navigator));
            const f = {
                buttons: {
                  PAD_FACE_1: x.ok,
                  PAD_FACE_2: x.vY,
                  PAD_FACE_3: x.oF,
                  PAD_FACE_4: x.hO,
                  PAD_L_SHOULDER_1: x.Wx,
                  PAD_R_SHOULDER_1: x.Ci,
                  PAD_L_SHOULDER_2: x.b,
                  PAD_R_SHOULDER_2: x.vl,
                  PAD_SELECT: x.ni,
                  PAD_START: x.Rg,
                  PAD_L_STICK_BUTTON: x.JN,
                  PAD_R_STICK_BUTTON: x.xA,
                  PAD_UP: x.Ct,
                  PAD_DOWN: x.Jf,
                  PAD_LEFT: x.yV,
                  PAD_RIGHT: x.aD,
                  PAD_VENDOR: x.LN,
                  XRPAD_TRIGGER: x.LA,
                  XRPAD_SQUEEZE: x.Pw,
                  XRPAD_TOUCHPAD_BUTTON: x.Mw,
                  XRPAD_STICK_BUTTON: x.WA,
                  XRPAD_A: x.io,
                  XRPAD_B: x.br,
                },
                axes: {
                  PAD_L_STICK_X: x.tc,
                  PAD_L_STICK_Y: x.AQ,
                  PAD_R_STICK_X: x.fi,
                  PAD_R_STICK_Y: x.mW,
                  XRPAD_TOUCHPAD_X: x.az,
                  XRPAD_TOUCHPAD_Y: x.VW,
                  XRPAD_STICK_X: x.__,
                  XRPAD_STICK_Y: x.Tw,
                },
              },
              s = {
                DEFAULT: {
                  buttons: [
                    "PAD_FACE_1",
                    "PAD_FACE_2",
                    "PAD_FACE_3",
                    "PAD_FACE_4",
                    "PAD_L_SHOULDER_1",
                    "PAD_R_SHOULDER_1",
                    "PAD_L_SHOULDER_2",
                    "PAD_R_SHOULDER_2",
                    "PAD_SELECT",
                    "PAD_START",
                    "PAD_L_STICK_BUTTON",
                    "PAD_R_STICK_BUTTON",
                    "PAD_UP",
                    "PAD_DOWN",
                    "PAD_LEFT",
                    "PAD_RIGHT",
                    "PAD_VENDOR",
                  ],
                  axes: [
                    "PAD_L_STICK_X",
                    "PAD_L_STICK_Y",
                    "PAD_R_STICK_X",
                    "PAD_R_STICK_Y",
                  ],
                },
                DEFAULT_DUAL: {
                  buttons: [
                    "PAD_FACE_1",
                    "PAD_FACE_2",
                    "PAD_FACE_3",
                    "PAD_FACE_4",
                    "PAD_L_SHOULDER_1",
                    "PAD_R_SHOULDER_1",
                    "PAD_L_SHOULDER_2",
                    "PAD_R_SHOULDER_2",
                    "PAD_SELECT",
                    "PAD_START",
                    "PAD_L_STICK_BUTTON",
                    "PAD_R_STICK_BUTTON",
                    "PAD_VENDOR",
                  ],
                  axes: [
                    "PAD_L_STICK_X",
                    "PAD_L_STICK_Y",
                    "PAD_R_STICK_X",
                    "PAD_R_STICK_Y",
                  ],
                  synthesizedButtons: {
                    PAD_UP: { axis: 0, min: 0, max: 1 },
                    PAD_DOWN: { axis: 0, min: -1, max: 0 },
                    PAD_LEFT: { axis: 0, min: -1, max: 0 },
                    PAD_RIGHT: { axis: 0, min: 0, max: 1 },
                  },
                },
                PS3: {
                  buttons: [
                    "PAD_FACE_1",
                    "PAD_FACE_2",
                    "PAD_FACE_4",
                    "PAD_FACE_3",
                    "PAD_L_SHOULDER_1",
                    "PAD_R_SHOULDER_1",
                    "PAD_L_SHOULDER_2",
                    "PAD_R_SHOULDER_2",
                    "PAD_SELECT",
                    "PAD_START",
                    "PAD_L_STICK_BUTTON",
                    "PAD_R_STICK_BUTTON",
                    "PAD_UP",
                    "PAD_DOWN",
                    "PAD_LEFT",
                    "PAD_RIGHT",
                    "PAD_VENDOR",
                  ],
                  axes: [
                    "PAD_L_STICK_X",
                    "PAD_L_STICK_Y",
                    "PAD_R_STICK_X",
                    "PAD_R_STICK_Y",
                  ],
                  mapping: "standard",
                },
                DEFAULT_XR: {
                  buttons: [
                    "XRPAD_TRIGGER",
                    "XRPAD_SQUEEZE",
                    "XRPAD_TOUCHPAD_BUTTON",
                    "XRPAD_STICK_BUTTON",
                    "XRPAD_A",
                    "XRPAD_B",
                  ],
                  axes: [
                    "XRPAD_TOUCHPAD_X",
                    "XRPAD_TOUCHPAD_Y",
                    "XRPAD_STICK_X",
                    "XRPAD_STICK_Y",
                  ],
                  mapping: "xr-standard",
                },
              },
              l = { "Product: 0268": "PS3" },
              n = {};
            function o(_) {
              const m = n[_.id];
              if (m) return m;
              for (const E in l)
                if (_.id.indexOf(E) !== -1) {
                  const M = l[E];
                  if (!_.mapping) {
                    const R = s["RAW_" + M];
                    if (R) return R;
                  }
                  return s[M];
                }
              if (_.mapping === "xr-standard") return s.DEFAULT_XR;
              const g = s.DEFAULT,
                T = _.buttons.length < g.buttons.length ? s.DEFAULT_DUAL : g;
              return (T.mapping = _.mapping), T;
            }
            let i = 0.25;
            function e(_) {
              return new Promise((m) => {
                setTimeout(m, _);
              });
            }
            class t {
              constructor(m, g) {
                if (
                  ((this.value = 0),
                  (this.pressed = !1),
                  (this.touched = !1),
                  (this.wasPressed = !1),
                  (this.wasReleased = !1),
                  (this.wasTouched = !1),
                  typeof m == "number")
                )
                  (this.value = m),
                    (this.pressed = m === 1),
                    (this.touched = m > 0);
                else {
                  var T;
                  (this.value = m.value),
                    (this.pressed = m.pressed),
                    (this.touched = (T = m.touched) != null ? T : m.value > 0);
                }
                if (g)
                  if (typeof g == "number")
                    (this.wasPressed = g !== 1 && this.pressed),
                      (this.wasReleased = g === 1 && !this.pressed),
                      (this.wasTouched = g === 0 && this.touched);
                  else {
                    var E;
                    (this.wasPressed = !g.pressed && this.pressed),
                      (this.wasReleased = g.pressed && !this.pressed),
                      (this.wasTouched =
                        !((E = g.touched) != null ? E : g.value > 0) &&
                        this.touched);
                  }
              }
              update(m) {
                var g;
                const { value: T, pressed: E } = m,
                  M = (g = m.touched) != null ? g : T > 0;
                (this.wasPressed = !this.pressed && E),
                  (this.wasReleased = this.pressed && !E),
                  (this.wasTouched = !this.touched && M),
                  (this.value = T),
                  (this.pressed = E),
                  (this.touched = M);
              }
            }
            const r = Object.freeze(new t(0));
            class u {
              constructor(m, g) {
                (this._compiledMapping = { buttons: [], axes: [] }),
                  (this.id = m.id),
                  (this.index = m.index),
                  (this._buttons = m.buttons.map((T) => new t(T))),
                  (this._axes = [...m.axes]),
                  (this._previousAxes = [...m.axes]),
                  (this.mapping = g.mapping),
                  (this.map = g),
                  (this.hand = m.hand || "none"),
                  (this.pad = m),
                  this._compileMapping();
              }
              get connected() {
                return this.pad.connected;
              }
              _compileMapping() {
                const { axes: m, buttons: g } = this._compiledMapping,
                  T = f.axes,
                  E = f.buttons;
                (m.length = 0),
                  (g.length = 0),
                  this.map.axes &&
                    this.map.axes.forEach((F, b) => {
                      m[T[F]] = () => this.pad.axes[b] || 0;
                    });
                for (let F = 0, b = m.length; F < b; F++)
                  m[F] || (m[F] = () => 0);
                const R = this.map.buttons;
                R &&
                  R.forEach((F, b) => {
                    g[E[F]] = () => this._buttons[b] || r;
                  });
                const P = this.map.synthesizedButtons;
                P &&
                  Object.entries(P).forEach((F) => {
                    const { axis: b, max: D, min: G } = F[1];
                    g[E[F[0]]] = () => {
                      var X, ie;
                      return new t(
                        Math.abs(
                          y.D.clamp((X = this._axes[b]) != null ? X : 0, G, D)
                        ),
                        Math.abs(
                          y.D.clamp(
                            (ie = this._previousAxes[b]) != null ? ie : 0,
                            G,
                            D
                          )
                        )
                      );
                    };
                  });
                for (let F = 0, b = g.length; F < b; F++)
                  g[F] || (g[F] = () => r);
              }
              update(m) {
                this.pad = m;
                const g = this._previousAxes,
                  T = this._axes;
                (g.length = 0), g.push(...T), (T.length = 0), T.push(...m.axes);
                const E = this._buttons;
                for (let M = 0, R = E.length; M < R; M++)
                  E[M].update(m.buttons[M]);
                return this;
              }
              updateMap(m) {
                (m.mapping = "custom"),
                  (n[this.id] = m),
                  (this.map = m),
                  (this.mapping = "custom"),
                  this._compileMapping();
              }
              resetMap() {
                if (n[this.id]) {
                  delete n[this.id];
                  const m = o(this.pad);
                  (this.map = m),
                    (this.mapping = m.mapping),
                    this._compileMapping();
                }
              }
              get axes() {
                return this._compiledMapping.axes.map((m) => m());
              }
              get buttons() {
                return this._compiledMapping.buttons.map((m) => m());
              }
              pulse(m, g, T) {
                return Kt(this, null, function* () {
                  const E = this.pad.vibrationActuator
                    ? [this.pad.vibrationActuator]
                    : this.pad.hapticActuators || d;
                  if (E.length) {
                    var M, R, P;
                    const F =
                        (M = T == null ? void 0 : T.startDelay) != null ? M : 0,
                      b =
                        (R = T == null ? void 0 : T.strongMagnitude) != null
                          ? R
                          : m,
                      D =
                        (P = T == null ? void 0 : T.weakMagnitude) != null
                          ? P
                          : m;
                    return (yield Promise.all(
                      E.map(function (X) {
                        return Kt(this, null, function* () {
                          return X
                            ? X.playEffect
                              ? X.playEffect(X.type, {
                                  duration: g,
                                  startDelay: F,
                                  strongMagnitude: b,
                                  weakMagnitude: D,
                                })
                              : X.pulse
                              ? (yield e(F), X.pulse(m, g))
                              : !1
                            : !0;
                        });
                      })
                    )).some((X) => X === !0 || X === "complete");
                  }
                  return !1;
                });
              }
              getButton(m) {
                const g = this._compiledMapping.buttons[m];
                return g ? g() : r;
              }
              isPressed(m) {
                return this.getButton(m).pressed;
              }
              wasPressed(m) {
                return this.getButton(m).wasPressed;
              }
              wasReleased(m) {
                return this.getButton(m).wasReleased;
              }
              isTouched(m) {
                return this.getButton(m).touched;
              }
              wasTouched(m) {
                return this.getButton(m).wasTouched;
              }
              getValue(m) {
                return this.getButton(m).value;
              }
              getAxis(m) {
                const g = this.axes[m];
                return g && Math.abs(g) > i ? g : 0;
              }
            }
            class v extends A.J {
              constructor() {
                super(),
                  (this.gamepadsSupported = c.i.gamepads),
                  (this.current = []),
                  (this._previous = []),
                  (this._ongamepadconnectedHandler =
                    this._ongamepadconnected.bind(this)),
                  (this._ongamepaddisconnectedHandler =
                    this._ongamepaddisconnected.bind(this)),
                  window.addEventListener(
                    "gamepadconnected",
                    this._ongamepadconnectedHandler,
                    !1
                  ),
                  window.addEventListener(
                    "gamepaddisconnected",
                    this._ongamepaddisconnectedHandler,
                    !1
                  ),
                  this.poll();
              }
              set deadZone(m) {
                i = m;
              }
              get deadZone() {
                return i;
              }
              get previous() {
                const m = this.current;
                for (let g = 0, T = m.length; g < T; g++) {
                  const E = m[g]._buttons;
                  this._previous[g] || (this._previous[g] = []);
                  for (let M = 0, R = E.length; M < R; M++) {
                    const P = E[g];
                    this.previous[g][M] = P
                      ? (!P.wasPressed && P.pressed) || P.wasReleased
                      : !1;
                  }
                }
                return (
                  (this._previous.length = this.current.length), this._previous
                );
              }
              _ongamepadconnected(m) {
                const g = new u(m.gamepad, this.getMap(m.gamepad)),
                  T = this.current;
                let E = T.findIndex((M) => M.index === g.index);
                for (; E !== -1; )
                  T.splice(E, 1), (E = T.findIndex((M) => M.index === g.index));
                T.push(g), this.fire(x.mz, g);
              }
              _ongamepaddisconnected(m) {
                const g = this.current,
                  T = g.findIndex((E) => E.index === m.gamepad.index);
                T !== -1 && (this.fire(x.Ut, g[T]), g.splice(T, 1));
              }
              update() {
                this.poll();
              }
              poll(m = []) {
                m.length > 0 && (m.length = 0);
                const g = h();
                for (let T = 0, E = g.length; T < E; T++)
                  if (g[T]) {
                    const M = this.findByIndex(g[T].index);
                    if (M) m.push(M.update(g[T]));
                    else {
                      const R = new u(g[T], this.getMap(g[T]));
                      this.current.push(R), m.push(R);
                    }
                  }
                return m;
              }
              destroy() {
                window.removeEventListener(
                  "gamepadconnected",
                  this._ongamepadconnectedHandler,
                  !1
                ),
                  window.removeEventListener(
                    "gamepaddisconnected",
                    this._ongamepaddisconnectedHandler,
                    !1
                  );
              }
              getMap(m) {
                return o(m);
              }
              isPressed(m, g) {
                var T;
                return (
                  ((T = this.current[m]) == null ? void 0 : T.isPressed(g)) ||
                  !1
                );
              }
              wasPressed(m, g) {
                var T;
                return (
                  ((T = this.current[m]) == null ? void 0 : T.wasPressed(g)) ||
                  !1
                );
              }
              wasReleased(m, g) {
                var T;
                return (
                  ((T = this.current[m]) == null ? void 0 : T.wasReleased(g)) ||
                  !1
                );
              }
              getAxis(m, g) {
                var T;
                return (
                  ((T = this.current[m]) == null ? void 0 : T.getAxis(g)) || 0
                );
              }
              pulse(m, g, T, E) {
                const M = this.current[m];
                return M ? M.pulse(g, T, E) : Promise.resolve(!1);
              }
              pulseAll(m, g, T) {
                return Promise.all(this.current.map((E) => E.pulse(m, g, T)));
              }
              findById(m) {
                return this.current.find((g) => g && g.id === m) || null;
              }
              findByIndex(m) {
                return this.current.find((g) => g && g.index === m) || null;
              }
            }
          },
          4967: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => A });
            class A {
              constructor(y, c) {
                c
                  ? ((this.key = c.keyCode),
                    (this.element = c.target),
                    (this.event = c))
                  : ((this.key = null),
                    (this.element = null),
                    (this.event = null));
              }
            }
          },
          8789: (xe, V, a) => {
            "use strict";
            a.d(V, { s: () => f });
            var A = a(8976),
              x = a(4967);
            const y = new x.k();
            function c(s) {
              return (
                (y.key = s.keyCode), (y.element = s.target), (y.event = s), y
              );
            }
            function d(s) {
              return typeof s == "string" ? s.toUpperCase().charCodeAt(0) : s;
            }
            const h = {
              9: "Tab",
              13: "Enter",
              16: "Shift",
              17: "Control",
              18: "Alt",
              27: "Escape",
              37: "Left",
              38: "Up",
              39: "Right",
              40: "Down",
              46: "Delete",
              91: "Win",
            };
            class f extends A.J {
              constructor(l, n = {}) {
                super(),
                  (this._element = null),
                  (this._keyDownHandler = this._handleKeyDown.bind(this)),
                  (this._keyUpHandler = this._handleKeyUp.bind(this)),
                  (this._keyPressHandler = this._handleKeyPress.bind(this)),
                  (this._visibilityChangeHandler =
                    this._handleVisibilityChange.bind(this)),
                  (this._windowBlurHandler = this._handleWindowBlur.bind(this)),
                  (this._keymap = {}),
                  (this._lastmap = {}),
                  l && this.attach(l),
                  (this.preventDefault = n.preventDefault || !1),
                  (this.stopPropagation = n.stopPropagation || !1);
              }
              attach(l) {
                this._element && this.detach(),
                  (this._element = l),
                  this._element.addEventListener(
                    "keydown",
                    this._keyDownHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "keypress",
                    this._keyPressHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "keyup",
                    this._keyUpHandler,
                    !1
                  ),
                  document.addEventListener(
                    "visibilitychange",
                    this._visibilityChangeHandler,
                    !1
                  ),
                  window.addEventListener("blur", this._windowBlurHandler, !1);
              }
              detach() {
                this._element &&
                  (this._element.removeEventListener(
                    "keydown",
                    this._keyDownHandler
                  ),
                  this._element.removeEventListener(
                    "keypress",
                    this._keyPressHandler
                  ),
                  this._element.removeEventListener(
                    "keyup",
                    this._keyUpHandler
                  ),
                  (this._element = null),
                  document.removeEventListener(
                    "visibilitychange",
                    this._visibilityChangeHandler,
                    !1
                  ),
                  window.removeEventListener(
                    "blur",
                    this._windowBlurHandler,
                    !1
                  ));
              }
              toKeyIdentifier(l) {
                l = d(l);
                const n = h[l.toString()];
                if (n) return n;
                let o = l.toString(16).toUpperCase();
                const i = o.length;
                for (let e = 0; e < 4 - i; e++) o = "0" + o;
                return "U+" + o;
              }
              _handleKeyDown(l) {
                const n = l.keyCode || l.charCode;
                if (n === void 0) return;
                const o = this.toKeyIdentifier(n);
                (this._keymap[o] = !0),
                  this.fire("keydown", c(l)),
                  this.preventDefault && l.preventDefault(),
                  this.stopPropagation && l.stopPropagation();
              }
              _handleKeyUp(l) {
                const n = l.keyCode || l.charCode;
                if (n === void 0) return;
                const o = this.toKeyIdentifier(n);
                delete this._keymap[o],
                  this.fire("keyup", c(l)),
                  this.preventDefault && l.preventDefault(),
                  this.stopPropagation && l.stopPropagation();
              }
              _handleKeyPress(l) {
                this.fire("keypress", c(l)),
                  this.preventDefault && l.preventDefault(),
                  this.stopPropagation && l.stopPropagation();
              }
              _handleVisibilityChange() {
                document.visibilityState === "hidden" &&
                  this._handleWindowBlur();
              }
              _handleWindowBlur() {
                (this._keymap = {}), (this._lastmap = {});
              }
              update() {
                for (const l in this._lastmap) delete this._lastmap[l];
                for (const l in this._keymap)
                  this._keymap.hasOwnProperty(l) &&
                    (this._lastmap[l] = this._keymap[l]);
              }
              isPressed(l) {
                const n = d(l),
                  o = this.toKeyIdentifier(n);
                return !!this._keymap[o];
              }
              wasPressed(l) {
                const n = d(l),
                  o = this.toKeyIdentifier(n);
                return !!this._keymap[o] && !this._lastmap[o];
              }
              wasReleased(l) {
                const n = d(l),
                  o = this.toKeyIdentifier(n);
                return !this._keymap[o] && !!this._lastmap[o];
              }
            }
          },
          9800: (xe, V, a) => {
            "use strict";
            a.d(V, { C: () => y, V: () => x });
            var A = a(9939);
            function x() {
              return !!(
                document.pointerLockElement ||
                document.mozPointerLockElement ||
                document.webkitPointerLockElement
              );
            }
            class y {
              constructor(d, h) {
                let f = { x: 0, y: 0 };
                if (h) {
                  if (h instanceof y) throw Error("Expected MouseEvent");
                  f = d._getTargetCoords(h);
                } else h = {};
                if (f) (this.x = f.x), (this.y = f.y);
                else if (x()) (this.x = 0), (this.y = 0);
                else return;
                (this.wheelDelta = 0),
                  h.type === "wheel" &&
                    (h.deltaY > 0
                      ? (this.wheelDelta = 1)
                      : h.deltaY < 0 && (this.wheelDelta = -1)),
                  x()
                    ? ((this.dx =
                        h.movementX ||
                        h.webkitMovementX ||
                        h.mozMovementX ||
                        0),
                      (this.dy =
                        h.movementY ||
                        h.webkitMovementY ||
                        h.mozMovementY ||
                        0))
                    : ((this.dx = this.x - d._lastX),
                      (this.dy = this.y - d._lastY)),
                  h.type === "mousedown" || h.type === "mouseup"
                    ? (this.button = h.button)
                    : (this.button = A.Z5),
                  (this.buttons = d._buttons.slice(0)),
                  (this.element = h.target),
                  (this.ctrlKey = h.ctrlKey || !1),
                  (this.altKey = h.altKey || !1),
                  (this.shiftKey = h.shiftKey || !1),
                  (this.metaKey = h.metaKey || !1),
                  (this.event = h);
              }
            }
          },
          9273: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => d });
            var A = a(9222),
              x = a(8976),
              y = a(9939),
              c = a(9800);
            class d extends x.J {
              constructor(f) {
                super(),
                  (this._lastX = 0),
                  (this._lastY = 0),
                  (this._buttons = [!1, !1, !1]),
                  (this._lastbuttons = [!1, !1, !1]),
                  (this._upHandler = this._handleUp.bind(this)),
                  (this._downHandler = this._handleDown.bind(this)),
                  (this._moveHandler = this._handleMove.bind(this)),
                  (this._wheelHandler = this._handleWheel.bind(this)),
                  (this._contextMenuHandler = (s) => {
                    s.preventDefault();
                  }),
                  (this._target = null),
                  (this._attached = !1),
                  this.attach(f);
              }
              static isPointerLocked() {
                return (0, c.V)();
              }
              attach(f) {
                if (((this._target = f), this._attached)) return;
                this._attached = !0;
                const s = A.i.passiveEvents ? { passive: !1 } : !1;
                window.addEventListener("mouseup", this._upHandler, s),
                  window.addEventListener("mousedown", this._downHandler, s),
                  window.addEventListener("mousemove", this._moveHandler, s),
                  window.addEventListener("wheel", this._wheelHandler, s);
              }
              detach() {
                if (!this._attached) return;
                (this._attached = !1), (this._target = null);
                const f = A.i.passiveEvents ? { passive: !1 } : !1;
                window.removeEventListener("mouseup", this._upHandler, f),
                  window.removeEventListener("mousedown", this._downHandler, f),
                  window.removeEventListener("mousemove", this._moveHandler, f),
                  window.removeEventListener("wheel", this._wheelHandler, f);
              }
              disableContextMenu() {
                this._target &&
                  this._target.addEventListener(
                    "contextmenu",
                    this._contextMenuHandler
                  );
              }
              enableContextMenu() {
                this._target &&
                  this._target.removeEventListener(
                    "contextmenu",
                    this._contextMenuHandler
                  );
              }
              enablePointerLock(f, s) {
                if (!document.body.requestPointerLock) {
                  s && s();
                  return;
                }
                const l = () => {
                    f(), document.removeEventListener("pointerlockchange", l);
                  },
                  n = () => {
                    s(), document.removeEventListener("pointerlockerror", n);
                  };
                f && document.addEventListener("pointerlockchange", l, !1),
                  s && document.addEventListener("pointerlockerror", n, !1),
                  document.body.requestPointerLock();
              }
              disablePointerLock(f) {
                if (!document.exitPointerLock) return;
                const s = () => {
                  f(), document.removeEventListener("pointerlockchange", s);
                };
                f && document.addEventListener("pointerlockchange", s, !1),
                  document.exitPointerLock();
              }
              update() {
                (this._lastbuttons[0] = this._buttons[0]),
                  (this._lastbuttons[1] = this._buttons[1]),
                  (this._lastbuttons[2] = this._buttons[2]);
              }
              isPressed(f) {
                return this._buttons[f];
              }
              wasPressed(f) {
                return this._buttons[f] && !this._lastbuttons[f];
              }
              wasReleased(f) {
                return !this._buttons[f] && this._lastbuttons[f];
              }
              _handleUp(f) {
                this._buttons[f.button] = !1;
                const s = new c.C(this, f);
                s.event && this.fire(y.Ol, s);
              }
              _handleDown(f) {
                this._buttons[f.button] = !0;
                const s = new c.C(this, f);
                s.event && this.fire(y.B$, s);
              }
              _handleMove(f) {
                const s = new c.C(this, f);
                s.event &&
                  (this.fire(y.SV, s),
                  (this._lastX = s.x),
                  (this._lastY = s.y));
              }
              _handleWheel(f) {
                const s = new c.C(this, f);
                s.event && this.fire(y.yX, s);
              }
              _getTargetCoords(f) {
                const s = this._target.getBoundingClientRect(),
                  l = Math.floor(s.left),
                  n = Math.floor(s.top);
                return f.clientX < l ||
                  f.clientX >= l + this._target.clientWidth ||
                  f.clientY < n ||
                  f.clientY >= n + this._target.clientHeight
                  ? null
                  : { x: f.clientX - l, y: f.clientY - n };
              }
            }
          },
          8520: (xe, V, a) => {
            "use strict";
            a.d(V, { a: () => y });
            var A = a(8976),
              x = a(7500);
            class y extends A.J {
              constructor(d) {
                super(),
                  (this._element = null),
                  (this._startHandler = this._handleTouchStart.bind(this)),
                  (this._endHandler = this._handleTouchEnd.bind(this)),
                  (this._moveHandler = this._handleTouchMove.bind(this)),
                  (this._cancelHandler = this._handleTouchCancel.bind(this)),
                  this.attach(d);
              }
              attach(d) {
                this._element && this.detach(),
                  (this._element = d),
                  this._element.addEventListener(
                    "touchstart",
                    this._startHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "touchend",
                    this._endHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "touchmove",
                    this._moveHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "touchcancel",
                    this._cancelHandler,
                    !1
                  );
              }
              detach() {
                this._element &&
                  (this._element.removeEventListener(
                    "touchstart",
                    this._startHandler,
                    !1
                  ),
                  this._element.removeEventListener(
                    "touchend",
                    this._endHandler,
                    !1
                  ),
                  this._element.removeEventListener(
                    "touchmove",
                    this._moveHandler,
                    !1
                  ),
                  this._element.removeEventListener(
                    "touchcancel",
                    this._cancelHandler,
                    !1
                  )),
                  (this._element = null);
              }
              _handleTouchStart(d) {
                this.fire("touchstart", new x.sD(this, d));
              }
              _handleTouchEnd(d) {
                this.fire("touchend", new x.sD(this, d));
              }
              _handleTouchMove(d) {
                d.preventDefault(), this.fire("touchmove", new x.sD(this, d));
              }
              _handleTouchCancel(d) {
                this.fire("touchcancel", new x.sD(this, d));
              }
            }
          },
          7500: (xe, V, a) => {
            "use strict";
            a.d(V, { Up: () => x, rT: () => A, sD: () => y });
            function A(c) {
              let d = 0,
                h = 0,
                f = c.target;
              for (; !(f instanceof HTMLElement); ) f = f.parentNode;
              let s = f;
              do
                (d += s.offsetLeft - s.scrollLeft),
                  (h += s.offsetTop - s.scrollTop),
                  (s = s.offsetParent);
              while (s);
              return { x: c.pageX - d, y: c.pageY - h };
            }
            class x {
              constructor(d) {
                const h = A(d);
                (this.id = d.identifier),
                  (this.x = h.x),
                  (this.y = h.y),
                  (this.target = d.target),
                  (this.touch = d);
              }
            }
            class y {
              constructor(d, h) {
                if (
                  ((this.element = h.target),
                  (this.event = h),
                  (this.touches = []),
                  (this.changedTouches = []),
                  h)
                ) {
                  for (let f = 0, s = h.touches.length; f < s; f++)
                    this.touches.push(new x(h.touches[f]));
                  for (let f = 0, s = h.changedTouches.length; f < s; f++)
                    this.changedTouches.push(new x(h.changedTouches[f]));
                }
              }
              getTouchById(d, h) {
                for (let f = 0, s = h.length; f < s; f++)
                  if (h[f].id === d) return h[f];
                return null;
              }
            }
          },
          8633: (xe, V, a) => {
            "use strict";
            a.d(V, { L: () => f, l: () => h });
            var A = a(8506),
              x = a(9516),
              y = a(1870),
              c = a(2079),
              d = a(8656);
            class h {
              get(l, n, o) {
                return (
                  typeof n == "function" && ((o = n), (n = {})),
                  this.request("GET", l, n, o)
                );
              }
              post(l, n, o, i) {
                return (
                  typeof o == "function" && ((i = o), (o = {})),
                  (o.postdata = n),
                  this.request("POST", l, o, i)
                );
              }
              put(l, n, o, i) {
                return (
                  typeof o == "function" && ((i = o), (o = {})),
                  (o.postdata = n),
                  this.request("PUT", l, o, i)
                );
              }
              del(l, n, o) {
                return (
                  typeof n == "function" && ((o = n), (n = {})),
                  this.request("DELETE", l, n, o)
                );
              }
              request(l, n, o, i) {
                let e,
                  t,
                  r,
                  u = !1;
                if (
                  (typeof o == "function" && ((i = o), (o = {})),
                  o.retry &&
                    (o = Object.assign({ retries: 0, maxRetries: 5 }, o)),
                  (o.callback = i),
                  o.async == null && (o.async = !0),
                  o.headers == null && (o.headers = {}),
                  o.postdata != null)
                )
                  if (o.postdata instanceof Document) r = o.postdata;
                  else if (o.postdata instanceof FormData) r = o.postdata;
                  else if (o.postdata instanceof Object) {
                    let _ = o.headers["Content-Type"];
                    switch (
                      (_ === void 0 &&
                        ((o.headers["Content-Type"] =
                          h.ContentType.FORM_URLENCODED),
                        (_ = o.headers["Content-Type"])),
                      _)
                    ) {
                      case h.ContentType.FORM_URLENCODED: {
                        r = "";
                        let m = !0;
                        for (const g in o.postdata)
                          if (o.postdata.hasOwnProperty(g)) {
                            m ? (m = !1) : (r += "&");
                            const T = encodeURIComponent(g),
                              E = encodeURIComponent(o.postdata[g]);
                            r += `${T}=${E}`;
                          }
                        break;
                      }
                      default:
                      case h.ContentType.JSON:
                        _ == null &&
                          (o.headers["Content-Type"] = h.ContentType.JSON),
                          (r = JSON.stringify(o.postdata));
                        break;
                    }
                  } else r = o.postdata;
                if (o.cache === !1) {
                  const _ = (0, x.t)();
                  (e = new c.r(n)),
                    e.query
                      ? (e.query = e.query + "&ts=" + _)
                      : (e.query = "ts=" + _),
                    (n = e.toString());
                }
                o.query &&
                  ((e = new c.r(n)),
                  (t = (0, A.X$)(e.getQuery(), o.query)),
                  e.setQuery(t),
                  (n = e.toString()));
                const v = new XMLHttpRequest();
                v.open(l, n, o.async),
                  (v.withCredentials =
                    o.withCredentials !== void 0 ? o.withCredentials : !1),
                  (v.responseType =
                    o.responseType || this._guessResponseType(n));
                for (const _ in o.headers)
                  o.headers.hasOwnProperty(_) &&
                    v.setRequestHeader(_, o.headers[_]);
                (v.onreadystatechange = () => {
                  this._onReadyStateChange(l, n, o, v);
                }),
                  (v.onerror = () => {
                    this._onError(l, n, o, v), (u = !0);
                  });
                try {
                  v.send(r);
                } catch (_) {
                  u || o.error(v.status, v, _);
                }
                return v;
              }
              _guessResponseType(l) {
                const n = new c.r(l),
                  o = y.A.getExtension(n.path).toLowerCase();
                return h.binaryExtensions.indexOf(o) >= 0
                  ? h.ResponseType.ARRAY_BUFFER
                  : o === ".json"
                  ? h.ResponseType.JSON
                  : o === ".xml"
                  ? h.ResponseType.DOCUMENT
                  : h.ResponseType.TEXT;
              }
              _isBinaryContentType(l) {
                return (
                  [
                    h.ContentType.BASIS,
                    h.ContentType.BIN,
                    h.ContentType.DDS,
                    h.ContentType.GLB,
                    h.ContentType.MP3,
                    h.ContentType.MP4,
                    h.ContentType.OGG,
                    h.ContentType.OPUS,
                    h.ContentType.WAV,
                  ].indexOf(l) >= 0
                );
              }
              _isBinaryResponseType(l) {
                return (
                  l === h.ResponseType.ARRAY_BUFFER ||
                  l === h.ResponseType.BLOB ||
                  l === h.ResponseType.JSON
                );
              }
              _onReadyStateChange(l, n, o, i) {
                if (i.readyState === 4)
                  switch (i.status) {
                    case 0: {
                      i.responseURL && i.responseURL.startsWith("file:///")
                        ? this._onSuccess(l, n, o, i)
                        : this._onError(l, n, o, i);
                      break;
                    }
                    case 200:
                    case 201:
                    case 206:
                    case 304: {
                      this._onSuccess(l, n, o, i);
                      break;
                    }
                    default: {
                      this._onError(l, n, o, i);
                      break;
                    }
                  }
              }
              _onSuccess(l, n, o, i) {
                let e, t;
                const r = i.getResponseHeader("Content-Type");
                r && (t = r.split(";")[0].trim());
                try {
                  this._isBinaryContentType(t) ||
                  this._isBinaryResponseType(i.responseType)
                    ? (e = i.response)
                    : t === h.ContentType.JSON ||
                      n.split("?")[0].endsWith(".json")
                    ? (e = JSON.parse(i.responseText))
                    : i.responseType === h.ResponseType.DOCUMENT ||
                      t === h.ContentType.XML
                    ? (e = i.responseXML)
                    : (e = i.responseText),
                    o.callback(null, e);
                } catch (u) {
                  o.callback(u);
                }
              }
              _onError(l, n, o, i) {
                if (!o.retrying)
                  if (o.retry && o.retries < o.maxRetries) {
                    o.retries++, (o.retrying = !0);
                    const e = d.D.clamp(
                      Math.pow(2, o.retries) * h.retryDelay,
                      0,
                      o.maxRetryDelay || 5e3
                    );
                    console.log(
                      `${l}: ${n} - Error ${i.status}. Retrying in ${e} ms`
                    ),
                      setTimeout(() => {
                        (o.retrying = !1), this.request(l, n, o, o.callback);
                      }, e);
                  } else
                    o.callback(
                      i.status === 0 ? "Network error" : i.status,
                      null
                    );
              }
            }
            (h.ContentType = {
              AAC: "audio/aac",
              BASIS: "image/basis",
              BIN: "application/octet-stream",
              DDS: "image/dds",
              FORM_URLENCODED: "application/x-www-form-urlencoded",
              GIF: "image/gif",
              GLB: "model/gltf-binary",
              JPEG: "image/jpeg",
              JSON: "application/json",
              MP3: "audio/mpeg",
              MP4: "audio/mp4",
              OGG: "audio/ogg",
              OPUS: 'audio/ogg; codecs="opus"',
              PNG: "image/png",
              TEXT: "text/plain",
              WAV: "audio/x-wav",
              XML: "application/xml",
            }),
              (h.ResponseType = {
                TEXT: "text",
                ARRAY_BUFFER: "arraybuffer",
                BLOB: "blob",
                DOCUMENT: "document",
                JSON: "json",
              }),
              (h.binaryExtensions = [
                ".model",
                ".wav",
                ".ogg",
                ".mp3",
                ".mp4",
                ".m4a",
                ".aac",
                ".dds",
                ".basis",
                ".glb",
                ".opus",
              ]),
              (h.retryDelay = 100);
            const f = new h();
          },
          6046: (xe, V, a) => {
            "use strict";
            a.d(V, { X: () => s });
            var A = a(8976),
              x = a(8656),
              y = a(9104);
            const c = 0,
              d = 1,
              h = 2;
            function f(l, n) {
              return l % n || 0;
            }
            class s extends A.J {
              constructor(n, o, i) {
                super(),
                  (this.source = null),
                  (this._manager = n),
                  (this._volume =
                    i.volume !== void 0
                      ? x.D.clamp(Number(i.volume) || 0, 0, 1)
                      : 1),
                  (this._pitch =
                    i.pitch !== void 0
                      ? Math.max(0.01, Number(i.pitch) || 0)
                      : 1),
                  (this._loop = !!(i.loop !== void 0 && i.loop)),
                  (this._sound = o),
                  (this._state = h),
                  (this._suspended = !1),
                  (this._suspendEndEvent = 0),
                  (this._suspendInstanceEvents = !1),
                  (this._playWhenLoaded = !0),
                  (this._startTime = Math.max(0, Number(i.startTime) || 0)),
                  (this._duration = Math.max(0, Number(i.duration) || 0)),
                  (this._startOffset = null),
                  (this._onPlayCallback = i.onPlay),
                  (this._onPauseCallback = i.onPause),
                  (this._onResumeCallback = i.onResume),
                  (this._onStopCallback = i.onStop),
                  (this._onEndCallback = i.onEnd),
                  (0, y.U)()
                    ? ((this._startedAt = 0),
                      (this._currentTime = 0),
                      (this._currentOffset = 0),
                      (this._inputNode = null),
                      (this._connectorNode = null),
                      (this._firstNode = null),
                      (this._lastNode = null),
                      (this._waitingContextSuspension = !1),
                      this._initializeNodes(),
                      (this._endedHandler = this._onEnded.bind(this)))
                    : ((this._isReady = !1),
                      (this._loadedMetadataHandler =
                        this._onLoadedMetadata.bind(this)),
                      (this._timeUpdateHandler = this._onTimeUpdate.bind(this)),
                      (this._endedHandler = this._onEnded.bind(this)),
                      this._createSource());
              }
              set currentTime(n) {
                if (!(n < 0))
                  if (this._state === c) {
                    const o = this._suspendInstanceEvents;
                    (this._suspendInstanceEvents = !0),
                      this.stop(),
                      (this._startOffset = n),
                      this.play(),
                      (this._suspendInstanceEvents = o);
                  } else (this._startOffset = n), (this._currentTime = n);
              }
              get currentTime() {
                return this._startOffset !== null
                  ? this._startOffset
                  : this._state === d
                  ? this._currentTime
                  : this._state === h || !this.source
                  ? 0
                  : (this._updateCurrentTime(), this._currentTime);
              }
              set duration(n) {
                this._duration = Math.max(0, Number(n) || 0);
                const o = this._state === c;
                this.stop(), o && this.play();
              }
              get duration() {
                return this._sound
                  ? this._duration
                    ? f(this._duration, this._sound.duration)
                    : this._sound.duration
                  : 0;
              }
              get isPaused() {
                return this._state === d;
              }
              get isPlaying() {
                return this._state === c;
              }
              get isStopped() {
                return this._state === h;
              }
              get isSuspended() {
                return this._suspended;
              }
              set loop(n) {
                (this._loop = !!n),
                  this.source && (this.source.loop = this._loop);
              }
              get loop() {
                return this._loop;
              }
              set pitch(n) {
                (this._currentOffset = this.currentTime),
                  (this._startedAt = this._manager.context.currentTime),
                  (this._pitch = Math.max(Number(n) || 0, 0.01)),
                  this.source && (this.source.playbackRate.value = this._pitch);
              }
              get pitch() {
                return this._pitch;
              }
              set sound(n) {
                (this._sound = n),
                  this._state !== h ? this.stop() : this._createSource();
              }
              get sound() {
                return this._sound;
              }
              set startTime(n) {
                this._startTime = Math.max(0, Number(n) || 0);
                const o = this._state === c;
                this.stop(), o && this.play();
              }
              get startTime() {
                return this._startTime;
              }
              set volume(n) {
                (n = x.D.clamp(n, 0, 1)),
                  (this._volume = n),
                  this.gain &&
                    (this.gain.gain.value = n * this._manager.volume);
              }
              get volume() {
                return this._volume;
              }
              _onPlay() {
                this.fire("play"),
                  this._onPlayCallback && this._onPlayCallback(this);
              }
              _onPause() {
                this.fire("pause"),
                  this._onPauseCallback && this._onPauseCallback(this);
              }
              _onResume() {
                this.fire("resume"),
                  this._onResumeCallback && this._onResumeCallback(this);
              }
              _onStop() {
                this.fire("stop"),
                  this._onStopCallback && this._onStopCallback(this);
              }
              _onEnded() {
                if (this._suspendEndEvent > 0) {
                  this._suspendEndEvent--;
                  return;
                }
                this.fire("end"),
                  this._onEndCallback && this._onEndCallback(this),
                  this.stop();
              }
              _onManagerVolumeChange() {
                this.volume = this._volume;
              }
              _onManagerSuspend() {
                this._state === c &&
                  !this._suspended &&
                  ((this._suspended = !0), this.pause());
              }
              _onManagerResume() {
                this._suspended && ((this._suspended = !1), this.resume());
              }
              _initializeNodes() {
                (this.gain = this._manager.context.createGain()),
                  (this._inputNode = this.gain),
                  (this._connectorNode = this.gain),
                  this._connectorNode.connect(
                    this._manager.context.destination
                  );
              }
              play() {
                return (
                  this._state !== h && this.stop(),
                  (this._state = c),
                  (this._playWhenLoaded = !1),
                  this._waitingContextSuspension
                    ? !1
                    : this._manager.suspended
                    ? (this._manager.once(
                        "resume",
                        this._playAudioImmediate,
                        this
                      ),
                      (this._waitingContextSuspension = !0),
                      !1)
                    : (this._playAudioImmediate(), !0)
                );
              }
              _playAudioImmediate() {
                if (((this._waitingContextSuspension = !1), this._state !== c))
                  return;
                this.source || this._createSource();
                let n = f(this._startOffset, this.duration);
                (n = f(this._startTime + n, this._sound.duration)),
                  (this._startOffset = null),
                  this._duration
                    ? this.source.start(0, n, this._duration)
                    : this.source.start(0, n),
                  (this._startedAt = this._manager.context.currentTime),
                  (this._currentTime = 0),
                  (this._currentOffset = n),
                  (this.volume = this._volume),
                  (this.loop = this._loop),
                  (this.pitch = this._pitch),
                  this._manager.on(
                    "volumechange",
                    this._onManagerVolumeChange,
                    this
                  ),
                  this._manager.on("suspend", this._onManagerSuspend, this),
                  this._manager.on("resume", this._onManagerResume, this),
                  this._manager.on("destroy", this._onManagerDestroy, this),
                  this._suspendInstanceEvents || this._onPlay();
              }
              pause() {
                return (
                  (this._playWhenLoaded = !1),
                  this._state !== c
                    ? !1
                    : ((this._state = d),
                      this._waitingContextSuspension ||
                        (this._updateCurrentTime(),
                        this._suspendEndEvent++,
                        this.source.stop(0),
                        (this.source = null),
                        (this._startOffset = null),
                        this._suspendInstanceEvents || this._onPause()),
                      !0)
                );
              }
              resume() {
                if (this._state !== d) return !1;
                let n = this.currentTime;
                return (
                  (this._state = c),
                  this._waitingContextSuspension ||
                    (this.source || this._createSource(),
                    this._startOffset !== null &&
                      ((n = f(this._startOffset, this.duration)),
                      (n = f(this._startTime + n, this._sound.duration)),
                      (this._startOffset = null)),
                    this._duration
                      ? this.source.start(0, n, this._duration)
                      : this.source.start(0, n),
                    (this._startedAt = this._manager.context.currentTime),
                    (this._currentOffset = n),
                    (this.volume = this._volume),
                    (this.loop = this._loop),
                    (this.pitch = this._pitch),
                    (this._playWhenLoaded = !1),
                    this._suspendInstanceEvents || this._onResume()),
                  !0
                );
              }
              stop() {
                if (((this._playWhenLoaded = !1), this._state === h)) return !1;
                const n = this._state === c;
                return (
                  (this._state = h),
                  this._waitingContextSuspension ||
                    (this._manager.off(
                      "volumechange",
                      this._onManagerVolumeChange,
                      this
                    ),
                    this._manager.off("suspend", this._onManagerSuspend, this),
                    this._manager.off("resume", this._onManagerResume, this),
                    this._manager.off("destroy", this._onManagerDestroy, this),
                    (this._startedAt = 0),
                    (this._currentTime = 0),
                    (this._currentOffset = 0),
                    (this._startOffset = null),
                    this._suspendEndEvent++,
                    n && this.source && this.source.stop(0),
                    (this.source = null),
                    this._suspendInstanceEvents || this._onStop()),
                  !0
                );
              }
              setExternalNodes(n, o) {
                if (!n) {
                  console.error("The firstNode must be a valid Audio Node");
                  return;
                }
                o || (o = n);
                const i = this._manager.context.destination;
                this._firstNode !== n &&
                  (this._firstNode
                    ? this._connectorNode.disconnect(this._firstNode)
                    : this._connectorNode.disconnect(i),
                  (this._firstNode = n),
                  this._connectorNode.connect(n)),
                  this._lastNode !== o &&
                    (this._lastNode && this._lastNode.disconnect(i),
                    (this._lastNode = o),
                    this._lastNode.connect(i));
              }
              clearExternalNodes() {
                const n = this._manager.context.destination;
                this._firstNode &&
                  (this._connectorNode.disconnect(this._firstNode),
                  (this._firstNode = null)),
                  this._lastNode &&
                    (this._lastNode.disconnect(n), (this._lastNode = null)),
                  this._connectorNode.connect(n);
              }
              getExternalNodes() {
                return [this._firstNode, this._lastNode];
              }
              _createSource() {
                if (!this._sound) return null;
                const n = this._manager.context;
                return (
                  this._sound.buffer &&
                    ((this.source = n.createBufferSource()),
                    (this.source.buffer = this._sound.buffer),
                    this.source.connect(this._inputNode),
                    (this.source.onended = this._endedHandler),
                    (this.source.loopStart = f(
                      this._startTime,
                      this.source.buffer.duration
                    )),
                    this._duration &&
                      (this.source.loopEnd = Math.max(
                        this.source.loopStart,
                        f(
                          this._startTime + this._duration,
                          this.source.buffer.duration
                        )
                      ))),
                  this.source
                );
              }
              _updateCurrentTime() {
                this._currentTime = f(
                  (this._manager.context.currentTime - this._startedAt) *
                    this._pitch +
                    this._currentOffset,
                  this.duration
                );
              }
              _onManagerDestroy() {
                this.source &&
                  this._state === c &&
                  (this.source.stop(0), (this.source = null));
              }
            }
            (0, y.U)() ||
              (Object.assign(s.prototype, {
                play: function () {
                  return (
                    this._state !== h && this.stop(),
                    !this.source && !this._createSource()
                      ? !1
                      : ((this.volume = this._volume),
                        (this.pitch = this._pitch),
                        (this.loop = this._loop),
                        this.source.play(),
                        (this._state = c),
                        (this._playWhenLoaded = !1),
                        this._manager.on(
                          "volumechange",
                          this._onManagerVolumeChange,
                          this
                        ),
                        this._manager.on(
                          "suspend",
                          this._onManagerSuspend,
                          this
                        ),
                        this._manager.on("resume", this._onManagerResume, this),
                        this._manager.on(
                          "destroy",
                          this._onManagerDestroy,
                          this
                        ),
                        this._manager.suspended && this._onManagerSuspend(),
                        this._suspendInstanceEvents || this._onPlay(),
                        !0)
                  );
                },
                pause: function () {
                  return !this.source || this._state !== c
                    ? !1
                    : (this._suspendEndEvent++,
                      this.source.pause(),
                      (this._playWhenLoaded = !1),
                      (this._state = d),
                      (this._startOffset = null),
                      this._suspendInstanceEvents || this._onPause(),
                      !0);
                },
                resume: function () {
                  return !this.source || this._state !== d
                    ? !1
                    : ((this._state = c),
                      (this._playWhenLoaded = !1),
                      this.source.paused &&
                        (this.source.play(),
                        this._suspendInstanceEvents || this._onResume()),
                      !0);
                },
                stop: function () {
                  return !this.source || this._state === h
                    ? !1
                    : (this._manager.off(
                        "volumechange",
                        this._onManagerVolumeChange,
                        this
                      ),
                      this._manager.off(
                        "suspend",
                        this._onManagerSuspend,
                        this
                      ),
                      this._manager.off("resume", this._onManagerResume, this),
                      this._manager.off(
                        "destroy",
                        this._onManagerDestroy,
                        this
                      ),
                      this._suspendEndEvent++,
                      this.source.pause(),
                      (this._playWhenLoaded = !1),
                      (this._state = h),
                      (this._startOffset = null),
                      this._suspendInstanceEvents || this._onStop(),
                      !0);
                },
                setExternalNodes: function () {},
                clearExternalNodes: function () {},
                getExternalNodes: function () {
                  return [null, null];
                },
                _onLoadedMetadata: function () {
                  this.source.removeEventListener(
                    "loadedmetadata",
                    this._loadedMetadataHandler
                  ),
                    (this._isReady = !0);
                  let l = f(this._startOffset, this.duration);
                  (l = f(this._startTime + l, this._sound.duration)),
                    (this._startOffset = null),
                    (this.source.currentTime = l);
                },
                _createSource: function () {
                  return (
                    this._sound &&
                      this._sound.audio &&
                      ((this._isReady = !1),
                      (this.source = this._sound.audio.cloneNode(!0)),
                      this.source.addEventListener(
                        "loadedmetadata",
                        this._loadedMetadataHandler
                      ),
                      this.source.addEventListener(
                        "timeupdate",
                        this._timeUpdateHandler
                      ),
                      (this.source.onended = this._endedHandler)),
                    this.source
                  );
                },
                _onTimeUpdate: function () {
                  this._duration &&
                    this.source.currentTime >
                      f(
                        this._startTime + this._duration,
                        this.source.duration
                      ) &&
                    (this.loop
                      ? (this.source.currentTime = f(
                          this._startTime,
                          this.source.duration
                        ))
                      : (this.source.removeEventListener(
                          "timeupdate",
                          this._timeUpdateHandler
                        ),
                        this.source.pause(),
                        this._onEnded()));
                },
                _onManagerDestroy: function () {
                  this.source && this.source.pause();
                },
              }),
              Object.defineProperty(s.prototype, "volume", {
                get: function () {
                  return this._volume;
                },
                set: function (l) {
                  (l = x.D.clamp(l, 0, 1)),
                    (this._volume = l),
                    this.source &&
                      (this.source.volume = l * this._manager.volume);
                },
              }),
              Object.defineProperty(s.prototype, "pitch", {
                get: function () {
                  return this._pitch;
                },
                set: function (l) {
                  (this._pitch = Math.max(Number(l) || 0, 0.01)),
                    this.source && (this.source.playbackRate = this._pitch);
                },
              }),
              Object.defineProperty(s.prototype, "sound", {
                get: function () {
                  return this._sound;
                },
                set: function (l) {
                  this.stop(), (this._sound = l);
                },
              }),
              Object.defineProperty(s.prototype, "currentTime", {
                get: function () {
                  return this._startOffset !== null
                    ? this._startOffset
                    : this._state === h || !this.source
                    ? 0
                    : this.source.currentTime - this._startTime;
                },
                set: function (l) {
                  l < 0 ||
                    ((this._startOffset = l),
                    this.source &&
                      this._isReady &&
                      ((this.source.currentTime = f(
                        this._startTime + f(l, this.duration),
                        this._sound.duration
                      )),
                      (this._startOffset = null)));
                },
              }));
          },
          7365: (xe, V, a) => {
            "use strict";
            a.d(V, { S: () => f });
            var A = a(8656),
              x = a(7481),
              y = a(1145),
              c = a(9104),
              d = a(6046);
            const h = 1e4;
            class f extends d.X {
              constructor(l, n, o = {}) {
                super(l, n, o),
                  (this._position = new x.e()),
                  (this._velocity = new x.e()),
                  o.position && (this.position = o.position),
                  (this.maxDistance =
                    o.maxDistance !== void 0 ? Number(o.maxDistance) : h),
                  (this.refDistance =
                    o.refDistance !== void 0 ? Number(o.refDistance) : 1),
                  (this.rollOffFactor =
                    o.rollOffFactor !== void 0 ? Number(o.rollOffFactor) : 1),
                  (this.distanceModel =
                    o.distanceModel !== void 0 ? o.distanceModel : y.q9);
              }
              _initializeNodes() {
                (this.gain = this._manager.context.createGain()),
                  (this.panner = this._manager.context.createPanner()),
                  this.panner.connect(this.gain),
                  (this._inputNode = this.panner),
                  (this._connectorNode = this.gain),
                  this._connectorNode.connect(
                    this._manager.context.destination
                  );
              }
              set position(l) {
                this._position.copy(l);
                const n = this.panner;
                "positionX" in n
                  ? ((n.positionX.value = l.x),
                    (n.positionY.value = l.y),
                    (n.positionZ.value = l.z))
                  : n.setPosition && n.setPosition(l.x, l.y, l.z);
              }
              get position() {
                return this._position;
              }
              set velocity(l) {
                this._velocity.copy(l);
              }
              get velocity() {
                return this._velocity;
              }
              set maxDistance(l) {
                this.panner.maxDistance = l;
              }
              get maxDistance() {
                return this.panner.maxDistance;
              }
              set refDistance(l) {
                this.panner.refDistance = l;
              }
              get refDistance() {
                return this.panner.refDistance;
              }
              set rollOffFactor(l) {
                this.panner.rolloffFactor = l;
              }
              get rollOffFactor() {
                return this.panner.rolloffFactor;
              }
              set distanceModel(l) {
                this.panner.distanceModel = l;
              }
              get distanceModel() {
                return this.panner.distanceModel;
              }
            }
            if (!(0, c.U)()) {
              let s = new x.e();
              const l = function (o, i, e, t, r, u) {
                s = s.sub2(o, i);
                const v = s.length();
                if (v < e) return 1;
                if (v > t) return 0;
                let _ = 0;
                return (
                  u === y.q9
                    ? (_ = 1 - (r * (v - e)) / (t - e))
                    : u === y.Jq
                    ? (_ = e / (e + r * (v - e)))
                    : u === y.an && (_ = Math.pow(v / e, -r)),
                  A.D.clamp(_, 0, 1)
                );
              };
              Object.defineProperty(f.prototype, "position", {
                get: function () {
                  return this._position;
                },
                set: function (n) {
                  if ((this._position.copy(n), this.source)) {
                    const i = this._manager.listener.getPosition(),
                      e = l(
                        i,
                        this._position,
                        this.refDistance,
                        this.maxDistance,
                        this.rollOffFactor,
                        this.distanceModel
                      ),
                      t = this.volume;
                    this.source.volume = t * e * this._manager.volume;
                  }
                },
              }),
                Object.defineProperty(f.prototype, "maxDistance", {
                  get: function () {
                    return this._maxDistance;
                  },
                  set: function (n) {
                    this._maxDistance = n;
                  },
                }),
                Object.defineProperty(f.prototype, "refDistance", {
                  get: function () {
                    return this._refDistance;
                  },
                  set: function (n) {
                    this._refDistance = n;
                  },
                }),
                Object.defineProperty(f.prototype, "rollOffFactor", {
                  get: function () {
                    return this._rollOffFactor;
                  },
                  set: function (n) {
                    this._rollOffFactor = n;
                  },
                }),
                Object.defineProperty(f.prototype, "distanceModel", {
                  get: function () {
                    return this._distanceModel;
                  },
                  set: function (n) {
                    this._distanceModel = n;
                  },
                });
            }
          },
          5009: (xe, V, a) => {
            "use strict";
            a.d(V, { r: () => y });
            var A = a(8484),
              x = a(7481);
            class y {
              constructor(d) {
                (this._manager = d),
                  (this.position = new x.e()),
                  (this.velocity = new x.e()),
                  (this.orientation = new A.$());
              }
              getPosition() {
                return this.position;
              }
              setPosition(d) {
                this.position.copy(d);
                const h = this.listener;
                h &&
                  ("positionX" in h
                    ? ((h.positionX.value = d.x),
                      (h.positionY.value = d.y),
                      (h.positionZ.value = d.z))
                    : h.setPosition && h.setPosition(d.x, d.y, d.z));
              }
              getVelocity() {
                return this.velocity;
              }
              setVelocity(d) {}
              setOrientation(d) {
                this.orientation.copy(d);
                const h = this.listener;
                if (h) {
                  const f = d.data;
                  "forwardX" in h
                    ? ((h.forwardX.value = -f[8]),
                      (h.forwardY.value = -f[9]),
                      (h.forwardZ.value = -f[10]),
                      (h.upX.value = f[4]),
                      (h.upY.value = f[5]),
                      (h.upZ.value = f[6]))
                    : h.setOrientation &&
                      h.setOrientation(-f[8], -f[9], -f[10], f[4], f[5], f[6]);
                }
              }
              getOrientation() {
                return this.orientation;
              }
              get listener() {
                const d = this._manager.context;
                return d ? d.listener : null;
              }
            }
          },
          2378: (xe, V, a) => {
            "use strict";
            a.d(V, { x: () => s });
            var A = a(8976),
              x = a(8656),
              y = a(3231),
              c = a(8844),
              d = a(5009);
            const h = "running",
              f = ["click", "touchstart", "mousedown"];
            class s extends A.J {
              constructor() {
                super(),
                  (this._context = null),
                  (this.AudioContext =
                    (typeof AudioContext != "undefined" && AudioContext) ||
                    (typeof webkitAudioContext != "undefined" &&
                      webkitAudioContext)),
                  this.AudioContext,
                  (this._unlockHandlerFunc = this._unlockHandler.bind(this)),
                  (this._userSuspended = !1),
                  (this.listener = new d.r(this)),
                  (this._volume = 1);
              }
              set volume(n) {
                (n = x.D.clamp(n, 0, 1)),
                  (this._volume = n),
                  this.fire("volumechange", n);
              }
              get volume() {
                return this._volume;
              }
              get suspended() {
                return this._userSuspended;
              }
              get context() {
                return (
                  !this._context &&
                    this.AudioContext &&
                    ((this._context = new this.AudioContext()),
                    this._context.state !== h &&
                      this._registerUnlockListeners()),
                  this._context
                );
              }
              suspend() {
                this._userSuspended ||
                  ((this._userSuspended = !0),
                  this._context &&
                    this._context.state === h &&
                    this._suspend());
              }
              resume() {
                this._userSuspended &&
                  ((this._userSuspended = !1),
                  this._context && this._context.state !== h && this._resume());
              }
              destroy() {
                if ((this.fire("destroy"), this._context)) {
                  var n;
                  this._removeUnlockListeners(),
                    (n = this._context) == null || n.close(),
                    (this._context = null);
                }
              }
              playSound(n, o = {}) {
                let i = null;
                return y.c && ((i = new y.c(this, n, o)), i.play()), i;
              }
              playSound3d(n, o, i = {}) {
                let e = null;
                return (
                  c.j &&
                    ((e = new c.j(this, n, i)),
                    e.setPosition(o),
                    i.volume && e.setVolume(i.volume),
                    i.loop && e.setLoop(i.loop),
                    i.maxDistance && e.setMaxDistance(i.maxDistance),
                    i.minDistance && e.setMinDistance(i.minDistance),
                    i.rollOffFactor && e.setRollOffFactor(i.rollOffFactor),
                    i.distanceModel && e.setDistanceModel(i.distanceModel),
                    e.play()),
                  e
                );
              }
              _resume() {
                this._context
                  .resume()
                  .then(
                    () => {
                      const n = this._context.createBufferSource();
                      (n.buffer = this._context.createBuffer(
                        1,
                        1,
                        this._context.sampleRate
                      )),
                        n.connect(this._context.destination),
                        n.start(0),
                        (n.onended = (o) => {
                          n.disconnect(0), this.fire("resume");
                        });
                    },
                    (n) => {}
                  )
                  .catch((n) => {});
              }
              _suspend() {
                this._context
                  .suspend()
                  .then(
                    () => {
                      this.fire("suspend");
                    },
                    (n) => {}
                  )
                  .catch((n) => {});
              }
              _unlockHandler() {
                this._removeUnlockListeners(),
                  !this._userSuspended &&
                    this._context.state !== h &&
                    this._resume();
              }
              _registerUnlockListeners() {
                f.forEach((n) => {
                  window.addEventListener(n, this._unlockHandlerFunc, !1);
                });
              }
              _removeUnlockListeners() {
                f.forEach((n) => {
                  window.removeEventListener(n, this._unlockHandlerFunc, !1);
                });
              }
            }
          },
          6122: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => A });
            class A {
              constructor(y) {
                (this.audio = void 0),
                  (this.buffer = void 0),
                  y instanceof Audio ? (this.audio = y) : (this.buffer = y);
              }
              get duration() {
                let y = 0;
                return (
                  this.buffer
                    ? (y = this.buffer.duration)
                    : this.audio && (y = this.audio.duration),
                  y || 0
                );
              }
            }
          },
          5465: (xe, V, a) => {
            "use strict";
            a.d(V, { Uz: () => A, X5: () => y, bP: () => x });
            class A {
              constructor(d, h, f, s) {
                (this.time = d),
                  (this.position = h),
                  (this.rotation = f),
                  (this.scale = s);
              }
            }
            class x {
              constructor() {
                (this._name = ""), (this._keys = []);
              }
            }
            class y {
              constructor() {
                (this.name = ""),
                  (this.duration = 0),
                  (this._nodes = []),
                  (this._nodeDict = {});
              }
              getNode(d) {
                return this._nodeDict[d];
              }
              addNode(d) {
                this._nodes.push(d), (this._nodeDict[d._name] = d);
              }
              get nodes() {
                return this._nodes;
              }
            }
          },
          7284: (xe, V, a) => {
            "use strict";
            a.d(V, { E: () => c });
            var A = a(3021),
              x = a(7481);
            class y {
              constructor() {
                (this._written = !1),
                  (this._name = ""),
                  (this._keyFrames = []),
                  (this._quat = new A.k()),
                  (this._pos = new x.e()),
                  (this._scale = new x.e()),
                  (this._targetNode = null);
              }
              getTarget() {
                return this._targetNode;
              }
              setTarget(h) {
                this._targetNode = h;
              }
            }
            class c {
              constructor(h) {
                (this.looping = !0),
                  (this._animation = null),
                  (this._time = 0),
                  (this._interpolatedKeys = []),
                  (this._interpolatedKeyDict = {}),
                  (this._currKeyIndices = {}),
                  (this.graph = null);
                const f = (s) => {
                  const l = new y();
                  (l._name = s.name),
                    this._interpolatedKeys.push(l),
                    (this._interpolatedKeyDict[s.name] = l),
                    (this._currKeyIndices[s.name] = 0);
                  for (let n = 0; n < s._children.length; n++)
                    f(s._children[n]);
                };
                f(h);
              }
              set animation(h) {
                (this._animation = h), (this.currentTime = 0);
              }
              get animation() {
                return this._animation;
              }
              set currentTime(h) {
                this._time = h;
                const f = this._interpolatedKeys.length;
                for (let s = 0; s < f; s++) {
                  const n = this._interpolatedKeys[s]._name;
                  this._currKeyIndices[n] = 0;
                }
                this.addTime(0), this.updateGraph();
              }
              get currentTime() {
                return this._time;
              }
              get numNodes() {
                return this._interpolatedKeys.length;
              }
              addTime(h) {
                if (this._animation !== null) {
                  const f = this._animation._nodes,
                    s = this._animation.duration;
                  if (this._time === s && !this.looping) return;
                  if (((this._time += h), this._time > s)) {
                    this._time = this.looping ? 0 : s;
                    for (let n = 0; n < f.length; n++) {
                      const i = f[n]._name;
                      this._currKeyIndices[i] = 0;
                    }
                  } else if (this._time < 0) {
                    this._time = this.looping ? s : 0;
                    for (let n = 0; n < f.length; n++) {
                      const o = f[n],
                        i = o._name;
                      this._currKeyIndices[i] = o._keys.length - 2;
                    }
                  }
                  const l = h >= 0 ? 1 : -1;
                  for (let n = 0; n < f.length; n++) {
                    const o = f[n],
                      i = o._name,
                      e = o._keys,
                      t = this._interpolatedKeyDict[i];
                    if (t === void 0) continue;
                    let r = !1;
                    if (e.length !== 1)
                      for (
                        let u = this._currKeyIndices[i];
                        u < e.length - 1 && u >= 0;
                        u += l
                      ) {
                        const v = e[u],
                          _ = e[u + 1];
                        if (v.time <= this._time && _.time >= this._time) {
                          const m = (this._time - v.time) / (_.time - v.time);
                          t._pos.lerp(v.position, _.position, m),
                            t._quat.slerp(v.rotation, _.rotation, m),
                            t._scale.lerp(v.scale, _.scale, m),
                            (t._written = !0),
                            (this._currKeyIndices[i] = u),
                            (r = !0);
                          break;
                        }
                      }
                    (e.length === 1 ||
                      (!r && this._time === 0 && this.looping)) &&
                      (t._pos.copy(e[0].position),
                      t._quat.copy(e[0].rotation),
                      t._scale.copy(e[0].scale),
                      (t._written = !0));
                  }
                }
              }
              blend(h, f, s) {
                const l = this._interpolatedKeys.length;
                for (let n = 0; n < l; n++) {
                  const o = h._interpolatedKeys[n],
                    i = f._interpolatedKeys[n],
                    e = this._interpolatedKeys[n];
                  o._written && i._written
                    ? (e._quat.slerp(o._quat, f._interpolatedKeys[n]._quat, s),
                      e._pos.lerp(o._pos, f._interpolatedKeys[n]._pos, s),
                      e._scale.lerp(o._scale, i._scale, s),
                      (e._written = !0))
                    : o._written
                    ? (e._quat.copy(o._quat),
                      e._pos.copy(o._pos),
                      e._scale.copy(o._scale),
                      (e._written = !0))
                    : i._written &&
                      (e._quat.copy(i._quat),
                      e._pos.copy(i._pos),
                      e._scale.copy(i._scale),
                      (e._written = !0));
                }
              }
              setGraph(h) {
                if (((this.graph = h), h))
                  for (let f = 0; f < this._interpolatedKeys.length; f++) {
                    const s = this._interpolatedKeys[f],
                      l = h.findByName(s._name);
                    this._interpolatedKeys[f].setTarget(l);
                  }
                else
                  for (let f = 0; f < this._interpolatedKeys.length; f++)
                    this._interpolatedKeys[f].setTarget(null);
              }
              updateGraph() {
                if (this.graph)
                  for (let h = 0; h < this._interpolatedKeys.length; h++) {
                    const f = this._interpolatedKeys[h];
                    if (f._written) {
                      const s = f.getTarget();
                      s.localPosition.copy(f._pos),
                        s.localRotation.copy(f._quat),
                        s.localScale.copy(f._scale),
                        s._dirtyLocal || s._dirtifyLocal(),
                        (f._written = !1);
                    }
                  }
              }
            }
          },
          5041: (xe, V, a) => {
            "use strict";
            a.d(V, { w: () => x });
            var A = a(9391);
            class x {
              constructor(c, d, h, f, s = [A.uE]) {
                (this._ui = !1),
                  (this._sprite = !1),
                  (this._obj = {
                    model: [],
                    element: [],
                    sprite: [],
                    render: [],
                  }),
                  (this.id = void 0),
                  (this.name = void 0),
                  (this.dynamic = void 0),
                  (this.maxAabbSize = void 0),
                  (this.layers = void 0),
                  (this.id = c),
                  (this.name = d),
                  (this.dynamic = h),
                  (this.maxAabbSize = f),
                  (this.layers = s);
              }
            }
            (x.MODEL = "model"),
              (x.ELEMENT = "element"),
              (x.SPRITE = "sprite"),
              (x.RENDER = "render");
          },
          5833: (xe, V, a) => {
            "use strict";
            a.d(V, { Y: () => _ });
            var A = a(2209),
              x = a(7481),
              y = a(7915),
              c = a(1630),
              d = a(9391),
              h = a(7197),
              f = a(3637),
              s = a(2910),
              l = a(4471),
              n = a(5041),
              o = a(6367);
            function i(m, g) {
              if ((m && !g) || (!m && g)) return !1;
              if (((m = m.data), (g = g.data), m === g)) return !0;
              if (m instanceof Float32Array && g instanceof Float32Array) {
                if (m.length !== g.length) return !1;
                for (let T = 0; T < m.length; T++) if (m[T] !== g[T]) return !1;
                return !0;
              }
              return !1;
            }
            function e(m, g) {
              for (const T in m)
                if (m.hasOwnProperty(T) && !i(m[T], g[T])) return !1;
              for (const T in g)
                if (g.hasOwnProperty(T) && !i(g[T], m[T])) return !1;
              return !0;
            }
            const t = [0, 1, 3, 2, 3, 1],
              r = [0, 1, 3, 0, 3, 2],
              u = new A.U();
            function v(m) {
              return m.node.worldTransform.scaleSign;
            }
            class _ {
              constructor(g, T, E) {
                (this.device = g),
                  (this.rootNode = T),
                  (this.scene = E),
                  (this._init = !1),
                  (this._batchGroups = {}),
                  (this._batchGroupCounter = 0),
                  (this._batchList = []),
                  (this._dirtyGroups = []);
              }
              destroy() {
                (this.device = null),
                  (this.rootNode = null),
                  (this.scene = null),
                  (this._batchGroups = {}),
                  (this._batchList = []),
                  (this._dirtyGroups = []);
              }
              addGroup(g, T, E, M, R) {
                if (
                  (M === void 0 &&
                    ((M = this._batchGroupCounter), this._batchGroupCounter++),
                  this._batchGroups[M])
                )
                  return;
                const P = new n.w(M, g, T, E, R);
                return (this._batchGroups[M] = P), P;
              }
              removeGroup(g) {
                if (!this._batchGroups[g]) return;
                const T = [];
                for (let E = 0; E < this._batchList.length; E++)
                  this._batchList[E].batchGroupId === g
                    ? this.destroyBatch(this._batchList[E])
                    : T.push(this._batchList[E]);
                (this._batchList = T),
                  this._removeModelsFromBatchGroup(this.rootNode, g),
                  delete this._batchGroups[g];
              }
              markGroupDirty(g) {
                this._dirtyGroups.indexOf(g) < 0 && this._dirtyGroups.push(g);
              }
              getGroupByName(g) {
                const T = this._batchGroups;
                for (const E in T)
                  if (T.hasOwnProperty(E) && T[E].name === g) return T[E];
                return null;
              }
              getBatches(g) {
                const T = [],
                  E = this._batchList.length;
                for (let M = 0; M < E; M++) {
                  const R = this._batchList[M];
                  R.batchGroupId === g && T.push(R);
                }
                return T;
              }
              _removeModelsFromBatchGroup(g, T) {
                if (g.enabled) {
                  g.model &&
                    g.model.batchGroupId === T &&
                    (g.model.batchGroupId = -1),
                    g.render &&
                      g.render.batchGroupId === T &&
                      (g.render.batchGroupId = -1),
                    g.element &&
                      g.element.batchGroupId === T &&
                      (g.element.batchGroupId = -1),
                    g.sprite &&
                      g.sprite.batchGroupId === T &&
                      (g.sprite.batchGroupId = -1);
                  for (let E = 0; E < g._children.length; E++)
                    this._removeModelsFromBatchGroup(g._children[E], T);
                }
              }
              insert(g, T, E) {
                const M = this._batchGroups[T];
                M &&
                  M._obj[g].indexOf(E) < 0 &&
                  (M._obj[g].push(E), this.markGroupDirty(T));
              }
              remove(g, T, E) {
                const M = this._batchGroups[T];
                if (M) {
                  const R = M._obj[g].indexOf(E);
                  R >= 0 && (M._obj[g].splice(R, 1), this.markGroupDirty(T));
                }
              }
              _extractRender(g, T, E, M) {
                return (
                  g.render &&
                    ((T = M[g.render.batchGroupId] =
                      T.concat(g.render.meshInstances)),
                    g.render.removeFromLayers()),
                  T
                );
              }
              _extractModel(g, T, E, M) {
                return (
                  g.model &&
                    g.model.model &&
                    ((T = M[g.model.batchGroupId] =
                      T.concat(g.model.meshInstances)),
                    g.model.removeModelFromLayers()),
                  T
                );
              }
              _extractElement(g, T, E) {
                if (!g.element) return;
                let M = !1;
                g.element._text &&
                g.element._text._model.meshInstances.length > 0
                  ? (T.push(g.element._text._model.meshInstances[0]),
                    g.element.removeModelFromLayers(g.element._text._model),
                    (M = !0))
                  : g.element._image &&
                    (T.push(g.element._image._renderable.meshInstance),
                    g.element.removeModelFromLayers(
                      g.element._image._renderable.model
                    ),
                    g.element._image._renderable.unmaskMeshInstance &&
                      (T.push(g.element._image._renderable.unmaskMeshInstance),
                      (!g.element._image._renderable.unmaskMeshInstance
                        .stencilFront ||
                        !g.element._image._renderable.unmaskMeshInstance
                          .stencilBack) &&
                        (g.element._dirtifyMask(), g.element._onPrerender())),
                    (M = !0)),
                  M && (E._ui = !0);
              }
              _collectAndRemoveMeshInstances(g, T) {
                for (let E = 0; E < T.length; E++) {
                  const M = T[E],
                    R = this._batchGroups[M];
                  if (!R) continue;
                  let P = g[M];
                  P || (P = g[M] = []);
                  for (let F = 0; F < R._obj.model.length; F++)
                    P = this._extractModel(R._obj.model[F], P, R, g);
                  for (let F = 0; F < R._obj.render.length; F++)
                    P = this._extractRender(R._obj.render[F], P, R, g);
                  for (let F = 0; F < R._obj.element.length; F++)
                    this._extractElement(R._obj.element[F], P, R);
                  for (let F = 0; F < R._obj.sprite.length; F++) {
                    const b = R._obj.sprite[F];
                    b.sprite &&
                      b.sprite._meshInstance &&
                      (R.dynamic || b.sprite.sprite._renderMode === d.hA) &&
                      (P.push(b.sprite._meshInstance),
                      b.sprite.removeModelFromLayers(),
                      (R._sprite = !0),
                      (b.sprite._batchGroup = R));
                  }
                }
              }
              generate(g) {
                const T = {};
                g || (g = Object.keys(this._batchGroups));
                const E = [];
                for (let b = 0; b < this._batchList.length; b++) {
                  if (g.indexOf(this._batchList[b].batchGroupId) < 0) {
                    E.push(this._batchList[b]);
                    continue;
                  }
                  this.destroyBatch(this._batchList[b]);
                }
                if (
                  ((this._batchList = E),
                  this._collectAndRemoveMeshInstances(T, g),
                  g === this._dirtyGroups)
                )
                  this._dirtyGroups.length = 0;
                else {
                  const b = [];
                  for (let D = 0; D < this._dirtyGroups.length; D++)
                    g.indexOf(this._dirtyGroups[D]) < 0 &&
                      b.push(this._dirtyGroups[D]);
                  this._dirtyGroups = b;
                }
                let M, R, P, F;
                for (const b in T)
                  if (
                    T.hasOwnProperty(b) &&
                    ((M = T[b]), (P = this._batchGroups[b]), !!P)
                  ) {
                    R = this.prepare(
                      M,
                      P.dynamic,
                      P.maxAabbSize,
                      P._ui || P._sprite
                    );
                    for (let D = 0; D < R.length; D++)
                      (F = this.create(R[D], P.dynamic, parseInt(b, 10))),
                        F && F.addToLayers(this.scene, P.layers);
                  }
              }
              prepare(g, T, E = Number.POSITIVE_INFINITY, M) {
                if (g.length === 0) return [];
                const R = E * 0.5,
                  P = this.device.supportsBoneTextures
                    ? 1024
                    : this.device.boneLimit,
                  F = this.device.extUintElement ? 4294967295 : 65535,
                  b = new y.I(),
                  D = new y.I();
                let G = null,
                  X;
                const ie = [];
                let Q = 0;
                M &&
                  g.sort(function (J, ve) {
                    return J.drawOrder - ve.drawOrder;
                  });
                let te = g,
                  ae;
                const Z = M
                  ? function (J) {
                      G ? G.add(J.aabb) : (G = J.aabb.clone()), ae.push(J);
                    }
                  : function (J) {
                      ae.push(J);
                    };
                for (; te.length > 0; ) {
                  (ie[Q] = [te[0]]), (ae = []);
                  const J = te[0].material,
                    ve = te[0].layer,
                    _e = te[0]._shaderDefs,
                    L = te[0].parameters,
                    ge = te[0].stencilFront;
                  let k = te[0].mesh.vertexBuffer.getNumVertices();
                  const j = te[0].drawOrder;
                  b.copy(te[0].aabb);
                  const B = v(te[0]),
                    $ = te[0].mesh.vertexBuffer.format.batchingHash,
                    le = te[0].mesh.primitive[0].indexed;
                  G = null;
                  for (let O = 1; O < te.length; O++) {
                    const Y = te[O];
                    if (T && ie[Q].length >= P) {
                      ae = ae.concat(te.slice(O));
                      break;
                    }
                    if (
                      J !== Y.material ||
                      ve !== Y.layer ||
                      $ !== Y.mesh.vertexBuffer.format.batchingHash ||
                      le !== Y.mesh.primitive[0].indexed ||
                      _e !== Y._shaderDefs ||
                      k + Y.mesh.vertexBuffer.getNumVertices() > F
                    ) {
                      Z(Y);
                      continue;
                    }
                    if (
                      (D.copy(b),
                      D.add(Y.aabb),
                      D.halfExtents.x > R ||
                        D.halfExtents.y > R ||
                        D.halfExtents.z > R)
                    ) {
                      Z(Y);
                      continue;
                    }
                    if (
                      ge &&
                      (!(X = Y.stencilFront) ||
                        ge.func !== X.func ||
                        ge.zpass !== X.zpass)
                    ) {
                      Z(Y);
                      continue;
                    }
                    if (B !== v(Y)) {
                      Z(Y);
                      continue;
                    }
                    if (!e(L, Y.parameters)) {
                      Z(Y);
                      continue;
                    }
                    if (M && G && G.intersects(Y.aabb) && Y.drawOrder !== j) {
                      Z(Y);
                      continue;
                    }
                    b.add(Y.aabb),
                      (k += Y.mesh.vertexBuffer.getNumVertices()),
                      ie[Q].push(Y);
                  }
                  Q++, (te = ae);
                }
                return ie;
              }
              collectBatchedMeshData(g, T) {
                let E = null,
                  M = 0,
                  R = 0,
                  P = null;
                for (let F = 0; F < g.length; F++)
                  if (g[F].visible) {
                    const b = g[F].mesh,
                      D = b.vertexBuffer.numVertices;
                    if (((M += D), b.primitive[0].indexed))
                      R += b.primitive[0].count;
                    else {
                      const G = b.primitive[0].type;
                      (G === c.zl$ || G === c.SF$) &&
                        b.primitive[0].count === 4 &&
                        (R += 6);
                    }
                    if (!E) {
                      (P = g[F].material), (E = {});
                      const G = b.vertexBuffer.format.elements;
                      for (let X = 0; X < G.length; X++) {
                        const ie = G[X].name;
                        E[ie] = {
                          numComponents: G[X].numComponents,
                          dataType: G[X].dataType,
                          normalize: G[X].normalize,
                          count: 0,
                        };
                      }
                      T &&
                        (E[c.aVd] = {
                          numComponents: 1,
                          dataType: c.n$B,
                          normalize: !1,
                          count: 0,
                        });
                    }
                  }
                return {
                  streams: E,
                  batchNumVerts: M,
                  batchNumIndices: R,
                  material: P,
                };
              }
              create(g, T, E) {
                if (!this._init) {
                  const G =
                    "#define BONE_LIMIT " +
                    this.device.getBoneLimit() +
                    `
`;
                  (this.transformVS =
                    G +
                    `#define DYNAMICBATCH
` +
                    s.G.transformVS),
                    (this.skinTexVS = s.G.skinBatchTexVS),
                    (this.skinConstVS = s.G.skinBatchConstVS),
                    (this.vertexFormats = {}),
                    (this._init = !0);
                }
                let M = null,
                  R,
                  P,
                  F,
                  b = null;
                const D = this.collectBatchedMeshData(g, T);
                if (D.streams) {
                  const G = D.streams;
                  let X = D.material;
                  const ie = D.batchNumVerts,
                    Q = D.batchNumIndices;
                  (b = new l.l(g, T, E)), this._batchList.push(b);
                  let te,
                    ae,
                    Z,
                    J = 0,
                    ve = 0,
                    _e;
                  const L = new x.e(),
                    ge = ie <= 65535 ? Uint16Array : Uint32Array,
                    k = new ge(Q);
                  for (R in G)
                    (M = G[R]),
                      (M.typeArrayType = c.B8J[M.dataType]),
                      (M.elementByteSize = c.sYG[M.dataType]),
                      (M.buffer = new M.typeArrayType(ie * M.numComponents));
                  for (let $ = 0; $ < g.length; $++)
                    if (g[$].visible) {
                      (P = g[$].mesh),
                        (F = P.vertexBuffer.numVertices),
                        T || (_e = g[$].node.getWorldTransform());
                      for (R in G)
                        if (R !== c.aVd) {
                          M = G[R];
                          const le = new M.typeArrayType(
                              M.buffer.buffer,
                              M.elementByteSize * M.count
                            ),
                            O = P.getVertexStream(R, le) * M.numComponents;
                          if (((M.count += O), !T && M.numComponents >= 3)) {
                            if (R === c.JYe)
                              for (let Y = 0; Y < O; Y += M.numComponents)
                                L.set(le[Y], le[Y + 1], le[Y + 2]),
                                  _e.transformPoint(L, L),
                                  (le[Y] = L.x),
                                  (le[Y + 1] = L.y),
                                  (le[Y + 2] = L.z);
                            else if (R === c.XF6 || R === c.h3u) {
                              _e.invertTo3x3(u), u.transpose();
                              for (let Y = 0; Y < O; Y += M.numComponents)
                                L.set(le[Y], le[Y + 1], le[Y + 2]),
                                  u.transformVector(L, L),
                                  (le[Y] = L.x),
                                  (le[Y + 1] = L.y),
                                  (le[Y + 2] = L.z);
                            }
                          }
                        }
                      if (T) {
                        M = G[c.aVd];
                        for (let le = 0; le < F; le++) M.buffer[M.count++] = $;
                      }
                      if (P.primitive[0].indexed) {
                        (te = P.primitive[0].base), (ae = P.primitive[0].count);
                        const le = P.indexBuffer[0].getFormat();
                        Z = new c.SGA[le](P.indexBuffer[0].storage);
                      } else {
                        const le = P.primitive[0].type;
                        if (le === c.zl$ || le === c.SF$)
                          if (P.primitive[0].count === 4)
                            (te = 0), (ae = 6), (Z = le === c.zl$ ? t : r);
                          else {
                            ae = 0;
                            continue;
                          }
                      }
                      for (let le = 0; le < ae; le++)
                        k[le + ve] = Z[te + le] + J;
                      (ve += ae), (J += F);
                    }
                  P = new h.e(this.device);
                  for (R in G)
                    (M = G[R]),
                      P.setVertexStream(
                        R,
                        M.buffer,
                        M.numComponents,
                        void 0,
                        M.dataType,
                        M.normalize
                      );
                  k.length > 0 && P.setIndices(k),
                    P.update(c.Qpk, !1),
                    T &&
                      ((X = X.clone()),
                      (X.chunks.transformVS = this.transformVS),
                      (X.chunks.skinTexVS = this.skinTexVS),
                      (X.chunks.skinConstVS = this.skinConstVS),
                      X.update());
                  const j = new f.F(P, X, this.rootNode);
                  (j.castShadow = b.origMeshInstances[0].castShadow),
                    (j.parameters = b.origMeshInstances[0].parameters),
                    (j.layer = b.origMeshInstances[0].layer),
                    (j._shaderDefs = b.origMeshInstances[0]._shaderDefs),
                    (j.cull = b.origMeshInstances[0].cull);
                  const B = this._batchGroups[E];
                  if ((B && B._ui && (j.cull = !1), T)) {
                    const $ = [];
                    for (let le = 0; le < b.origMeshInstances.length; le++)
                      $.push(b.origMeshInstances[le].node);
                    j.skinInstance = new o.D(this.device, $, this.rootNode);
                  }
                  (j._updateAabb = !1),
                    (j.drawOrder = b.origMeshInstances[0].drawOrder),
                    (j.stencilFront = b.origMeshInstances[0].stencilFront),
                    (j.stencilBack = b.origMeshInstances[0].stencilBack),
                    (j.flipFacesFactor = v(b.origMeshInstances[0])),
                    (j.castShadow = b.origMeshInstances[0].castShadow),
                    (b.meshInstance = j),
                    b.updateBoundingBox();
                }
                return b;
              }
              updateAll() {
                this._dirtyGroups.length > 0 &&
                  this.generate(this._dirtyGroups);
                for (let g = 0; g < this._batchList.length; g++)
                  this._batchList[g].dynamic &&
                    this._batchList[g].updateBoundingBox();
              }
              clone(g, T) {
                const E = new l.l(T, g.dynamic, g.batchGroupId);
                this._batchList.push(E);
                const M = [];
                for (let R = 0; R < T.length; R++) M.push(T[R].node);
                return (
                  (E.meshInstance = new f.F(
                    g.meshInstance.mesh,
                    g.meshInstance.material,
                    g.meshInstance.node
                  )),
                  (E.meshInstance._updateAabb = !1),
                  (E.meshInstance.parameters = T[0].parameters),
                  (E.meshInstance.cull = T[0].cull),
                  (E.meshInstance.layer = T[0].layer),
                  g.dynamic &&
                    (E.meshInstance.skinInstance = new o.D(
                      this.device,
                      M,
                      this.rootNode
                    )),
                  (E.meshInstance.castShadow = g.meshInstance.castShadow),
                  (E.meshInstance._shader = g.meshInstance._shader.slice()),
                  (E.meshInstance.castShadow = g.meshInstance.castShadow),
                  E
                );
              }
              destroyBatch(g) {
                g.destroy(this.scene, this._batchGroups[g.batchGroupId].layers);
              }
            }
          },
          4471: (xe, V, a) => {
            "use strict";
            a.d(V, { l: () => x });
            var A = a(7915);
            class x {
              constructor(c, d, h) {
                (this._aabb = new A.I()),
                  (this.origMeshInstances = void 0),
                  (this.meshInstance = null),
                  (this.dynamic = void 0),
                  (this.batchGroupId = void 0),
                  (this.origMeshInstances = c),
                  (this.dynamic = d),
                  (this.batchGroupId = h);
              }
              destroy(c, d) {
                this.meshInstance &&
                  (this.removeFromLayers(c, d),
                  this.meshInstance.destroy(),
                  (this.meshInstance = null));
              }
              addToLayers(c, d) {
                for (let h = 0; h < d.length; h++) {
                  const f = c.layers.getLayerById(d[h]);
                  f && f.addMeshInstances([this.meshInstance]);
                }
              }
              removeFromLayers(c, d) {
                for (let h = 0; h < d.length; h++) {
                  const f = c.layers.getLayerById(d[h]);
                  f && f.removeMeshInstances([this.meshInstance]);
                }
              }
              updateBoundingBox() {
                this._aabb.copy(this.origMeshInstances[0].aabb);
                for (let c = 1; c < this.origMeshInstances.length; c++)
                  this._aabb.add(this.origMeshInstances[c].aabb);
                (this.meshInstance.aabb = this._aabb),
                  (this.meshInstance._aabbVer = 0);
              }
            }
          },
          6367: (xe, V, a) => {
            "use strict";
            a.d(V, { D: () => x });
            var A = a(8777);
            class x extends A.h {
              constructor(c, d, h) {
                super();
                const f = d.length;
                this.init(c, f),
                  (this.device = c),
                  (this.rootNode = h),
                  (this.bones = d);
              }
              updateMatrices(c, d) {}
              updateMatrixPalette(c, d) {
                const h = this.matrixPalette,
                  f = this.bones.length;
                for (let s = 0; s < f; s++) {
                  const l = this.bones[s].getWorldTransform().data,
                    n = s * 12;
                  (h[n] = l[0]),
                    (h[n + 1] = l[4]),
                    (h[n + 2] = l[8]),
                    (h[n + 3] = l[12]),
                    (h[n + 4] = l[1]),
                    (h[n + 5] = l[5]),
                    (h[n + 6] = l[9]),
                    (h[n + 7] = l[13]),
                    (h[n + 8] = l[2]),
                    (h[n + 9] = l[6]),
                    (h[n + 10] = l[10]),
                    (h[n + 11] = l[14]);
                }
                this.uploadBones(this.device);
              }
            }
          },
          5463: (xe, V, a) => {
            "use strict";
            a.d(V, { i: () => e });
            var A = a(5227),
              x = a(8484),
              y = a(7481),
              c = a(5596),
              d = a(8656),
              h = a(3221),
              f = a(9391);
            const s = new y.e(),
              l = new y.e(),
              n = new y.e(),
              o = new x.$(),
              i = [
                new y.e(),
                new y.e(),
                new y.e(),
                new y.e(),
                new y.e(),
                new y.e(),
                new y.e(),
                new y.e(),
              ];
            class e {
              constructor() {
                (this.shaderPassInfo = void 0),
                  (this._aspectRatio = 1.7777777777777777),
                  (this._aspectRatioMode = f.LF),
                  (this._calculateProjection = null),
                  (this._calculateTransform = null),
                  (this._clearColor = new A.Q(0.75, 0.75, 0.75, 1)),
                  (this._clearColorBuffer = !0),
                  (this._clearDepth = 1),
                  (this._clearDepthBuffer = !0),
                  (this._clearStencil = 0),
                  (this._clearStencilBuffer = !0),
                  (this._cullFaces = !0),
                  (this._farClip = 1e3),
                  (this._flipFaces = !1),
                  (this._fov = 45),
                  (this._frustumCulling = !0),
                  (this._horizontalFov = !1),
                  (this._layers = [f.uE, f.$9, f.CT, f.Qe, f.t0]),
                  (this._layersSet = new Set(this._layers)),
                  (this._nearClip = 0.1),
                  (this._node = null),
                  (this._orthoHeight = 10),
                  (this._projection = f.$J),
                  (this._rect = new c.Z(0, 0, 1, 1)),
                  (this._renderTarget = null),
                  (this._scissorRect = new c.Z(0, 0, 1, 1)),
                  (this._scissorRectClear = !1),
                  (this._aperture = 16),
                  (this._shutter = 0.001),
                  (this._sensitivity = 1e3),
                  (this._projMat = new x.$()),
                  (this._projMatDirty = !0),
                  (this._projMatSkybox = new x.$()),
                  (this._viewMat = new x.$()),
                  (this._viewMatDirty = !0),
                  (this._viewProjMat = new x.$()),
                  (this._viewProjMatDirty = !0),
                  (this.frustum = new h.P()),
                  (this._xr = null),
                  (this._xrProperties = {
                    horizontalFov: this._horizontalFov,
                    fov: this._fov,
                    aspectRatio: this._aspectRatio,
                    farClip: this._farClip,
                    nearClip: this._nearClip,
                  });
              }
              get fullSizeClearRect() {
                const r = this._scissorRectClear
                  ? this.scissorRect
                  : this._rect;
                return r.x === 0 && r.y === 0 && r.z === 1 && r.w === 1;
              }
              set aspectRatio(r) {
                this._aspectRatio !== r &&
                  ((this._aspectRatio = r), (this._projMatDirty = !0));
              }
              get aspectRatio() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.aspectRatio
                  : this._aspectRatio;
              }
              set aspectRatioMode(r) {
                this._aspectRatioMode !== r &&
                  ((this._aspectRatioMode = r), (this._projMatDirty = !0));
              }
              get aspectRatioMode() {
                return this._aspectRatioMode;
              }
              set calculateProjection(r) {
                (this._calculateProjection = r), (this._projMatDirty = !0);
              }
              get calculateProjection() {
                return this._calculateProjection;
              }
              set calculateTransform(r) {
                this._calculateTransform = r;
              }
              get calculateTransform() {
                return this._calculateTransform;
              }
              set clearColor(r) {
                this._clearColor.copy(r);
              }
              get clearColor() {
                return this._clearColor;
              }
              set clearColorBuffer(r) {
                this._clearColorBuffer = r;
              }
              get clearColorBuffer() {
                return this._clearColorBuffer;
              }
              set clearDepth(r) {
                this._clearDepth = r;
              }
              get clearDepth() {
                return this._clearDepth;
              }
              set clearDepthBuffer(r) {
                this._clearDepthBuffer = r;
              }
              get clearDepthBuffer() {
                return this._clearDepthBuffer;
              }
              set clearStencil(r) {
                this._clearStencil = r;
              }
              get clearStencil() {
                return this._clearStencil;
              }
              set clearStencilBuffer(r) {
                this._clearStencilBuffer = r;
              }
              get clearStencilBuffer() {
                return this._clearStencilBuffer;
              }
              set cullFaces(r) {
                this._cullFaces = r;
              }
              get cullFaces() {
                return this._cullFaces;
              }
              set farClip(r) {
                this._farClip !== r &&
                  ((this._farClip = r), (this._projMatDirty = !0));
              }
              get farClip() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.farClip
                  : this._farClip;
              }
              set flipFaces(r) {
                this._flipFaces = r;
              }
              get flipFaces() {
                return this._flipFaces;
              }
              set fov(r) {
                this._fov !== r && ((this._fov = r), (this._projMatDirty = !0));
              }
              get fov() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.fov
                  : this._fov;
              }
              set frustumCulling(r) {
                this._frustumCulling = r;
              }
              get frustumCulling() {
                return this._frustumCulling;
              }
              set horizontalFov(r) {
                this._horizontalFov !== r &&
                  ((this._horizontalFov = r), (this._projMatDirty = !0));
              }
              get horizontalFov() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.horizontalFov
                  : this._horizontalFov;
              }
              set layers(r) {
                (this._layers = r.slice(0)),
                  (this._layersSet = new Set(this._layers));
              }
              get layers() {
                return this._layers;
              }
              get layersSet() {
                return this._layersSet;
              }
              set nearClip(r) {
                this._nearClip !== r &&
                  ((this._nearClip = r), (this._projMatDirty = !0));
              }
              get nearClip() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.nearClip
                  : this._nearClip;
              }
              set node(r) {
                this._node = r;
              }
              get node() {
                return this._node;
              }
              set orthoHeight(r) {
                this._orthoHeight !== r &&
                  ((this._orthoHeight = r), (this._projMatDirty = !0));
              }
              get orthoHeight() {
                return this._orthoHeight;
              }
              set projection(r) {
                this._projection !== r &&
                  ((this._projection = r), (this._projMatDirty = !0));
              }
              get projection() {
                return this._projection;
              }
              get projectionMatrix() {
                return this._evaluateProjectionMatrix(), this._projMat;
              }
              set rect(r) {
                this._rect.copy(r);
              }
              get rect() {
                return this._rect;
              }
              set renderTarget(r) {
                this._renderTarget = r;
              }
              get renderTarget() {
                return this._renderTarget;
              }
              set scissorRect(r) {
                this._scissorRect.copy(r);
              }
              get scissorRect() {
                return this._scissorRect;
              }
              get viewMatrix() {
                if (this._viewMatDirty) {
                  const r = this._node.getWorldTransform();
                  this._viewMat.copy(r).invert(), (this._viewMatDirty = !1);
                }
                return this._viewMat;
              }
              set aperture(r) {
                this._aperture = r;
              }
              get aperture() {
                return this._aperture;
              }
              set sensitivity(r) {
                this._sensitivity = r;
              }
              get sensitivity() {
                return this._sensitivity;
              }
              set shutter(r) {
                this._shutter = r;
              }
              get shutter() {
                return this._shutter;
              }
              set xr(r) {
                this._xr !== r && ((this._xr = r), (this._projMatDirty = !0));
              }
              get xr() {
                return this._xr;
              }
              clone() {
                return new e().copy(this);
              }
              copy(r) {
                return (
                  (this._aspectRatio = r._aspectRatio),
                  (this._farClip = r._farClip),
                  (this._fov = r._fov),
                  (this._horizontalFov = r._horizontalFov),
                  (this._nearClip = r._nearClip),
                  (this._xrProperties.aspectRatio =
                    r._xrProperties.aspectRatio),
                  (this._xrProperties.farClip = r._xrProperties.farClip),
                  (this._xrProperties.fov = r._xrProperties.fov),
                  (this._xrProperties.horizontalFov =
                    r._xrProperties.horizontalFov),
                  (this._xrProperties.nearClip = r._xrProperties.nearClip),
                  (this.aspectRatioMode = r.aspectRatioMode),
                  (this.calculateProjection = r.calculateProjection),
                  (this.calculateTransform = r.calculateTransform),
                  (this.clearColor = r.clearColor),
                  (this.clearColorBuffer = r.clearColorBuffer),
                  (this.clearDepth = r.clearDepth),
                  (this.clearDepthBuffer = r.clearDepthBuffer),
                  (this.clearStencil = r.clearStencil),
                  (this.clearStencilBuffer = r.clearStencilBuffer),
                  (this.cullFaces = r.cullFaces),
                  (this.flipFaces = r.flipFaces),
                  (this.frustumCulling = r.frustumCulling),
                  (this.layers = r.layers),
                  (this.orthoHeight = r.orthoHeight),
                  (this.projection = r.projection),
                  (this.rect = r.rect),
                  (this.renderTarget = r.renderTarget),
                  (this.scissorRect = r.scissorRect),
                  (this.aperture = r.aperture),
                  (this.shutter = r.shutter),
                  (this.sensitivity = r.sensitivity),
                  (this.shaderPassInfo = r.shaderPassInfo),
                  (this._projMatDirty = !0),
                  this
                );
              }
              _updateViewProjMat() {
                (this._projMatDirty ||
                  this._viewMatDirty ||
                  this._viewProjMatDirty) &&
                  (this._viewProjMat.mul2(
                    this.projectionMatrix,
                    this.viewMatrix
                  ),
                  (this._viewProjMatDirty = !1));
              }
              worldToScreen(r, u, v, _ = new y.e()) {
                this._updateViewProjMat(),
                  this._viewProjMat.transformPoint(r, _);
                const m = this._viewProjMat.data,
                  g = r.x * m[3] + r.y * m[7] + r.z * m[11] + 1 * m[15];
                return (
                  (_.x = (_.x / g + 1) * 0.5 * u),
                  (_.y = (1 - _.y / g) * 0.5 * v),
                  _
                );
              }
              screenToWorld(r, u, v, _, m, g = new y.e()) {
                const T = this.farClip - this.nearClip;
                if (
                  (s.set(r / _, (m - u) / m, v / T),
                  s.mulScalar(2),
                  s.sub(y.e.ONE),
                  this._projection === f.$J)
                ) {
                  x.$._getPerspectiveHalfSize(
                    l,
                    this.fov,
                    this.aspectRatio,
                    this.nearClip,
                    this.horizontalFov
                  ),
                    (l.x *= s.x),
                    (l.y *= s.y);
                  const E = this._node.getWorldTransform();
                  (l.z = -this.nearClip), E.transformPoint(l, n);
                  const M = this._node.getPosition();
                  g.sub2(n, M), g.normalize(), g.mulScalar(v), g.add(M);
                } else
                  this._updateViewProjMat(),
                    o.copy(this._viewProjMat).invert(),
                    o.transformPoint(s, g);
                return g;
              }
              _evaluateProjectionMatrix() {
                if (this._projMatDirty) {
                  if (this._projection === f.$J)
                    this._projMat.setPerspective(
                      this.fov,
                      this.aspectRatio,
                      this.nearClip,
                      this.farClip,
                      this.horizontalFov
                    ),
                      this._projMatSkybox.copy(this._projMat);
                  else {
                    const r = this._orthoHeight,
                      u = r * this.aspectRatio;
                    this._projMat.setOrtho(
                      -u,
                      u,
                      -r,
                      r,
                      this.nearClip,
                      this.farClip
                    ),
                      this._projMatSkybox.setPerspective(
                        this.fov,
                        this.aspectRatio,
                        this.nearClip,
                        this.farClip
                      );
                  }
                  this._projMatDirty = !1;
                }
              }
              getProjectionMatrixSkybox() {
                return this._evaluateProjectionMatrix(), this._projMatSkybox;
              }
              getExposure() {
                const r = Math.log2(
                  (((this._aperture * this._aperture) / this._shutter) * 100) /
                    this._sensitivity
                );
                return 1 / (Math.pow(2, r) * 1.2);
              }
              getScreenSize(r) {
                if (this._projection === f.$J) {
                  const u = this._node.getPosition().distance(r.center);
                  if (u < r.radius) return 1;
                  const v = Math.asin(r.radius / u),
                    _ = Math.tan(v),
                    m = Math.tan((this.fov / 2) * d.D.DEG_TO_RAD);
                  return Math.min(_ / m, 1);
                }
                return d.D.clamp(r.radius / this._orthoHeight, 0, 1);
              }
              getFrustumCorners(r = this.nearClip, u = this.farClip) {
                const v = (this.fov * Math.PI) / 180;
                let _ =
                    this._projection === f.$J
                      ? Math.tan(v / 2) * r
                      : this._orthoHeight,
                  m = _ * this.aspectRatio;
                const g = i;
                return (
                  (g[0].x = m),
                  (g[0].y = -_),
                  (g[0].z = -r),
                  (g[1].x = m),
                  (g[1].y = _),
                  (g[1].z = -r),
                  (g[2].x = -m),
                  (g[2].y = _),
                  (g[2].z = -r),
                  (g[3].x = -m),
                  (g[3].y = -_),
                  (g[3].z = -r),
                  this._projection === f.$J &&
                    ((_ = Math.tan(v / 2) * u), (m = _ * this.aspectRatio)),
                  (g[4].x = m),
                  (g[4].y = -_),
                  (g[4].z = -u),
                  (g[5].x = m),
                  (g[5].y = _),
                  (g[5].z = -u),
                  (g[6].x = -m),
                  (g[6].y = _),
                  (g[6].z = -u),
                  (g[7].x = -m),
                  (g[7].y = -_),
                  (g[7].z = -u),
                  g
                );
              }
              setXrProperties(r) {
                Object.assign(this._xrProperties, r), (this._projMatDirty = !0);
              }
            }
          },
          1232: (xe, V, a) => {
            "use strict";
            a.d(V, { e: () => n });
            var A = a(8976);
            const x = {
              equals: function (o, i) {
                if (o.size !== i.size) return !1;
                for (const e of o) if (!i.has(e)) return !1;
                return !0;
              },
            };
            var y = a(1014),
              c = a(9391);
            class d {
              constructor() {
                (this.layerIndex = 0),
                  (this.cameraIndex = 0),
                  (this.camera = null),
                  (this.renderTarget = null),
                  (this.lightClusters = null),
                  (this.clearColor = !1),
                  (this.clearDepth = !1),
                  (this.clearStencil = !1),
                  (this.triggerPostprocess = !1),
                  (this.firstCameraUse = !1),
                  (this.lastCameraUse = !1),
                  (this.directionalLightsSet = new Set()),
                  (this.directionalLights = []),
                  (this.directionalLightsIndices = []),
                  (this.viewBindGroups = []);
              }
              destroy() {
                this.viewBindGroups.forEach((i) => {
                  i.defaultUniformBuffer.destroy(), i.destroy();
                }),
                  (this.viewBindGroups.length = 0);
              }
              get hasDirectionalShadowLights() {
                return this.directionalLights.length > 0;
              }
              reset() {
                (this.lightClusters = null),
                  this.directionalLightsSet.clear(),
                  (this.directionalLights.length = 0),
                  (this.directionalLightsIndices.length = 0);
              }
              isLayerEnabled(i) {
                return (
                  i.layerList[this.layerIndex].enabled &&
                  i.subLayerEnabled[this.layerIndex]
                );
              }
              collectDirectionalLights(i, e, t) {
                this.directionalLightsSet.clear(),
                  (this.directionalLights.length = 0),
                  (this.directionalLightsIndices.length = 0);
                for (let r = 0; r < e.length; r++) {
                  const u = e[r];
                  if (u.castShadows) {
                    for (let v = 0; v < i.length; v++)
                      if (
                        i[v]._splitLights[c.kx].indexOf(u) >= 0 &&
                        !this.directionalLightsSet.has(u)
                      ) {
                        this.directionalLightsSet.add(u),
                          this.directionalLights.push(u);
                        const _ = t.indexOf(u);
                        this.directionalLightsIndices.push(_);
                      }
                  }
                }
              }
            }
            var h = a(7087);
            class f {
              constructor() {
                (this.shadowCastersSet = new Set()),
                  (this.shadowCastersList = []);
              }
              clearShadowCasters() {
                this.shadowCastersSet.clear(),
                  (this.shadowCastersList.length = 0);
              }
              addShadowCasters(i) {
                for (let e = 0; e < i.length; e++) {
                  const t = i[e];
                  this.shadowCastersSet.has(t) ||
                    (this.shadowCastersSet.add(t),
                    this.shadowCastersList.push(t));
                }
              }
            }
            const s = new Set(),
              l = [];
            class n extends A.J {
              constructor(i = "Untitled") {
                super(),
                  (this.layerList = []),
                  (this.layerIdMap = new Map()),
                  (this.layerNameMap = new Map()),
                  (this.subLayerList = []),
                  (this.subLayerEnabled = []),
                  (this.cameras = []),
                  (this._renderActions = []),
                  (this.name = i),
                  (this._opaqueOrder = {}),
                  (this._transparentOrder = {}),
                  (this._dirty = !1),
                  (this._dirtyBlend = !1),
                  (this._dirtyLights = !1),
                  (this._dirtyCameras = !1),
                  (this._meshInstances = []),
                  (this._meshInstancesSet = new Set()),
                  (this._lights = []),
                  (this._lightsMap = new Map()),
                  (this._lightCompositionData = []),
                  (this._splitLights = [[], [], []]),
                  (this._worldClusters = []),
                  (this._emptyWorldClusters = null);
              }
              destroy() {
                this._emptyWorldClusters &&
                  (this._emptyWorldClusters.destroy(),
                  (this._emptyWorldClusters = null)),
                  this._worldClusters.forEach((i) => {
                    i.destroy();
                  }),
                  (this._worldClusters = null),
                  this._renderActions.forEach((i) => i.destroy()),
                  (this._renderActions = null);
              }
              getEmptyWorldClusters(i) {
                return (
                  this._emptyWorldClusters ||
                    ((this._emptyWorldClusters = new h.q(i)),
                    (this._emptyWorldClusters.name = "ClusterEmpty"),
                    this._emptyWorldClusters.update([], !1, null)),
                  this._emptyWorldClusters
                );
              }
              _splitLightsArray(i) {
                const e = i._splitLights;
                (e[c.kx].length = 0),
                  (e[c.dG].length = 0),
                  (e[c.Gy].length = 0);
                const t = i._lights;
                for (let r = 0; r < t.length; r++) {
                  const u = t[r];
                  u.enabled && e[u._type].push(u);
                }
                e[c.kx].sort((r, u) => r.key - u.key),
                  e[c.dG].sort((r, u) => r.key - u.key),
                  e[c.Gy].sort((r, u) => r.key - u.key);
              }
              _update(i, e = !1) {
                const t = this.layerList.length;
                let r = 0;
                if (!this._dirty || !this._dirtyLights || !this._dirtyCameras)
                  for (let _ = 0; _ < t; _++) {
                    const m = this.layerList[_];
                    m._dirty && (this._dirty = !0),
                      m._dirtyLights && (this._dirtyLights = !0),
                      m._dirtyCameras && (this._dirtyCameras = !0);
                  }
                function u(_, m, g) {
                  let T = !1;
                  const E = g.length;
                  for (let M = 0; M < E; M++) {
                    const R = g[M];
                    if (!m.has(R)) {
                      m.add(R), _.push(R);
                      const P = R.material;
                      P && P._dirtyBlend && ((T = !0), (P._dirtyBlend = !1));
                    }
                  }
                  return T;
                }
                if (this._dirty) {
                  (r |= c.s0),
                    (this._meshInstances.length = 0),
                    this._meshInstancesSet.clear();
                  for (let _ = 0; _ < t; _++) {
                    const m = this.layerList[_];
                    m.passThrough ||
                      ((this._dirtyBlend =
                        u(
                          this._meshInstances,
                          this._meshInstancesSet,
                          m.opaqueMeshInstances
                        ) || this._dirtyBlend),
                      (this._dirtyBlend =
                        u(
                          this._meshInstances,
                          this._meshInstancesSet,
                          m.transparentMeshInstances
                        ) || this._dirtyBlend)),
                      (m._dirty = !1);
                  }
                  this._dirty = !1;
                }
                function v(_, m, g) {
                  for (let T = 0; T < m.length; )
                    m[T].transparent === g
                      ? (_.push(m[T]), (m[T] = m[m.length - 1]), m.length--)
                      : T++;
                }
                if (this._dirtyBlend) {
                  r |= c.Fe;
                  for (let _ = 0; _ < t; _++) {
                    const m = this.layerList[_];
                    m.passThrough ||
                      (v(m.opaqueMeshInstances, m.transparentMeshInstances, !1),
                      v(m.transparentMeshInstances, m.opaqueMeshInstances, !0));
                  }
                  this._dirtyBlend = !1;
                }
                if (
                  (this._dirtyLights &&
                    ((r |= c.DA),
                    (this._dirtyLights = !1),
                    this.updateLights()),
                  r && this.updateShadowCasters(),
                  this._dirtyCameras || r & c.DA)
                ) {
                  (this._dirtyCameras = !1),
                    (r |= c.mJ),
                    (this.cameras.length = 0);
                  for (let g = 0; g < t; g++) {
                    const T = this.layerList[g];
                    T._dirtyCameras = !1;
                    for (let E = 0; E < T.cameras.length; E++) {
                      const M = T.cameras[E];
                      this.cameras.indexOf(M) < 0 && this.cameras.push(M);
                    }
                  }
                  this.cameras.length > 1 && (0, y.Z)(this.cameras);
                  const _ = [];
                  let m = 0;
                  for (let g = 0; g < this.cameras.length; g++) {
                    const T = this.cameras[g];
                    _.length = 0;
                    let E = !0;
                    const M = m;
                    let R = null,
                      P = !1;
                    for (let F = 0; F < t; F++) {
                      const b = this.layerList[F],
                        D = this.subLayerEnabled[F];
                      if (
                        b &&
                        D &&
                        b.cameras.length > 0 &&
                        T.layers.indexOf(b.id) >= 0
                      ) {
                        _.push(b),
                          !P &&
                            b.id === T.disablePostEffectsLayer &&
                            ((P = !0), R && (R.triggerPostprocess = !0));
                        const G = b.cameras.indexOf(T);
                        G >= 0 &&
                          ((R = this.addRenderAction(
                            this._renderActions,
                            m,
                            b,
                            F,
                            G,
                            E,
                            P
                          )),
                          m++,
                          (E = !1));
                      }
                    }
                    M < m &&
                      (this._renderActions[M].collectDirectionalLights(
                        _,
                        this._splitLights[c.kx],
                        this._lights
                      ),
                      (R.lastCameraUse = !0)),
                      !P && R && (R.triggerPostprocess = !0),
                      T.renderTarget &&
                        T.postEffectsEnabled &&
                        this.propagateRenderTarget(M - 1, T);
                  }
                  for (let g = m; g < this._renderActions.length; g++)
                    this._renderActions[g].destroy();
                  this._renderActions.length = m;
                }
                return (
                  r & (c.mJ | c.DA | c.s0) &&
                    e &&
                    this.allocateLightClusters(i),
                  r & (c.DA | c.DA) && this._logRenderActions(),
                  r
                );
              }
              updateShadowCasters() {
                const i = this._lights.length;
                for (let t = 0; t < i; t++)
                  this._lightCompositionData[t].clearShadowCasters();
                const e = this.layerList.length;
                for (let t = 0; t < e; t++) {
                  const r = this.layerList[t];
                  if (!s.has(r)) {
                    s.add(r);
                    const u = r._lights;
                    for (let v = 0; v < u.length; v++)
                      if (u[v].castShadows) {
                        const _ = this._lightsMap.get(u[v]);
                        this._lightCompositionData[_].addShadowCasters(
                          r.shadowCasters
                        );
                      }
                  }
                }
                s.clear();
              }
              updateLights() {
                (this._lights.length = 0), this._lightsMap.clear();
                const i = this.layerList.length;
                for (let t = 0; t < i; t++) {
                  const r = this.layerList[t];
                  if (!s.has(r)) {
                    s.add(r);
                    const u = r._lights;
                    for (let v = 0; v < u.length; v++) {
                      const _ = u[v];
                      let m = this._lightsMap.get(_);
                      if (m === void 0) {
                        (m = this._lights.length),
                          this._lightsMap.set(_, m),
                          this._lights.push(_);
                        let g = this._lightCompositionData[m];
                        g ||
                          ((g = new f()), (this._lightCompositionData[m] = g));
                      }
                    }
                  }
                  this._splitLightsArray(r), (r._dirtyLights = !1);
                }
                s.clear(), this._splitLightsArray(this);
                const e = this._lights.length;
                this._lightCompositionData.length = e;
              }
              findCompatibleCluster(i, e, t) {
                for (let r = 0; r < e; r++) {
                  const u = this._renderActions[r],
                    v = this.layerList[u.layerIndex];
                  if (
                    u.lightClusters !== t &&
                    (i === v ||
                      (u.lightClusters &&
                        x.equals(i._clusteredLightsSet, v._clusteredLightsSet)))
                  )
                    return u.lightClusters;
                }
                return null;
              }
              allocateLightClusters(i) {
                l.push(...this._worldClusters);
                const e = this.getEmptyWorldClusters(i);
                this._worldClusters.length = 0;
                const t = this._renderActions.length;
                for (let r = 0; r < t; r++) {
                  const u = this._renderActions[r],
                    v = this.layerList[u.layerIndex];
                  if (
                    ((u.lightClusters = null),
                    v.hasClusteredLights &&
                      (this.subLayerList[u.layerIndex]
                        ? v.transparentMeshInstances
                        : v.opaqueMeshInstances
                      ).length)
                  ) {
                    let g = this.findCompatibleCluster(v, r, e);
                    g ||
                      (l.length && (g = l.pop()),
                      g || (g = new h.q(i)),
                      (g.name = "Cluster-" + this._worldClusters.length),
                      this._worldClusters.push(g)),
                      (u.lightClusters = g);
                  }
                  u.lightClusters || (u.lightClusters = e);
                }
                l.forEach((r) => {
                  r.destroy();
                }),
                  (l.length = 0);
              }
              addRenderAction(i, e, t, r, u, v, _) {
                let m = i[e];
                m || (m = i[e] = new d());
                let g = t.renderTarget;
                const T = t.cameras[u];
                T && T.renderTarget && t.id !== c.$9 && (g = T.renderTarget);
                let E = !1;
                for (let b = e - 1; b >= 0; b--)
                  if (i[b].camera === T && i[b].renderTarget === g) {
                    E = !0;
                    break;
                  }
                const M = v || !E;
                let R = M ? T.clearColorBuffer : !1,
                  P = M ? T.clearDepthBuffer : !1,
                  F = M ? T.clearStencilBuffer : !1;
                return (
                  R || (R = t.clearColorBuffer),
                  P || (P = t.clearDepthBuffer),
                  F || (F = t.clearStencilBuffer),
                  _ && T.postEffectsEnabled && (g = null),
                  m.reset(),
                  (m.triggerPostprocess = !1),
                  (m.layerIndex = r),
                  (m.cameraIndex = u),
                  (m.camera = T),
                  (m.renderTarget = g),
                  (m.clearColor = R),
                  (m.clearDepth = P),
                  (m.clearStencil = F),
                  (m.firstCameraUse = v),
                  (m.lastCameraUse = !1),
                  m
                );
              }
              propagateRenderTarget(i, e) {
                for (let t = i; t >= 0; t--) {
                  const r = this._renderActions[t],
                    u = this.layerList[r.layerIndex];
                  if (r.renderTarget && u.id !== c.$9) break;
                  if (u.id === c.$9) continue;
                  const v = r == null ? void 0 : r.camera.camera;
                  if (
                    v &&
                    (!e.camera.rect.equals(v.rect) ||
                      !e.camera.scissorRect.equals(v.scissorRect))
                  )
                    break;
                  r.renderTarget = e.renderTarget;
                }
              }
              _logRenderActions() {}
              _isLayerAdded(i) {
                return this.layerIdMap.get(i.id) === i;
              }
              _isSublayerAdded(i, e) {
                for (let t = 0; t < this.layerList.length; t++)
                  if (this.layerList[t] === i && this.subLayerList[t] === e)
                    return !0;
                return !1;
              }
              push(i) {
                this._isLayerAdded(i) ||
                  (this.layerList.push(i),
                  this.layerList.push(i),
                  (this._opaqueOrder[i.id] = this.subLayerList.push(!1) - 1),
                  (this._transparentOrder[i.id] =
                    this.subLayerList.push(!0) - 1),
                  this.subLayerEnabled.push(!0),
                  this.subLayerEnabled.push(!0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i));
              }
              insert(i, e) {
                if (this._isLayerAdded(i)) return;
                this.layerList.splice(e, 0, i, i),
                  this.subLayerList.splice(e, 0, !1, !0);
                const t = this.layerList.length;
                this._updateOpaqueOrder(e, t - 1),
                  this._updateTransparentOrder(e, t - 1),
                  this.subLayerEnabled.splice(e, 0, !0, !0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i);
              }
              remove(i) {
                let e = this.layerList.indexOf(i);
                for (
                  delete this._opaqueOrder[e], delete this._transparentOrder[e];
                  e >= 0;

                )
                  this.layerList.splice(e, 1),
                    this.subLayerList.splice(e, 1),
                    this.subLayerEnabled.splice(e, 1),
                    (e = this.layerList.indexOf(i)),
                    (this._dirty = !0),
                    (this._dirtyLights = !0),
                    (this._dirtyCameras = !0),
                    this.fire("remove", i);
                const t = this.layerList.length;
                this._updateOpaqueOrder(0, t - 1),
                  this._updateTransparentOrder(0, t - 1),
                  this._updateLayerMaps();
              }
              pushOpaque(i) {
                this._isSublayerAdded(i, !1) ||
                  (this.layerList.push(i),
                  (this._opaqueOrder[i.id] = this.subLayerList.push(!1) - 1),
                  this.subLayerEnabled.push(!0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i));
              }
              insertOpaque(i, e) {
                if (this._isSublayerAdded(i, !1)) return;
                this.layerList.splice(e, 0, i),
                  this.subLayerList.splice(e, 0, !1);
                const t = this.subLayerList.length;
                this._updateOpaqueOrder(e, t - 1),
                  this.subLayerEnabled.splice(e, 0, !0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i);
              }
              removeOpaque(i) {
                for (let e = 0, t = this.layerList.length; e < t; e++)
                  if (this.layerList[e] === i && !this.subLayerList[e]) {
                    this.layerList.splice(e, 1),
                      this.subLayerList.splice(e, 1),
                      t--,
                      this._updateOpaqueOrder(e, t - 1),
                      this.subLayerEnabled.splice(e, 1),
                      (this._dirty = !0),
                      (this._dirtyLights = !0),
                      (this._dirtyCameras = !0),
                      this.layerList.indexOf(i) < 0 && this.fire("remove", i);
                    break;
                  }
                this._updateLayerMaps();
              }
              pushTransparent(i) {
                this._isSublayerAdded(i, !0) ||
                  (this.layerList.push(i),
                  (this._transparentOrder[i.id] =
                    this.subLayerList.push(!0) - 1),
                  this.subLayerEnabled.push(!0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i));
              }
              insertTransparent(i, e) {
                if (this._isSublayerAdded(i, !0)) return;
                this.layerList.splice(e, 0, i),
                  this.subLayerList.splice(e, 0, !0);
                const t = this.subLayerList.length;
                this._updateTransparentOrder(e, t - 1),
                  this.subLayerEnabled.splice(e, 0, !0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i);
              }
              removeTransparent(i) {
                for (let e = 0, t = this.layerList.length; e < t; e++)
                  if (this.layerList[e] === i && this.subLayerList[e]) {
                    this.layerList.splice(e, 1),
                      this.subLayerList.splice(e, 1),
                      t--,
                      this._updateTransparentOrder(e, t - 1),
                      this.subLayerEnabled.splice(e, 1),
                      (this._dirty = !0),
                      (this._dirtyLights = !0),
                      (this._dirtyCameras = !0),
                      this.layerList.indexOf(i) < 0 && this.fire("remove", i);
                    break;
                  }
                this._updateLayerMaps();
              }
              _getSublayerIndex(i, e) {
                let t = this.layerList.indexOf(i);
                return t < 0 ||
                  (this.subLayerList[t] !== e &&
                    ((t = this.layerList.indexOf(i, t + 1)),
                    t < 0 || this.subLayerList[t] !== e))
                  ? -1
                  : t;
              }
              getOpaqueIndex(i) {
                return this._getSublayerIndex(i, !1);
              }
              getTransparentIndex(i) {
                return this._getSublayerIndex(i, !0);
              }
              _updateLayerMaps() {
                this.layerIdMap.clear(), this.layerNameMap.clear();
                for (let i = 0; i < this.layerList.length; i++) {
                  const e = this.layerList[i];
                  this.layerIdMap.set(e.id, e),
                    this.layerNameMap.set(e.name, e);
                }
              }
              getLayerById(i) {
                var e;
                return (e = this.layerIdMap.get(i)) != null ? e : null;
              }
              getLayerByName(i) {
                var e;
                return (e = this.layerNameMap.get(i)) != null ? e : null;
              }
              _updateOpaqueOrder(i, e) {
                for (let t = i; t <= e; t++)
                  this.subLayerList[t] === !1 &&
                    (this._opaqueOrder[this.layerList[t].id] = t);
              }
              _updateTransparentOrder(i, e) {
                for (let t = i; t <= e; t++)
                  this.subLayerList[t] === !0 &&
                    (this._transparentOrder[this.layerList[t].id] = t);
              }
              _sortLayersDescending(i, e, t) {
                let r = -1,
                  u = -1;
                for (let v = 0, _ = i.length; v < _; v++) {
                  const m = i[v];
                  t.hasOwnProperty(m) && (r = Math.max(r, t[m]));
                }
                for (let v = 0, _ = e.length; v < _; v++) {
                  const m = e[v];
                  t.hasOwnProperty(m) && (u = Math.max(u, t[m]));
                }
                return r === -1 && u !== -1
                  ? 1
                  : u === -1 && r !== -1
                  ? -1
                  : u - r;
              }
              sortTransparentLayers(i, e) {
                return this._sortLayersDescending(i, e, this._transparentOrder);
              }
              sortOpaqueLayers(i, e) {
                return this._sortLayersDescending(i, e, this._opaqueOrder);
              }
            }
          },
          9391: (xe, V, a) => {
            "use strict";
            a.d(V, {
              $1: () => T,
              $2: () => Ps,
              $7: () => J,
              $9: () => M,
              $J: () => ke,
              $M: () => h,
              $x: () => Js,
              Af: () => es,
              As: () => ls,
              Av: () => bt,
              BE: () => li,
              BS: () => O,
              BV: () => zt,
              CD: () => Ne,
              CO: () => wt,
              CT: () => R,
              Ck: () => pe,
              Cn: () => Je,
              DA: () => ii,
              DT: () => j,
              Df: () => Pe,
              E5: () => ss,
              EB: () => I,
              FC: () => Xe,
              Fe: () => mt,
              Gn: () => et,
              Gy: () => X,
              HG: () => f,
              HV: () => o,
              Hx: () => W,
              I1: () => Pt,
              IT: () => Ts,
              IY: () => ds,
              JQ: () => N,
              Jb: () => nt,
              Jd: () => tt,
              Jo: () => g,
              Jq: () => $e,
              KM: () => me,
              KQ: () => Oe,
              L$: () => rt,
              LF: () => Ot,
              LL: () => s,
              M2: () => ue,
              M5: () => ze,
              MF: () => _e,
              Mk: () => $,
              Mq: () => B,
              N9: () => bs,
              Ni: () => A,
              Nk: () => ve,
              Nt: () => Xt,
              OP: () => Tt,
              OZ: () => Ge,
              On: () => Ye,
              PD: () => Cs,
              Q$: () => ct,
              QK: () => q,
              Qe: () => F,
              Ql: () => he,
              R9: () => $s,
              RD: () => Ue,
              RV: () => r,
              Rj: () => c,
              Rz: () => it,
              SB: () => H,
              SU: () => v,
              SY: () => Z,
              Su: () => ft,
              Sz: () => qt,
              TE: () => se,
              Tp: () => Te,
              WL: () => de,
              WW: () => Ke,
              WX: () => Y,
              Ww: () => Ce,
              XE: () => xt,
              Xj: () => Qe,
              YU: () => Ae,
              Yn: () => is,
              Z7: () => n,
              ZS: () => e,
              Zt: () => w,
              _S: () => Ms,
              aP: () => Zt,
              b2: () => yt,
              bY: () => d,
              be: () => lt,
              c1: () => Rt,
              c2: () => ut,
              ce: () => G,
              cz: () => Fe,
              dG: () => D,
              dc: () => x,
              e3: () => ot,
              eQ: () => hi,
              fJ: () => K,
              gF: () => fs,
              gp: () => ye,
              hA: () => us,
              hF: () => Ft,
              hI: () => Nt,
              hP: () => t,
              hV: () => u,
              hc: () => Le,
              i9: () => y,
              iU: () => ae,
              ip: () => z,
              j0: () => Q,
              jZ: () => vs,
              jy: () => Lt,
              k: () => ce,
              kx: () => b,
              l3: () => ht,
              lU: () => Os,
              ll: () => At,
              m2: () => _,
              mJ: () => je,
              nc: () => re,
              oR: () => ge,
              on: () => Me,
              ov: () => De,
              pB: () => _t,
              qK: () => we,
              qX: () => i,
              rG: () => Gs,
              rU: () => ie,
              rZ: () => l,
              s0: () => ci,
              t0: () => P,
              t4: () => vt,
              tE: () => Ze,
              tT: () => Ve,
              tt: () => te,
              uE: () => E,
              uJ: () => fe,
              uT: () => kt,
              v2: () => L,
              vJ: () => le,
              vT: () => Qt,
              w8: () => gt,
              wA: () => ne,
              xv: () => k,
              yh: () => Ie,
              yr: () => at,
              z5: () => $t,
              z8: () => Bt,
              zW: () => m,
              zp: () => os,
            });
            const A = 0,
              x = 1,
              y = 2,
              c = 3,
              d = 4,
              h = 5,
              f = 6,
              s = 7,
              l = 8,
              n = 9,
              o = 10,
              i = "none",
              e = "linear",
              t = "exp",
              r = "exp2",
              u = 0,
              v = 2,
              _ = 0,
              m = 1,
              g = 2,
              T = 15,
              E = 0,
              M = 1,
              R = 2,
              P = 3,
              F = 4,
              b = 0,
              D = 1,
              G = D,
              X = 2,
              ie = 3,
              Q = 0,
              te = 1,
              ae = 2,
              Z = 3,
              J = 0,
              ve = 1,
              _e = 0,
              L = 0,
              ge = 1,
              k = 2,
              j = 3,
              B = 4,
              $ = 5,
              le = 6,
              O = {};
            (O[_e] = "PCF3"),
              (O[ge] = "VSM8"),
              (O[k] = "VSM16"),
              (O[j] = "VSM32"),
              (O[B] = "PCF5"),
              (O[$] = "PCF1"),
              (O[le] = "PCSS");
            const Y = 0,
              ne = 1,
              de = 0,
              re = 1,
              I = 2,
              w = 3,
              N = 0,
              W = 1,
              he = 0,
              ue = 1,
              ye = 0,
              Oe = 1,
              Ae = 2,
              ke = 0,
              Ue = 1,
              Ge = 0,
              ht = 1,
              me = 2,
              z = 0,
              K = 1,
              Te = 0,
              H = 1,
              q = "mul",
              se = "add",
              Ce = "screen",
              we = "overlay",
              Me = "min",
              Ie = "max",
              Le = 0,
              tt = 1,
              vt = 2,
              it = 3,
              At = 0,
              Rt = 1,
              Ft = 2,
              ut = 3,
              Pt = 4,
              bt = 0,
              Zt = 1,
              Xt = 2,
              yt = 1,
              Pe = 2,
              $e = 4,
              Je = 8,
              rt = 16,
              ct = 32,
              Ve = 64,
              wt = 128,
              at = 256,
              ce = 512,
              pe = 1024,
              De = 2048,
              fe = 4096,
              Ze = 8192,
              Ne = 0,
              Ye = 1,
              Ke = 2,
              nt = 0,
              ot = 1,
              ze = 2,
              et = 0,
              _t = 1,
              Qe = 1,
              lt = 2,
              xt = 4,
              Tt = 0,
              ft = 1,
              gt = 2,
              Fe = 3,
              Qt = 4,
              zt = "forward",
              Lt = "debug_albedo",
              $t = "debug_world_normal",
              Bt = "debug_opacity",
              Nt = "debug_specularity",
              es = "debug_gloss",
              kt = "debug_metalness",
              ds = "debug_ao",
              os = "debug_emission",
              ls = "debug_lighting",
              Ps = "debug_uv0",
              us = 0,
              Xe = 1,
              vs = 2,
              fs = 0,
              bs = 1,
              Ms = 0,
              Ts = 1,
              Js = 2,
              Os = 0,
              li = 1,
              $s = 2,
              Cs = 3,
              Gs = 4,
              hi = 5,
              ci = 1,
              ii = 2,
              je = 4,
              mt = 8,
              Ot = 0,
              ss = 1,
              qt = 0,
              is = 1;
          },
          3035: (xe, V, a) => {
            "use strict";
            a.d(V, { t: () => E });
            var A = a(8976),
              x = a(244),
              y = a(2209),
              c = a(8484),
              d = a(3021),
              h = a(7481);
            const f = new c.$(),
              s = new h.e(),
              l = new d.k(),
              n = new d.k(),
              o = new h.e(),
              i = new h.e(),
              e = new c.$(),
              t = new d.k(),
              r = new h.e(),
              u = new c.$(),
              v = new d.k(),
              _ = new d.k(),
              m = new c.$(),
              g = new h.e(),
              T = new h.e();
            class E extends A.J {
              constructor(R = "Untitled") {
                super(),
                  (this.name = void 0),
                  (this.tags = new x.Y(this)),
                  (this._labels = {}),
                  (this.localPosition = new h.e()),
                  (this.localRotation = new d.k()),
                  (this.localScale = new h.e(1, 1, 1)),
                  (this.localEulerAngles = new h.e()),
                  (this.position = new h.e()),
                  (this.rotation = new d.k()),
                  (this.eulerAngles = new h.e()),
                  (this._scale = null),
                  (this.localTransform = new c.$()),
                  (this._dirtyLocal = !1),
                  (this._aabbVer = 0),
                  (this._frozen = !1),
                  (this.worldTransform = new c.$()),
                  (this._dirtyWorld = !1),
                  (this._worldScaleSign = 0),
                  (this._normalMatrix = new y.U()),
                  (this._dirtyNormal = !0),
                  (this._right = null),
                  (this._up = null),
                  (this._forward = null),
                  (this._parent = null),
                  (this._children = []),
                  (this._graphDepth = 0),
                  (this._enabled = !0),
                  (this._enabledInHierarchy = !1),
                  (this.scaleCompensation = !1),
                  (this.name = R);
              }
              get right() {
                return (
                  this._right || (this._right = new h.e()),
                  this.getWorldTransform().getX(this._right).normalize()
                );
              }
              get up() {
                return (
                  this._up || (this._up = new h.e()),
                  this.getWorldTransform().getY(this._up).normalize()
                );
              }
              get forward() {
                return (
                  this._forward || (this._forward = new h.e()),
                  this.getWorldTransform()
                    .getZ(this._forward)
                    .normalize()
                    .mulScalar(-1)
                );
              }
              get normalMatrix() {
                const R = this._normalMatrix;
                return (
                  this._dirtyNormal &&
                    (this.getWorldTransform().invertTo3x3(R),
                    R.transpose(),
                    (this._dirtyNormal = !1)),
                  R
                );
              }
              set enabled(R) {
                if (this._enabled !== R) {
                  var P;
                  (this._enabled = R),
                    ((R && (P = this._parent) != null && P.enabled) || !R) &&
                      this._notifyHierarchyStateChanged(this, R);
                }
              }
              get enabled() {
                return this._enabled && this._enabledInHierarchy;
              }
              get parent() {
                return this._parent;
              }
              get path() {
                let R = this._parent;
                if (!R) return "";
                let P = this.name;
                for (; R && R._parent; )
                  (P = `${R.name}/${P}`), (R = R._parent);
                return P;
              }
              get root() {
                let R = this;
                for (; R._parent; ) R = R._parent;
                return R;
              }
              get children() {
                return this._children;
              }
              get graphDepth() {
                return this._graphDepth;
              }
              _notifyHierarchyStateChanged(R, P) {
                R._onHierarchyStateChanged(P);
                const F = R._children;
                for (let b = 0, D = F.length; b < D; b++)
                  F[b]._enabled && this._notifyHierarchyStateChanged(F[b], P);
              }
              _onHierarchyStateChanged(R) {
                (this._enabledInHierarchy = R),
                  R && !this._frozen && this._unfreezeParentToRoot();
              }
              _cloneInternal(R) {
                R.name = this.name;
                const P = this.tags._list;
                R.tags.clear();
                for (let F = 0; F < P.length; F++) R.tags.add(P[F]);
                (R._labels = Object.assign({}, this._labels)),
                  R.localPosition.copy(this.localPosition),
                  R.localRotation.copy(this.localRotation),
                  R.localScale.copy(this.localScale),
                  R.localEulerAngles.copy(this.localEulerAngles),
                  R.position.copy(this.position),
                  R.rotation.copy(this.rotation),
                  R.eulerAngles.copy(this.eulerAngles),
                  R.localTransform.copy(this.localTransform),
                  (R._dirtyLocal = this._dirtyLocal),
                  R.worldTransform.copy(this.worldTransform),
                  (R._dirtyWorld = this._dirtyWorld),
                  (R._dirtyNormal = this._dirtyNormal),
                  (R._aabbVer = this._aabbVer + 1),
                  (R._enabled = this._enabled),
                  (R.scaleCompensation = this.scaleCompensation),
                  (R._enabledInHierarchy = !1);
              }
              clone() {
                const R = new this.constructor();
                return this._cloneInternal(R), R;
              }
              copy(R) {
                return R._cloneInternal(this), this;
              }
              destroy() {
                this.remove();
                const R = this._children;
                for (; R.length; ) {
                  const P = R.pop();
                  (P._parent = null), P.destroy();
                }
                this.fire("destroy", this), this.off();
              }
              find(R, P) {
                let F,
                  b = [];
                const D = this._children.length;
                if (R instanceof Function) {
                  const G = R;
                  (F = G(this)), F && b.push(this);
                  for (let X = 0; X < D; X++) {
                    const ie = this._children[X].find(G);
                    ie.length && (b = b.concat(ie));
                  }
                } else {
                  let G;
                  this[R] &&
                    (this[R] instanceof Function
                      ? (G = this[R]())
                      : (G = this[R]),
                    G === P && b.push(this));
                  for (let X = 0; X < D; ++X) {
                    const ie = this._children[X].find(R, P);
                    ie.length && (b = b.concat(ie));
                  }
                }
                return b;
              }
              findOne(R, P) {
                const F = this._children.length;
                let b = null;
                if (R instanceof Function) {
                  const D = R;
                  if (((b = D(this)), b)) return this;
                  for (let G = 0; G < F; G++)
                    if (((b = this._children[G].findOne(D)), b)) return b;
                } else {
                  let D;
                  if (
                    this[R] &&
                    (this[R] instanceof Function
                      ? (D = this[R]())
                      : (D = this[R]),
                    D === P)
                  )
                    return this;
                  for (let G = 0; G < F; G++)
                    if (((b = this._children[G].findOne(R, P)), b !== null))
                      return b;
                }
                return null;
              }
              findByTag() {
                const R = arguments,
                  P = [],
                  F = (b, D) => {
                    D && b.tags.has(...R) && P.push(b);
                    for (let G = 0; G < b._children.length; G++)
                      F(b._children[G], !0);
                  };
                return F(this, !1), P;
              }
              findByName(R) {
                if (this.name === R) return this;
                for (let P = 0; P < this._children.length; P++) {
                  const F = this._children[P].findByName(R);
                  if (F !== null) return F;
                }
                return null;
              }
              findByPath(R) {
                const P = Array.isArray(R) ? R : R.split("/");
                let F = this;
                for (let b = 0, D = P.length; b < D; ++b)
                  if (((F = F.children.find((G) => G.name === P[b])), !F))
                    return null;
                return F;
              }
              forEach(R, P) {
                R.call(P, this);
                const F = this._children;
                for (let b = 0; b < F.length; b++) F[b].forEach(R, P);
              }
              isDescendantOf(R) {
                let P = this._parent;
                for (; P; ) {
                  if (P === R) return !0;
                  P = P._parent;
                }
                return !1;
              }
              isAncestorOf(R) {
                return R.isDescendantOf(this);
              }
              getEulerAngles() {
                return (
                  this.getWorldTransform().getEulerAngles(this.eulerAngles),
                  this.eulerAngles
                );
              }
              getLocalEulerAngles() {
                return (
                  this.localRotation.getEulerAngles(this.localEulerAngles),
                  this.localEulerAngles
                );
              }
              getLocalPosition() {
                return this.localPosition;
              }
              getLocalRotation() {
                return this.localRotation;
              }
              getLocalScale() {
                return this.localScale;
              }
              getLocalTransform() {
                return (
                  this._dirtyLocal &&
                    (this.localTransform.setTRS(
                      this.localPosition,
                      this.localRotation,
                      this.localScale
                    ),
                    (this._dirtyLocal = !1)),
                  this.localTransform
                );
              }
              getPosition() {
                return (
                  this.getWorldTransform().getTranslation(this.position),
                  this.position
                );
              }
              getRotation() {
                return (
                  this.rotation.setFromMat4(this.getWorldTransform()),
                  this.rotation
                );
              }
              getScale() {
                return (
                  this._scale || (this._scale = new h.e()),
                  this.getWorldTransform().getScale(this._scale)
                );
              }
              getWorldTransform() {
                return !this._dirtyLocal && !this._dirtyWorld
                  ? this.worldTransform
                  : (this._parent && this._parent.getWorldTransform(),
                    this._sync(),
                    this.worldTransform);
              }
              get worldScaleSign() {
                return (
                  this._worldScaleSign === 0 &&
                    (this._worldScaleSign = this.getWorldTransform().scaleSign),
                  this._worldScaleSign
                );
              }
              remove() {
                var R;
                (R = this._parent) == null || R.removeChild(this);
              }
              reparent(R, P) {
                this.remove(),
                  R && (P >= 0 ? R.insertChild(this, P) : R.addChild(this));
              }
              setLocalEulerAngles(R, P, F) {
                this.localRotation.setFromEulerAngles(R, P, F),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setLocalPosition(R, P, F) {
                R instanceof h.e
                  ? this.localPosition.copy(R)
                  : this.localPosition.set(R, P, F),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setLocalRotation(R, P, F, b) {
                R instanceof d.k
                  ? this.localRotation.copy(R)
                  : this.localRotation.set(R, P, F, b),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setLocalScale(R, P, F) {
                R instanceof h.e
                  ? this.localScale.copy(R)
                  : this.localScale.set(R, P, F),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              _dirtifyLocal() {
                this._dirtyLocal ||
                  ((this._dirtyLocal = !0),
                  this._dirtyWorld || this._dirtifyWorld());
              }
              _unfreezeParentToRoot() {
                let R = this._parent;
                for (; R; ) (R._frozen = !1), (R = R._parent);
              }
              _dirtifyWorld() {
                this._dirtyWorld || this._unfreezeParentToRoot(),
                  this._dirtifyWorldInternal();
              }
              _dirtifyWorldInternal() {
                if (!this._dirtyWorld) {
                  (this._frozen = !1), (this._dirtyWorld = !0);
                  for (let R = 0; R < this._children.length; R++)
                    this._children[R]._dirtyWorld ||
                      this._children[R]._dirtifyWorldInternal();
                }
                (this._dirtyNormal = !0),
                  (this._worldScaleSign = 0),
                  this._aabbVer++;
              }
              setPosition(R, P, F) {
                R instanceof h.e ? r.copy(R) : r.set(R, P, F),
                  this._parent === null
                    ? this.localPosition.copy(r)
                    : (u.copy(this._parent.getWorldTransform()).invert(),
                      u.transformPoint(r, this.localPosition)),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setRotation(R, P, F, b) {
                if (
                  (R instanceof d.k ? v.copy(R) : v.set(R, P, F, b),
                  this._parent === null)
                )
                  this.localRotation.copy(v);
                else {
                  const D = this._parent.getRotation();
                  _.copy(D).invert(), this.localRotation.copy(_).mul(v);
                }
                this._dirtyLocal || this._dirtifyLocal();
              }
              setEulerAngles(R, P, F) {
                if (
                  (this.localRotation.setFromEulerAngles(R, P, F),
                  this._parent !== null)
                ) {
                  const b = this._parent.getRotation();
                  _.copy(b).invert(),
                    this.localRotation.mul2(_, this.localRotation);
                }
                this._dirtyLocal || this._dirtifyLocal();
              }
              addChild(R) {
                this._prepareInsertChild(R),
                  this._children.push(R),
                  this._onInsertChild(R);
              }
              addChildAndSaveTransform(R) {
                const P = R.getPosition(),
                  F = R.getRotation();
                this._prepareInsertChild(R),
                  R.setPosition(
                    e.copy(this.worldTransform).invert().transformPoint(P)
                  ),
                  R.setRotation(t.copy(this.getRotation()).invert().mul(F)),
                  this._children.push(R),
                  this._onInsertChild(R);
              }
              insertChild(R, P) {
                this._prepareInsertChild(R),
                  this._children.splice(P, 0, R),
                  this._onInsertChild(R);
              }
              _prepareInsertChild(R) {
                R.remove();
              }
              _fireOnHierarchy(R, P, F) {
                this.fire(R, F);
                for (let b = 0; b < this._children.length; b++)
                  this._children[b]._fireOnHierarchy(P, P, F);
              }
              _onInsertChild(R) {
                R._parent = this;
                const P = R._enabled && this.enabled;
                R._enabledInHierarchy !== P &&
                  ((R._enabledInHierarchy = P),
                  R._notifyHierarchyStateChanged(R, P)),
                  R._updateGraphDepth(),
                  R._dirtifyWorld(),
                  this._frozen && R._unfreezeParentToRoot(),
                  R._fireOnHierarchy("insert", "inserthierarchy", this),
                  this.fire && this.fire("childinsert", R);
              }
              _updateGraphDepth() {
                this._graphDepth = this._parent
                  ? this._parent._graphDepth + 1
                  : 0;
                for (let R = 0, P = this._children.length; R < P; R++)
                  this._children[R]._updateGraphDepth();
              }
              removeChild(R) {
                const P = this._children.indexOf(R);
                P !== -1 &&
                  (this._children.splice(P, 1),
                  (R._parent = null),
                  R._fireOnHierarchy("remove", "removehierarchy", this),
                  this.fire("childremove", R));
              }
              _sync() {
                if (
                  (this._dirtyLocal &&
                    (this.localTransform.setTRS(
                      this.localPosition,
                      this.localRotation,
                      this.localScale
                    ),
                    (this._dirtyLocal = !1)),
                  this._dirtyWorld)
                ) {
                  if (this._parent === null)
                    this.worldTransform.copy(this.localTransform);
                  else if (this.scaleCompensation) {
                    let R;
                    const P = this._parent;
                    let F = this.localScale,
                      b = P;
                    if (b) {
                      for (; b && b.scaleCompensation; ) b = b._parent;
                      b &&
                        ((b = b._parent),
                        b &&
                          ((R = b.worldTransform.getScale()),
                          o.mul2(R, this.localScale),
                          (F = o)));
                    }
                    n.setFromMat4(P.worldTransform),
                      l.mul2(n, this.localRotation);
                    let D = P.worldTransform;
                    P.scaleCompensation &&
                      (i.mul2(R, P.getLocalScale()),
                      f.setTRS(P.worldTransform.getTranslation(s), n, i),
                      (D = f)),
                      D.transformPoint(this.localPosition, s),
                      this.worldTransform.setTRS(s, l, F);
                  } else
                    this.worldTransform.mulAffine2(
                      this._parent.worldTransform,
                      this.localTransform
                    );
                  this._dirtyWorld = !1;
                }
              }
              syncHierarchy() {
                if (!this._enabled || this._frozen) return;
                (this._frozen = !0),
                  (this._dirtyLocal || this._dirtyWorld) && this._sync();
                const R = this._children;
                for (let P = 0, F = R.length; P < F; P++) R[P].syncHierarchy();
              }
              lookAt(R, P, F, b = 0, D = 1, G = 0) {
                if (R instanceof h.e)
                  g.copy(R), P instanceof h.e ? T.copy(P) : T.copy(h.e.UP);
                else {
                  if (F === void 0) return;
                  g.set(R, P, F), T.set(b, D, G);
                }
                m.setLookAt(this.getPosition(), g, T),
                  v.setFromMat4(m),
                  this.setRotation(v);
              }
              translate(R, P, F) {
                R instanceof h.e ? r.copy(R) : r.set(R, P, F),
                  r.add(this.getPosition()),
                  this.setPosition(r);
              }
              translateLocal(R, P, F) {
                R instanceof h.e ? r.copy(R) : r.set(R, P, F),
                  this.localRotation.transformVector(r, r),
                  this.localPosition.add(r),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              rotate(R, P, F) {
                if ((v.setFromEulerAngles(R, P, F), this._parent === null))
                  this.localRotation.mul2(v, this.localRotation);
                else {
                  const b = this.getRotation(),
                    D = this._parent.getRotation();
                  _.copy(D).invert(),
                    v.mul2(_, v),
                    this.localRotation.mul2(v, b);
                }
                this._dirtyLocal || this._dirtifyLocal();
              }
              rotateLocal(R, P, F) {
                v.setFromEulerAngles(R, P, F),
                  this.localRotation.mul(v),
                  this._dirtyLocal || this._dirtifyLocal();
              }
            }
          },
          3362: (xe, V, a) => {
            "use strict";
            a.d(V, { S: () => i });
            var A = a(5596),
              x = a(1208),
              y = a(5490),
              c = a(1630);
            const d = !0,
              h = (e, t = 0) => 1 + Math.floor(Math.log2(Math.max(e, t))),
              f = (e) => e.extTextureHalfFloat && e.textureHalfFloatRenderable,
              s = (e) => e.extTextureFloat && e.textureFloatRenderable,
              l = (e) => (f(e) ? c.WBN : s(e) ? c.s7h : c.Lxj),
              n = (e) => c.Lxj,
              o = (e, t, r, u) =>
                new x.g(e, {
                  name: `lighting-${t}`,
                  cubemap: !0,
                  width: t,
                  height: t,
                  format: r,
                  type: r === c.Lxj ? c.mEg : c.s64,
                  addressU: c.vq6,
                  addressV: c.vq6,
                  fixCubemapSeams: d,
                  mipmaps: !!u,
                });
            class i {
              static generateSkyboxCubemap(t, r) {
                const u = t.device,
                  v = o(u, r || (t.cubemap ? t.width : t.width / 4), c.Lxj, !1);
                return (0, y.Q)(t, v, { numSamples: 1024 }), v;
              }
              static generateLightingSource(t, r) {
                const u = t.device,
                  v = l(u),
                  _ =
                    (r == null ? void 0 : r.target) ||
                    new x.g(u, {
                      name: "lighting-source",
                      cubemap: !0,
                      width: (r == null ? void 0 : r.size) || 128,
                      height: (r == null ? void 0 : r.size) || 128,
                      format: v,
                      type: v === c.Lxj ? c.mEg : c.s64,
                      addressU: c.vq6,
                      addressV: c.vq6,
                      fixCubemapSeams: !1,
                      mipmaps: !0,
                    });
                return (0, y.Q)(t, _, { numSamples: t.mipmaps ? 1 : 1024 }), _;
              }
              static generateAtlas(t, r) {
                const u = t.device,
                  v = n(),
                  _ =
                    (r == null ? void 0 : r.target) ||
                    new x.g(u, {
                      name: "envAtlas",
                      width: (r == null ? void 0 : r.size) || 512,
                      height: (r == null ? void 0 : r.size) || 512,
                      format: v,
                      type: c.mEg,
                      projection: c.CG0,
                      addressU: c.vq6,
                      addressV: c.vq6,
                      mipmaps: !1,
                    }),
                  m = _.width / 512,
                  g = new A.Z(0, 0, 512 * m, 256 * m),
                  T = h(256) - h(4);
                for (let E = 0; E < T; ++E)
                  (0, y.Q)(t, _, { numSamples: 1, rect: g, seamPixels: m }),
                    (g.x += g.w),
                    (g.y += g.w),
                    (g.z = Math.max(1, Math.floor(g.z * 0.5))),
                    (g.w = Math.max(1, Math.floor(g.w * 0.5)));
                g.set(0, 256 * m, 256 * m, 128 * m);
                for (let E = 1; E < 7; ++E)
                  (0, y.Q)(t, _, {
                    numSamples:
                      (r == null ? void 0 : r.numReflectionSamples) || 1024,
                    distribution:
                      (r == null ? void 0 : r.distribution) || "ggx",
                    specularPower: Math.max(1, 2048 >> (E * 2)),
                    rect: g,
                    seamPixels: m,
                  }),
                    (g.y += g.w),
                    (g.z = Math.max(1, Math.floor(g.z * 0.5))),
                    (g.w = Math.max(1, Math.floor(g.w * 0.5)));
                return (
                  g.set(128 * m, 384 * m, 64 * m, 32 * m),
                  (0, y.Q)(t, _, {
                    numSamples:
                      (r == null ? void 0 : r.numAmbientSamples) || 2048,
                    distribution: "lambert",
                    rect: g,
                    seamPixels: m,
                  }),
                  _
                );
              }
              static generatePrefilteredAtlas(t, r) {
                const u = t[0].device,
                  v = t[0].format,
                  _ = t[0].type,
                  m =
                    (r == null ? void 0 : r.target) ||
                    new x.g(u, {
                      name: "envPrefilteredAtlas",
                      width: (r == null ? void 0 : r.size) || 512,
                      height: (r == null ? void 0 : r.size) || 512,
                      format: v,
                      type: _,
                      projection: c.CG0,
                      addressU: c.vq6,
                      addressV: c.vq6,
                      mipmaps: !1,
                    }),
                  g = m.width / 512,
                  T = new A.Z(0, 0, 512 * g, 256 * g),
                  E = h(512);
                for (let M = 0; M < E; ++M)
                  (0, y.Q)(t[0], m, { numSamples: 1, rect: T, seamPixels: g }),
                    (T.x += T.w),
                    (T.y += T.w),
                    (T.z = Math.max(1, Math.floor(T.z * 0.5))),
                    (T.w = Math.max(1, Math.floor(T.w * 0.5)));
                T.set(0, 256 * g, 256 * g, 128 * g);
                for (let M = 1; M < t.length; ++M)
                  (0, y.Q)(t[M], m, { numSamples: 1, rect: T, seamPixels: g }),
                    (T.y += T.w),
                    (T.z = Math.max(1, Math.floor(T.z * 0.5))),
                    (T.w = Math.max(1, Math.floor(T.w * 0.5)));
                return (
                  T.set(128 * g, 384 * g, 64 * g, 32 * g),
                  r != null && r.legacyAmbient
                    ? (0, y.Q)(t[5], m, {
                        numSamples: 1,
                        rect: T,
                        seamPixels: g,
                      })
                    : (0, y.Q)(t[0], m, {
                        numSamples: (r == null ? void 0 : r.numSamples) || 2048,
                        distribution: "lambert",
                        rect: T,
                        seamPixels: g,
                      }),
                  m
                );
              }
            }
          },
          9788: (xe, V, a) => {
            "use strict";
            a.d(V, { j: () => x });
            class A {
              constructor() {
                this.cache = new Map();
              }
              destroy() {
                this.cache.forEach((c, d) => {
                  d.destroy();
                }),
                  this.cache.clear();
              }
              incRef(c) {
                const d = (this.cache.get(c) || 0) + 1;
                this.cache.set(c, d);
              }
              decRef(c) {
                if (c) {
                  let d = this.cache.get(c);
                  d &&
                    (d--,
                    d === 0
                      ? (this.cache.delete(c), c.destroy())
                      : this.cache.set(c, d));
                }
              }
            }
            class x {
              static incRef(c) {
                this.cache.incRef(c);
              }
              static decRef(c) {
                this.cache.decRef(c);
              }
              static destroy() {
                this.cache.destroy();
              }
            }
            x.cache = new A();
          },
          4294: (xe, V, a) => {
            "use strict";
            a.d(V, { o: () => d });
            var A = a(5596),
              x = a(1268),
              y = a(8524);
            const c = new A.Z();
            class d {
              constructor(f) {
                (this.device = f), (this.needsDepthBuffer = !1);
              }
              render(f, s, l) {}
              drawQuad(f, s, l) {
                let n;
                if (l) {
                  const o = f ? f.width : this.device.width,
                    i = f ? f.height : this.device.height;
                  n = c.set(l.x * o, l.y * i, l.z * o, l.w * i);
                }
                this.device.setBlendState(x.t.NOBLEND),
                  (0, y.l)(this.device, f, s, n);
              }
            }
            d.quadVertexShader = `
				attribute vec2 aPosition;
				varying vec2 vUv0;
				void main(void)
				{
						gl_Position = vec4(aPosition, 0.0, 1.0);
						vUv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);
				}
		`;
          },
          8524: (xe, V, a) => {
            "use strict";
            a.d(V, { _: () => s, l: () => f });
            var A = a(5596),
              x = a(1630),
              y = a(4870),
              c = a(2485),
              d = a(3936);
            const h = new A.Z();
            function f(l, n, o, i, e) {
              l.setCullMode(x.pLF),
                l.setDepthState(y.H.NODEPTH),
                l.setStencilState(null, null);
              const t = new d.o(o);
              i ||
                ((i = h),
                (i.x = 0),
                (i.y = 0),
                (i.z = n ? n.width : l.width),
                (i.w = n ? n.height : l.height));
              const r = new c.AH(l, () => {
                t.render(i, e);
              });
              if (
                (r.init(n),
                (r.colorOps.clear = !1),
                (r.depthStencilOps.clearDepth = !1),
                l.isWebGPU && n === null)
              ) {
                var u;
                ((u = n == null ? void 0 : n.samples) != null ? u : l.samples) >
                  1 && (r.colorOps.store = !0);
              }
              r.render(), t.destroy();
            }
            function s(l, n, o, i, e, t) {
              (i = i || l.getCopyShader()),
                l.constantTexSource.setValue(n),
                f(l, o, i, e, t);
            }
          },
          3936: (xe, V, a) => {
            "use strict";
            a.d(V, { o: () => n });
            var A = a(5596),
              x = a(2978),
              y = a(1630),
              c = a(8568),
              d = a(5006),
              h = a(333);
            const f = { type: y.SF$, base: 0, count: 4, indexed: !1 },
              s = new A.Z(),
              l = new A.Z();
            class n {
              constructor(i) {
                (this.uniformBuffer = void 0), (this.bindGroup = void 0);
                const e = i.device;
                if (((this.shader = i), e.supportsUniformBuffers)) {
                  const t = new c.c();
                  this.shader = (0, h.V$)(i, t);
                  const r = this.shader.meshUniformBufferFormat;
                  r && (this.uniformBuffer = new d.D(e, r, !1));
                  const u = this.shader.meshBindGroupFormat;
                  this.bindGroup = new x.T(e, u, this.uniformBuffer);
                }
              }
              destroy() {
                var i, e;
                (i = this.uniformBuffer) == null || i.destroy(),
                  (this.uniformBuffer = null),
                  (e = this.bindGroup) == null || e.destroy(),
                  (this.bindGroup = null);
              }
              render(i, e) {
                const t = this.shader.device;
                if (i) {
                  var r;
                  s.set(t.vx, t.vy, t.vw, t.vh),
                    l.set(t.sx, t.sy, t.sw, t.sh),
                    (e = (r = e) != null ? r : i),
                    t.setViewport(i.x, i.y, i.z, i.w),
                    t.setScissor(e.x, e.y, e.z, e.w);
                }
                t.setVertexBuffer(t.quadVertexBuffer, 0);
                const u = this.shader;
                if ((t.setShader(u), t.supportsUniformBuffers)) {
                  var v;
                  const _ = this.bindGroup;
                  (v = _.defaultUniformBuffer) == null || v.update(),
                    _.update(),
                    t.setBindGroup(y.pNk, _);
                }
                t.draw(f),
                  i &&
                    (t.setViewport(s.x, s.y, s.z, s.w),
                    t.setScissor(l.x, l.y, l.z, l.w));
              }
            }
          },
          5490: (xe, V, a) => {
            "use strict";
            a.d(V, { Q: () => Z });
            var A = a(9833),
              x = a(7481),
              y = a(1630),
              c = a(5950),
              d = a(4461),
              h = a(9061),
              f = a(8524),
              s = a(1208),
              l = a(725),
              n = a(2910),
              o = a(783),
              i = a(333),
              e = a(1268);
            const t = (J) => {
                switch (J) {
                  case y.$mg:
                    return "Cubemap";
                  case y.vct:
                    return "Octahedral";
                  default:
                    return "Equirect";
                }
              },
              r = (J, ve, _e) => {
                if (J <= 0)
                  (ve[_e + 0] = 0),
                    (ve[_e + 1] = 0),
                    (ve[_e + 2] = 0),
                    (ve[_e + 3] = 0);
                else if (J >= 1)
                  (ve[_e + 0] = 255),
                    (ve[_e + 1] = 0),
                    (ve[_e + 2] = 0),
                    (ve[_e + 3] = 0);
                else {
                  let L = (1 * J) % 1,
                    ge = (255 * J) % 1,
                    k = (65025 * J) % 1;
                  const j = (16581375 * J) % 1;
                  (L -= ge / 255),
                    (ge -= k / 255),
                    (k -= j / 255),
                    (ve[_e + 0] = Math.min(255, Math.floor(L * 256))),
                    (ve[_e + 1] = Math.min(255, Math.floor(ge * 256))),
                    (ve[_e + 2] = Math.min(255, Math.floor(k * 256))),
                    (ve[_e + 3] = Math.min(255, Math.floor(j * 256)));
                }
              },
              u = (J) => {
                const ve = J.length,
                  _e = Math.min(ve, 512),
                  L = Math.ceil(ve / _e),
                  ge = new Uint8Array(_e * L * 4);
                let k = 0;
                for (let j = 0; j < ve; j += 4)
                  r(J[j + 0] * 0.5 + 0.5, ge, k + 0),
                    r(J[j + 1] * 0.5 + 0.5, ge, k + 4),
                    r(J[j + 2] * 0.5 + 0.5, ge, k + 8),
                    r(J[j + 3] / 8, ge, k + 12),
                    (k += 16);
                return { width: _e, height: L, data: ge };
              },
              v = (J, ve, _e, L) => {
                const ge = _e * 2 * Math.PI,
                  k = Math.pow(1 - ve, 1 / (L + 1)),
                  j = Math.sqrt(1 - k * k);
                J.set(Math.cos(ge) * j, Math.sin(ge) * j, k).normalize();
              },
              _ = (J, ve, _e) => {
                const L = _e * 2 * Math.PI,
                  ge = Math.sqrt(1 - ve),
                  k = Math.sqrt(ve);
                J.set(Math.cos(L) * k, Math.sin(L) * k, ge).normalize();
              },
              m = (J, ve, _e, L) => {
                const ge = _e * 2 * Math.PI,
                  k = Math.sqrt((1 - ve) / (1 + (L * L - 1) * ve)),
                  j = Math.sqrt(1 - k * k);
                J.set(Math.cos(ge) * j, Math.sin(ge) * j, k).normalize();
              },
              g = (J, ve) => {
                const _e = J * ve,
                  L = ve / (1 - J * J + _e * _e);
                return L * L * (1 / Math.PI);
              },
              T = (J, ve) => {
                const _e = new x.e(),
                  L = [];
                for (let ge = 0; ge < J; ++ge)
                  v(_e, ge / J, A.y.radicalInverse(ge), ve),
                    L.push(_e.x, _e.y, _e.z, 0);
                return L;
              },
              E = (J, ve) => {
                const _e = ve / J,
                  L = new x.e(),
                  ge = [];
                for (let k = 0; k < J; ++k) {
                  _(L, k / J, A.y.radicalInverse(k));
                  const j = L.z / Math.PI,
                    B = 0.5 * Math.log2(_e / j);
                  ge.push(L.x, L.y, L.z, B);
                }
                return ge;
              },
              M = {
                16: { 2: 26, 8: 20, 32: 17, 128: 16, 512: 16 },
                32: { 2: 53, 8: 40, 32: 34, 128: 32, 512: 32 },
                128: { 2: 214, 8: 163, 32: 139, 128: 130, 512: 128 },
                1024: { 2: 1722, 8: 1310, 32: 1114, 128: 1041, 512: 1025 },
              },
              R = (J, ve) => {
                const _e = M[J];
                return (_e && _e[ve]) || J;
              },
              P = (J, ve, _e) => {
                const L = _e / J,
                  ge = 1 - Math.log2(ve) / 11,
                  k = ge * ge,
                  j = new x.e(),
                  B = new x.e(),
                  $ = new x.e(0, 0, 1),
                  le = [],
                  O = R(J, ve);
                for (let Y = 0; Y < O; ++Y) {
                  m(j, Y / O, A.y.radicalInverse(Y), k);
                  const ne = j.z;
                  if (
                    (B.set(j.x, j.y, j.z)
                      .mulScalar(2 * ne)
                      .sub($),
                    B.z > 0)
                  ) {
                    const de = g(Math.min(1, ne), k) / 4 + 0.001,
                      re = 0.5 * Math.log2(L / de);
                    le.push(B.x, B.y, B.z, re);
                  }
                }
                for (; le.length < J * 4; ) le.push(0, 0, 0, 0);
                return le;
              },
              F = (J, ve, _e) => {
                const L = u(_e);
                return new s.g(J, {
                  name: ve,
                  width: L.width,
                  height: L.height,
                  mipmaps: !1,
                  minFilter: y.uhC,
                  magFilter: y.uhC,
                  levels: [L.data],
                });
              };
            class b {
              constructor(ve = !0) {
                (this.map = new Map()), (this.destroyContent = ve);
              }
              destroy() {
                this.destroyContent &&
                  this.map.forEach((ve, _e) => {
                    ve.destroy();
                  });
              }
              get(ve, _e) {
                if (!this.map.has(ve)) {
                  const L = _e();
                  return this.map.set(ve, L), L;
                }
                return this.map.get(ve);
              }
            }
            const D = new b(!1),
              G = new c.N(),
              X = (J, ve, _e) =>
                G.get(J, () => new b()).get(ve, () => F(J, ve, D.get(ve, _e))),
              ie = (J, ve, _e) => {
                const L = `lambert-samples-${ve}-${_e}`;
                return X(J, L, () => E(ve, _e));
              },
              Q = (J, ve, _e) => {
                const L = `phong-samples-${ve}-${_e}`;
                return X(J, L, () => T(ve, _e));
              },
              te = (J, ve, _e, L) => {
                const ge = `ggx-samples-${ve}-${_e}-${L}`;
                return X(J, ge, () => P(ve, _e, L));
              },
              ae = `
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);
}
`;
            function Z(J, ve, _e = {}) {
              var L;
              J instanceof d.G &&
                ((J = arguments[1]),
                (ve = arguments[2]),
                (_e = {}),
                arguments[3] !== void 0 && (_e.specularPower = arguments[3]),
                arguments[4] !== void 0 && (_e.numSamples = arguments[4]));
              const ge = {
                  none: "reproject",
                  lambert: "prefilterSamplesUnweighted",
                  phong: "prefilterSamplesUnweighted",
                  ggx: "prefilterSamples",
                },
                k = _e.hasOwnProperty("specularPower") ? _e.specularPower : 1,
                j = _e.hasOwnProperty("face") ? _e.face : null,
                B = _e.hasOwnProperty("distribution")
                  ? _e.distribution
                  : k === 1
                  ? "none"
                  : "phong",
                $ = ge[B] || "reproject",
                le = $.startsWith("prefilterSamples"),
                O = l.N.decodeFunc(J.encoding),
                Y = l.N.encodeFunc(ve.encoding),
                ne = `sample${t(J.projection)}`,
                de = `getDirection${t(ve.projection)}`,
                re = _e.hasOwnProperty("numSamples") ? _e.numSamples : 1024,
                I = `${$}_${O}_${Y}_${ne}_${de}_${re}`,
                w = J.device;
              let N = (0, o.k)(w).getCachedShader(I);
              if (!N) {
                const Ue =
                  `#define PROCESS_FUNC ${$}
` +
                  (le
                    ? `#define USE_SAMPLES_TEX
`
                    : "") +
                  (J.cubemap
                    ? `#define CUBEMAP_SOURCE
`
                    : "") +
                  `#define DECODE_FUNC ${O}
#define ENCODE_FUNC ${Y}
#define SOURCE_FUNC ${ne}
#define TARGET_FUNC ${de}
#define NUM_SAMPLES ${re}
#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(re)).toFixed(1)}
`;
                N = (0, i.$$)(
                  w,
                  ae,
                  `${Ue}
${n.G.reprojectPS}`,
                  I
                );
              }
              w.setBlendState(e.t.NOBLEND),
                w.scope
                  .resolve(J.cubemap ? "sourceCube" : "sourceTex")
                  .setValue(J);
              const he = w.scope.resolve("params"),
                ue = w.scope.resolve("params2"),
                ye = w.scope.resolve("uvMod");
              if ((L = _e) != null && L.seamPixels) {
                const Ue = _e.seamPixels,
                  Ge = _e.rect ? _e.rect.z : ve.width,
                  ht = _e.rect ? _e.rect.w : ve.height,
                  me = Ge - Ue * 2,
                  z = ht - Ue * 2;
                ye.setValue([
                  (me + Ue * 2) / me,
                  (z + Ue * 2) / z,
                  -Ue / me,
                  -Ue / z,
                ]);
              } else ye.setValue([1, 1, 0, 0]);
              const Oe = [
                  0,
                  k,
                  J.fixCubemapSeams ? 1 / J.width : 0,
                  ve.fixCubemapSeams ? 1 / ve.width : 0,
                ],
                Ae = [
                  ve.width * ve.height * (ve.cubemap ? 6 : 1),
                  J.width * J.height * (J.cubemap ? 6 : 1),
                ];
              if (le) {
                const Ue = J.width * J.height * (J.cubemap ? 6 : 1),
                  Ge =
                    B === "ggx"
                      ? te(w, re, k, Ue)
                      : B === "lambert"
                      ? ie(w, re, Ue)
                      : Q(w, re, k);
                w.scope.resolve("samplesTex").setValue(Ge),
                  w.scope
                    .resolve("samplesTexInverseSize")
                    .setValue([1 / Ge.width, 1 / Ge.height]);
              }
              for (let Ue = 0; Ue < (ve.cubemap ? 6 : 1); Ue++)
                if (j === null || Ue === j) {
                  var ke;
                  const Ge = new h.O({
                    colorBuffer: ve,
                    face: Ue,
                    depth: !1,
                    flipY: w.isWebGPU,
                  });
                  (Oe[0] = Ue),
                    he.setValue(Oe),
                    ue.setValue(Ae),
                    (0, f.l)(w, Ge, N, (ke = _e) == null ? void 0 : ke.rect),
                    Ge.destroy();
                }
            }
          },
          8197: (xe, V, a) => {
            "use strict";
            a.d(V, { f: () => l });
            var A = a(1630),
              x = a(9061),
              y = a(1208),
              c = a(1268),
              d = a(9391),
              h = a(2223);
            const f = ["uSceneDepthMap", "uDepthMap"],
              s = ["uSceneColorMap", "texture_grabPass"];
            class l {
              constructor(o, i) {
                (this.scene = i),
                  (this.device = o),
                  (this.layer = null),
                  this.device.webgl2 || this.device.isWebGPU
                    ? this.initMainPath()
                    : this.initFallbackPath();
              }
              static requiresRenderPass(o, i) {
                return o.webgl2 || o.isWebGPU ? !1 : i.renderSceneDepthMap;
              }
              setupUniform(o, i, e) {
                (i ? f : s).forEach((r) => o.scope.resolve(r).setValue(e));
              }
              allocateTexture(o, i, e, t, r, u) {
                return new y.g(o, {
                  name: e,
                  format: t,
                  width: i ? i.colorBuffer.width : o.width,
                  height: i ? i.colorBuffer.height : o.height,
                  mipmaps: u,
                  minFilter: r ? A.uhC : u ? A.qn_ : A.DrA,
                  magFilter: r ? A.uhC : A.DrA,
                  addressU: A.vq6,
                  addressV: A.vq6,
                });
              }
              getSourceColorFormat(o) {
                var i;
                return (i = o == null ? void 0 : o.format) != null
                  ? i
                  : this.device.framebufferFormat;
              }
              shouldReallocate(o, i, e) {
                if (e) {
                  const u = o == null ? void 0 : o.colorBuffer.format,
                    v = this.getSourceColorFormat(i);
                  if (u !== v) return !0;
                }
                const t = (i == null ? void 0 : i.width) || this.device.width,
                  r = (i == null ? void 0 : i.height) || this.device.height;
                return !o || t !== o.width || r !== o.height;
              }
              allocateRenderTarget(o, i, e, t, r, u, v) {
                const _ = v ? f : s,
                  m = this.allocateTexture(e, i, _[0], t, r, u);
                return (
                  o
                    ? (o.destroyFrameBuffers(),
                      r
                        ? (o._depthBuffer = m)
                        : ((o._colorBuffer = m), (o._colorBuffers = [m])))
                    : (o = new x.O({
                        name: "renderTargetSceneGrab",
                        colorBuffer: r ? null : m,
                        depthBuffer: r ? m : null,
                        depth: !r,
                        stencil: e.supportsStencil,
                        autoResolve: !1,
                      })),
                  o
                );
              }
              releaseRenderTarget(o) {
                o && (o.destroyTextureBuffers(), o.destroy());
              }
              initMainPath() {
                const o = this.device,
                  i = this;
                this.layer = new h.W({
                  enabled: !1,
                  name: "Depth",
                  id: d.$9,
                  onDisable: function () {
                    i.releaseRenderTarget(this.depthRenderTarget),
                      (this.depthRenderTarget = null),
                      i.releaseRenderTarget(this.colorRenderTarget),
                      (this.colorRenderTarget = null);
                  },
                  onPreRenderOpaque: function (e) {
                    const t = this.cameras[e];
                    if (t.renderSceneColorMap) {
                      var r;
                      if (
                        i.shouldReallocate(
                          this.colorRenderTarget,
                          (r = t.renderTarget) == null ? void 0 : r.colorBuffer,
                          !0
                        )
                      ) {
                        var u;
                        i.releaseRenderTarget(this.colorRenderTarget);
                        const T = i.getSourceColorFormat(
                          (u = t.renderTarget) == null ? void 0 : u.colorBuffer
                        );
                        this.colorRenderTarget = i.allocateRenderTarget(
                          this.colorRenderTarget,
                          t.renderTarget,
                          o,
                          T,
                          !1,
                          !0,
                          !1
                        );
                      }
                      const g = this.colorRenderTarget.colorBuffer;
                      o.isWebGPU
                        ? (o.copyRenderTarget(
                            t.renderTarget,
                            this.colorRenderTarget,
                            !0,
                            !1
                          ),
                          o.mipmapRenderer.generate(
                            this.colorRenderTarget.colorBuffer.impl
                          ))
                        : (o.copyRenderTarget(
                            o.renderTarget,
                            this.colorRenderTarget,
                            !0,
                            !1
                          ),
                          o.activeTexture(o.maxCombinedTextures - 1),
                          o.bindTexture(g),
                          o.gl.generateMipmap(g.impl._glTarget)),
                        i.setupUniform(o, !1, g);
                    }
                    if (t.renderSceneDepthMap) {
                      var v;
                      let g = !0,
                        T = A.Mg$;
                      if (o.isWebGPU) {
                        var _, m;
                        ((_ =
                          (m = t.renderTarget) == null ? void 0 : m.samples) !=
                        null
                          ? _
                          : o.samples) > 1 && ((T = A.IQA), (g = !1));
                      }
                      i.shouldReallocate(
                        this.depthRenderTarget,
                        (v = t.renderTarget) == null ? void 0 : v.depthBuffer
                      ) &&
                        (i.releaseRenderTarget(this.depthRenderTarget),
                        (this.depthRenderTarget = i.allocateRenderTarget(
                          this.depthRenderTarget,
                          t.renderTarget,
                          o,
                          T,
                          g,
                          !1,
                          !0
                        ))),
                        o.copyRenderTarget(
                          o.renderTarget,
                          this.depthRenderTarget,
                          !1,
                          !0
                        ),
                        i.setupUniform(
                          o,
                          !0,
                          g
                            ? this.depthRenderTarget.depthBuffer
                            : this.depthRenderTarget.colorBuffer
                        );
                    }
                  },
                  onPostRenderOpaque: function (e) {},
                });
              }
              initFallbackPath() {
                const o = this,
                  i = this.device,
                  e = this.scene;
                this.layer = new h.W({
                  enabled: !1,
                  name: "Depth",
                  id: d.$9,
                  shaderPass: d.w8,
                  onEnable: function () {
                    (this.depthRenderTarget = new x.O({
                      name: "depthRenderTarget-webgl1",
                      depth: !0,
                      stencil: i.supportsStencil,
                      autoResolve: !1,
                      graphicsDevice: i,
                    })),
                      (this.renderTarget = this.depthRenderTarget);
                  },
                  onDisable: function () {
                    this.depthRenderTarget.destroyTextureBuffers(),
                      (this.renderTarget = null),
                      o.releaseRenderTarget(this.colorRenderTarget),
                      (this.colorRenderTarget = null);
                  },
                  onPostCull: function (t) {
                    const r = this.cameras[t];
                    if (r.renderSceneDepthMap) {
                      var u, v;
                      if (
                        !(
                          (u = this.depthRenderTarget) != null && u.colorBuffer
                        ) ||
                        o.shouldReallocate(
                          this.depthRenderTarget,
                          (v = r.renderTarget) == null ? void 0 : v.depthBuffer
                        )
                      ) {
                        var _;
                        (_ = this.depthRenderTarget) == null ||
                          _.destroyTextureBuffers(),
                          (this.depthRenderTarget = o.allocateRenderTarget(
                            this.depthRenderTarget,
                            r.renderTarget,
                            i,
                            A.Lxj,
                            !1,
                            !1,
                            !0
                          )),
                          (this.renderTarget = this.depthRenderTarget);
                      }
                      const m = this.instances.visibleOpaque[t],
                        g = m.list,
                        T = e.layers,
                        E = T.subLayerEnabled,
                        M = T.subLayerList,
                        R = T.getLayerById(d.uE).renderTarget;
                      let P = 0;
                      const F = T.layerList;
                      for (let b = 0; b < F.length; b++) {
                        const D = F[b];
                        if (D === this) break;
                        if (D.renderTarget !== R || !D.enabled || !E[b])
                          continue;
                        const G = D.cameras.indexOf(r);
                        if (G < 0) continue;
                        let ie = M[b]
                          ? D.instances.visibleTransparent[G]
                          : D.instances.visibleOpaque[G];
                        const Q = ie.length;
                        ie = ie.list;
                        for (let te = 0; te < Q; te++) {
                          const ae = ie[te];
                          ae.material &&
                            ae.material.depthWrite &&
                            !ae._noDepthDrawGl1 &&
                            ((g[P] = ae), P++);
                        }
                      }
                      m.length = P;
                    }
                  },
                  onPreRenderOpaque: function (t) {
                    const r = this.cameras[t];
                    if (r.renderSceneColorMap) {
                      var u;
                      if (
                        o.shouldReallocate(
                          this.colorRenderTarget,
                          (u = r.renderTarget) == null ? void 0 : u.colorBuffer
                        )
                      ) {
                        var v;
                        o.releaseRenderTarget(this.colorRenderTarget);
                        const g = o.getSourceColorFormat(
                          (v = r.renderTarget) == null ? void 0 : v.colorBuffer
                        );
                        this.colorRenderTarget = o.allocateRenderTarget(
                          this.colorRenderTarget,
                          r.renderTarget,
                          i,
                          g,
                          !1,
                          !1,
                          !1
                        );
                      }
                      const _ = this.colorRenderTarget._colorBuffer;
                      _.impl._glTexture || _.impl.initialize(i, _),
                        i.bindTexture(_);
                      const m = i.gl;
                      m.copyTexImage2D(
                        m.TEXTURE_2D,
                        0,
                        _.impl._glFormat,
                        0,
                        0,
                        _.width,
                        _.height,
                        0
                      ),
                        (_._needsUpload = !1),
                        (_._needsMipmapsUpload = !1),
                        o.setupUniform(i, !1, _);
                    }
                    r.renderSceneDepthMap &&
                      o.setupUniform(i, !0, this.depthRenderTarget.colorBuffer);
                  },
                  onDrawCall: function () {
                    i.setBlendState(c.t.NOBLEND);
                  },
                  onPostRenderOpaque: function (t) {
                    if (this.cameras[t].renderSceneDepthMap) {
                      const u = this.instances.visibleOpaque[t];
                      u.length = 0;
                    }
                  },
                });
              }
              patch(o) {
                (o.onEnable = this.layer.onEnable),
                  (o.onDisable = this.layer.onDisable),
                  (o.onPreRenderOpaque = this.layer.onPreRenderOpaque),
                  (o.onPostRenderOpaque = this.layer.onPostRenderOpaque),
                  (o.shaderPass = this.layer.shaderPass),
                  (o.onPostCull = this.layer.onPostCull),
                  (o.onDrawCall = this.layer.onDrawCall);
              }
            }
          },
          2223: (xe, V, a) => {
            "use strict";
            a.d(V, { W: () => t });
            var A = a(8981),
              x = a(9391),
              y = a(2658);
            function c(r, u) {
              return r.drawOrder - u.drawOrder;
            }
            function d(r, u) {
              const v = r._key[x.Gn],
                _ = u._key[x.Gn];
              return v === _ && r.mesh && u.mesh
                ? u.mesh.id - r.mesh.id
                : _ - v;
            }
            function h(r, u) {
              return u.zdist - r.zdist;
            }
            function f(r, u) {
              return r.zdist - u.zdist;
            }
            const s = [null, c, d, h, f];
            function l(r, u) {
              return u.key - r.key;
            }
            let n = 0;
            const o = [];
            class i {
              constructor() {
                (this.list = []), (this.length = 0), (this.done = !1);
              }
            }
            class e {
              constructor() {
                (this.opaqueMeshInstances = []),
                  (this.transparentMeshInstances = []),
                  (this.shadowCasters = []),
                  (this.visibleOpaque = []),
                  (this.visibleTransparent = []);
              }
              prepare(u) {
                this.visibleOpaque[u] || (this.visibleOpaque[u] = new i()),
                  this.visibleTransparent[u] ||
                    (this.visibleTransparent[u] = new i()),
                  (this.visibleOpaque[u].done = !1),
                  (this.visibleTransparent[u].done = !1);
              }
              delete(u) {
                u < this.visibleOpaque.length &&
                  this.visibleOpaque.splice(u, 1),
                  u < this.visibleTransparent.length &&
                    this.visibleTransparent.splice(u, 1);
              }
            }
            class t {
              constructor(u = {}) {
                var v, _, m, g, T;
                u.id !== void 0
                  ? ((this.id = u.id), (n = Math.max(this.id + 1, n)))
                  : (this.id = n++),
                  (this.name = u.name),
                  (this._enabled = (v = u.enabled) != null ? v : !0),
                  (this._refCounter = this._enabled ? 1 : 0),
                  (this.opaqueSortMode =
                    (_ = u.opaqueSortMode) != null ? _ : x.R9),
                  (this.transparentSortMode =
                    (m = u.transparentSortMode) != null ? m : x.PD),
                  u.renderTarget && (this.renderTarget = u.renderTarget),
                  (this.shaderPass = (g = u.shaderPass) != null ? g : x.OP),
                  (this.passThrough = (T = u.passThrough) != null ? T : !1),
                  (this._clearColorBuffer = !!u.clearColorBuffer),
                  (this._clearDepthBuffer = !!u.clearDepthBuffer),
                  (this._clearStencilBuffer = !!u.clearStencilBuffer),
                  (this.onPreCull = u.onPreCull),
                  (this.onPreRender = u.onPreRender),
                  (this.onPreRenderOpaque = u.onPreRenderOpaque),
                  (this.onPreRenderTransparent = u.onPreRenderTransparent),
                  (this.onPostCull = u.onPostCull),
                  (this.onPostRender = u.onPostRender),
                  (this.onPostRenderOpaque = u.onPostRenderOpaque),
                  (this.onPostRenderTransparent = u.onPostRenderTransparent),
                  (this.onDrawCall = u.onDrawCall),
                  (this.onEnable = u.onEnable),
                  (this.onDisable = u.onDisable),
                  this._enabled && this.onEnable && this.onEnable(),
                  (this.layerReference = u.layerReference),
                  (this.instances = u.layerReference
                    ? u.layerReference.instances
                    : new e()),
                  (this.opaqueMeshInstances =
                    this.instances.opaqueMeshInstances),
                  (this.transparentMeshInstances =
                    this.instances.transparentMeshInstances),
                  (this.shadowCasters = this.instances.shadowCasters),
                  (this.customSortCallback = null),
                  (this.customCalculateSortValues = null),
                  (this._lights = []),
                  (this._lightsSet = new Set()),
                  (this._clusteredLightsSet = new Set()),
                  (this._splitLights = [[], [], []]),
                  (this.cameras = []),
                  (this._dirty = !1),
                  (this._dirtyLights = !1),
                  (this._dirtyCameras = !1),
                  (this._lightHash = 0),
                  (this._lightHashDirty = !1),
                  (this._shaderVersion = -1),
                  (this._lightCube = null);
              }
              get hasClusteredLights() {
                return this._clusteredLightsSet.size > 0;
              }
              set enabled(u) {
                u !== this._enabled &&
                  ((this._enabled = u),
                  u
                    ? (this.incrementCounter(),
                      this.onEnable && this.onEnable())
                    : (this.decrementCounter(),
                      this.onDisable && this.onDisable()));
              }
              get enabled() {
                return this._enabled;
              }
              set clearColorBuffer(u) {
                (this._clearColorBuffer = u), (this._dirtyCameras = !0);
              }
              get clearColorBuffer() {
                return this._clearColorBuffer;
              }
              set clearDepthBuffer(u) {
                (this._clearDepthBuffer = u), (this._dirtyCameras = !0);
              }
              get clearDepthBuffer() {
                return this._clearDepthBuffer;
              }
              set clearStencilBuffer(u) {
                (this._clearStencilBuffer = u), (this._dirtyCameras = !0);
              }
              get clearStencilBuffer() {
                return this._clearStencilBuffer;
              }
              get clusteredLightsSet() {
                return this._clusteredLightsSet;
              }
              incrementCounter() {
                this._refCounter === 0 &&
                  ((this._enabled = !0), this.onEnable && this.onEnable()),
                  this._refCounter++;
              }
              decrementCounter() {
                if (this._refCounter === 1)
                  (this._enabled = !1), this.onDisable && this.onDisable();
                else if (this._refCounter === 0) return;
                this._refCounter--;
              }
              addMeshInstances(u, v) {
                const _ = this._shaderVersion,
                  m = this.shadowCasters;
                for (let g = 0; g < u.length; g++) {
                  const T = u[g],
                    E = T.material,
                    M =
                      E.blendType === x.Rj
                        ? this.opaqueMeshInstances
                        : this.transparentMeshInstances;
                  this.opaqueMeshInstances.indexOf(T) < 0 &&
                    this.transparentMeshInstances.indexOf(T) < 0 &&
                    M.push(T),
                    !v && T.castShadow && m.indexOf(T) < 0 && m.push(T),
                    !this.passThrough &&
                      _ >= 0 &&
                      E._shaderVersion !== _ &&
                      (E.getShaderVariant !== y.i.prototype.getShaderVariant &&
                        E.clearVariants(),
                      (E._shaderVersion = _));
                }
                this.passThrough || (this._dirty = !0);
              }
              removeMeshInstanceFromArray(u, v) {
                const _ = v.indexOf(u);
                _ >= 0 && v.splice(_, 1);
              }
              removeMeshInstances(u, v) {
                const _ = this.opaqueMeshInstances,
                  m = this.transparentMeshInstances,
                  g = this.shadowCasters;
                for (let T = 0; T < u.length; T++) {
                  const E = u[T];
                  if (
                    (this.removeMeshInstanceFromArray(E, _),
                    this.removeMeshInstanceFromArray(E, m),
                    !v)
                  ) {
                    const M = g.indexOf(E);
                    M >= 0 && g.splice(M, 1);
                  }
                }
                this._dirty = !0;
              }
              clearMeshInstances(u) {
                (this.opaqueMeshInstances.length === 0 &&
                  this.transparentMeshInstances.length === 0 &&
                  (u || this.shadowCasters.length === 0)) ||
                  ((this.opaqueMeshInstances.length = 0),
                  (this.transparentMeshInstances.length = 0),
                  u || (this.shadowCasters.length = 0),
                  this.passThrough || (this._dirty = !0));
              }
              addLight(u) {
                const v = u.light;
                this._lightsSet.has(v) ||
                  (this._lightsSet.add(v),
                  this._lights.push(v),
                  (this._dirtyLights = !0),
                  (this._lightHashDirty = !0)),
                  v.type !== x.kx && this._clusteredLightsSet.add(v);
              }
              removeLight(u) {
                const v = u.light;
                this._lightsSet.has(v) &&
                  (this._lightsSet.delete(v),
                  this._lights.splice(this._lights.indexOf(v), 1),
                  (this._dirtyLights = !0),
                  (this._lightHashDirty = !0)),
                  v.type !== x.kx && this._clusteredLightsSet.delete(v);
              }
              clearLights() {
                this._lightsSet.clear(),
                  this._clusteredLightsSet.clear(),
                  (this._lights.length = 0),
                  (this._dirtyLights = !0);
              }
              addShadowCasters(u) {
                const v = this.shadowCasters;
                for (let _ = 0; _ < u.length; _++) {
                  const m = u[_];
                  m.castShadow && v.indexOf(m) < 0 && v.push(m);
                }
                this._dirtyLights = !0;
              }
              removeShadowCasters(u) {
                const v = this.shadowCasters;
                for (let _ = 0; _ < u.length; _++) {
                  const m = v.indexOf(u[_]);
                  m >= 0 && v.splice(m, 1);
                }
                this._dirtyLights = !0;
              }
              getLightHash(u) {
                if (this._lightHashDirty) {
                  (this._lightHashDirty = !1), (this._lightHash = 0);
                  const v = this._lights;
                  if (v.length > 0) {
                    v.sort(l);
                    for (let _ = 0; _ < v.length; _++)
                      (u && v[_].type !== x.kx) || o.push(v[_].key);
                    o.length > 0 &&
                      ((this._lightHash = (0, A.m)(o)), (o.length = 0));
                  }
                }
                return this._lightHash;
              }
              addCamera(u) {
                this.cameras.indexOf(u) >= 0 ||
                  (this.cameras.push(u), (this._dirtyCameras = !0));
              }
              removeCamera(u) {
                const v = this.cameras.indexOf(u);
                v >= 0 &&
                  (this.cameras.splice(v, 1),
                  (this._dirtyCameras = !0),
                  this.instances.delete(v));
              }
              clearCameras() {
                (this.cameras.length = 0), (this._dirtyCameras = !0);
              }
              _calculateSortDistances(u, v, _, m) {
                for (let g = 0; g < v; g++) {
                  const T = u[g];
                  if (T.command || T.layer <= x.Jo) continue;
                  if (T.calculateSortDistance) {
                    T.zdist = T.calculateSortDistance(T, _, m);
                    continue;
                  }
                  const E = T.aabb.center,
                    M = E.x - _.x,
                    R = E.y - _.y,
                    P = E.z - _.z;
                  T.zdist = M * m.x + R * m.y + P * m.z;
                }
              }
              _sortVisible(u, v, _) {
                const m = this.instances,
                  g = u ? this.transparentSortMode : this.opaqueSortMode;
                if (g === x.lU) return;
                const T = u ? m.visibleTransparent[_] : m.visibleOpaque[_];
                if (g === x.eQ) {
                  const E = v.getPosition(),
                    M = v.forward;
                  this.customCalculateSortValues &&
                    this.customCalculateSortValues(T.list, T.length, E, M),
                    T.list.length !== T.length && (T.list.length = T.length),
                    this.customSortCallback &&
                      T.list.sort(this.customSortCallback);
                } else {
                  if (g === x.PD || g === x.rG) {
                    const E = v.getPosition(),
                      M = v.forward;
                    this._calculateSortDistances(T.list, T.length, E, M);
                  }
                  T.list.length !== T.length && (T.list.length = T.length),
                    T.list.sort(s[g]);
                }
              }
            }
          },
          8026: (xe, V, a) => {
            "use strict";
            a.d(V, { A: () => i, v: () => u });
            var A = a(8656),
              x = a(5227),
              y = a(8484),
              c = a(7994),
              d = a(7481),
              h = a(5596),
              f = a(9391),
              s = a(5520);
            const l = new d.e(),
              n = { bias: 0, normalBias: 0 },
              o = { r: 0, g: 1, b: 2, a: 3 },
              i = { directional: f.kx, omni: f.dG, point: f.dG, spot: f.Gy },
              e = [
                [new h.Z(0, 0, 1, 1)],
                [new h.Z(0, 0, 0.5, 0.5), new h.Z(0, 0.5, 0.5, 0.5)],
                [
                  new h.Z(0, 0, 0.5, 0.5),
                  new h.Z(0, 0.5, 0.5, 0.5),
                  new h.Z(0.5, 0, 0.5, 0.5),
                ],
                [
                  new h.Z(0, 0, 0.5, 0.5),
                  new h.Z(0, 0.5, 0.5, 0.5),
                  new h.Z(0.5, 0, 0.5, 0.5),
                  new h.Z(0.5, 0.5, 0.5, 0.5),
                ],
              ];
            let t = 0;
            class r {
              constructor(_, m, g, T) {
                (this.light = T),
                  (this.camera = m),
                  (this.shadowCamera = s.u.createShadowCamera(
                    _,
                    T._shadowType,
                    T._type,
                    g
                  )),
                  (this.shadowMatrix = new y.$()),
                  (this.shadowViewport = new h.Z(0, 0, 1, 1)),
                  (this.shadowScissor = new h.Z(0, 0, 1, 1)),
                  (this.depthRangeCompensation = 0),
                  (this.projectionCompensation = 0),
                  (this.face = g),
                  (this.visibleCasters = []),
                  (this.viewBindGroups = []);
              }
              destroy() {
                this.viewBindGroups.forEach((_) => {
                  _.defaultUniformBuffer.destroy(), _.destroy();
                }),
                  (this.viewBindGroups.length = 0);
              }
              get shadowBuffer() {
                const _ = this.shadowCamera.renderTarget;
                if (_) {
                  const m = this.light;
                  return m._type === f.dG
                    ? _.colorBuffer
                    : m._isPcf && m.device.supportsDepthShadow
                    ? _.depthBuffer
                    : _.colorBuffer;
                }
                return null;
              }
            }
            class u {
              constructor(_) {
                (this.device = _),
                  (this.id = t++),
                  (this._type = f.kx),
                  (this._color = new x.Q(0.8, 0.8, 0.8)),
                  (this._intensity = 1),
                  (this._affectSpecularity = !0),
                  (this._luminance = 0),
                  (this._castShadows = !1),
                  (this._enabled = !1),
                  (this.mask = f.Xj),
                  (this.isStatic = !1),
                  (this.key = 0),
                  (this.bakeDir = !0),
                  (this.bakeNumSamples = 1),
                  (this.bakeArea = 0),
                  (this.attenuationStart = 10),
                  (this.attenuationEnd = 10),
                  (this._falloffMode = f.$7),
                  (this._shadowType = f.MF),
                  (this._vsmBlurSize = 11),
                  (this.vsmBlurMode = f.wA),
                  (this.vsmBias = 0.0025),
                  (this._cookie = null),
                  (this.cookieIntensity = 1),
                  (this._cookieFalloff = !0),
                  (this._cookieChannel = "rgb"),
                  (this._cookieTransform = null),
                  (this._cookieTransformUniform = new Float32Array(4)),
                  (this._cookieOffset = null),
                  (this._cookieOffsetUniform = new Float32Array(2)),
                  (this._cookieTransformSet = !1),
                  (this._cookieOffsetSet = !1),
                  (this._innerConeAngle = 40),
                  (this._outerConeAngle = 45),
                  (this.cascades = null),
                  (this._shadowMatrixPalette = null),
                  (this._shadowCascadeDistances = null),
                  (this.numCascades = 1),
                  (this.cascadeDistribution = 0.5),
                  (this._shape = f.j0),
                  (this._finalColor = new Float32Array([0.8, 0.8, 0.8]));
                const m = Math.pow(this._finalColor[0], 2.2);
                (this._linearFinalColor = new Float32Array([m, m, m])),
                  (this._position = new d.e(0, 0, 0)),
                  (this._direction = new d.e(0, 0, 0)),
                  (this._innerConeAngleCos = Math.cos(
                    (this._innerConeAngle * Math.PI) / 180
                  )),
                  this._updateOuterAngle(this._outerConeAngle),
                  (this._usePhysicalUnits = void 0),
                  (this._shadowMap = null),
                  (this._shadowRenderParams = []),
                  (this._shadowCameraParams = []),
                  (this.shadowDistance = 40),
                  (this._shadowResolution = 1024),
                  (this.shadowBias = -5e-4),
                  (this.shadowIntensity = 1),
                  (this._normalOffsetBias = 0),
                  (this.shadowUpdateMode = f.M5),
                  (this.shadowUpdateOverrides = null),
                  (this._penumbraSize = 1),
                  (this._isVsm = !1),
                  (this._isPcf = !0),
                  (this._cookieMatrix = null),
                  (this._atlasViewport = null),
                  (this.atlasViewportAllocated = !1),
                  (this.atlasVersion = 0),
                  (this.atlasSlotIndex = 0),
                  (this.atlasSlotUpdated = !1),
                  (this._scene = null),
                  (this._node = null),
                  (this._renderData = []),
                  (this.visibleThisFrame = !1),
                  (this.maxScreenSize = 0);
              }
              destroy() {
                this._destroyShadowMap(),
                  this.releaseRenderData(),
                  (this._renderData = null);
              }
              releaseRenderData() {
                if (this._renderData) {
                  for (let _ = 0; _ < this._renderData.length; _++)
                    this._renderData[_].destroy();
                  this._renderData.length = 0;
                }
              }
              set numCascades(_) {
                (!this.cascades || this.numCascades !== _) &&
                  ((this.cascades = e[_ - 1]),
                  (this._shadowMatrixPalette = new Float32Array(64)),
                  (this._shadowCascadeDistances = new Float32Array(4)),
                  this._destroyShadowMap(),
                  this.updateKey());
              }
              get numCascades() {
                return this.cascades.length;
              }
              set shadowMap(_) {
                this._shadowMap !== _ &&
                  (this._destroyShadowMap(), (this._shadowMap = _));
              }
              get shadowMap() {
                return this._shadowMap;
              }
              get numShadowFaces() {
                const _ = this._type;
                return _ === f.kx ? this.numCascades : _ === f.dG ? 6 : 1;
              }
              set type(_) {
                if (this._type === _) return;
                (this._type = _), this._destroyShadowMap(), this.updateKey();
                const m = this._shadowType;
                (this._shadowType = null),
                  (this.shadowUpdateOverrides = null),
                  (this.shadowType = m);
              }
              get type() {
                return this._type;
              }
              set shape(_) {
                if (this._shape === _) return;
                (this._shape = _), this._destroyShadowMap(), this.updateKey();
                const m = this._shadowType;
                (this._shadowType = null), (this.shadowType = m);
              }
              get shape() {
                return this._shape;
              }
              set usePhysicalUnits(_) {
                this._usePhysicalUnits !== _ &&
                  ((this._usePhysicalUnits = _), this._updateFinalColor());
              }
              get usePhysicalUnits() {
                return this._usePhysicalUnits;
              }
              set shadowType(_) {
                if (this._shadowType === _) return;
                const m = this.device;
                this._type === f.dG && _ !== f.MF && _ !== f.vJ && (_ = f.MF);
                const g = m.supportsDepthShadow;
                _ === f.Mq && !g && (_ = f.MF),
                  _ === f.DT && !m.textureFloatRenderable && (_ = f.xv),
                  _ === f.xv && !m.textureHalfFloatRenderable && (_ = f.oR),
                  (this._isVsm = _ >= f.oR && _ <= f.DT),
                  (this._isPcf = _ === f.Mk || _ === f.MF || _ === f.Mq),
                  (this._shadowType = _),
                  this._destroyShadowMap(),
                  this.updateKey();
              }
              get shadowType() {
                return this._shadowType;
              }
              set enabled(_) {
                this._enabled !== _ &&
                  ((this._enabled = _), this.layersDirty());
              }
              get enabled() {
                return this._enabled;
              }
              set castShadows(_) {
                this._castShadows !== _ &&
                  ((this._castShadows = _),
                  this._destroyShadowMap(),
                  this.layersDirty(),
                  this.updateKey());
              }
              get castShadows() {
                return (
                  this._castShadows && this.mask !== f.XE && this.mask !== 0
                );
              }
              set shadowResolution(_) {
                this._shadowResolution !== _ &&
                  (this._type === f.dG
                    ? (_ = Math.min(_, this.device.maxCubeMapSize))
                    : (_ = Math.min(_, this.device.maxTextureSize)),
                  (this._shadowResolution = _),
                  this._destroyShadowMap());
              }
              get shadowResolution() {
                return this._shadowResolution;
              }
              set vsmBlurSize(_) {
                this._vsmBlurSize !== _ &&
                  (_ % 2 === 0 && _++, (this._vsmBlurSize = _));
              }
              get vsmBlurSize() {
                return this._vsmBlurSize;
              }
              set normalOffsetBias(_) {
                this._normalOffsetBias !== _ &&
                  (((!this._normalOffsetBias && _) ||
                    (this._normalOffsetBias && !_)) &&
                    this.updateKey(),
                  (this._normalOffsetBias = _));
              }
              get normalOffsetBias() {
                return this._normalOffsetBias;
              }
              set falloffMode(_) {
                this._falloffMode !== _ &&
                  ((this._falloffMode = _), this.updateKey());
              }
              get falloffMode() {
                return this._falloffMode;
              }
              set innerConeAngle(_) {
                this._innerConeAngle !== _ &&
                  ((this._innerConeAngle = _),
                  (this._innerConeAngleCos = Math.cos((_ * Math.PI) / 180)),
                  this._usePhysicalUnits && this._updateFinalColor());
              }
              get innerConeAngle() {
                return this._innerConeAngle;
              }
              set outerConeAngle(_) {
                this._outerConeAngle !== _ &&
                  ((this._outerConeAngle = _),
                  this._updateOuterAngle(_),
                  this._usePhysicalUnits && this._updateFinalColor());
              }
              get outerConeAngle() {
                return this._outerConeAngle;
              }
              set penumbraSize(_) {
                this._penumbraSize = _;
              }
              get penumbraSize() {
                return this._penumbraSize;
              }
              _updateOuterAngle(_) {
                const m = (_ * Math.PI) / 180;
                (this._outerConeAngleCos = Math.cos(m)),
                  (this._outerConeAngleSin = Math.sin(m));
              }
              set intensity(_) {
                this._intensity !== _ &&
                  ((this._intensity = _), this._updateFinalColor());
              }
              get intensity() {
                return this._intensity;
              }
              set affectSpecularity(_) {
                this._type === f.kx &&
                  ((this._affectSpecularity = _), this.updateKey());
              }
              get affectSpecularity() {
                return this._affectSpecularity;
              }
              set luminance(_) {
                this._luminance !== _ &&
                  ((this._luminance = _), this._updateFinalColor());
              }
              get luminance() {
                return this._luminance;
              }
              get cookieMatrix() {
                return (
                  this._cookieMatrix || (this._cookieMatrix = new y.$()),
                  this._cookieMatrix
                );
              }
              get atlasViewport() {
                return (
                  this._atlasViewport ||
                    (this._atlasViewport = new h.Z(0, 0, 1, 1)),
                  this._atlasViewport
                );
              }
              set cookie(_) {
                this._cookie !== _ && ((this._cookie = _), this.updateKey());
              }
              get cookie() {
                return this._cookie;
              }
              set cookieFalloff(_) {
                this._cookieFalloff !== _ &&
                  ((this._cookieFalloff = _), this.updateKey());
              }
              get cookieFalloff() {
                return this._cookieFalloff;
              }
              set cookieChannel(_) {
                if (this._cookieChannel !== _) {
                  if (_.length < 3) {
                    const m = _.charAt(_.length - 1),
                      g = 3 - _.length;
                    for (let T = 0; T < g; T++) _ += m;
                  }
                  (this._cookieChannel = _), this.updateKey();
                }
              }
              get cookieChannel() {
                return this._cookieChannel;
              }
              set cookieTransform(_) {
                this._cookieTransform !== _ &&
                  ((this._cookieTransform = _),
                  (this._cookieTransformSet = !!_),
                  _ &&
                    !this._cookieOffset &&
                    ((this.cookieOffset = new c.Z()),
                    (this._cookieOffsetSet = !1)),
                  this.updateKey());
              }
              get cookieTransform() {
                return this._cookieTransform;
              }
              set cookieOffset(_) {
                if (this._cookieOffset === _) return;
                !!(this._cookieTransformSet || _) && !_ && this._cookieOffset
                  ? this._cookieOffset.set(0, 0)
                  : (this._cookieOffset = _),
                  (this._cookieOffsetSet = !!_),
                  _ &&
                    !this._cookieTransform &&
                    ((this.cookieTransform = new h.Z(1, 1, 0, 0)),
                    (this._cookieTransformSet = !1)),
                  this.updateKey();
              }
              get cookieOffset() {
                return this._cookieOffset;
              }
              beginFrame() {
                (this.visibleThisFrame = this._type === f.kx && this._enabled),
                  (this.maxScreenSize = 0),
                  (this.atlasViewportAllocated = !1),
                  (this.atlasSlotUpdated = !1);
              }
              _destroyShadowMap() {
                if (
                  (this.releaseRenderData(),
                  this._shadowMap &&
                    (this._shadowMap.cached || this._shadowMap.destroy(),
                    (this._shadowMap = null)),
                  this.shadowUpdateMode === f.Jb &&
                    (this.shadowUpdateMode = f.e3),
                  this.shadowUpdateOverrides)
                )
                  for (let _ = 0; _ < this.shadowUpdateOverrides.length; _++)
                    this.shadowUpdateOverrides[_] === f.Jb &&
                      (this.shadowUpdateOverrides[_] = f.e3);
              }
              getRenderData(_, m) {
                for (let T = 0; T < this._renderData.length; T++) {
                  const E = this._renderData[T];
                  if (E.camera === _ && E.face === m) return E;
                }
                const g = new r(this.device, _, m, this);
                return this._renderData.push(g), g;
              }
              clone() {
                const _ = new u(this.device);
                return (
                  (_.type = this._type),
                  _.setColor(this._color),
                  (_.intensity = this._intensity),
                  (_.affectSpecularity = this._affectSpecularity),
                  (_.luminance = this._luminance),
                  (_.castShadows = this.castShadows),
                  (_._enabled = this._enabled),
                  (_.attenuationStart = this.attenuationStart),
                  (_.attenuationEnd = this.attenuationEnd),
                  (_.falloffMode = this._falloffMode),
                  (_.shadowType = this._shadowType),
                  (_.vsmBlurSize = this._vsmBlurSize),
                  (_.vsmBlurMode = this.vsmBlurMode),
                  (_.vsmBias = this.vsmBias),
                  (_.penumbraSize = this.penumbraSize),
                  (_.shadowUpdateMode = this.shadowUpdateMode),
                  (_.mask = this.mask),
                  this.shadowUpdateOverrides &&
                    (_.shadowUpdateOverrides =
                      this.shadowUpdateOverrides.slice()),
                  (_.innerConeAngle = this._innerConeAngle),
                  (_.outerConeAngle = this._outerConeAngle),
                  (_.numCascades = this.numCascades),
                  (_.cascadeDistribution = this.cascadeDistribution),
                  (_.shape = this._shape),
                  (_.shadowBias = this.shadowBias),
                  (_.normalOffsetBias = this._normalOffsetBias),
                  (_.shadowResolution = this._shadowResolution),
                  (_.shadowDistance = this.shadowDistance),
                  (_.shadowIntensity = this.shadowIntensity),
                  _
                );
              }
              static getLightUnitConversion(_, m = Math.PI / 4, g = 0) {
                switch (_) {
                  case f.Gy: {
                    const T = Math.cos(m),
                      E = Math.cos(g);
                    return 2 * Math.PI * (1 - E + (E - T) / 2);
                  }
                  case f.dG:
                    return 4 * Math.PI;
                  case f.kx:
                    return 1;
                }
              }
              _getUniformBiasValues(_) {
                const m = _.shadowCamera._farClip;
                switch (this._type) {
                  case f.dG:
                    (n.bias = this.shadowBias),
                      (n.normalBias = this._normalOffsetBias);
                    break;
                  case f.Gy:
                    this._isVsm
                      ? (n.bias = -2e-4)
                      : ((n.bias = this.shadowBias * 20),
                        !this.device.webgl2 &&
                          this.device.extStandardDerivatives &&
                          (n.bias *= -100)),
                      (n.normalBias = this._isVsm
                        ? this.vsmBias / (this.attenuationEnd / 7)
                        : this._normalOffsetBias);
                    break;
                  case f.kx:
                    this._isVsm
                      ? (n.bias = -2e-4)
                      : ((n.bias = (this.shadowBias / m) * 100),
                        !this.device.webgl2 &&
                          this.device.extStandardDerivatives &&
                          (n.bias *= -100)),
                      (n.normalBias = this._isVsm
                        ? this.vsmBias / (m / 7)
                        : this._normalOffsetBias);
                    break;
                }
                return n;
              }
              getColor() {
                return this._color;
              }
              getBoundingSphere(_) {
                if (this._type === f.Gy) {
                  const m = this.attenuationEnd,
                    g = this._outerConeAngle,
                    T = this._outerConeAngleCos,
                    E = this._node;
                  l.copy(E.up),
                    g > 45
                      ? ((_.radius = m * this._outerConeAngleSin),
                        l.mulScalar(-m * T))
                      : ((_.radius = m / (2 * T)), l.mulScalar(-_.radius)),
                    _.center.add2(E.getPosition(), l);
                } else
                  this._type === f.dG &&
                    ((_.center = this._node.getPosition()),
                    (_.radius = this.attenuationEnd));
              }
              getBoundingBox(_) {
                if (this._type === f.Gy) {
                  const m = this.attenuationEnd,
                    g = this._outerConeAngle,
                    T = this._node,
                    E = Math.abs(Math.sin(g * A.D.DEG_TO_RAD) * m);
                  _.center.set(0, -m * 0.5, 0),
                    _.halfExtents.set(E, m * 0.5, E),
                    _.setFromTransformedAabb(_, T.getWorldTransform(), !0);
                } else
                  this._type === f.dG &&
                    (_.center.copy(this._node.getPosition()),
                    _.halfExtents.set(
                      this.attenuationEnd,
                      this.attenuationEnd,
                      this.attenuationEnd
                    ));
              }
              _updateFinalColor() {
                const _ = this._color,
                  m = _.r,
                  g = _.g,
                  T = _.b;
                let E = this._intensity;
                this._usePhysicalUnits &&
                  (E =
                    this._luminance /
                    u.getLightUnitConversion(
                      this._type,
                      this._outerConeAngle * A.D.DEG_TO_RAD,
                      this._innerConeAngle * A.D.DEG_TO_RAD
                    ));
                const M = this._finalColor,
                  R = this._linearFinalColor;
                (M[0] = m * E),
                  (M[1] = g * E),
                  (M[2] = T * E),
                  E >= 1
                    ? ((R[0] = Math.pow(m, 2.2) * E),
                      (R[1] = Math.pow(g, 2.2) * E),
                      (R[2] = Math.pow(T, 2.2) * E))
                    : ((R[0] = Math.pow(M[0], 2.2)),
                      (R[1] = Math.pow(M[1], 2.2)),
                      (R[2] = Math.pow(M[2], 2.2)));
              }
              setColor() {
                arguments.length === 1
                  ? this._color.set(
                      arguments[0].r,
                      arguments[0].g,
                      arguments[0].b
                    )
                  : arguments.length === 3 &&
                    this._color.set(arguments[0], arguments[1], arguments[2]),
                  this._updateFinalColor();
              }
              layersDirty() {
                var _;
                (_ = this._scene) != null &&
                  _.layers &&
                  (this._scene.layers._dirtyLights = !0);
              }
              updateKey() {
                let _ =
                  (this._type << 29) |
                  ((this._castShadows ? 1 : 0) << 28) |
                  (this._shadowType << 25) |
                  (this._falloffMode << 23) |
                  ((this._normalOffsetBias !== 0 ? 1 : 0) << 22) |
                  ((this._cookie ? 1 : 0) << 21) |
                  ((this._cookieFalloff ? 1 : 0) << 20) |
                  (o[this._cookieChannel.charAt(0)] << 18) |
                  ((this._cookieTransform ? 1 : 0) << 12) |
                  (this._shape << 10) |
                  ((this.numCascades - 1) << 8) |
                  ((this.affectSpecularity ? 1 : 0) << 7);
                this._cookieChannel.length === 3 &&
                  ((_ |= o[this._cookieChannel.charAt(1)] << 16),
                  (_ |= o[this._cookieChannel.charAt(2)] << 14)),
                  _ !== this.key && this._scene !== null && this.layersDirty(),
                  (this.key = _);
              }
            }
          },
          818: (xe, V, a) => {
            "use strict";
            a.d(V, { p: () => c });
            var A = a(8656),
              x = a(7481),
              y = a(9391);
            class c {
              constructor(h, f, s) {
                (this._areaLightsEnabled = !1),
                  (this._cells = new x.e(10, 3, 10)),
                  (this._maxLightsPerCell = 255),
                  (this._shadowsEnabled = !0),
                  (this._shadowType = y.MF),
                  (this._shadowAtlasResolution = 2048),
                  (this._cookiesEnabled = !1),
                  (this._cookieAtlasResolution = 2048),
                  (this.debugLayer = void 0),
                  (this.atlasSplit = null),
                  (this._supportsAreaLights = h),
                  (this._maxTextureSize = f),
                  (this._dirtyLightsFnc = s);
              }
              applySettings(h) {
                var f, s, l, n, o, i, e;
                (this.shadowsEnabled =
                  (f = h.lightingShadowsEnabled) != null
                    ? f
                    : this.shadowsEnabled),
                  (this.cookiesEnabled =
                    (s = h.lightingCookiesEnabled) != null
                      ? s
                      : this.cookiesEnabled),
                  (this.areaLightsEnabled =
                    (l = h.lightingAreaLightsEnabled) != null
                      ? l
                      : this.areaLightsEnabled),
                  (this.shadowAtlasResolution =
                    (n = h.lightingShadowAtlasResolution) != null
                      ? n
                      : this.shadowAtlasResolution),
                  (this.cookieAtlasResolution =
                    (o = h.lightingCookieAtlasResolution) != null
                      ? o
                      : this.cookieAtlasResolution),
                  (this.maxLightsPerCell =
                    (i = h.lightingMaxLightsPerCell) != null
                      ? i
                      : this.maxLightsPerCell),
                  (this.shadowType =
                    (e = h.lightingShadowType) != null ? e : this.shadowType),
                  h.lightingCells && (this.cell = new x.e(h.lightingCells));
              }
              set cells(h) {
                this._cells.copy(h);
              }
              get cells() {
                return this._cells;
              }
              set maxLightsPerCell(h) {
                this._maxLightsPerCell = A.D.clamp(h, 1, 255);
              }
              get maxLightsPerCell() {
                return this._maxLightsPerCell;
              }
              set cookieAtlasResolution(h) {
                this._cookieAtlasResolution = A.D.clamp(
                  h,
                  32,
                  this._maxTextureSize
                );
              }
              get cookieAtlasResolution() {
                return this._cookieAtlasResolution;
              }
              set shadowAtlasResolution(h) {
                this._shadowAtlasResolution = A.D.clamp(
                  h,
                  32,
                  this._maxTextureSize
                );
              }
              get shadowAtlasResolution() {
                return this._shadowAtlasResolution;
              }
              set shadowType(h) {
                this._shadowType !== h &&
                  ((this._shadowType = h), this._dirtyLightsFnc());
              }
              get shadowType() {
                return this._shadowType;
              }
              set cookiesEnabled(h) {
                this._cookiesEnabled !== h &&
                  ((this._cookiesEnabled = h), this._dirtyLightsFnc());
              }
              get cookiesEnabled() {
                return this._cookiesEnabled;
              }
              set areaLightsEnabled(h) {
                this._supportsAreaLights &&
                  this._areaLightsEnabled !== h &&
                  ((this._areaLightsEnabled = h), this._dirtyLightsFnc());
              }
              get areaLightsEnabled() {
                return this._areaLightsEnabled;
              }
              set shadowsEnabled(h) {
                this._shadowsEnabled !== h &&
                  ((this._shadowsEnabled = h), this._dirtyLightsFnc());
              }
              get shadowsEnabled() {
                return this._shadowsEnabled;
              }
            }
          },
          9877: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => t });
            var A = a(7481),
              x = a(1630),
              y = a(3064),
              c = a(9391),
              d = a(1208),
              h = a(222);
            const f = 1e-6,
              s = new A.e(),
              l = new Float32Array(6),
              n = new A.e(-0.5, 0, 0),
              o = new A.e(0, 0, 0.5),
              i = {
                FLAGS: 0,
                COLOR_A: 1,
                COLOR_B: 2,
                SPOT_ANGLES: 3,
                SHADOW_BIAS: 4,
                COOKIE_A: 5,
                COOKIE_B: 6,
                COUNT_ALWAYS: 7,
                POSITION_X: 7,
                POSITION_Y: 8,
                POSITION_Z: 9,
                RANGE: 10,
                SPOT_DIRECTION_X: 11,
                SPOT_DIRECTION_Y: 12,
                SPOT_DIRECTION_Z: 13,
                PROJ_MAT_00: 14,
                ATLAS_VIEWPORT_A: 14,
                PROJ_MAT_01: 15,
                ATLAS_VIEWPORT_B: 15,
                PROJ_MAT_02: 16,
                PROJ_MAT_03: 17,
                PROJ_MAT_10: 18,
                PROJ_MAT_11: 19,
                PROJ_MAT_12: 20,
                PROJ_MAT_13: 21,
                PROJ_MAT_20: 22,
                PROJ_MAT_21: 23,
                PROJ_MAT_22: 24,
                PROJ_MAT_23: 25,
                PROJ_MAT_30: 26,
                PROJ_MAT_31: 27,
                PROJ_MAT_32: 28,
                PROJ_MAT_33: 29,
                AREA_DATA_WIDTH_X: 30,
                AREA_DATA_WIDTH_Y: 31,
                AREA_DATA_WIDTH_Z: 32,
                AREA_DATA_HEIGHT_X: 33,
                AREA_DATA_HEIGHT_Y: 34,
                AREA_DATA_HEIGHT_Z: 35,
                COUNT: 36,
              },
              e = {
                POSITION_RANGE: 0,
                SPOT_DIRECTION: 1,
                PROJ_MAT_0: 2,
                ATLAS_VIEWPORT: 2,
                PROJ_MAT_1: 3,
                PROJ_MAT_2: 4,
                PROJ_MAT_3: 5,
                AREA_DATA_WIDTH: 6,
                AREA_DATA_HEIGHT: 7,
                COUNT: 8,
              };
            class t {
              static initShaderDefines() {
                const u =
                  t.lightTextureFormat === t.FORMAT_FLOAT ? "FLOAT" : "8BIT";
                t.shaderDefines = `
						
#define CLUSTER_TEXTURE_${u}
						${t.buildShaderDefines(i, "CLUSTER_TEXTURE_8_")}
						${t.buildShaderDefines(e, "CLUSTER_TEXTURE_F_")}
				`;
              }
              static buildShaderDefines(u, v) {
                let _ = "";
                const m = t.useTexelFetch ? "" : ".5";
                return (
                  Object.keys(u).forEach((g) => {
                    _ += `
#define ${v}${g} ${u[g]}${m}`;
                  }),
                  _
                );
              }
              static init(u) {
                (t.lightTextureFormat =
                  u.extTextureFloat && u.maxTextures > 8
                    ? t.FORMAT_FLOAT
                    : t.FORMAT_8BIT),
                  (t.useTexelFetch = u.supportsTextureFetch),
                  t.initShaderDefines();
              }
              static createTexture(u, v, _, m, g) {
                return new d.g(u, {
                  name: g,
                  width: v,
                  height: _,
                  mipmaps: !1,
                  format: m,
                  addressU: x.vq6,
                  addressV: x.vq6,
                  type: x.s64,
                  magFilter: x.uhC,
                  minFilter: x.uhC,
                  anisotropy: 1,
                });
              }
              constructor(u) {
                (this.device = u),
                  (this.cookiesEnabled = !1),
                  (this.shadowsEnabled = !1),
                  (this.areaLightsEnabled = !1),
                  (this.maxLights = 255);
                let v = i.COUNT_ALWAYS,
                  _ = 0;
                t.lightTextureFormat === t.FORMAT_FLOAT
                  ? (_ = e.COUNT)
                  : (v = i.COUNT),
                  (this.lights8 = new Uint8ClampedArray(
                    4 * v * this.maxLights
                  )),
                  (this.lightsTexture8 = t.createTexture(
                    this.device,
                    v,
                    this.maxLights,
                    x.Lxj,
                    "LightsTexture8"
                  )),
                  (this._lightsTexture8Id =
                    this.device.scope.resolve("lightsTexture8")),
                  _
                    ? ((this.lightsFloat = new Float32Array(
                        4 * _ * this.maxLights
                      )),
                      (this.lightsTextureFloat = t.createTexture(
                        this.device,
                        _,
                        this.maxLights,
                        x.s7h,
                        "LightsTextureFloat"
                      )),
                      (this._lightsTextureFloatId =
                        this.device.scope.resolve("lightsTextureFloat")))
                    : ((this.lightsFloat = null),
                      (this.lightsTextureFloat = null),
                      (this._lightsTextureFloatId = void 0)),
                  (this._lightsTextureInvSizeId = this.device.scope.resolve(
                    "lightsTextureInvSize"
                  )),
                  (this._lightsTextureInvSizeData = new Float32Array(4)),
                  (this._lightsTextureInvSizeData[0] = _
                    ? 1 / this.lightsTextureFloat.width
                    : 0),
                  (this._lightsTextureInvSizeData[1] = _
                    ? 1 / this.lightsTextureFloat.height
                    : 0),
                  (this._lightsTextureInvSizeData[2] =
                    1 / this.lightsTexture8.width),
                  (this._lightsTextureInvSizeData[3] =
                    1 / this.lightsTexture8.height),
                  (this.invMaxColorValue = 0),
                  (this.invMaxAttenuation = 0),
                  (this.boundsMin = new A.e()),
                  (this.boundsDelta = new A.e());
              }
              destroy() {
                this.lightsTexture8 &&
                  (this.lightsTexture8.destroy(), (this.lightsTexture8 = null)),
                  this.lightsTextureFloat &&
                    (this.lightsTextureFloat.destroy(),
                    (this.lightsTextureFloat = null));
              }
              setCompressionRanges(u, v) {
                (this.invMaxColorValue = 1 / v),
                  (this.invMaxAttenuation = 1 / u);
              }
              setBounds(u, v) {
                this.boundsMin.copy(u), this.boundsDelta.copy(v);
              }
              uploadTextures() {
                this.lightsTextureFloat &&
                  (this.lightsTextureFloat.lock().set(this.lightsFloat),
                  this.lightsTextureFloat.unlock()),
                  this.lightsTexture8.lock().set(this.lights8),
                  this.lightsTexture8.unlock();
              }
              updateUniforms() {
                this._lightsTexture8Id.setValue(this.lightsTexture8),
                  t.lightTextureFormat === t.FORMAT_FLOAT &&
                    this._lightsTextureFloatId.setValue(
                      this.lightsTextureFloat
                    ),
                  this._lightsTextureInvSizeId.setValue(
                    this._lightsTextureInvSizeData
                  );
              }
              getSpotDirection(u, v) {
                v._node.getWorldTransform().getY(u).mulScalar(-1),
                  u.normalize();
              }
              getLightAreaSizes(u) {
                const v = u._node.getWorldTransform();
                return (
                  v.transformVector(n, s),
                  (l[0] = s.x),
                  (l[1] = s.y),
                  (l[2] = s.z),
                  v.transformVector(o, s),
                  (l[3] = s.x),
                  (l[4] = s.y),
                  (l[5] = s.z),
                  l
                );
              }
              addLightDataFlags(u, v, _, m, g, T) {
                (u[v + 0] = m ? 255 : 0),
                  (u[v + 1] = _._shape * 64),
                  (u[v + 2] = _._falloffMode * 255),
                  (u[v + 3] = g ? T * 255 : 0);
              }
              addLightDataColor(u, v, _, m, g) {
                const T = this.invMaxColorValue,
                  E = m ? _._linearFinalColor : _._finalColor;
                y.A.float2Bytes(E[0] * T, u, v + 0, 2),
                  y.A.float2Bytes(E[1] * T, u, v + 2, 2),
                  y.A.float2Bytes(E[2] * T, u, v + 4, 2),
                  (u[v + 6] = g ? 255 : 0);
                const M = !!(_.mask & c.Xj),
                  R = !!(_.mask & c.be);
                u[v + 7] = M && R ? 127 : R ? 255 : 0;
              }
              addLightDataSpotAngles(u, v, _) {
                y.A.float2Bytes(
                  _._innerConeAngleCos * (0.5 - f) + 0.5,
                  u,
                  v + 0,
                  2
                ),
                  y.A.float2Bytes(
                    _._outerConeAngleCos * (0.5 - f) + 0.5,
                    u,
                    v + 2,
                    2
                  );
              }
              addLightDataShadowBias(u, v, _) {
                const m = _.getRenderData(null, 0),
                  g = _._getUniformBiasValues(m);
                y.A.float2BytesRange(g.bias, u, v, -1, 20, 2),
                  y.A.float2Bytes(g.normalBias, u, v + 2, 2);
              }
              addLightDataPositionRange(u, v, _, m) {
                const g = s.sub2(m, this.boundsMin).div(this.boundsDelta);
                y.A.float2Bytes(g.x, u, v + 0, 4),
                  y.A.float2Bytes(g.y, u, v + 4, 4),
                  y.A.float2Bytes(g.z, u, v + 8, 4),
                  y.A.float2Bytes(
                    _.attenuationEnd * this.invMaxAttenuation,
                    u,
                    v + 12,
                    4
                  );
              }
              addLightDataSpotDirection(u, v, _) {
                this.getSpotDirection(s, _),
                  y.A.float2Bytes(s.x * (0.5 - f) + 0.5, u, v + 0, 4),
                  y.A.float2Bytes(s.y * (0.5 - f) + 0.5, u, v + 4, 4),
                  y.A.float2Bytes(s.z * (0.5 - f) + 0.5, u, v + 8, 4);
              }
              addLightDataLightProjMatrix(u, v, _) {
                const m = _.data;
                for (let g = 0; g < 12; g++)
                  y.A.float2BytesRange(m[g], u, v + 4 * g, -2, 2, 4);
                for (let g = 12; g < 16; g++)
                  y.A.float2MantissaExponent(m[g], u, v + 4 * g, 4);
              }
              addLightDataCookies(u, v, _) {
                const m = _._cookieChannel === "rgb";
                if (
                  ((u[v + 0] = Math.floor(_.cookieIntensity * 255)),
                  (u[v + 1] = m ? 255 : 0),
                  !m)
                ) {
                  const g = _._cookieChannel;
                  (u[v + 4] = g === "rrr" ? 255 : 0),
                    (u[v + 5] = g === "ggg" ? 255 : 0),
                    (u[v + 6] = g === "bbb" ? 255 : 0),
                    (u[v + 7] = g === "aaa" ? 255 : 0);
                }
              }
              addLightAtlasViewport(u, v, _) {
                y.A.float2Bytes(_.x, u, v + 0, 2),
                  y.A.float2Bytes(_.y, u, v + 2, 2),
                  y.A.float2Bytes(_.z / 3, u, v + 4, 2);
              }
              addLightAreaSizes(u, v, _) {
                const m = this.getLightAreaSizes(_);
                for (let g = 0; g < 6; g++)
                  y.A.float2MantissaExponent(m[g], u, v + 4 * g, 4);
              }
              addLightData(u, v, _) {
                const m = u._type === c.Gy,
                  g = u.atlasViewportAllocated,
                  T = this.cookiesEnabled && !!u._cookie && g,
                  E = this.areaLightsEnabled && u.shape !== c.j0,
                  M = this.shadowsEnabled && u.castShadows && g,
                  R = u._node.getPosition();
                let P = null,
                  F = null;
                m
                  ? M
                    ? (P = u.getRenderData(null, 0).shadowMatrix)
                    : T && (P = h.S.evalSpotCookieMatrix(u))
                  : (M || T) && (F = u.atlasViewport);
                const b = this.lights8,
                  D = v * this.lightsTexture8.width * 4;
                if (
                  (this.addLightDataFlags(
                    b,
                    D + 4 * i.FLAGS,
                    u,
                    m,
                    M,
                    u.shadowIntensity
                  ),
                  this.addLightDataColor(b, D + 4 * i.COLOR_A, u, _, T),
                  m && this.addLightDataSpotAngles(b, D + 4 * i.SPOT_ANGLES, u),
                  u.castShadows &&
                    this.addLightDataShadowBias(b, D + 4 * i.SHADOW_BIAS, u),
                  T && this.addLightDataCookies(b, D + 4 * i.COOKIE_A, u),
                  t.lightTextureFormat === t.FORMAT_FLOAT)
                ) {
                  const G = this.lightsFloat,
                    X = v * this.lightsTextureFloat.width * 4;
                  if (
                    ((G[X + 4 * e.POSITION_RANGE + 0] = R.x),
                    (G[X + 4 * e.POSITION_RANGE + 1] = R.y),
                    (G[X + 4 * e.POSITION_RANGE + 2] = R.z),
                    (G[X + 4 * e.POSITION_RANGE + 3] = u.attenuationEnd),
                    m &&
                      (this.getSpotDirection(s, u),
                      (G[X + 4 * e.SPOT_DIRECTION + 0] = s.x),
                      (G[X + 4 * e.SPOT_DIRECTION + 1] = s.y),
                      (G[X + 4 * e.SPOT_DIRECTION + 2] = s.z)),
                    P)
                  ) {
                    const ie = P.data;
                    for (let Q = 0; Q < 16; Q++)
                      G[X + 4 * e.PROJ_MAT_0 + Q] = ie[Q];
                  }
                  if (
                    (F &&
                      ((G[X + 4 * e.ATLAS_VIEWPORT + 0] = F.x),
                      (G[X + 4 * e.ATLAS_VIEWPORT + 1] = F.y),
                      (G[X + 4 * e.ATLAS_VIEWPORT + 2] = F.z / 3)),
                    E)
                  ) {
                    const ie = this.getLightAreaSizes(u);
                    (G[X + 4 * e.AREA_DATA_WIDTH + 0] = ie[0]),
                      (G[X + 4 * e.AREA_DATA_WIDTH + 1] = ie[1]),
                      (G[X + 4 * e.AREA_DATA_WIDTH + 2] = ie[2]),
                      (G[X + 4 * e.AREA_DATA_HEIGHT + 0] = ie[3]),
                      (G[X + 4 * e.AREA_DATA_HEIGHT + 1] = ie[4]),
                      (G[X + 4 * e.AREA_DATA_HEIGHT + 2] = ie[5]);
                  }
                } else
                  this.addLightDataPositionRange(b, D + 4 * i.POSITION_X, u, R),
                    m &&
                      this.addLightDataSpotDirection(
                        b,
                        D + 4 * i.SPOT_DIRECTION_X,
                        u
                      ),
                    P &&
                      this.addLightDataLightProjMatrix(
                        b,
                        D + 4 * i.PROJ_MAT_00,
                        P
                      ),
                    F &&
                      this.addLightAtlasViewport(
                        b,
                        D + 4 * i.ATLAS_VIEWPORT_A,
                        F
                      ),
                    E &&
                      this.addLightAreaSizes(b, D + 4 * i.AREA_DATA_WIDTH_X, u);
              }
            }
            (t.FORMAT_FLOAT = 0),
              (t.FORMAT_8BIT = 1),
              (t.lightTextureFormat = t.FORMAT_8BIT),
              (t.useTexelFetch = !1),
              (t.shaderDefines = "");
          },
          7087: (xe, V, a) => {
            "use strict";
            a.d(V, { q: () => e });
            var A = a(7481),
              x = a(8656),
              y = a(7915),
              c = a(1630),
              d = a(9391),
              h = a(9877);
            const f = new A.e(),
              s = new A.e(),
              l = new A.e(),
              n = new y.I(),
              o = 1e-6;
            class i {
              constructor() {
                (this.light = null),
                  (this.min = new A.e()),
                  (this.max = new A.e());
              }
            }
            class e {
              constructor(r) {
                (this.clusterTexture = void 0),
                  (this.device = r),
                  (this.name = "Untitled"),
                  (this.reportCount = 0),
                  (this.boundsMin = new A.e()),
                  (this.boundsMax = new A.e()),
                  (this.boundsDelta = new A.e()),
                  (this._cells = new A.e(1, 1, 1)),
                  (this._cellsLimit = new A.e()),
                  (this.cells = this._cells),
                  (this.maxCellLightCount = 4),
                  (this._maxAttenuation = 0),
                  (this._maxColorValue = 0),
                  (this._usedLights = []),
                  this._usedLights.push(new i()),
                  (this.lightsBuffer = new h.u(r)),
                  this.registerUniforms(r);
              }
              set maxCellLightCount(r) {
                r !== this._maxCellLightCount &&
                  ((this._maxCellLightCount = r), (this._cellsDirty = !0));
              }
              get maxCellLightCount() {
                return this._maxCellLightCount;
              }
              set cells(r) {
                f.copy(r).floor(),
                  this._cells.equals(f) ||
                    (this._cells.copy(f),
                    this._cellsLimit.copy(f).sub(A.e.ONE),
                    (this._cellsDirty = !0));
              }
              get cells() {
                return this._cells;
              }
              destroy() {
                this.lightsBuffer.destroy(), this.releaseClusterTexture();
              }
              releaseClusterTexture() {
                this.clusterTexture &&
                  (this.clusterTexture.destroy(), (this.clusterTexture = null));
              }
              registerUniforms(r) {
                (this._clusterSkipId = r.scope.resolve("clusterSkip")),
                  (this._clusterMaxCellsId =
                    r.scope.resolve("clusterMaxCells")),
                  (this._clusterWorldTextureId = r.scope.resolve(
                    "clusterWorldTexture"
                  )),
                  (this._clusterTextureSizeId =
                    r.scope.resolve("clusterTextureSize")),
                  (this._clusterTextureSizeData = new Float32Array(3)),
                  (this._clusterBoundsMinId =
                    r.scope.resolve("clusterBoundsMin")),
                  (this._clusterBoundsMinData = new Float32Array(3)),
                  (this._clusterBoundsDeltaId =
                    r.scope.resolve("clusterBoundsDelta")),
                  (this._clusterBoundsDeltaData = new Float32Array(3)),
                  (this._clusterCellsCountByBoundsSizeId = r.scope.resolve(
                    "clusterCellsCountByBoundsSize"
                  )),
                  (this._clusterCellsCountByBoundsSizeData = new Float32Array(
                    3
                  )),
                  (this._clusterCellsDotId =
                    r.scope.resolve("clusterCellsDot")),
                  (this._clusterCellsDotData = new Float32Array(3)),
                  (this._clusterCellsMaxId =
                    r.scope.resolve("clusterCellsMax")),
                  (this._clusterCellsMaxData = new Float32Array(3)),
                  (this._clusterCompressionLimit0Id = r.scope.resolve(
                    "clusterCompressionLimit0"
                  )),
                  (this._clusterCompressionLimit0Data = new Float32Array(2));
              }
              updateParams(r) {
                r &&
                  ((this.cells = r.cells),
                  (this.maxCellLightCount = r.maxLightsPerCell),
                  (this.lightsBuffer.cookiesEnabled = r.cookiesEnabled),
                  (this.lightsBuffer.shadowsEnabled = r.shadowsEnabled),
                  (this.lightsBuffer.areaLightsEnabled = r.areaLightsEnabled));
              }
              updateCells() {
                if (this._cellsDirty) {
                  this._cellsDirty = !1;
                  const r = this._cells.x,
                    u = this._cells.y,
                    v = this._cells.z,
                    _ = r * u * v,
                    m = this.maxCellLightCount * _;
                  let g = Math.ceil(Math.sqrt(m));
                  g = x.D.roundUp(g, this.maxCellLightCount);
                  const T = Math.ceil(m / g);
                  (this._clusterCellsMaxData[0] = r),
                    (this._clusterCellsMaxData[1] = u),
                    (this._clusterCellsMaxData[2] = v),
                    (this._clusterCellsDotData[0] = this.maxCellLightCount),
                    (this._clusterCellsDotData[1] =
                      r * v * this.maxCellLightCount),
                    (this._clusterCellsDotData[2] = r * this.maxCellLightCount),
                    (this.clusters = new Uint8ClampedArray(m)),
                    (this.counts = new Int32Array(_)),
                    (this._clusterTextureSizeData[0] = g),
                    (this._clusterTextureSizeData[1] = 1 / g),
                    (this._clusterTextureSizeData[2] = 1 / T),
                    this.releaseClusterTexture(),
                    (this.clusterTexture = h.u.createTexture(
                      this.device,
                      g,
                      T,
                      c.RSt,
                      "ClusterTexture"
                    ));
                }
              }
              uploadTextures() {
                this.clusterTexture.lock().set(this.clusters),
                  this.clusterTexture.unlock(),
                  this.lightsBuffer.uploadTextures();
              }
              updateUniforms() {
                this._clusterSkipId.setValue(
                  this._usedLights.length > 1 ? 0 : 1
                ),
                  this.lightsBuffer.updateUniforms(),
                  this._clusterWorldTextureId.setValue(this.clusterTexture),
                  this._clusterMaxCellsId.setValue(this.maxCellLightCount);
                const r = this.boundsDelta;
                (this._clusterCellsCountByBoundsSizeData[0] =
                  this._cells.x / r.x),
                  (this._clusterCellsCountByBoundsSizeData[1] =
                    this._cells.y / r.y),
                  (this._clusterCellsCountByBoundsSizeData[2] =
                    this._cells.z / r.z),
                  this._clusterCellsCountByBoundsSizeId.setValue(
                    this._clusterCellsCountByBoundsSizeData
                  ),
                  (this._clusterBoundsMinData[0] = this.boundsMin.x),
                  (this._clusterBoundsMinData[1] = this.boundsMin.y),
                  (this._clusterBoundsMinData[2] = this.boundsMin.z),
                  (this._clusterBoundsDeltaData[0] = r.x),
                  (this._clusterBoundsDeltaData[1] = r.y),
                  (this._clusterBoundsDeltaData[2] = r.z),
                  (this._clusterCompressionLimit0Data[0] =
                    this._maxAttenuation),
                  (this._clusterCompressionLimit0Data[1] = this._maxColorValue),
                  this._clusterTextureSizeId.setValue(
                    this._clusterTextureSizeData
                  ),
                  this._clusterBoundsMinId.setValue(this._clusterBoundsMinData),
                  this._clusterBoundsDeltaId.setValue(
                    this._clusterBoundsDeltaData
                  ),
                  this._clusterCellsDotId.setValue(this._clusterCellsDotData),
                  this._clusterCellsMaxId.setValue(this._clusterCellsMaxData),
                  this._clusterCompressionLimit0Id.setValue(
                    this._clusterCompressionLimit0Data
                  );
              }
              evalLightCellMinMax(r, u, v) {
                u.copy(r.min),
                  u.sub(this.boundsMin),
                  u.div(this.boundsDelta),
                  u.mul2(u, this.cells),
                  u.floor(),
                  v.copy(r.max),
                  v.sub(this.boundsMin),
                  v.div(this.boundsDelta),
                  v.mul2(v, this.cells),
                  v.ceil(),
                  u.max(A.e.ZERO),
                  v.min(this._cellsLimit);
              }
              collectLights(r) {
                const u = this.lightsBuffer.maxLights,
                  v = this._usedLights;
                let _ = 1;
                r.forEach((m) => {
                  const g = !!(m.mask & (d.Xj | d.be)),
                    T = m.type === d.Gy && m._outerConeAngle === 0;
                  if (
                    m.enabled &&
                    m.type !== d.kx &&
                    m.visibleThisFrame &&
                    m.intensity > 0 &&
                    g &&
                    !T &&
                    _ < u
                  ) {
                    let E;
                    _ < v.length ? (E = v[_]) : ((E = new i()), v.push(E)),
                      (E.light = m),
                      m.getBoundingBox(n),
                      E.min.copy(n.getMin()),
                      E.max.copy(n.getMax()),
                      _++;
                  }
                }),
                  (v.length = _);
              }
              evaluateBounds() {
                const r = this._usedLights,
                  u = this.boundsMin,
                  v = this.boundsMax;
                if (r.length > 1) {
                  u.copy(r[1].min), v.copy(r[1].max);
                  for (let _ = 2; _ < r.length; _++)
                    u.min(r[_].min), v.max(r[_].max);
                } else u.set(0, 0, 0), v.set(1, 1, 1);
                this.boundsDelta.sub2(v, u),
                  this.lightsBuffer.setBounds(u, this.boundsDelta);
              }
              evaluateCompressionLimits(r) {
                let u = 0,
                  v = 0;
                const _ = this._usedLights;
                for (let m = 1; m < _.length; m++) {
                  const g = _[m].light;
                  u = Math.max(g.attenuationEnd, u);
                  const T = r ? g._linearFinalColor : g._finalColor;
                  (v = Math.max(T[0], v)),
                    (v = Math.max(T[1], v)),
                    (v = Math.max(T[2], v));
                }
                (this._maxAttenuation = u + o),
                  (this._maxColorValue = v + o),
                  this.lightsBuffer.setCompressionRanges(
                    this._maxAttenuation,
                    this._maxColorValue
                  );
              }
              updateClusters(r) {
                this.counts.fill(0), this.clusters.fill(0);
                const u = this._cells.x,
                  v = this._cells.z,
                  _ = this.counts,
                  m = this._maxCellLightCount,
                  g = this.clusters,
                  T = this.maxCellLightCount,
                  E = this._usedLights;
                for (let M = 1; M < E.length; M++) {
                  const R = E[M],
                    P = R.light;
                  this.lightsBuffer.addLightData(P, M, r),
                    this.evalLightCellMinMax(R, s, l);
                  const F = s.x,
                    b = l.x,
                    D = s.y,
                    G = l.y,
                    X = s.z,
                    ie = l.z;
                  for (let Q = F; Q <= b; Q++)
                    for (let te = X; te <= ie; te++)
                      for (let ae = D; ae <= G; ae++) {
                        const Z = Q + u * (te + ae * v),
                          J = _[Z];
                        J < m && ((g[T * Z + J] = M), (_[Z] = J + 1));
                      }
                }
              }
              update(r, u, v) {
                this.updateParams(v),
                  this.updateCells(),
                  this.collectLights(r),
                  this.evaluateBounds(),
                  this.evaluateCompressionLimits(u),
                  this.updateClusters(u),
                  this.uploadTextures();
              }
              activate() {
                this.updateUniforms();
              }
            }
          },
          597: (xe, V, a) => {
            "use strict";
            a.d(V, { E: () => i });
            var A = a(5227),
              x = a(8568),
              y = a(9391),
              c = a(783),
              d = a(1630),
              h = a(9855),
              f = a(2910),
              s = a(4639),
              l = a(4559);
            const n = {
              generateKey: function (e) {
                let t = "basic";
                return (
                  e.fog && (t += "_fog"),
                  e.alphaTest && (t += "_atst"),
                  e.vertexColors && (t += "_vcol"),
                  e.diffuseMap && (t += "_diff"),
                  e.skin && (t += "_skin"),
                  e.screenSpace && (t += "_ss"),
                  e.useInstancing && (t += "_inst"),
                  e.useMorphPosition && (t += "_morphp"),
                  e.useMorphNormal && (t += "_morphn"),
                  e.useMorphTextureBased && (t += "_morpht"),
                  (t += "_" + e.pass),
                  t
                );
              },
              createShaderDefinition: function (e, t) {
                const r = { vertex_position: d.JYe };
                t.skin &&
                  ((r.vertex_boneWeights = d.Hn_),
                  (r.vertex_boneIndices = d.aVd)),
                  t.vertexColors && (r.vertex_color = d.F8$),
                  t.diffuseMap && (r.vertex_texCoord0 = d.slc);
                const v = s.p.get(e).getByIndex(t.pass).shaderDefines;
                let _ = v;
                (_ += f.G.transformDeclVS),
                  t.skin
                    ? ((_ += (0, l.P1)(e)), (_ += f.G.transformSkinnedVS))
                    : (_ += f.G.transformVS),
                  t.vertexColors &&
                    ((_ += `attribute vec4 vertex_color;
`),
                    (_ += `varying vec4 vColor;
`)),
                  t.diffuseMap &&
                    ((_ += `attribute vec2 vertex_texCoord0;
`),
                    (_ += `varying vec2 vUv0;
`)),
                  t.pass === y.w8 &&
                    ((_ += `varying float vDepth;
`),
                    (_ += `#ifndef VIEWMATRIX
`),
                    (_ += `#define VIEWMATRIX
`),
                    (_ += `uniform mat4 matrix_view;
`),
                    (_ += `#endif
`),
                    (_ += `#ifndef CAMERAPLANES
`),
                    (_ += `#define CAMERAPLANES
`),
                    (_ += `uniform vec4 camera_params;

`),
                    (_ += `#endif
`)),
                  (_ += (0, l.qN)()),
                  (_ += `   gl_Position = getPosition();
`),
                  t.pass === y.w8 &&
                    (_ += `    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;
`),
                  t.vertexColors &&
                    (_ += `    vColor = vertex_color;
`),
                  t.diffuseMap &&
                    (_ += `    vUv0 = vertex_texCoord0;
`),
                  (_ += (0, l._N)());
                let m = v;
                return (
                  t.vertexColors
                    ? (m += `varying vec4 vColor;
`)
                    : (m += `uniform vec4 uColor;
`),
                  t.diffuseMap &&
                    ((m += `varying vec2 vUv0;
`),
                    (m += `uniform sampler2D texture_diffuseMap;
`)),
                  t.fog && (m += (0, l.cu)(t.fog)),
                  t.alphaTest && (m += f.G.alphaTestPS),
                  t.pass === y.w8 &&
                    ((m += `varying float vDepth;
`),
                    (m += f.G.packDepthPS)),
                  (m += (0, l.qN)()),
                  t.vertexColors
                    ? (m += `    gl_FragColor = vColor;
`)
                    : (m += `    gl_FragColor = uColor;
`),
                  t.diffuseMap &&
                    (m += `    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);
`),
                  t.alphaTest &&
                    (m += `   alphaTest(gl_FragColor.a);
`),
                  t.pass !== y.cz &&
                    (t.pass === y.w8
                      ? (m += `    gl_FragColor = packFloat(vDepth);
`)
                      : t.fog &&
                        (m += `   glFragColor.rgb = addFog(gl_FragColor.rgb);
`)),
                  (m += (0, l._N)()),
                  h.l.createDefinition(e, {
                    name: "BasicShader",
                    attributes: r,
                    vertexCode: _,
                    fragmentCode: m,
                  })
                );
              },
            };
            var o = a(2658);
            class i extends o.i {
              constructor(...t) {
                super(...t),
                  (this.color = new A.Q(1, 1, 1, 1)),
                  (this.colorUniform = new Float32Array(4)),
                  (this.colorMap = null),
                  (this.vertexColors = !1);
              }
              copy(t) {
                return (
                  super.copy(t),
                  this.color.copy(t.color),
                  (this.colorMap = t.colorMap),
                  (this.vertexColors = t.vertexColors),
                  this
                );
              }
              updateUniforms(t, r) {
                this.clearParameters(),
                  (this.colorUniform[0] = this.color.r),
                  (this.colorUniform[1] = this.color.g),
                  (this.colorUniform[2] = this.color.b),
                  (this.colorUniform[3] = this.color.a),
                  this.setParameter("uColor", this.colorUniform),
                  this.colorMap &&
                    this.setParameter("texture_diffuseMap", this.colorMap);
              }
              getShaderVariant(t, r, u, v, _, m, g, T, E) {
                const M = {
                    skin: u && (u & y.Df) !== 0,
                    screenSpace: u && (u & y.yr) !== 0,
                    useInstancing: u && (u & y.Q$) !== 0,
                    useMorphPosition: u && (u & y.Ck) !== 0,
                    useMorphNormal: u && (u & y.ov) !== 0,
                    useMorphTextureBased: u && (u & y.uJ) !== 0,
                    alphaTest: this.alphaTest > 0,
                    vertexColors: this.vertexColors,
                    diffuseMap: !!this.colorMap,
                    pass: _,
                  },
                  R = new x.c(g, T, E),
                  P = (0, c.k)(t);
                return (
                  P.register("basic", n),
                  P.getProgram("basic", M, R, this.userId)
                );
              }
            }
          },
          1594: (xe, V, a) => {
            "use strict";
            a.d(V, { h: () => y, z: () => c });
            var A = a(5950);
            const x = new A.N();
            function y(d) {
              return x.get(d);
            }
            function c(d, h) {
              x.get(d, () => h);
            }
          },
          7715: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => x });
            var A = a(9391);
            class x {
              static update(c, d, h, f, s, l) {
                x.updateSharedOptions(c, d, h, f, s),
                  x.updateMaterialOptions(c, d),
                  x.updateEnvOptions(c, d, h),
                  x.updateLightingOptions(c, d, f, l),
                  s === A.Su && ((c.gamma = A.Rz), (c.toneMap = A.ll));
              }
              static updateSharedOptions(c, d, h, f, s) {
                (c.chunks = d.chunks),
                  (c.pass = s),
                  (c.alphaTest = d.alphaTest > 0),
                  (c.blendType = d.blendType),
                  (c.screenSpace = f && (f & A.yr) !== 0),
                  (c.skin = f && (f & A.Df) !== 0),
                  (c.useInstancing = f && (f & A.Q$) !== 0),
                  (c.useMorphPosition = f && (f & A.Ck) !== 0),
                  (c.useMorphNormal = f && (f & A.ov) !== 0),
                  (c.useMorphTextureBased = f && (f & A.uJ) !== 0),
                  (c.hasTangents = f && (f & A.k) !== 0),
                  (c.nineSlicedMode = d.nineSlicedMode || A.hA),
                  d.useLighting && h.clusteredLightingEnabled
                    ? ((c.clusteredLightingEnabled = !0),
                      (c.clusteredLightingCookiesEnabled =
                        h.lighting.cookiesEnabled),
                      (c.clusteredLightingShadowsEnabled =
                        h.lighting.shadowsEnabled),
                      (c.clusteredLightingShadowType = h.lighting.shadowType),
                      (c.clusteredLightingAreaLightsEnabled =
                        h.lighting.areaLightsEnabled))
                    : ((c.clusteredLightingEnabled = !1),
                      (c.clusteredLightingCookiesEnabled = !1),
                      (c.clusteredLightingShadowsEnabled = !1),
                      (c.clusteredLightingAreaLightsEnabled = !1));
              }
              static updateMaterialOptions(c, d) {
                (c.useAmbientTint = !1),
                  (c.separateAmbient = !1),
                  (c.customFragmentShader = null),
                  (c.pixelSnap = d.pixelSnap),
                  (c.shadingModel = d.shadingModel),
                  (c.ambientSH = d.ambientSH),
                  (c.fastTbn = d.fastTbn),
                  (c.twoSidedLighting = d.twoSidedLighting),
                  (c.occludeDirect = d.occludeDirect),
                  (c.occludeSpecular = d.occludeSpecular),
                  (c.occludeSpecularFloat = d.occludeSpecularIntensity !== 1),
                  (c.useMsdf = !1),
                  (c.msdfTextAttribute = !1),
                  (c.alphaToCoverage = d.alphaToCoverage),
                  (c.opacityFadesSpecular = d.opacityFadesSpecular),
                  (c.cubeMapProjection = A.ip),
                  (c.conserveEnergy =
                    d.conserveEnergy && d.shadingModel === A.SB),
                  (c.useSpecular = d.hasSpecular),
                  (c.useSpecularityFactor = d.hasSpecularityFactor),
                  (c.enableGGXSpecular = d.ggxSpecular),
                  (c.fresnelModel = d.fresnelModel),
                  (c.useRefraction = d.hasRefraction),
                  (c.useClearCoat = d.hasClearCoat),
                  (c.useSheen = d.hasSheen),
                  (c.useIridescence = d.hasIrridescence),
                  (c.useMetalness = d.hasMetalness),
                  (c.useDynamicRefraction = d.dynamicRefraction),
                  (c.vertexColors = !1),
                  (c.lightMapEnabled = d.hasLighting),
                  (c.dirLightMapEnabled = d.dirLightMap),
                  (c.useHeights = d.hasHeights),
                  (c.useNormals = d.hasNormals),
                  (c.useClearCoatNormals = d.hasClearCoatNormals),
                  (c.useAo = d.hasAo),
                  (c.diffuseMapEnabled = d.hasDiffuseMap);
              }
              static updateEnvOptions(c, d, h) {
                (c.fog = d.useFog ? h.fog : "none"),
                  (c.gamma = d.useGammaTonemap ? h.gammaCorrection : A.hc),
                  (c.toneMap = d.useGammaTonemap ? h.toneMapping : -1),
                  (c.fixSeams = !1),
                  d.useSkybox && h.envAtlas && h.skybox
                    ? ((c.reflectionSource = "envAtlasHQ"),
                      (c.reflectionEncoding = h.envAtlas.encoding),
                      (c.reflectionCubemapEncoding = h.skybox.encoding))
                    : d.useSkybox && h.envAtlas
                    ? ((c.reflectionSource = "envAtlas"),
                      (c.reflectionEncoding = h.envAtlas.encoding))
                    : d.useSkybox && h.skybox
                    ? ((c.reflectionSource = "cubeMap"),
                      (c.reflectionEncoding = h.skybox.encoding))
                    : ((c.reflectionSource = null),
                      (c.reflectionEncoding = null)),
                  d.ambientSH
                    ? ((c.ambientSource = "ambientSH"),
                      (c.ambientEncoding = null))
                    : c.reflectionSource && h.envAtlas
                    ? ((c.ambientSource = "envAtlas"),
                      (c.ambientEncoding = h.envAtlas.encoding))
                    : ((c.ambientSource = "constant"),
                      (c.ambientEncoding = null));
                const f = !!c.reflectionSource;
                (c.skyboxIntensity =
                  f && (h.skyboxIntensity !== 1 || h.physicalUnits)),
                  (c.useCubeMapRotation = f && h._skyboxRotationShaderInclude);
              }
              static updateLightingOptions(c, d, h, f) {
                if (((c.lightMapWithoutAmbient = !1), d.useLighting)) {
                  const s = [],
                    l = h ? h >> 16 : A.Xj;
                  (c.lightMaskDynamic = !!(l & A.Xj)),
                    (c.lightMapWithoutAmbient = !1),
                    f &&
                      (x.collectLights(A.kx, f[A.kx], s, l),
                      x.collectLights(A.dG, f[A.dG], s, l),
                      x.collectLights(A.Gy, f[A.Gy], s, l)),
                    (c.lights = s);
                } else c.lights = [];
                (c.lights.length === 0 || h & A.b2) && (c.noShadow = !0);
              }
              static collectLights(c, d, h, f) {
                for (let s = 0; s < d.length; s++) {
                  const l = d[s];
                  if (l.enabled && l.mask & f) {
                    if (c !== A.kx && l.isStatic) continue;
                    h.push(l);
                  }
                }
              }
            }
          },
          2658: (xe, V, a) => {
            "use strict";
            a.d(V, { i: () => n });
            var A = a(1630),
              x = a(1268),
              y = a(4870),
              c = a(8568),
              d = a(9391),
              h = a(333),
              f = a(1594);
            const s = [];
            (s[d.Ni] = { src: A.qa5, dst: A.qa5, op: A.OgC }),
              (s[d.Rj] = { src: A.qa5, dst: A.seI, op: A.KLp }),
              (s[d.i9] = { src: A.LDz, dst: A.dIP, op: A.KLp }),
              (s[d.bY] = { src: A.qa5, dst: A.dIP, op: A.KLp }),
              (s[d.dc] = { src: A.qa5, dst: A.qa5, op: A.KLp }),
              (s[d.HG] = { src: A.LDz, dst: A.qa5, op: A.KLp }),
              (s[d.LL] = { src: A.FHY, dst: A.iRx, op: A.KLp }),
              (s[d.rZ] = { src: A.$Qt, dst: A.qa5, op: A.KLp }),
              (s[d.$M] = { src: A.FHY, dst: A.seI, op: A.KLp }),
              (s[d.Z7] = { src: A.qa5, dst: A.qa5, op: A.tAf }),
              (s[d.HV] = { src: A.qa5, dst: A.qa5, op: A.pJd });
            let l = 0;
            class n {
              constructor() {
                (this._shader = null),
                  (this.meshInstances = []),
                  (this.name = "Untitled"),
                  (this.userId = ""),
                  (this.id = l++),
                  (this.variants = new Map()),
                  (this.parameters = {}),
                  (this.alphaTest = 0),
                  (this.alphaToCoverage = !1),
                  (this._blendState = new x.t()),
                  (this._depthState = new y.H()),
                  (this.cull = A.K1r),
                  (this.stencilFront = null),
                  (this.stencilBack = null),
                  (this.depthBias = 0),
                  (this.slopeDepthBias = 0),
                  (this._shaderVersion = 0),
                  (this._scene = null),
                  (this._dirtyBlend = !1),
                  (this.dirty = !0);
              }
              set redWrite(i) {
                this._blendState.redWrite = i;
              }
              get redWrite() {
                return this._blendState.redWrite;
              }
              set greenWrite(i) {
                this._blendState.greenWrite = i;
              }
              get greenWrite() {
                return this._blendState.greenWrite;
              }
              set blueWrite(i) {
                this._blendState.blueWrite = i;
              }
              get blueWrite() {
                return this._blendState.blueWrite;
              }
              set alphaWrite(i) {
                this._blendState.alphaWrite = i;
              }
              get alphaWrite() {
                return this._blendState.alphaWrite;
              }
              set shader(i) {
                this._shader = i;
              }
              get shader() {
                return this._shader;
              }
              get transparent() {
                return this._blendState.blend;
              }
              _updateTransparency() {
                const i = this.transparent,
                  e = this.meshInstances;
                for (let t = 0; t < e.length; t++) e[t].transparent = i;
              }
              _markBlendDirty() {
                this._scene
                  ? (this._scene.layers._dirtyBlend = !0)
                  : (this._dirtyBlend = !0);
              }
              set blendState(i) {
                this._blendState.blend !== i.blend && this._markBlendDirty(),
                  this._blendState.copy(i),
                  this._updateTransparency();
              }
              get blendState() {
                return this._blendState;
              }
              set blendType(i) {
                const e = s[i];
                this._blendState.setColorBlend(e.op, e.src, e.dst),
                  this._blendState.setAlphaBlend(e.op, e.src, e.dst);
                const t = i !== d.Rj;
                this._blendState.blend !== t &&
                  ((this._blendState.blend = t),
                  this._updateTransparency(),
                  this._markBlendDirty()),
                  this._updateMeshInstanceKeys();
              }
              get blendType() {
                if (!this.transparent) return d.Rj;
                const {
                  colorOp: i,
                  colorSrcFactor: e,
                  colorDstFactor: t,
                  alphaOp: r,
                  alphaSrcFactor: u,
                  alphaDstFactor: v,
                } = this._blendState;
                for (let _ = 0; _ < s.length; _++) {
                  const m = s[_];
                  if (
                    m.src === e &&
                    m.dst === t &&
                    m.op === i &&
                    m.src === u &&
                    m.dst === v &&
                    m.op === r
                  )
                    return _;
                }
                return d.i9;
              }
              set depthState(i) {
                this._depthState.copy(i);
              }
              get depthState() {
                return this._depthState;
              }
              set depthTest(i) {
                this._depthState.test = i;
              }
              get depthTest() {
                return this._depthState.test;
              }
              set depthFunc(i) {
                this._depthState.func = i;
              }
              get depthFunc() {
                return this._depthState.func;
              }
              set depthWrite(i) {
                this._depthState.write = i;
              }
              get depthWrite() {
                return this._depthState.write;
              }
              copy(i) {
                var e;
                return (
                  (this.name = i.name),
                  (this._shader = i._shader),
                  (this.alphaTest = i.alphaTest),
                  (this.alphaToCoverage = i.alphaToCoverage),
                  this._blendState.copy(i._blendState),
                  this._depthState.copy(i._depthState),
                  (this.cull = i.cull),
                  (this.depthBias = i.depthBias),
                  (this.slopeDepthBias = i.slopeDepthBias),
                  (this.stencilFront =
                    (e = i.stencilFront) == null ? void 0 : e.clone()),
                  i.stencilBack &&
                    (this.stencilBack =
                      i.stencilFront === i.stencilBack
                        ? this.stencilFront
                        : i.stencilBack.clone()),
                  this
                );
              }
              clone() {
                return new this.constructor().copy(this);
              }
              _updateMeshInstanceKeys() {
                const i = this.meshInstances;
                for (let e = 0; e < i.length; e++) i[e].updateKey();
              }
              updateUniforms(i, e) {}
              getShaderVariant(i, e, t, r, u, v, _, m, g) {
                const T = new c.c(_, m, g);
                return (0, h.V$)(this._shader, T);
              }
              update() {
                (this.dirty = !0), this._shader && (this._shader.failed = !1);
              }
              clearParameters() {
                this.parameters = {};
              }
              getParameters() {
                return this.parameters;
              }
              clearVariants() {
                this.variants.clear();
                const i = this.meshInstances,
                  e = i.length;
                for (let t = 0; t < e; t++) i[t].clearShaders();
              }
              getParameter(i) {
                return this.parameters[i];
              }
              setParameter(i, e) {
                if (e === void 0 && typeof i == "object") {
                  const r = i;
                  if (r.length) {
                    for (let u = 0; u < r.length; u++) this.setParameter(r[u]);
                    return;
                  }
                  (i = r.name), (e = r.value);
                }
                const t = this.parameters[i];
                t
                  ? (t.data = e)
                  : (this.parameters[i] = { scopeId: null, data: e });
              }
              deleteParameter(i) {
                this.parameters[i] && delete this.parameters[i];
              }
              setParameters(i, e) {
                const t = this.parameters;
                e === void 0 && (e = t);
                for (const r in e) {
                  const u = t[r];
                  u &&
                    (u.scopeId || (u.scopeId = i.scope.resolve(r)),
                    u.scopeId.setValue(u.data));
                }
              }
              destroy() {
                this.variants.clear(), (this._shader = null);
                for (let i = 0; i < this.meshInstances.length; i++) {
                  const e = this.meshInstances[i];
                  if ((e.clearShaders(), (e._material = null), e.mesh)) {
                    const t = (0, f.h)(e.mesh.device);
                    this !== t && (e.material = t);
                  }
                }
                this.meshInstances.length = 0;
              }
              addMeshInstanceRef(i) {
                this.meshInstances.push(i);
              }
              removeMeshInstanceRef(i) {
                const e = this.meshInstances,
                  t = e.indexOf(i);
                t !== -1 && e.splice(t, 1);
              }
            }
          },
          6261: (xe, V, a) => {
            "use strict";
            a.d(V, { l: () => x });
            var A = a(8944);
            class x {
              constructor() {
                (this.forceUv1 = !1),
                  (this.ambientTint = !1),
                  (this.diffuseTint = !1),
                  (this.specularTint = !1),
                  (this.metalnessTint = !1),
                  (this.glossTint = !1),
                  (this.emissiveTint = !1),
                  (this.opacityTint = !1),
                  (this.emissiveEncoding = "linear"),
                  (this.lightMapEncoding = "linear"),
                  (this.packedNormal = !1),
                  (this.glossInvert = !1),
                  (this.sheenGlossInvert = !1),
                  (this.clearCoatGlossInvert = !1),
                  (this.litOptions = new A.n());
              }
              get pass() {
                return this.litOptions.pass;
              }
            }
          },
          6679: (xe, V, a) => {
            "use strict";
            a.d(V, { Gc: () => c, PQ: () => h, W5: () => d, lY: () => y });
            var A = a(4751);
            function x(f, s = !0, l = !0) {
              const n = {};
              return (
                (n[`${f}Map`] = "texture"),
                (n[`${f}MapTiling`] = "vec2"),
                (n[`${f}MapOffset`] = "vec2"),
                (n[`${f}MapRotation`] = "number"),
                (n[`${f}MapUv`] = "number"),
                s &&
                  ((n[`${f}MapChannel`] = "string"),
                  l &&
                    ((n[`${f}VertexColor`] = "boolean"),
                    (n[`${f}VertexColorChannel`] = "string"))),
                n
              );
            }
            const y = (0, A._)(
                {
                  name: "string",
                  chunks: "chunks",
                  mappingFormat: "string",
                  _engine: "boolean",
                  ambient: "rgb",
                  ambientTint: "boolean",
                },
                x("ao"),
                x("aoDetail", !0, !1),
                {
                  aoDetailMode: "string",
                  diffuse: "rgb",
                  diffuseTint: "boolean",
                },
                x("diffuse"),
                x("diffuseDetail", !0, !1),
                {
                  diffuseDetailMode: "string",
                  specular: "rgb",
                  specularTint: "boolean",
                },
                x("specular"),
                {
                  occludeSpecular: "enum:occludeSpecular",
                  specularityFactor: "number",
                  specularityFactorTint: "boolean",
                },
                x("specularityFactor"),
                {
                  useMetalness: "boolean",
                  metalness: "number",
                  enableGGXSpecular: "boolean",
                  anisotropy: "number",
                  metalnessTint: "boolean",
                },
                x("metalness"),
                {
                  useMetalnessSpecularColor: "boolean",
                  conserveEnergy: "boolean",
                  shininess: "number",
                  gloss: "number",
                  glossInvert: "boolean",
                },
                x("gloss"),
                { clearCoat: "number" },
                x("clearCoat"),
                { clearCoatGloss: "number", clearCoatGlossInvert: "boolean" },
                x("clearCoatGloss"),
                { clearCoatBumpiness: "number" },
                x("clearCoatNormal", !1),
                { useSheen: "boolean", sheen: "rgb", sheenTint: "boolean" },
                x("sheen"),
                {
                  sheenGloss: "number",
                  sheenGlossTint: "boolean",
                  sheenGlossInvert: "boolean",
                },
                x("sheenGloss"),
                {
                  fresnelModel: "number",
                  emissive: "rgb",
                  emissiveTint: "boolean",
                },
                x("emissive"),
                { emissiveIntensity: "number" },
                x("normal", !1),
                { bumpiness: "number" },
                x("normalDetail", !1),
                { normalDetailMapBumpiness: "number" },
                x("height", !0, !1),
                {
                  heightMapFactor: "number",
                  alphaToCoverage: "boolean",
                  alphaTest: "number",
                  alphaFade: "number",
                  opacity: "number",
                },
                x("opacity"),
                {
                  opacityFadesSpecular: "boolean",
                  reflectivity: "number",
                  refraction: "number",
                  refractionTint: "boolean",
                },
                x("refraction"),
                {
                  refractionIndex: "number",
                  thickness: "number",
                  thicknessTint: "boolean",
                },
                x("thickness"),
                {
                  attenuation: "rgb",
                  attenuationDistance: "number",
                  useDynamicRefraction: "boolean",
                  sphereMap: "texture",
                  cubeMap: "cubemap",
                  cubeMapProjection: "number",
                  cubeMapProjectionBox: "boundingbox",
                  useIridescence: "boolean",
                  iridescence: "number",
                  iridescenceTint: "boolean",
                },
                x("iridescence"),
                {
                  iridescenceThicknessTint: "boolean",
                  iridescenceThicknessMin: "number",
                  iridescenceThicknessMax: "number",
                  iridescenceRefractionIndex: "number",
                },
                x("iridescenceThickness"),
                x("light"),
                {
                  depthTest: "boolean",
                  depthFunc: "enum:depthFunc",
                  depthWrite: "boolean",
                  depthBias: "number",
                  slopeDepthBias: "number",
                  cull: "enum:cull",
                  blendType: "enum:blendType",
                  shadingModel: "enum:shadingModel",
                  useFog: "boolean",
                  useLighting: "boolean",
                  useSkybox: "boolean",
                  useGammaTonemap: "boolean",
                  envAtlas: "texture",
                  twoSidedLighting: "boolean",
                }
              ),
              c = [];
            for (const f in y) y[f] === "texture" && c.push(f);
            const d = [];
            for (const f in y) y[f] === "cubemap" && d.push(f);
            const h = {
              aoMapVertexColor: "boolean",
              diffuseMapTint: "boolean",
              diffuseMapVertexColor: "boolean",
              emissiveMapTint: "boolean",
              emissiveMapVertexColor: "boolean",
              glossMapVertexColor: "boolean",
              metalnessMapVertexColor: "boolean",
              opacityMapVertexColor: "boolean",
              specularAntialias: "boolean",
              specularMapTint: "boolean",
              specularMapVertexColor: "boolean",
            };
          },
          1369: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => D });
            var A = a(5227),
              x = a(8656),
              y = a(7994),
              c = a(8568),
              d = a(9391),
              h = a(4639),
              f = a(3362),
              s = a(783),
              l = a(1151),
              n = a(7835),
              o = a(725),
              i = a(6261),
              e = a(8342);
            const t = [],
              r = (ge) =>
                Object.keys(ge)
                  .filter((k) => k !== "litOptions")
                  .sort(),
              u = {
                optionsContext: new i.l(),
                optionsContextMin: new i.l(),
                generateKey: function (ge) {
                  let k;
                  return (
                    ge === this.optionsContextMin
                      ? (this.propsMin || (this.propsMin = r(ge)),
                        (k = this.propsMin))
                      : ge === this.optionsContext
                      ? (this.props || (this.props = r(ge)), (k = this.props))
                      : (k = r(ge)),
                    `standard:
` +
                      k.map((B) => B + ge[B]).join(`
`) +
                      e.Z.generateKey(ge.litOptions)
                  );
                },
                _getUvSourceExpression: function (ge, k, j) {
                  const B = j[ge],
                    $ = j[k],
                    le =
                      j.litOptions.pass === d.OP || j.litOptions.pass === d.Su;
                  let O;
                  return (
                    (le && j.litOptions.nineSlicedMode === d.FC) ||
                    (le && j.litOptions.nineSlicedMode === d.jZ)
                      ? (O = "nineSlicedUv")
                      : (B === 0 ? (O = "vUv" + $) : (O = "vUV" + $ + "_" + B),
                        j.heightMap &&
                          ge !== "heightMapTransform" &&
                          (O += " + dUvOffset")),
                    O
                  );
                },
                _addMapDef: function (ge, k) {
                  return k
                    ? `#define ${ge}
`
                    : `#undef ${ge}
`;
                },
                _addMapDefs: function (ge, k, j, B, $) {
                  return (
                    this._addMapDef("MAPFLOAT", ge) +
                    this._addMapDef("MAPCOLOR", k) +
                    this._addMapDef("MAPVERTEX", j) +
                    this._addMapDef("MAPTEXTURE", B) +
                    this._addMapDef("MAPINVERT", $)
                  );
                },
                _addMap: function (ge, k, j, B, $, le = null) {
                  const O = ge + "Map",
                    Y = O + "Uv",
                    ne = O + "Identifier",
                    de = O + "Transform",
                    re = O + "Channel",
                    I = ge + "VertexColorChannel",
                    w = ge + "Tint",
                    N = ge + "VertexColor",
                    W = ge + "Mode",
                    he = ge + "Invert",
                    ue = j[w],
                    ye = j[N],
                    Oe = j[O],
                    Ae = j[ne],
                    ke = j[W];
                  let Ue = B[k];
                  if (Oe) {
                    const z = this._getUvSourceExpression(de, Y, j);
                    if (
                      ((Ue = Ue.replace(/\$UV/g, z).replace(/\$CH/g, j[re])),
                      $ && Ue.search(/\$SAMPLER/g) !== -1)
                    ) {
                      let K = "texture_" + O;
                      const Te = $[Ae];
                      Te ? (K = Te) : ($[Ae] = K),
                        (Ue = Ue.replace(/\$SAMPLER/g, K));
                    }
                    if (
                      le &&
                      (j[re] === "aaa"
                        ? (Ue = Ue.replace(/\$DECODE/g, "passThrough"))
                        : (Ue = Ue.replace(
                            /\$DECODE/g,
                            o.N.decodeFunc(
                              !j.litOptions.gamma && le === "srgb"
                                ? "linear"
                                : le
                            )
                          )),
                      Ue.indexOf("$texture2DSAMPLE"))
                    ) {
                      const K = {
                        linear: "texture2D",
                        srgb: "texture2DSRGB",
                        rgbm: "texture2DRGBM",
                        rgbe: "texture2DRGBE",
                      };
                      Ue = Ue.replace(
                        /\$texture2DSAMPLE/g,
                        K[le] || "texture2D"
                      );
                    }
                  }
                  ye && (Ue = Ue.replace(/\$VC/g, j[I])),
                    ke && (Ue = Ue.replace(/\$DETAILMODE/g, ke));
                  const Ge = !!(ue & 1),
                    ht = !!(ue & 2),
                    me = !!j[he];
                  return (
                    (Ue = this._addMapDefs(Ge, ht, ye, Oe, me) + Ue),
                    Ue.replace(/\$/g, "")
                  );
                },
                _correctChannel: function (ge, k, j) {
                  if (j[ge] > 0) {
                    if (j[ge] < k.length) return k.substring(0, j[ge]);
                    if (j[ge] > k.length) {
                      let B = k;
                      const $ = B.charAt(B.length - 1),
                        le = j[ge] - B.length;
                      for (let O = 0; O < le; O++) B += $;
                      return B;
                    }
                    return k;
                  }
                },
                createShaderDefinition: function (ge, k) {
                  const B = h.p.get(ge).getByIndex(k.litOptions.pass).isForward,
                    $ = new l.J(ge, k.litOptions),
                    le = [],
                    O = [],
                    Y = [],
                    ne = 2,
                    de = {};
                  for (const he in t) {
                    const ue = he + "Map";
                    if (k[he + "VertexColor"]) {
                      const ye = he + "VertexColorChannel";
                      k[ye] = this._correctChannel(he, k[ye], t);
                    }
                    if (k[ue]) {
                      const ye = ue + "Channel",
                        Oe = ue + "Transform",
                        Ae = ue + "Uv";
                      (k[Ae] = Math.min(k[Ae], ne - 1)),
                        (k[ye] = this._correctChannel(he, k[ye], t));
                      const ke = k[Ae];
                      (le[ke] = !0),
                        (O[ke] = O[ke] || (k[ue] && !k[Oe])),
                        k[Oe] && Y.push({ name: he, id: k[Oe], uv: k[Ae] });
                    }
                  }
                  k.forceUv1 &&
                    ((le[1] = !0), (O[1] = O[1] !== void 0 ? O[1] : !0)),
                    $.generateVertexShader(le, O, Y),
                    k.litOptions.shadingModel === d.Tp
                      ? ((k.litOptions.fresnelModel = 0),
                        (k.litOptions.ambientSH = !1))
                      : (k.litOptions.fresnelModel =
                          k.litOptions.fresnelModel === 0
                            ? d.SU
                            : k.litOptions.fresnelModel);
                  const re = new n.v(),
                    I = new n.v(),
                    w = new n.v(),
                    N = new n.v();
                  let W = "";
                  if (
                    (k.litOptions.nineSlicedMode === d.jZ
                      ? re.append("const float textureBias = -1000.0;")
                      : re.append("uniform float textureBias;"),
                    B)
                  ) {
                    if (
                      (k.heightMap &&
                        (re.append("vec2 dUvOffset;"),
                        I.append(
                          this._addMap("height", "parallaxPS", k, $.chunks, de)
                        ),
                        w.append("getParallax();")),
                      k.litOptions.blendType !== d.Rj ||
                      k.litOptions.alphaTest ||
                      k.litOptions.alphaToCoverage
                        ? (re.append("float dAlpha;"),
                          I.append(
                            this._addMap(
                              "opacity",
                              "opacityPS",
                              k,
                              $.chunks,
                              de
                            )
                          ),
                          w.append("getOpacity();"),
                          N.append("litArgs_opacity = dAlpha;"),
                          k.litOptions.alphaTest &&
                            (I.append($.chunks.alphaTestPS),
                            w.append("alphaTest(dAlpha);")))
                        : re.append("float dAlpha = 1.0;"),
                      $.needsNormal)
                    ) {
                      if (
                        (k.normalMap || k.clearCoatNormalMap) &&
                        (I.append(
                          k.packedNormal
                            ? $.chunks.normalXYPS
                            : $.chunks.normalXYZPS
                        ),
                        !k.litOptions.hasTangents)
                      ) {
                        const he = k.normalMap
                          ? "normalMap"
                          : "clearCoatNormalMap";
                        W = this._getUvSourceExpression(
                          `${he}Transform`,
                          `${he}Uv`,
                          k
                        );
                      }
                      re.append("vec3 dNormalW;"),
                        I.append(
                          this._addMap(
                            "normalDetail",
                            "normalDetailMapPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        I.append(
                          this._addMap("normal", "normalMapPS", k, $.chunks, de)
                        ),
                        w.append("getNormal();"),
                        N.append("litArgs_worldNormal = dNormalW;");
                    }
                    if (
                      ($.needsSceneColor &&
                        re.append("uniform sampler2D uSceneColorMap;"),
                      $.needsScreenSize &&
                        re.append("uniform vec4 uScreenSize;"),
                      $.needsTransforms &&
                        (re.append("uniform mat4 matrix_viewProjection;"),
                        re.append("uniform mat4 matrix_model;")),
                      (k.diffuseDetail || k.aoDetail) &&
                        I.append($.chunks.detailModesPS),
                      re.append("vec3 dAlbedo;"),
                      k.diffuseDetail &&
                        I.append(
                          this._addMap(
                            "diffuseDetail",
                            "diffuseDetailMapPS",
                            k,
                            $.chunks,
                            de,
                            k.diffuseDetailEncoding
                          )
                        ),
                      I.append(
                        this._addMap(
                          "diffuse",
                          "diffusePS",
                          k,
                          $.chunks,
                          de,
                          k.diffuseEncoding
                        )
                      ),
                      w.append("getAlbedo();"),
                      N.append("litArgs_albedo = dAlbedo;"),
                      k.litOptions.useRefraction &&
                        (re.append("float dTransmission;"),
                        I.append(
                          this._addMap(
                            "refraction",
                            "transmissionPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        w.append("getRefraction();"),
                        N.append("litArgs_transmission = dTransmission;"),
                        re.append("float dThickness;"),
                        I.append(
                          this._addMap(
                            "thickness",
                            "thicknessPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        w.append("getThickness();"),
                        N.append("litArgs_thickness = dThickness;")),
                      k.litOptions.useIridescence &&
                        (re.append("float dIridescence;"),
                        I.append(
                          this._addMap(
                            "iridescence",
                            "iridescencePS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        w.append("getIridescence();"),
                        N.append(
                          "litArgs_iridescence_intensity = dIridescence;"
                        ),
                        re.append("float dIridescenceThickness;"),
                        I.append(
                          this._addMap(
                            "iridescenceThickness",
                            "iridescenceThicknessPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        w.append("getIridescenceThickness();"),
                        N.append(
                          "litArgs_iridescence_thickness = dIridescenceThickness;"
                        )),
                      ($.lighting && k.litOptions.useSpecular) || $.reflections
                        ? (re.append("vec3 dSpecularity;"),
                          re.append("float dGlossiness;"),
                          k.litOptions.useSheen &&
                            (re.append("vec3 sSpecularity;"),
                            I.append(
                              this._addMap(
                                "sheen",
                                "sheenPS",
                                k,
                                $.chunks,
                                de,
                                k.sheenEncoding
                              )
                            ),
                            w.append("getSheen();"),
                            N.append(
                              "litArgs_sheen_specularity = sSpecularity;"
                            ),
                            re.append("float sGlossiness;"),
                            I.append(
                              this._addMap(
                                "sheenGloss",
                                "sheenGlossPS",
                                k,
                                $.chunks,
                                de
                              )
                            ),
                            w.append("getSheenGlossiness();"),
                            N.append("litArgs_sheen_gloss = sGlossiness;")),
                          k.litOptions.useMetalness &&
                            (re.append("float dMetalness;"),
                            I.append(
                              this._addMap(
                                "metalness",
                                "metalnessPS",
                                k,
                                $.chunks,
                                de
                              )
                            ),
                            w.append("getMetalness();"),
                            N.append("litArgs_metalness = dMetalness;"),
                            re.append("float dIor;"),
                            I.append(
                              this._addMap("ior", "iorPS", k, $.chunks, de)
                            ),
                            w.append("getIor();"),
                            N.append("litArgs_ior = dIor;")),
                          k.litOptions.useSpecularityFactor &&
                            (re.append("float dSpecularityFactor;"),
                            I.append(
                              this._addMap(
                                "specularityFactor",
                                "specularityFactorPS",
                                k,
                                $.chunks,
                                de
                              )
                            ),
                            w.append("getSpecularityFactor();"),
                            N.append(
                              "litArgs_specularityFactor = dSpecularityFactor;"
                            )),
                          k.useSpecularColor
                            ? I.append(
                                this._addMap(
                                  "specular",
                                  "specularPS",
                                  k,
                                  $.chunks,
                                  de,
                                  k.specularEncoding
                                )
                              )
                            : I.append(
                                "void getSpecularity() { dSpecularity = vec3(1); }"
                              ),
                          I.append(
                            this._addMap("gloss", "glossPS", k, $.chunks, de)
                          ),
                          w.append("getGlossiness();"),
                          w.append("getSpecularity();"),
                          N.append("litArgs_specularity = dSpecularity;"),
                          N.append("litArgs_gloss = dGlossiness;"))
                        : (re.append("vec3 dSpecularity = vec3(0.0);"),
                          re.append("float dGlossiness = 0.0;")),
                      k.aoDetail &&
                        I.append(
                          this._addMap(
                            "aoDetail",
                            "aoDetailMapPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                      (k.aoMap || k.aoVertexColor) &&
                        (re.append("float dAo;"),
                        I.append(this._addMap("ao", "aoPS", k, $.chunks, de)),
                        w.append("getAO();"),
                        N.append("litArgs_ao = dAo;")),
                      re.append("vec3 dEmission;"),
                      I.append(
                        this._addMap(
                          "emissive",
                          "emissivePS",
                          k,
                          $.chunks,
                          de,
                          k.emissiveEncoding
                        )
                      ),
                      w.append("getEmission();"),
                      N.append("litArgs_emission = dEmission;"),
                      k.litOptions.useClearCoat &&
                        (re.append("float ccSpecularity;"),
                        re.append("float ccGlossiness;"),
                        re.append("vec3 ccNormalW;"),
                        I.append(
                          this._addMap(
                            "clearCoat",
                            "clearCoatPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        I.append(
                          this._addMap(
                            "clearCoatGloss",
                            "clearCoatGlossPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        I.append(
                          this._addMap(
                            "clearCoatNormal",
                            "clearCoatNormalPS",
                            k,
                            $.chunks,
                            de
                          )
                        ),
                        w.append("getClearCoat();"),
                        w.append("getClearCoatGlossiness();"),
                        w.append("getClearCoatNormal();"),
                        N.append(
                          "litArgs_clearcoat_specularity = ccSpecularity;"
                        ),
                        N.append("litArgs_clearcoat_gloss = ccGlossiness;"),
                        N.append("litArgs_clearcoat_worldNormal = ccNormalW;")),
                      k.lightMap || k.lightVertexColor)
                    ) {
                      const he = k.dirLightMap && k.litOptions.useSpecular,
                        ue = he ? "lightmapDirPS" : "lightmapSinglePS";
                      re.append("vec3 dLightmap;"),
                        he && re.append("vec3 dLightmapDir;"),
                        I.append(
                          this._addMap(
                            "light",
                            ue,
                            k,
                            $.chunks,
                            de,
                            k.lightMapEncoding
                          )
                        ),
                        w.append("getLightMap();"),
                        N.append("litArgs_lightmap = dLightmap;"),
                        he && N.append("litArgs_lightmapDir = dLightmapDir;");
                    }
                    (I.code.indexOf("texture2DSRGB") !== -1 ||
                      I.code.indexOf("texture2DRGBM") !== -1 ||
                      I.code.indexOf("texture2DRGBE") !== -1) &&
                      I.prepend($.chunks.textureSamplePS);
                  } else
                    k.litOptions.alphaTest &&
                      (re.append("float dAlpha;"),
                      I.append(
                        this._addMap("opacity", "opacityPS", k, $.chunks, de)
                      ),
                      I.append($.chunks.alphaTestPS),
                      w.append("getOpacity();"),
                      w.append("alphaTest(dAlpha);"),
                      N.append("litArgs_opacity = dAlpha;"));
                  re.append($.chunks.litShaderArgsPS),
                    I.append(`void evaluateFrontend() { 
${w.code}
${N.code}
 }
`),
                    (w.code = "evaluateFrontend();");
                  for (const he in de)
                    re.append(`uniform sampler2D ${de[he]};`);
                  return (
                    (w.code = `
${w.code
  .split(
    `
`
  )
  .map((he) => `    ${he}`).join(`
`)}

`),
                    $.generateFragmentShader(re.code, I.code, w.code, W),
                    $.getDefinition()
                  );
                },
              };
            var v = a(2658),
              _ = a(1630),
              m = a(7715);
            const g = (ge, k) => {
                if (ge.length !== k.length) return !1;
                for (let j = 0; j < ge.length; ++j)
                  if (ge[j] !== k[j]) return !1;
                return !0;
              },
              T = (ge) => ge.r !== 1 || ge.g !== 1 || ge.b !== 1,
              E = (ge) => ge.r !== 0 || ge.g !== 0 || ge.b !== 0;
            class M {
              constructor() {
                this._mapXForms = null;
              }
              updateMinRef(k, j, B, $, le, O) {
                this._updateSharedOptions(k, j, B, $, le),
                  this._updateMinOptions(k, B),
                  this._updateUVOptions(k, B, $, !0);
              }
              updateRef(k, j, B, $, le, O) {
                this._updateSharedOptions(k, j, B, $, le),
                  this._updateEnvOptions(k, B, j),
                  this._updateMaterialOptions(k, B),
                  le === d.Su &&
                    (k.litOptions.gamma && (k.litOptions.gamma = d.Rz),
                    (k.litOptions.toneMap = d.ll)),
                  (k.litOptions.hasTangents = $ && ($ & d.k) !== 0),
                  this._updateLightOptions(k, j, B, $, O),
                  this._updateUVOptions(k, B, $, !1);
              }
              _updateSharedOptions(k, j, B, $, le) {
                (k.forceUv1 = B.forceUv1),
                  (k.litOptions.chunks = B.chunks || {}),
                  (k.litOptions.pass = le),
                  (k.litOptions.alphaTest = B.alphaTest > 0),
                  (k.litOptions.blendType = B.blendType),
                  (k.litOptions.screenSpace = $ && ($ & d.yr) !== 0),
                  (k.litOptions.skin = $ && ($ & d.Df) !== 0),
                  (k.litOptions.useInstancing = $ && ($ & d.Q$) !== 0),
                  (k.litOptions.useMorphPosition = $ && ($ & d.Ck) !== 0),
                  (k.litOptions.useMorphNormal = $ && ($ & d.ov) !== 0),
                  (k.litOptions.useMorphTextureBased = $ && ($ & d.uJ) !== 0),
                  (k.litOptions.nineSlicedMode = B.nineSlicedMode || 0),
                  j.clusteredLightingEnabled && B.useLighting
                    ? ((k.litOptions.clusteredLightingEnabled = !0),
                      (k.litOptions.clusteredLightingCookiesEnabled =
                        j.lighting.cookiesEnabled),
                      (k.litOptions.clusteredLightingShadowsEnabled =
                        j.lighting.shadowsEnabled),
                      (k.litOptions.clusteredLightingShadowType =
                        j.lighting.shadowType),
                      (k.litOptions.clusteredLightingAreaLightsEnabled =
                        j.lighting.areaLightsEnabled))
                    : ((k.litOptions.clusteredLightingEnabled = !1),
                      (k.litOptions.clusteredLightingCookiesEnabled = !1),
                      (k.litOptions.clusteredLightingShadowsEnabled = !1),
                      (k.litOptions.clusteredLightingAreaLightsEnabled = !1));
              }
              _updateUVOptions(k, j, B, $) {
                let le = !1,
                  O = !1,
                  Y = !1;
                B &&
                  ((le = (B & d.Jq) !== 0),
                  (O = (B & d.Cn) !== 0),
                  (Y = (B & d.L$) !== 0)),
                  (k.litOptions.vertexColors = !1),
                  (this._mapXForms = []);
                const ne = {};
                for (const de in t)
                  this._updateTexOptions(k, j, de, le, O, Y, $, ne);
                (this._mapXForms = null),
                  (k.litOptions.lightMapEnabled = k.lightMap),
                  (k.litOptions.dirLightMapEnabled = k.dirLightMap),
                  (k.litOptions.useHeights = k.heightMap),
                  (k.litOptions.useNormals = k.normalMap),
                  (k.litOptions.useClearCoatNormals = k.clearCoatNormalMap),
                  (k.litOptions.useAo = k.aoMap || k.aoVertexColor),
                  (k.litOptions.diffuseMapEnabled = k.diffuseMap);
              }
              _updateTexOptions(k, j, B, $, le, O, Y, ne) {
                const de = B === "opacity";
                if (!Y || de) {
                  const re = B + "Map",
                    I = B + "VertexColor",
                    w = B + "VertexColorChannel",
                    N = re + "Channel",
                    W = re + "Transform",
                    he = re + "Uv",
                    ue = re + "Identifier";
                  if (
                    (B !== "light" &&
                      ((k[re] = !1),
                      (k[ue] = void 0),
                      (k[N] = ""),
                      (k[W] = 0),
                      (k[he] = 0)),
                    (k[I] = !1),
                    (k[w] = ""),
                    de &&
                      j.blendType === d.Rj &&
                      j.alphaTest === 0 &&
                      !j.alphaToCoverage)
                  )
                    return;
                  if (
                    (B !== "height" &&
                      j[I] &&
                      O &&
                      ((k[I] = j[I]),
                      (k[w] = j[w]),
                      (k.litOptions.vertexColors = !0)),
                    j[re])
                  ) {
                    let ye = !0;
                    if (
                      (j[he] === 0 && !$ && (ye = !1),
                      j[he] === 1 && !le && (ye = !1),
                      ye)
                    ) {
                      const Oe = j[re].id;
                      let Ae = ne[Oe];
                      Ae === void 0 && ((ne[Oe] = B), (Ae = B)),
                        (k[re] = !!j[re]),
                        (k[ue] = Ae),
                        (k[W] = this._getMapTransformID(
                          j.getUniform(W),
                          j[he]
                        )),
                        (k[N] = j[N]),
                        (k[he] = j[he]);
                    }
                  }
                }
              }
              _updateMinOptions(k, j) {
                (k.opacityTint = j.opacity !== 1 && j.blendType !== d.Rj),
                  (k.litOptions.lights = []);
              }
              _updateMaterialOptions(k, j) {
                var B, $, le, O;
                const Y =
                    (j.diffuseTint ||
                      (!j.diffuseMap && !j.diffuseVertexColor)) &&
                    T(j.diffuse),
                  ne = !!(
                    j.useMetalness ||
                    j.specularMap ||
                    j.sphereMap ||
                    j.cubeMap ||
                    E(j.specular) ||
                    (j.specularityFactor > 0 && j.useMetalness) ||
                    j.enableGGXSpecular ||
                    j.clearCoat > 0
                  ),
                  de = !j.useMetalness || j.useMetalnessSpecularColor,
                  re =
                    ne &&
                    (j.specularTint ||
                      (!j.specularMap && !j.specularVertexColor)) &&
                    T(j.specular),
                  I =
                    ne &&
                    j.useMetalnessSpecularColor &&
                    (j.specularityFactorTint ||
                      (j.specularityFactor < 1 && !j.specularityFactorMap)),
                  w = !j.emissiveMap || (T(j.emissive) && j.emissiveTint),
                  N = j.emissiveIntensity !== 1,
                  W = j.normalMap
                    ? j.normalMap.format === _.E_6 || j.normalMap.type === _.wmq
                    : !1;
                (k.opacityTint =
                  j.opacity !== 1 && j.blendType !== d.Rj ? 1 : 0),
                  (k.ambientTint = j.ambientTint),
                  (k.diffuseTint = Y ? 2 : 0),
                  (k.specularTint = re ? 2 : 0),
                  (k.specularityFactorTint = I ? 1 : 0),
                  (k.metalnessTint = j.useMetalness && j.metalness < 1 ? 1 : 0),
                  (k.glossTint = 1),
                  (k.emissiveTint = (w ? 2 : 0) + (N ? 1 : 0)),
                  (k.diffuseEncoding =
                    (B = j.diffuseMap) == null ? void 0 : B.encoding),
                  (k.diffuseDetailEncoding =
                    ($ = j.diffuseDetailMap) == null ? void 0 : $.encoding),
                  (k.emissiveEncoding =
                    (le = j.emissiveMap) == null ? void 0 : le.encoding),
                  (k.lightMapEncoding =
                    (O = j.lightMap) == null ? void 0 : O.encoding),
                  (k.packedNormal = W),
                  (k.refractionTint = j.refraction !== 1 ? 1 : 0),
                  (k.refractionIndexTint =
                    j.refractionIndex !== 0.6666666666666666 ? 1 : 0),
                  (k.thicknessTint =
                    j.useDynamicRefraction && j.thickness !== 1 ? 1 : 0),
                  (k.specularEncoding = j.specularEncoding || "linear"),
                  (k.sheenEncoding = j.sheenEncoding || "linear"),
                  (k.aoMapUv = j.aoUvSet),
                  (k.aoDetail = !!j.aoMap),
                  (k.diffuseDetail = !!j.diffuseMap),
                  (k.normalDetail = !!j.normalMap),
                  (k.diffuseDetailMode = j.diffuseDetailMode),
                  (k.aoDetailMode = j.aoDetailMode),
                  (k.clearCoatTint = j.clearCoat !== 1 ? 1 : 0),
                  (k.clearCoatGloss = !!j.clearCoatGloss),
                  (k.clearCoatGlossTint = j.clearCoatGloss !== 1 ? 1 : 0),
                  (k.iorTint =
                    j.refractionIndex !== 0.6666666666666666 ? 1 : 0),
                  (k.iridescenceTint = j.iridescence !== 1 ? 1 : 0),
                  (k.sheenTint = j.useSheen && T(j.sheen) ? 2 : 0),
                  (k.sheenGlossTint = 1),
                  (k.glossInvert = j.glossInvert),
                  (k.sheenGlossInvert = j.sheenGlossInvert),
                  (k.clearCoatGlossInvert = j.clearCoatGlossInvert),
                  (k.useSpecularColor = de),
                  (k.litOptions.separateAmbient = !1),
                  (k.litOptions.useAmbientTint = j.ambientTint),
                  (k.litOptions.customFragmentShader = j.customFragmentShader),
                  (k.litOptions.pixelSnap = j.pixelSnap),
                  (k.litOptions.shadingModel = j.shadingModel),
                  (k.litOptions.ambientSH = !!j.ambientSH),
                  (k.litOptions.fastTbn = j.fastTbn),
                  (k.litOptions.twoSidedLighting = j.twoSidedLighting),
                  (k.litOptions.occludeSpecular = j.occludeSpecular),
                  (k.litOptions.occludeSpecularFloat =
                    j.occludeSpecularIntensity !== 1),
                  (k.litOptions.useMsdf = !!j.msdfMap),
                  (k.litOptions.msdfTextAttribute = !!j.msdfTextAttribute),
                  (k.litOptions.alphaToCoverage = j.alphaToCoverage),
                  (k.litOptions.opacityFadesSpecular = j.opacityFadesSpecular),
                  (k.litOptions.cubeMapProjection = j.cubeMapProjection),
                  (k.litOptions.occludeDirect = j.occludeDirect),
                  (k.litOptions.conserveEnergy =
                    j.conserveEnergy && j.shadingModel !== d.Tp),
                  (k.litOptions.useSpecular = ne),
                  (k.litOptions.useSpecularityFactor =
                    (I || !!j.specularityFactorMap) &&
                    j.useMetalnessSpecularColor),
                  (k.litOptions.enableGGXSpecular = j.enableGGXSpecular),
                  (k.litOptions.fresnelModel = j.fresnelModel),
                  (k.litOptions.useRefraction =
                    (j.refraction || !!j.refractionMap) &&
                    (j.useDynamicRefraction ||
                      !!k.litOptions.reflectionSource)),
                  (k.litOptions.useClearCoat = !!j.clearCoat),
                  (k.litOptions.useSheen = j.useSheen),
                  (k.litOptions.useIridescence =
                    j.useIridescence && j.iridescence !== 0),
                  (k.litOptions.useMetalness = j.useMetalness),
                  (k.litOptions.useDynamicRefraction = j.useDynamicRefraction);
              }
              _updateEnvOptions(k, j, B) {
                (k.litOptions.fog = j.useFog ? B.fog : "none"),
                  (k.litOptions.gamma = j.useGammaTonemap
                    ? B.gammaCorrection
                    : d.hc),
                  (k.litOptions.toneMap = j.useGammaTonemap
                    ? B.toneMapping
                    : -1),
                  (k.litOptions.fixSeams = j.cubeMap
                    ? j.cubeMap.fixCubemapSeams
                    : !1);
                const $ = j.shadingModel === d.Tp;
                let le = !1;
                if (
                  (j.envAtlas && j.cubeMap && !$
                    ? ((k.litOptions.reflectionSource = "envAtlasHQ"),
                      (k.litOptions.reflectionEncoding = j.envAtlas.encoding),
                      (k.litOptions.reflectionCubemapEncoding =
                        j.cubeMap.encoding))
                    : j.envAtlas && !$
                    ? ((k.litOptions.reflectionSource = "envAtlas"),
                      (k.litOptions.reflectionEncoding = j.envAtlas.encoding))
                    : j.cubeMap
                    ? ((k.litOptions.reflectionSource = "cubeMap"),
                      (k.litOptions.reflectionEncoding = j.cubeMap.encoding))
                    : j.sphereMap
                    ? ((k.litOptions.reflectionSource = "sphereMap"),
                      (k.litOptions.reflectionEncoding = j.sphereMap.encoding))
                    : j.useSkybox && B.envAtlas && B.skybox && !$
                    ? ((k.litOptions.reflectionSource = "envAtlasHQ"),
                      (k.litOptions.reflectionEncoding = B.envAtlas.encoding),
                      (k.litOptions.reflectionCubemapEncoding =
                        B.skybox.encoding),
                      (le = !0))
                    : j.useSkybox && B.envAtlas && !$
                    ? ((k.litOptions.reflectionSource = "envAtlas"),
                      (k.litOptions.reflectionEncoding = B.envAtlas.encoding),
                      (le = !0))
                    : j.useSkybox && B.skybox
                    ? ((k.litOptions.reflectionSource = "cubeMap"),
                      (k.litOptions.reflectionEncoding = B.skybox.encoding),
                      (le = !0))
                    : ((k.litOptions.reflectionSource = null),
                      (k.litOptions.reflectionEncoding = null)),
                  j.ambientSH && !$)
                )
                  (k.litOptions.ambientSource = "ambientSH"),
                    (k.litOptions.ambientEncoding = null);
                else {
                  const O =
                    j.envAtlas ||
                    (j.useSkybox && B.envAtlas ? B.envAtlas : null);
                  O && !$
                    ? ((k.litOptions.ambientSource = "envAtlas"),
                      (k.litOptions.ambientEncoding = O.encoding))
                    : ((k.litOptions.ambientSource = "constant"),
                      (k.litOptions.ambientEncoding = null));
                }
                (k.litOptions.skyboxIntensity =
                  le && (B.skyboxIntensity !== 1 || B.physicalUnits)),
                  (k.litOptions.useCubeMapRotation =
                    le && B._skyboxRotationShaderInclude);
              }
              _updateLightOptions(k, j, B, $, le) {
                if (
                  ((k.lightMap = !1),
                  (k.lightMapChannel = ""),
                  (k.lightMapUv = 0),
                  (k.lightMapTransform = 0),
                  (k.litOptions.lightMapWithoutAmbient = !1),
                  (k.dirLightMap = !1),
                  $ &&
                    ((k.litOptions.noShadow = ($ & d.b2) !== 0),
                    $ & d.tT &&
                      ((k.lightMapEncoding =
                        j.lightmapPixelFormat === _.Lxj ? "rgbm" : "linear"),
                      (k.lightMap = !0),
                      (k.lightMapChannel = "rgb"),
                      (k.lightMapUv = 1),
                      (k.lightMapTransform = 0),
                      (k.litOptions.lightMapWithoutAmbient = !B.lightMap),
                      $ & d.CO && (k.dirLightMap = !0),
                      $ & d.tE && (k.litOptions.lightMapWithoutAmbient = !1))),
                  B.useLighting)
                ) {
                  const O = [],
                    Y = $ ? $ >> 16 : d.Xj;
                  (k.litOptions.lightMaskDynamic = !!(Y & d.Xj)),
                    le &&
                      (m.K.collectLights(d.kx, le[d.kx], O, Y),
                      m.K.collectLights(d.dG, le[d.dG], O, Y),
                      m.K.collectLights(d.Gy, le[d.Gy], O, Y)),
                    (k.litOptions.lights = O);
                } else k.litOptions.lights = [];
                k.litOptions.lights.length === 0 &&
                  (k.litOptions.noShadow = !0);
              }
              _getMapTransformID(k, j) {
                if (!k) return 0;
                let B = this._mapXForms[j];
                B || ((B = []), (this._mapXForms[j] = B));
                for (let $ = 0; $ < B.length; $++)
                  if (
                    g(B[$][0].value, k[0].value) &&
                    g(B[$][1].value, k[1].value)
                  )
                    return $ + 1;
                return B.push(k);
              }
            }
            var R = a(6679);
            const P = {},
              F = {};
            let b = new Set();
            class D extends v.i {
              constructor() {
                super(),
                  (this._dirtyShader = !0),
                  (this._assetReferences = {}),
                  (this._activeParams = new Set()),
                  (this._activeLightingParams = new Set()),
                  (this.shaderOptBuilder = new M()),
                  this.reset();
              }
              reset() {
                Object.keys(P).forEach((k) => {
                  this[`_${k}`] = P[k].value();
                }),
                  (this._chunks = {}),
                  (this._uniformCache = {});
              }
              set shader(k) {}
              get shader() {
                return null;
              }
              set chunks(k) {
                (this._dirtyShader = !0), (this._chunks = k);
              }
              get chunks() {
                return (this._dirtyShader = !0), this._chunks;
              }
              copy(k) {
                super.copy(k),
                  Object.keys(P).forEach((j) => {
                    this[j] = k[j];
                  });
                for (const j in k._chunks)
                  k._chunks.hasOwnProperty(j) &&
                    (this._chunks[j] = k._chunks[j]);
                return this;
              }
              _setParameter(k, j) {
                b.add(k), this.setParameter(k, j);
              }
              _setParameters(k) {
                k.forEach((j) => {
                  this._setParameter(j.name, j.value);
                });
              }
              _processParameters(k) {
                const j = this[k];
                j.forEach((B) => {
                  b.has(B) || delete this.parameters[B];
                }),
                  (this[k] = b),
                  (b = j),
                  b.clear();
              }
              _updateMap(k) {
                const j = k + "Map",
                  B = this[j];
                if (B) {
                  this._setParameter("texture_" + j, B);
                  const $ = j + "Transform",
                    le = this.getUniform($);
                  le && this._setParameters(le);
                }
              }
              _allocUniform(k, j) {
                let B = this._uniformCache[k];
                return B || ((B = j()), (this._uniformCache[k] = B)), B;
              }
              getUniform(k, j, B) {
                return F[k](this, j, B);
              }
              updateUniforms(k, j) {
                const B = (le) => this.getUniform(le, k, j);
                this._setParameter("material_ambient", B("ambient")),
                  (!this.diffuseMap || this.diffuseTint) &&
                    this._setParameter("material_diffuse", B("diffuse")),
                  this.useMetalness
                    ? ((!this.metalnessMap || this.metalness < 1) &&
                        this._setParameter(
                          "material_metalness",
                          this.metalness
                        ),
                      (!this.specularMap || this.specularTint) &&
                        this._setParameter("material_specular", B("specular")),
                      (!this.specularityFactorMap ||
                        this.specularityFactorTint) &&
                        this._setParameter(
                          "material_specularityFactor",
                          this.specularityFactor
                        ),
                      (!this.sheenMap || this.sheenTint) &&
                        this._setParameter("material_sheen", B("sheen")),
                      (!this.sheenGlossMap || this.sheenGlossTint) &&
                        this._setParameter(
                          "material_sheenGloss",
                          this.sheenGloss
                        ),
                      this._setParameter(
                        "material_refractionIndex",
                        this.refractionIndex
                      ))
                    : (!this.specularMap || this.specularTint) &&
                      this._setParameter("material_specular", B("specular")),
                  this.enableGGXSpecular &&
                    this._setParameter("material_anisotropy", this.anisotropy),
                  this.clearCoat > 0 &&
                    (this._setParameter("material_clearCoat", this.clearCoat),
                    this._setParameter(
                      "material_clearCoatGloss",
                      this.clearCoatGloss
                    ),
                    this._setParameter(
                      "material_clearCoatBumpiness",
                      this.clearCoatBumpiness
                    )),
                  this._setParameter("material_gloss", B("gloss")),
                  (!this.emissiveMap || this.emissiveTint) &&
                    this._setParameter("material_emissive", B("emissive")),
                  this.emissiveIntensity !== 1 &&
                    this._setParameter(
                      "material_emissiveIntensity",
                      this.emissiveIntensity
                    ),
                  this.refraction > 0 &&
                    this._setParameter("material_refraction", this.refraction),
                  this.useDynamicRefraction &&
                    (this._setParameter("material_thickness", this.thickness),
                    this._setParameter(
                      "material_attenuation",
                      B("attenuation")
                    ),
                    this._setParameter(
                      "material_invAttenuationDistance",
                      this.attenuationDistance === 0
                        ? 0
                        : 1 / this.attenuationDistance
                    )),
                  this.useIridescence &&
                    (this._setParameter(
                      "material_iridescence",
                      this.iridescence
                    ),
                    this._setParameter(
                      "material_iridescenceRefractionIndex",
                      this.iridescenceRefractionIndex
                    ),
                    this._setParameter(
                      "material_iridescenceThicknessMin",
                      this.iridescenceThicknessMin
                    ),
                    this._setParameter(
                      "material_iridescenceThicknessMax",
                      this.iridescenceThicknessMax
                    )),
                  this._setParameter("material_opacity", this.opacity),
                  this.opacityFadesSpecular === !1 &&
                    this._setParameter("material_alphaFade", this.alphaFade),
                  this.occludeSpecular &&
                    this._setParameter(
                      "material_occludeSpecularIntensity",
                      this.occludeSpecularIntensity
                    ),
                  this.cubeMapProjection === d.fJ &&
                    this._setParameter(B("cubeMapProjectionBox"));
                for (const le in t) this._updateMap(le);
                this.ambientSH &&
                  this._setParameter("ambientSH[0]", this.ambientSH),
                  this.normalMap &&
                    this._setParameter("material_bumpiness", this.bumpiness),
                  this.normalMap &&
                    this.normalDetailMap &&
                    this._setParameter(
                      "material_normalDetailMapBumpiness",
                      this.normalDetailMapBumpiness
                    ),
                  this.heightMap &&
                    this._setParameter(
                      "material_heightMapFactor",
                      B("heightMapFactor")
                    );
                const $ = this.shadingModel === d.Tp;
                this.envAtlas && this.cubeMap && !$
                  ? (this._setParameter("texture_envAtlas", this.envAtlas),
                    this._setParameter("texture_cubeMap", this.cubeMap))
                  : this.envAtlas && !$
                  ? this._setParameter("texture_envAtlas", this.envAtlas)
                  : this.cubeMap
                  ? this._setParameter("texture_cubeMap", this.cubeMap)
                  : this.sphereMap &&
                    this._setParameter("texture_sphereMap", this.sphereMap),
                  this._setParameter(
                    "material_reflectivity",
                    this.reflectivity
                  ),
                  this._processParameters("_activeParams"),
                  this._dirtyShader && this.clearVariants();
              }
              updateEnvUniforms(k, j) {
                const B = this.shadingModel === d.Tp;
                !((this.envAtlas && !B) || this.cubeMap || this.sphereMap) &&
                  this.useSkybox &&
                  (j.envAtlas && j.skybox && !B
                    ? (this._setParameter("texture_envAtlas", j.envAtlas),
                      this._setParameter("texture_cubeMap", j.skybox))
                    : j.envAtlas && !B
                    ? this._setParameter("texture_envAtlas", j.envAtlas)
                    : j.skybox &&
                      this._setParameter("texture_cubeMap", j.skybox)),
                  this._processParameters("_activeLightingParams");
              }
              getShaderVariant(k, j, B, $, le, O, Y, ne, de) {
                this.updateEnvUniforms(k, j);
                const re = h.p.get(k).getByIndex(le),
                  I = le === d.w8 || le === d.cz || re.isShadow;
                let w = I ? u.optionsContextMin : u.optionsContext;
                I
                  ? this.shaderOptBuilder.updateMinRef(w, j, this, B, le, O)
                  : this.shaderOptBuilder.updateRef(w, j, this, B, le, O),
                  this.onUpdateShader && (w = this.onUpdateShader(w));
                const N = new c.c(Y, ne, de),
                  W = (0, s.k)(k);
                W.register("standard", u);
                const he = W.getProgram("standard", w, N, this.userId);
                return (this._dirtyShader = !1), he;
              }
              destroy() {
                for (const k in this._assetReferences)
                  this._assetReferences[k]._unbind();
                (this._assetReferences = null), super.destroy();
              }
            }
            (D.TEXTURE_PARAMETERS = R.Gc), (D.CUBEMAP_PARAMETERS = R.W5);
            const G = (ge, k) => {
                F[ge] = k;
              },
              X = (ge, k, j, B) => {
                Object.defineProperty(D.prototype, ge, {
                  get:
                    B ||
                    function () {
                      return this[`_${ge}`];
                    },
                  set: j,
                }),
                  (P[ge] = { value: k });
              },
              ie = (ge) => {
                const k = `_${ge.name}`,
                  j = ge.dirtyShaderFunc || (() => !0),
                  B = function (le) {
                    const O = this[k];
                    O !== le &&
                      ((this._dirtyShader = this._dirtyShader || j(O, le)),
                      (this[k] = le));
                  };
                X(ge.name, () => ge.defaultValue, B, ge.getterFunc);
              },
              Q = (ge) => {
                const k = `_${ge.name}`,
                  j = ge.dirtyShaderFunc || (() => !0),
                  B = function (le) {
                    const O = this[k];
                    O.equals(le) ||
                      ((this._dirtyShader = this._dirtyShader || j(O, le)),
                      (this[k] = O.copy(le)));
                  };
                X(ge.name, () => ge.defaultValue.clone(), B, ge.getterFunc);
              },
              te = (ge) =>
                ge.defaultValue && ge.defaultValue.clone ? Q(ge) : ie(ge);
            function ae(ge, k = "rgb", j = !0, B = 0) {
              (t[ge] = k.length || -1),
                te({
                  name: `${ge}Map`,
                  defaultValue: null,
                  dirtyShaderFunc: (ne, de) =>
                    !!ne != !!de ||
                    (ne &&
                      (ne.type !== de.type ||
                        ne.fixCubemapSeams !== de.fixCubemapSeams ||
                        ne.format !== de.format)),
                }),
                te({ name: `${ge}MapTiling`, defaultValue: new y.Z(1, 1) }),
                te({ name: `${ge}MapOffset`, defaultValue: new y.Z(0, 0) }),
                te({ name: `${ge}MapRotation`, defaultValue: 0 }),
                te({ name: `${ge}MapUv`, defaultValue: B }),
                k &&
                  (te({ name: `${ge}MapChannel`, defaultValue: k }),
                  j &&
                    (te({ name: `${ge}VertexColor`, defaultValue: !1 }),
                    te({ name: `${ge}VertexColorChannel`, defaultValue: k })));
              const $ = `${ge}MapTiling`,
                le = `${ge}MapOffset`,
                O = `${ge}MapRotation`,
                Y = `${ge}MapTransform`;
              G(Y, (ne, de, re) => {
                const I = ne[$],
                  w = ne[le],
                  N = ne[O];
                if (I.x === 1 && I.y === 1 && w.x === 0 && w.y === 0 && N === 0)
                  return null;
                const W = ne._allocUniform(Y, () => [
                    { name: `texture_${Y}0`, value: new Float32Array(3) },
                    { name: `texture_${Y}1`, value: new Float32Array(3) },
                  ]),
                  he = Math.cos(N * x.D.DEG_TO_RAD),
                  ue = Math.sin(N * x.D.DEG_TO_RAD),
                  ye = W[0].value;
                (ye[0] = he * I.x), (ye[1] = -ue * I.y), (ye[2] = w.x);
                const Oe = W[1].value;
                return (
                  (Oe[0] = ue * I.x),
                  (Oe[1] = he * I.y),
                  (Oe[2] = 1 - I.y - w.y),
                  W
                );
              });
            }
            function Z(ge, k) {
              te({
                name: ge,
                defaultValue: k,
                getterFunc: function () {
                  return (this._dirtyShader = !0), this[`_${ge}`];
                },
              }),
                G(ge, (j, B, $) => {
                  const le = j._allocUniform(ge, () => new Float32Array(3)),
                    O = j[ge];
                  return (
                    j.useGammaTonemap && $.gammaCorrection
                      ? ((le[0] = Math.pow(O.r, 2.2)),
                        (le[1] = Math.pow(O.g, 2.2)),
                        (le[2] = Math.pow(O.b, 2.2)))
                      : ((le[0] = O.r), (le[1] = O.g), (le[2] = O.b)),
                    le
                  );
                });
            }
            function J(ge, k, j) {
              te({
                name: ge,
                defaultValue: k,
                dirtyShaderFunc: (B, $) =>
                  (B === 0 || B === 1) != ($ === 0 || $ === 1),
              }),
                G(ge, j);
            }
            function ve(ge, k) {
              te({
                name: ge,
                defaultValue: null,
                dirtyShaderFunc: (j, B) => !!j == !!B,
              }),
                G(ge, k);
            }
            function _e(ge, k) {
              te({ name: ge, defaultValue: k });
            }
            function L() {
              Z("ambient", new A.Q(0.7, 0.7, 0.7)),
                Z("diffuse", new A.Q(1, 1, 1)),
                Z("specular", new A.Q(0, 0, 0)),
                Z("emissive", new A.Q(0, 0, 0)),
                Z("sheen", new A.Q(1, 1, 1)),
                Z("attenuation", new A.Q(1, 1, 1)),
                J("emissiveIntensity", 1),
                J("specularityFactor", 1),
                J("sheenGloss", 0),
                J("gloss", 0.25, (B, $, le) =>
                  B.shadingModel === d.Tp ? Math.pow(2, B.gloss * 11) : B.gloss
                ),
                J(
                  "heightMapFactor",
                  1,
                  (B, $, le) => B.heightMapFactor * 0.025
                ),
                J("opacity", 1),
                J("alphaFade", 1),
                J("alphaTest", 0),
                J("bumpiness", 1),
                J("normalDetailMapBumpiness", 1),
                J("reflectivity", 1),
                J("occludeSpecularIntensity", 1),
                J("refraction", 0),
                J("refractionIndex", 0.6666666666666666),
                J("thickness", 0),
                J("attenuationDistance", 0),
                J("metalness", 1),
                J("anisotropy", 0),
                J("clearCoat", 0),
                J("clearCoatGloss", 1),
                J("clearCoatBumpiness", 1),
                J("aoUvSet", 0, null),
                J("iridescence", 0),
                J("iridescenceRefractionIndex", 0.6666666666666666),
                J("iridescenceThicknessMin", 0),
                J("iridescenceThicknessMax", 0),
                ve("ambientSH"),
                ve("cubeMapProjectionBox", (B, $, le) => {
                  const O = B._allocUniform("cubeMapProjectionBox", () => [
                      { name: "envBoxMin", value: new Float32Array(3) },
                      { name: "envBoxMax", value: new Float32Array(3) },
                    ]),
                    Y = B.cubeMapProjectionBox.getMin(),
                    ne = O[0].value;
                  (ne[0] = Y.x), (ne[1] = Y.y), (ne[2] = Y.z);
                  const de = B.cubeMapProjectionBox.getMax(),
                    re = O[1].value;
                  return (re[0] = de.x), (re[1] = de.y), (re[2] = de.z), O;
                }),
                _e("ambientTint", !1),
                _e("diffuseTint", !1),
                _e("specularTint", !1),
                _e("specularityFactorTint", !1),
                _e("emissiveTint", !1),
                _e("fastTbn", !1),
                _e("useMetalness", !1),
                _e("useMetalnessSpecularColor", !1),
                _e("useSheen", !1),
                _e("enableGGXSpecular", !1),
                _e("occludeDirect", !1),
                _e("normalizeNormalMap", !0),
                _e("conserveEnergy", !0),
                _e("opacityFadesSpecular", !0),
                _e("occludeSpecular", d.aP),
                _e("shadingModel", d.SB),
                _e("fresnelModel", d.SU),
                _e("useDynamicRefraction", !1),
                _e("cubeMapProjection", d.ip),
                _e("customFragmentShader", null),
                _e("useFog", !0),
                _e("useLighting", !0),
                _e("useGammaTonemap", !0),
                _e("useSkybox", !0),
                _e("forceUv1", !1),
                _e("pixelSnap", !1),
                _e("twoSidedLighting", !1),
                _e("nineSlicedMode", void 0),
                _e("msdfTextAttribute", !1),
                _e("useIridescence", !1),
                _e("glossInvert", !1),
                _e("sheenGlossInvert", !1),
                _e("clearCoatGlossInvert", !1),
                ae("diffuse"),
                ae("specular"),
                ae("emissive"),
                ae("thickness", "g"),
                ae("specularityFactor", "g"),
                ae("normal", ""),
                ae("metalness", "g"),
                ae("gloss", "g"),
                ae("opacity", "a"),
                ae("refraction", "g"),
                ae("height", "g", !1),
                ae("ao", "g"),
                ae("light", "rgb", !0, 1),
                ae("msdf", ""),
                ae("diffuseDetail", "rgb", !1),
                ae("normalDetail", ""),
                ae("aoDetail", "g", !1),
                ae("clearCoat", "g"),
                ae("clearCoatGloss", "g"),
                ae("clearCoatNormal", ""),
                ae("sheen", "rgb"),
                ae("sheenGloss", "g"),
                ae("iridescence", "g"),
                ae("iridescenceThickness", "g"),
                _e("diffuseDetailMode", d.QK),
                _e("aoDetailMode", d.QK),
                ve("cubeMap"),
                ve("sphereMap"),
                ve("envAtlas");
              const ge = function () {
                  return this._prefilteredCubemaps;
                },
                k = function ($) {
                  const le = this._prefilteredCubemaps;
                  $ = $ || [];
                  let O = !1,
                    Y = !0;
                  for (let ne = 0; ne < 6; ++ne) {
                    const de = $[ne] || null;
                    le[ne] !== de && ((le[ne] = de), (O = !0)),
                      (Y = Y && !!le[ne]);
                  }
                  O &&
                    (Y
                      ? (this.envAtlas = f.S.generatePrefilteredAtlas(le, {
                          target: this.envAtlas,
                        }))
                      : this.envAtlas &&
                        (this.envAtlas.destroy(), (this.envAtlas = null)),
                    (this._dirtyShader = !0));
                },
                j = [null, null, null, null, null, null];
              X("prefilteredCubemaps", () => j.slice(), k, ge);
            }
            L();
          },
          3637: (xe, V, a) => {
            "use strict";
            a.d(V, { F: () => v, u: () => t });
            var A = a(7915),
              x = a(5145),
              y = a(2978),
              c = a(5006),
              d = a(9391),
              h = a(3035),
              f = a(1594),
              s = a(9788);
            const l = new A.I(),
              n = new A.I(),
              o = new x.i(),
              i = new Set();
            class e {
              constructor(g) {
                (this.vertexBuffer = null), (this.count = g);
              }
            }
            class t {
              constructor(g, T, E) {
                (this._key = []),
                  (this._key[d.Gn] = _(g, T, !0, 0)),
                  (this.command = E);
              }
              set key(g) {
                this._key[d.Gn] = g;
              }
              get key() {
                return this._key[d.Gn];
              }
            }
            class r {
              constructor() {
                (this.shader = void 0), (this.bindGroup = null);
              }
              getBindGroup(g) {
                if (!this.bindGroup) {
                  const T = this.shader,
                    E = T.meshUniformBufferFormat,
                    M = new c.D(g, E, !1),
                    R = T.meshBindGroupFormat;
                  this.bindGroup = new y.T(g, R, M);
                }
                return this.bindGroup;
              }
              destroy() {
                const g = this.bindGroup;
                if (g) {
                  var T;
                  (T = g.defaultUniformBuffer) == null || T.destroy(),
                    g.destroy(),
                    (this.bindGroup = null);
                }
              }
            }
            class u {
              constructor() {
                this.shaderInstances = new Map();
              }
              destroy() {
                this.shaderInstances.forEach((g) => g.destroy()),
                  this.shaderInstances.clear();
              }
            }
            class v {
              constructor(g, T, E = null) {
                if (
                  ((this.visible = !0),
                  (this.castShadow = !1),
                  (this.transparent = !1),
                  (this._material = null),
                  (this._shaderCache = []),
                  g instanceof h.t)
                ) {
                  const M = g;
                  (g = T), (T = E), (E = M);
                }
                (this._key = [0, 0]),
                  (this.node = E),
                  (this._mesh = g),
                  g.incRefCount(),
                  (this.material = T),
                  (this._shaderDefs = d.Xj << 16),
                  (this._shaderDefs |= g.vertexBuffer.format.hasUv0 ? d.Jq : 0),
                  (this._shaderDefs |= g.vertexBuffer.format.hasUv1 ? d.Cn : 0),
                  (this._shaderDefs |= g.vertexBuffer.format.hasColor
                    ? d.L$
                    : 0),
                  (this._shaderDefs |= g.vertexBuffer.format.hasTangents
                    ? d.k
                    : 0),
                  (this.layer = d.$1),
                  (this._renderStyle = d.OZ),
                  (this._receiveShadow = !0),
                  (this._screenSpace = !1),
                  (this._noDepthDrawGl1 = !1),
                  (this.cull = !0),
                  (this.pick = !0),
                  (this._updateAabb = !0),
                  (this._updateAabbFunc = null),
                  (this._calculateSortDistance = null),
                  this.updateKey(),
                  (this._skinInstance = null),
                  (this._morphInstance = null),
                  (this.instancingData = null),
                  (this._customAabb = null),
                  (this.aabb = new A.I()),
                  (this._aabbVer = -1),
                  (this.drawOrder = 0),
                  (this.visibleThisFrame = !1),
                  (this.isVisibleFunc = null),
                  (this.parameters = {}),
                  (this.stencilFront = null),
                  (this.stencilBack = null),
                  (this.flipFacesFactor = 1);
              }
              set renderStyle(g) {
                (this._renderStyle = g), this.mesh.prepareRenderState(g);
              }
              get renderStyle() {
                return this._renderStyle;
              }
              set mesh(g) {
                g !== this._mesh &&
                  (this._mesh && this._mesh.decRefCount(),
                  (this._mesh = g),
                  g && g.incRefCount());
              }
              get mesh() {
                return this._mesh;
              }
              set aabb(g) {
                this._aabb = g;
              }
              get aabb() {
                if (!this._updateAabb) return this._aabb;
                if (this._updateAabbFunc)
                  return this._updateAabbFunc(this._aabb);
                let g = this._customAabb,
                  T = !!g;
                if (!g) {
                  if (((g = l), this.skinInstance)) {
                    if (!this.mesh.boneAabb) {
                      const R = this._morphInstance
                        ? this._morphInstance.morph._targets
                        : null;
                      this.mesh._initBoneAabbs(R);
                    }
                    const E = this.mesh.boneUsed;
                    let M = !0;
                    for (let R = 0; R < this.mesh.boneAabb.length; R++)
                      E[R] &&
                        (n.setFromTransformedAabb(
                          this.mesh.boneAabb[R],
                          this.skinInstance.matrices[R]
                        ),
                        M
                          ? ((M = !1),
                            g.center.copy(n.center),
                            g.halfExtents.copy(n.halfExtents))
                          : g.add(n));
                    T = !0;
                  } else if (this.node._aabbVer !== this._aabbVer) {
                    if (
                      (this.mesh
                        ? (g.center.copy(this.mesh.aabb.center),
                          g.halfExtents.copy(this.mesh.aabb.halfExtents))
                        : (g.center.set(0, 0, 0), g.halfExtents.set(0, 0, 0)),
                      this.mesh && this.mesh.morph)
                    ) {
                      const E = this.mesh.morph.aabb;
                      g._expand(E.getMin(), E.getMax());
                    }
                    (T = !0), (this._aabbVer = this.node._aabbVer);
                  }
                }
                return (
                  T &&
                    this._aabb.setFromTransformedAabb(
                      g,
                      this.node.getWorldTransform()
                    ),
                  this._aabb
                );
              }
              clearShaders() {
                const g = this._shaderCache;
                for (let E = 0; E < g.length; E++) {
                  var T;
                  (T = g[E]) == null || T.destroy(), (g[E] = null);
                }
              }
              getShaderInstance(g, T, E, M, R, P) {
                let F,
                  b = this._shaderCache[g];
                if (
                  (b
                    ? (F = b.shaderInstances.get(T))
                    : ((b = new u()), (this._shaderCache[g] = b)),
                  !F)
                ) {
                  const D = this._material,
                    G = this._shaderDefs,
                    X = g + "_" + G + "_" + T;
                  if (
                    ((F = new r()), (F.shader = D.variants.get(X)), !F.shader)
                  ) {
                    const ie = D.getShaderVariant(
                      this.mesh.device,
                      E,
                      G,
                      null,
                      g,
                      P,
                      M,
                      R,
                      this._mesh.vertexBuffer.format
                    );
                    D.variants.set(X, ie), (F.shader = ie);
                  }
                  b.shaderInstances.set(T, F);
                }
                return F;
              }
              set material(g) {
                this.clearShaders();
                const T = this._material;
                if (
                  (T && T.removeMeshInstanceRef(this), (this._material = g), g)
                ) {
                  g.addMeshInstanceRef(this),
                    (this.transparent = g.transparent),
                    this.updateKey();
                  const E = T && T.transparent;
                  if (g.transparent !== E) {
                    const M =
                      this._material._scene || (T == null ? void 0 : T._scene);
                    M ? (M.layers._dirtyBlend = !0) : (g._dirtyBlend = !0);
                  }
                }
              }
              get material() {
                return this._material;
              }
              set layer(g) {
                (this._layer = g), this.updateKey();
              }
              get layer() {
                return this._layer;
              }
              _updateShaderDefs(g) {
                g !== this._shaderDefs &&
                  ((this._shaderDefs = g), this.clearShaders());
              }
              set calculateSortDistance(g) {
                this._calculateSortDistance = g;
              }
              get calculateSortDistance() {
                return this._calculateSortDistance;
              }
              set receiveShadow(g) {
                this._receiveShadow !== g &&
                  ((this._receiveShadow = g),
                  this._updateShaderDefs(
                    g ? this._shaderDefs & ~d.b2 : this._shaderDefs | d.b2
                  ));
              }
              get receiveShadow() {
                return this._receiveShadow;
              }
              set skinInstance(g) {
                (this._skinInstance = g),
                  this._updateShaderDefs(
                    g ? this._shaderDefs | d.Df : this._shaderDefs & ~d.Df
                  ),
                  this._setupSkinUpdate();
              }
              get skinInstance() {
                return this._skinInstance;
              }
              set morphInstance(g) {
                var T;
                (T = this._morphInstance) == null || T.destroy(),
                  (this._morphInstance = g);
                let E = this._shaderDefs;
                (E = g && g.morph.useTextureMorph ? E | d.uJ : E & ~d.uJ),
                  (E = g && g.morph.morphPositions ? E | d.Ck : E & ~d.Ck),
                  (E = g && g.morph.morphNormals ? E | d.ov : E & ~d.ov),
                  this._updateShaderDefs(E);
              }
              get morphInstance() {
                return this._morphInstance;
              }
              set screenSpace(g) {
                this._screenSpace !== g &&
                  ((this._screenSpace = g),
                  this._updateShaderDefs(
                    g ? this._shaderDefs | d.yr : this._shaderDefs & ~d.yr
                  ));
              }
              get screenSpace() {
                return this._screenSpace;
              }
              set key(g) {
                this._key[d.Gn] = g;
              }
              get key() {
                return this._key[d.Gn];
              }
              set mask(g) {
                const T = this._shaderDefs & 65535;
                this._updateShaderDefs(T | (g << 16));
              }
              get mask() {
                return this._shaderDefs >> 16;
              }
              set instancingCount(g) {
                this.instancingData && (this.instancingData.count = g);
              }
              get instancingCount() {
                return this.instancingData ? this.instancingData.count : 0;
              }
              destroy() {
                var g, T;
                const E = this.mesh;
                E && ((this.mesh = null), E.refCount < 1 && E.destroy()),
                  this.setRealtimeLightmap(v.lightmapParamNames[0], null),
                  this.setRealtimeLightmap(v.lightmapParamNames[1], null),
                  (g = this._skinInstance) == null || g.destroy(),
                  (this._skinInstance = null),
                  (T = this.morphInstance) == null || T.destroy(),
                  (this.morphInstance = null),
                  this.clearShaders(),
                  (this.material = null);
              }
              static _prepareRenderStyleForArray(g, T) {
                if (g) {
                  for (let E = 0; E < g.length; E++) {
                    g[E]._renderStyle = T;
                    const M = g[E].mesh;
                    i.has(M) || (i.add(M), M.prepareRenderState(T));
                  }
                  i.clear();
                }
              }
              _isVisible(g) {
                return this.visible
                  ? this.isVisibleFunc
                    ? this.isVisibleFunc(g)
                    : ((o.center = this.aabb.center),
                      (o.radius = this._aabb.halfExtents.length()),
                      g.frustum.containsSphere(o))
                  : !1;
              }
              updateKey() {
                const g = this.material;
                this._key[d.Gn] = _(
                  this.layer,
                  g.alphaToCoverage || g.alphaTest ? d.i9 : g.blendType,
                  !1,
                  g.id
                );
              }
              setInstancing(g) {
                g
                  ? ((this.instancingData = new e(g.numVertices)),
                    (this.instancingData.vertexBuffer = g),
                    (g.format.instancing = !0),
                    (this.cull = !1))
                  : ((this.instancingData = null), (this.cull = !0)),
                  this._updateShaderDefs(
                    g ? this._shaderDefs | d.Q$ : this._shaderDefs & ~d.Q$
                  );
              }
              ensureMaterial(g) {
                this.material || (this.material = (0, f.h)(g));
              }
              clearParameters() {
                this.parameters = {};
              }
              getParameters() {
                return this.parameters;
              }
              getParameter(g) {
                return this.parameters[g];
              }
              setParameter(g, T, E = -262141) {
                if (T === void 0 && typeof g == "object") {
                  const R = g;
                  if (R.length) {
                    for (let P = 0; P < R.length; P++) this.setParameter(R[P]);
                    return;
                  }
                  (g = R.name), (T = R.value);
                }
                const M = this.parameters[g];
                M
                  ? ((M.data = T), (M.passFlags = E))
                  : (this.parameters[g] = {
                      scopeId: null,
                      data: T,
                      passFlags: E,
                    });
              }
              setRealtimeLightmap(g, T) {
                const E = this.getParameter(g);
                E !== T &&
                  (E && s.j.decRef(E.data),
                  T
                    ? (s.j.incRef(T), this.setParameter(g, T))
                    : this.deleteParameter(g));
              }
              deleteParameter(g) {
                this.parameters[g] && delete this.parameters[g];
              }
              setParameters(g, T) {
                const E = this.parameters;
                for (const M in E) {
                  const R = E[M];
                  R.passFlags & T &&
                    (R.scopeId || (R.scopeId = g.scope.resolve(M)),
                    R.scopeId.setValue(R.data));
                }
              }
              setLightmapped(g) {
                g
                  ? (this.mask = (this.mask | d.be) & ~(d.Xj | d.XE))
                  : (this.setRealtimeLightmap(v.lightmapParamNames[0], null),
                    this.setRealtimeLightmap(v.lightmapParamNames[1], null),
                    (this._shaderDefs &= ~(d.tT | d.CO | d.tE)),
                    (this.mask = (this.mask | d.Xj) & ~(d.be | d.XE)));
              }
              setCustomAabb(g) {
                g
                  ? this._customAabb
                    ? this._customAabb.copy(g)
                    : (this._customAabb = g.clone())
                  : ((this._customAabb = null), (this._aabbVer = -1)),
                  this._setupSkinUpdate();
              }
              _setupSkinUpdate() {
                this._skinInstance &&
                  (this._skinInstance._updateBeforeCull = !this._customAabb);
              }
            }
            v.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];
            function _(m, g, T, E) {
              return (
                ((m & 15) << 27) |
                ((g === d.Rj ? 1 : 0) << 26) |
                ((T ? 1 : 0) << 25) |
                ((E & 33554431) << 0)
              );
            }
          },
          7197: (xe, V, a) => {
            "use strict";
            a.d(V, { e: () => t });
            var A = a(4460),
              x = a(7481),
              y = a(7915),
              c = a(1630),
              d = a(970),
              h = a(5860),
              f = a(6089),
              s = a(1984),
              l = a(8136),
              n = a(9391);
            let o = 0;
            class i {
              constructor() {
                this.initDefaults();
              }
              initDefaults() {
                (this.recreate = !1),
                  (this.verticesUsage = c.y1K),
                  (this.indicesUsage = c.y1K),
                  (this.maxVertices = 0),
                  (this.maxIndices = 0),
                  (this.vertexCount = 0),
                  (this.indexCount = 0),
                  (this.vertexStreamsUpdated = !1),
                  (this.indexStreamUpdated = !1),
                  (this.vertexStreamDictionary = {}),
                  (this.indices = null);
              }
              _changeVertexCount(u, v) {
                this.vertexCount || (this.vertexCount = u);
              }
            }
            (i.DEFAULT_COMPONENTS_POSITION = 3),
              (i.DEFAULT_COMPONENTS_NORMAL = 3),
              (i.DEFAULT_COMPONENTS_UV = 2),
              (i.DEFAULT_COMPONENTS_COLORS = 4);
            class e {
              constructor(u, v, _, m) {
                (this.data = u),
                  (this.componentCount = v),
                  (this.dataType = _),
                  (this.dataTypeNormalize = m);
              }
            }
            class t extends A.p {
              constructor(u) {
                super(),
                  (this.id = o++),
                  (this.device = u || l.A.get()),
                  (this.vertexBuffer = null),
                  (this.indexBuffer = [null]),
                  (this.primitive = [{ type: 0, base: 0, count: 0 }]),
                  (this.skin = null),
                  (this._morph = null),
                  (this._geometryData = null),
                  (this._aabb = new y.I()),
                  (this.boneAabb = null);
              }
              set morph(u) {
                u !== this._morph &&
                  (this._morph && this._morph.decRefCount(),
                  (this._morph = u),
                  u && u.incRefCount());
              }
              get morph() {
                return this._morph;
              }
              set aabb(u) {
                this._aabb = u;
              }
              get aabb() {
                return this._aabb;
              }
              destroy() {
                const u = this.morph;
                u && ((this.morph = null), u.refCount < 1 && u.destroy()),
                  this.vertexBuffer &&
                    (this.vertexBuffer.destroy(), (this.vertexBuffer = null));
                for (let v = 0; v < this.indexBuffer.length; v++)
                  this._destroyIndexBuffer(v);
                (this.indexBuffer.length = 0), (this._geometryData = null);
              }
              _destroyIndexBuffer(u) {
                this.indexBuffer[u] &&
                  (this.indexBuffer[u].destroy(), (this.indexBuffer[u] = null));
              }
              _initBoneAabbs(u) {
                (this.boneAabb = []), (this.boneUsed = []);
                let v, _, m, g, T;
                const E = [],
                  M = [],
                  R = this.boneUsed,
                  P = this.skin.boneNames.length;
                let F, b, D;
                for (let Z = 0; Z < P; Z++)
                  (E[Z] = new x.e(
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE
                  )),
                    (M[Z] = new x.e(
                      -Number.MAX_VALUE,
                      -Number.MAX_VALUE,
                      -Number.MAX_VALUE
                    ));
                const G = new s.P(this.vertexBuffer),
                  X = G.element[c.JYe],
                  ie = G.element[c.Hn_],
                  Q = G.element[c.aVd],
                  te = this.vertexBuffer.numVertices;
                for (let Z = 0; Z < te; Z++) {
                  for (let J = 0; J < 4; J++)
                    if (ie.array[ie.index + J] > 0) {
                      const _e = Q.array[Q.index + J];
                      if (
                        ((R[_e] = !0),
                        (v = X.array[X.index]),
                        (_ = X.array[X.index + 1]),
                        (m = X.array[X.index + 2]),
                        (g = M[_e]),
                        (T = E[_e]),
                        T.x > v && (T.x = v),
                        T.y > _ && (T.y = _),
                        T.z > m && (T.z = m),
                        g.x < v && (g.x = v),
                        g.y < _ && (g.y = _),
                        g.z < m && (g.z = m),
                        u)
                      ) {
                        let L = (F = v),
                          ge = (b = _),
                          k = (D = m);
                        for (let j = 0; j < u.length; j++) {
                          const B = u[j],
                            $ = B.deltaPositions[Z * 3],
                            le = B.deltaPositions[Z * 3 + 1],
                            O = B.deltaPositions[Z * 3 + 2];
                          $ < 0 ? (L += $) : (F += $),
                            le < 0 ? (ge += le) : (b += le),
                            O < 0 ? (k += O) : (D += O);
                        }
                        T.x > L && (T.x = L),
                          T.y > ge && (T.y = ge),
                          T.z > k && (T.z = k),
                          g.x < F && (g.x = F),
                          g.y < b && (g.y = b),
                          g.z < D && (g.z = D);
                      }
                    }
                  G.next();
                }
                const ae = this.vertexBuffer
                  .getFormat()
                  .elements.find((Z) => Z.name === c.JYe);
                if (ae && ae.normalize) {
                  const Z = (() => {
                    switch (ae.dataType) {
                      case c.VSW:
                        return (J) => Math.max(J / 127, -1);
                      case c.EUX:
                        return (J) => J / 255;
                      case c.kF:
                        return (J) => Math.max(J / 32767, -1);
                      case c.rvO:
                        return (J) => J / 65535;
                      default:
                        return (J) => J;
                    }
                  })();
                  for (let J = 0; J < P; J++)
                    if (R[J]) {
                      const ve = E[J],
                        _e = M[J];
                      ve.set(Z(ve.x), Z(ve.y), Z(ve.z)),
                        _e.set(Z(_e.x), Z(_e.y), Z(_e.z));
                    }
                }
                for (let Z = 0; Z < P; Z++) {
                  const J = new y.I();
                  J.setMinMax(E[Z], M[Z]), this.boneAabb.push(J);
                }
              }
              _initGeometryData() {
                this._geometryData ||
                  ((this._geometryData = new i()),
                  this.vertexBuffer &&
                    ((this._geometryData.vertexCount =
                      this.vertexBuffer.numVertices),
                    (this._geometryData.maxVertices =
                      this.vertexBuffer.numVertices)),
                  this.indexBuffer.length > 0 &&
                    this.indexBuffer[0] &&
                    ((this._geometryData.indexCount =
                      this.indexBuffer[0].numIndices),
                    (this._geometryData.maxIndices =
                      this.indexBuffer[0].numIndices)));
              }
              clear(u, v, _ = 0, m = 0) {
                this._initGeometryData(),
                  this._geometryData.initDefaults(),
                  (this._geometryData.recreate = !0),
                  (this._geometryData.maxVertices = _),
                  (this._geometryData.maxIndices = m),
                  (this._geometryData.verticesUsage = u ? c.y1K : c.pCO),
                  (this._geometryData.indicesUsage = v ? c.y1K : c.pCO);
              }
              setVertexStream(u, v, _, m, g = c.n$B, T = !1) {
                this._initGeometryData();
                const E = m || v.length / _;
                this._geometryData._changeVertexCount(E, u),
                  (this._geometryData.vertexStreamsUpdated = !0),
                  (this._geometryData.vertexStreamDictionary[u] = new e(
                    v,
                    _,
                    g,
                    T
                  ));
              }
              getVertexStream(u, v) {
                let _ = 0,
                  m = !1;
                if (this._geometryData) {
                  const g = this._geometryData.vertexStreamDictionary[u];
                  g &&
                    ((m = !0),
                    (_ = this._geometryData.vertexCount),
                    ArrayBuffer.isView(v)
                      ? v.set(g.data)
                      : ((v.length = 0), v.push(g.data)));
                }
                return (
                  m ||
                    (this.vertexBuffer &&
                      (_ = new s.P(this.vertexBuffer).readData(u, v))),
                  _
                );
              }
              setPositions(u, v = i.DEFAULT_COMPONENTS_POSITION, _) {
                this.setVertexStream(c.JYe, u, v, _, c.n$B, !1);
              }
              setNormals(u, v = i.DEFAULT_COMPONENTS_NORMAL, _) {
                this.setVertexStream(c.XF6, u, v, _, c.n$B, !1);
              }
              setUvs(u, v, _ = i.DEFAULT_COMPONENTS_UV, m) {
                this.setVertexStream(c.CWz + u, v, _, m, c.n$B, !1);
              }
              setColors(u, v = i.DEFAULT_COMPONENTS_COLORS, _) {
                this.setVertexStream(c.F8$, u, v, _, c.n$B, !1);
              }
              setColors32(u, v) {
                this.setVertexStream(
                  c.F8$,
                  u,
                  i.DEFAULT_COMPONENTS_COLORS,
                  v,
                  c.EUX,
                  !0
                );
              }
              setIndices(u, v) {
                this._initGeometryData(),
                  (this._geometryData.indexStreamUpdated = !0),
                  (this._geometryData.indices = u),
                  (this._geometryData.indexCount = v || u.length);
              }
              getPositions(u) {
                return this.getVertexStream(c.JYe, u);
              }
              getNormals(u) {
                return this.getVertexStream(c.XF6, u);
              }
              getUvs(u, v) {
                return this.getVertexStream(c.CWz + u, v);
              }
              getColors(u) {
                return this.getVertexStream(c.F8$, u);
              }
              getIndices(u) {
                let v = 0;
                if (this._geometryData && this._geometryData.indices) {
                  const _ = this._geometryData.indices;
                  (v = this._geometryData.indexCount),
                    ArrayBuffer.isView(u)
                      ? u.set(_)
                      : ((u.length = 0), u.push(_));
                } else
                  this.indexBuffer.length > 0 &&
                    this.indexBuffer[0] &&
                    (v = this.indexBuffer[0].readData(u));
                return v;
              }
              update(u = c.Qpk, v = !0) {
                if (this._geometryData) {
                  if (v) {
                    const g = this._geometryData.vertexStreamDictionary[c.JYe];
                    g &&
                      g.componentCount === 3 &&
                      this._aabb.compute(
                        g.data,
                        this._geometryData.vertexCount
                      );
                  }
                  let _ = this._geometryData.recreate;
                  this._geometryData.vertexCount >
                    this._geometryData.maxVertices &&
                    ((_ = !0),
                    (this._geometryData.maxVertices =
                      this._geometryData.vertexCount)),
                    _ &&
                      this.vertexBuffer &&
                      (this.vertexBuffer.destroy(), (this.vertexBuffer = null));
                  let m = this._geometryData.recreate;
                  this._geometryData.indexCount >
                    this._geometryData.maxIndices &&
                    ((m = !0),
                    (this._geometryData.maxIndices =
                      this._geometryData.indexCount)),
                    m &&
                      this.indexBuffer.length > 0 &&
                      this.indexBuffer[0] &&
                      (this.indexBuffer[0].destroy(),
                      (this.indexBuffer[0] = null)),
                    this._geometryData.vertexStreamsUpdated &&
                      this._updateVertexBuffer(),
                    this._geometryData.indexStreamUpdated &&
                      this._updateIndexBuffer(),
                    (this.primitive[0].type = u),
                    this.indexBuffer.length > 0 && this.indexBuffer[0]
                      ? this._geometryData.indexStreamUpdated &&
                        ((this.primitive[0].count =
                          this._geometryData.indexCount),
                        (this.primitive[0].indexed = !0))
                      : this._geometryData.vertexStreamsUpdated &&
                        ((this.primitive[0].count =
                          this._geometryData.vertexCount),
                        (this.primitive[0].indexed = !1)),
                    (this._geometryData.vertexCount = 0),
                    (this._geometryData.indexCount = 0),
                    (this._geometryData.vertexStreamsUpdated = !1),
                    (this._geometryData.indexStreamUpdated = !1),
                    (this._geometryData.recreate = !1),
                    this.updateRenderStates();
                }
              }
              _buildVertexFormat(u) {
                const v = [];
                for (const _ in this._geometryData.vertexStreamDictionary) {
                  const m = this._geometryData.vertexStreamDictionary[_];
                  v.push({
                    semantic: _,
                    components: m.componentCount,
                    type: m.dataType,
                    normalize: m.dataTypeNormalize,
                  });
                }
                return new f.y(this.device, v, u);
              }
              _updateVertexBuffer() {
                if (!this.vertexBuffer) {
                  const _ = this._geometryData.maxVertices,
                    m = this._buildVertexFormat(_);
                  this.vertexBuffer = new h.R(
                    this.device,
                    m,
                    _,
                    this._geometryData.verticesUsage
                  );
                }
                const u = new s.P(this.vertexBuffer),
                  v = this._geometryData.vertexCount;
                for (const _ in this._geometryData.vertexStreamDictionary) {
                  const m = this._geometryData.vertexStreamDictionary[_];
                  u.writeData(_, m.data, v),
                    delete this._geometryData.vertexStreamDictionary[_];
                }
                u.end();
              }
              _updateIndexBuffer() {
                if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
                  const v =
                    this._geometryData.maxVertices > 65535 ? c.gpl : c.c02;
                  this.indexBuffer[0] = new d.h(
                    this.device,
                    v,
                    this._geometryData.maxIndices,
                    this._geometryData.indicesUsage
                  );
                }
                const u = this._geometryData.indices;
                u &&
                  (this.indexBuffer[0].writeData(
                    u,
                    this._geometryData.indexCount
                  ),
                  (this._geometryData.indices = null));
              }
              prepareRenderState(u) {
                u === n.l3
                  ? this.generateWireframe()
                  : u === n.KM &&
                    (this.primitive[n.KM] = {
                      type: c._AA,
                      base: 0,
                      count: this.vertexBuffer
                        ? this.vertexBuffer.numVertices
                        : 0,
                      indexed: !1,
                    });
              }
              updateRenderStates() {
                this.primitive[n.KM] && this.prepareRenderState(n.KM),
                  this.primitive[n.l3] && this.prepareRenderState(n.l3);
              }
              generateWireframe() {
                this._destroyIndexBuffer(n.l3);
                const u = this.vertexBuffer.numVertices,
                  v = [];
                let _;
                if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
                  const T = [
                      [0, 1],
                      [1, 2],
                      [2, 0],
                    ],
                    E = this.primitive[n.OZ].base,
                    M = this.primitive[n.OZ].count,
                    R = this.indexBuffer[n.OZ],
                    P = new c.SGA[R.format](R.storage),
                    F = new Set();
                  for (let b = E; b < E + M; b += 3)
                    for (let D = 0; D < 3; D++) {
                      const G = P[b + T[D][0]],
                        X = P[b + T[D][1]],
                        ie = G > X ? X * u + G : G * u + X;
                      F.has(ie) || (F.add(ie), v.push(G, X));
                    }
                  _ = R.format;
                } else {
                  for (let T = 0; T < u; T += 3)
                    v.push(T, T + 1, T + 1, T + 2, T + 2, T);
                  _ = v.length > 65535 ? c.gpl : c.c02;
                }
                const m = new d.h(this.vertexBuffer.device, _, v.length);
                new c.SGA[m.format](m.storage).set(v),
                  m.unlock(),
                  (this.primitive[n.l3] = {
                    type: c.EEU,
                    base: 0,
                    count: v.length,
                    indexed: !0,
                  }),
                  (this.indexBuffer[n.l3] = m);
              }
            }
          },
          9611: (xe, V, a) => {
            "use strict";
            a.d(V, { K: () => d });
            var A = a(9391),
              x = a(3637),
              y = a(6414),
              c = a(8777);
            class d {
              constructor() {
                (this.graph = null),
                  (this.meshInstances = []),
                  (this.skinInstances = []),
                  (this.morphInstances = []),
                  (this.cameras = []),
                  (this.lights = []),
                  (this._shadersVersion = 0),
                  (this._immutable = !1);
              }
              getGraph() {
                return this.graph;
              }
              setGraph(f) {
                this.graph = f;
              }
              getCameras() {
                return this.cameras;
              }
              setCameras(f) {
                this.cameras = f;
              }
              getLights() {
                return this.lights;
              }
              setLights(f) {
                this.lights = f;
              }
              getMaterials() {
                const f = [];
                for (let s = 0; s < this.meshInstances.length; s++) {
                  const l = this.meshInstances[s];
                  f.indexOf(l.material) === -1 && f.push(l.material);
                }
                return f;
              }
              clone() {
                const f = [],
                  s = [],
                  n = (function r(u) {
                    const v = u.clone();
                    f.push(u), s.push(v);
                    for (let _ = 0; _ < u._children.length; _++)
                      v.addChild(r(u._children[_]));
                    return v;
                  })(this.graph),
                  o = [],
                  i = [],
                  e = [];
                for (let r = 0; r < this.skinInstances.length; r++) {
                  const u = this.skinInstances[r].skin,
                    v = new c.h(u),
                    _ = [];
                  for (let m = 0; m < u.boneNames.length; m++) {
                    const g = u.boneNames[m],
                      T = n.findByName(g);
                    _.push(T);
                  }
                  (v.bones = _), i.push(v);
                }
                for (let r = 0; r < this.morphInstances.length; r++) {
                  const u = this.morphInstances[r].morph,
                    v = new y.q(u);
                  e.push(v);
                }
                for (let r = 0; r < this.meshInstances.length; r++) {
                  const u = this.meshInstances[r],
                    v = f.indexOf(u.node),
                    _ = new x.F(u.mesh, u.material, s[v]);
                  if (u.skinInstance) {
                    const m = this.skinInstances.indexOf(u.skinInstance);
                    _.skinInstance = i[m];
                  }
                  if (u.morphInstance) {
                    const m = this.morphInstances.indexOf(u.morphInstance);
                    _.morphInstance = e[m];
                  }
                  o.push(_);
                }
                const t = new d();
                return (
                  (t.graph = n),
                  (t.meshInstances = o),
                  (t.skinInstances = i),
                  (t.morphInstances = e),
                  t.getGraph().syncHierarchy(),
                  t
                );
              }
              destroy() {
                const f = this.meshInstances;
                for (let s = 0; s < f.length; s++) f[s].destroy();
                this.meshInstances.length = 0;
              }
              generateWireframe() {
                x.F._prepareRenderStyleForArray(this.meshInstances, A.l3);
              }
            }
          },
          6414: (xe, V, a) => {
            "use strict";
            a.d(V, { q: () => s });
            var A = a(1630),
              x = a(8524),
              y = a(9061),
              c = a(333),
              d = a(1268);
            const h = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}
		`,
              f = new d.t(!0, A.KLp, A.qa5, A.qa5);
            class s {
              constructor(n) {
                (this.morph = n),
                  n.incRefCount(),
                  (this.device = n.device),
                  (this._weights = []),
                  (this._weightMap = new Map());
                for (let o = 0; o < n._targets.length; o++) {
                  const i = n._targets[o];
                  i.name && this._weightMap.set(i.name, o),
                    this.setWeight(o, i.defaultWeight);
                }
                if (((this._activeTargets = []), n.useTextureMorph)) {
                  (this.shaderCache = {}),
                    (this.maxSubmitCount = this.device.maxTextures),
                    (this._shaderMorphWeights = new Float32Array(
                      this.maxSubmitCount
                    ));
                  const o = (i, e) => (
                    (this[e] = n._createTexture(i, n._renderTextureFormat)),
                    new y.O({ colorBuffer: this[e], depth: !1 })
                  );
                  n.morphPositions &&
                    (this.rtPositions = o("MorphRTPos", "texturePositions")),
                    n.morphNormals &&
                      (this.rtNormals = o("MorphRTNrm", "textureNormals")),
                    (this._textureParams = new Float32Array([
                      n.morphTextureWidth,
                      n.morphTextureHeight,
                      1 / n.morphTextureWidth,
                      1 / n.morphTextureHeight,
                    ]));
                  for (let i = 0; i < this.maxSubmitCount; i++)
                    this["morphBlendTex" + i] = this.device.scope.resolve(
                      "morphBlendTex" + i
                    );
                  (this.morphFactor =
                    this.device.scope.resolve("morphFactor[0]")),
                    (this.zeroTextures = !1);
                } else
                  (this.maxSubmitCount = 8),
                    (this._shaderMorphWeights = new Float32Array(
                      this.maxSubmitCount
                    )),
                    (this._shaderMorphWeightsA = new Float32Array(
                      this._shaderMorphWeights.buffer,
                      0,
                      4
                    )),
                    (this._shaderMorphWeightsB = new Float32Array(
                      this._shaderMorphWeights.buffer,
                      16,
                      4
                    )),
                    (this._activeVertexBuffers = new Array(
                      this.maxSubmitCount
                    ));
              }
              destroy() {
                this.shader = null;
                const n = this.morph;
                n &&
                  ((this.morph = null),
                  n.decRefCount(),
                  n.refCount < 1 && n.destroy()),
                  this.rtPositions &&
                    (this.rtPositions.destroy(), (this.rtPositions = null)),
                  this.texturePositions &&
                    (this.texturePositions.destroy(),
                    (this.texturePositions = null)),
                  this.rtNormals &&
                    (this.rtNormals.destroy(), (this.rtNormals = null)),
                  this.textureNormals &&
                    (this.textureNormals.destroy(),
                    (this.textureNormals = null));
              }
              clone() {
                return new s(this.morph);
              }
              _getWeightIndex(n) {
                return typeof n == "string" ? this._weightMap.get(n) : n;
              }
              getWeight(n) {
                const o = this._getWeightIndex(n);
                return this._weights[o];
              }
              setWeight(n, o) {
                const i = this._getWeightIndex(n);
                (this._weights[i] = o), (this._dirty = !0);
              }
              _getFragmentShader(n) {
                let o = "";
                n > 0 &&
                  (o +=
                    `varying vec2 uv0;
uniform highp float morphFactor[` +
                    n +
                    `];
`);
                for (let i = 0; i < n; i++)
                  o +=
                    "uniform highp sampler2D morphBlendTex" +
                    i +
                    `;
`;
                o += `void main (void) {
    highp vec4 color = vec4(0, 0, 0, 1);
`;
                for (let i = 0; i < n; i++)
                  o +=
                    "    color.xyz += morphFactor[" +
                    i +
                    "] * texture2D(morphBlendTex" +
                    i +
                    `, uv0).xyz;
`;
                return (
                  (o += `    gl_FragColor = color;
}
`),
                  o
                );
              }
              _getShader(n) {
                let o = this.shaderCache[n];
                if (!o) {
                  const i = this._getFragmentShader(n);
                  (o = (0, c.$$)(this.device, h, i, "textureMorph" + n)),
                    (this.shaderCache[n] = o);
                }
                return o;
              }
              _updateTextureRenderTarget(n, o) {
                const i = this.device,
                  e = (v, _) => {
                    this.morphFactor.setValue(this._shaderMorphWeights),
                      i.setBlendState(_ ? f : d.t.NOBLEND);
                    const m = this._getShader(v);
                    (0, x.l)(i, n, m);
                  };
                let t = 0,
                  r = !1;
                const u = this._activeTargets.length;
                for (let v = 0; v < u; v++) {
                  const _ = this._activeTargets[v],
                    m = _.target[o];
                  m &&
                    (this["morphBlendTex" + t].setValue(m),
                    (this._shaderMorphWeights[t] = _.weight),
                    t++,
                    t >= this.maxSubmitCount && (e(t, r), (t = 0), (r = !0)));
                }
                (t > 0 || (u === 0 && !this.zeroTextures)) && e(t, r);
              }
              _updateTextureMorph() {
                this.device,
                  (this._activeTargets.length > 0 || !this.zeroTextures) &&
                    (this.rtPositions &&
                      this._updateTextureRenderTarget(
                        this.rtPositions,
                        "texturePositions"
                      ),
                    this.rtNormals &&
                      this._updateTextureRenderTarget(
                        this.rtNormals,
                        "textureNormals"
                      ),
                    (this.zeroTextures = this._activeTargets.length === 0));
              }
              _updateVertexMorph() {
                const n = this.maxSubmitCount;
                for (let e = 0; e < n; e++)
                  (this._shaderMorphWeights[e] = 0),
                    (this._activeVertexBuffers[e] = null);
                let o = 0,
                  i = this.morph.morphPositions ? 4 : 0;
                for (let e = 0; e < this._activeTargets.length; e++) {
                  const t = this._activeTargets[e].target;
                  t._vertexBufferPositions &&
                    ((this._activeVertexBuffers[o] = t._vertexBufferPositions),
                    (this._shaderMorphWeights[o] =
                      this._activeTargets[e].weight),
                    o++),
                    t._vertexBufferNormals &&
                      ((this._activeVertexBuffers[i] = t._vertexBufferNormals),
                      (this._shaderMorphWeights[i] =
                        this._activeTargets[e].weight),
                      i++);
                }
              }
              update() {
                this._dirty = !1;
                const n = this.morph._targets;
                let o = 0;
                const i = 1e-5;
                for (let t = 0; t < n.length; t++) {
                  const r = Math.abs(this.getWeight(t));
                  if (r > i) {
                    this._activeTargets.length <= o &&
                      (this._activeTargets[o] = {});
                    const u = this._activeTargets[o++];
                    (u.absWeight = r),
                      (u.weight = this.getWeight(t)),
                      (u.target = n[t]);
                  }
                }
                this._activeTargets.length = o;
                const e = this.morph.maxActiveTargets;
                this._activeTargets.length > e &&
                  (this._activeTargets.sort(function (t, r) {
                    return t.absWeight < r.absWeight
                      ? 1
                      : r.absWeight < t.absWeight
                      ? -1
                      : 0;
                  }),
                  (this._activeTargets.length = e)),
                  this.morph.useTextureMorph
                    ? this._updateTextureMorph()
                    : this._updateVertexMorph();
              }
            }
          },
          1336: (xe, V, a) => {
            "use strict";
            a.d(V, { M: () => d });
            var A = a(7915),
              x = a(1630),
              y = a(5860),
              c = a(6089);
            class d {
              constructor(f) {
                (this.used = !1),
                  arguments.length === 2 && (f = arguments[1]),
                  (this.options = f),
                  (this._name = f.name),
                  (this._defaultWeight = f.defaultWeight || 0),
                  (this._aabb = f.aabb),
                  (this.deltaPositions = f.deltaPositions);
              }
              destroy() {
                var f, s, l, n;
                (f = this._vertexBufferPositions) == null || f.destroy(),
                  (this._vertexBufferPositions = null),
                  (s = this._vertexBufferNormals) == null || s.destroy(),
                  (this._vertexBufferNormals = null),
                  (l = this.texturePositions) == null || l.destroy(),
                  (this.texturePositions = null),
                  (n = this.textureNormals) == null || n.destroy(),
                  (this.textureNormals = null);
              }
              get name() {
                return this._name;
              }
              get defaultWeight() {
                return this._defaultWeight;
              }
              get aabb() {
                return (
                  this._aabb ||
                    ((this._aabb = new A.I()),
                    this.deltaPositions &&
                      this._aabb.compute(this.deltaPositions)),
                  this._aabb
                );
              }
              get morphPositions() {
                return !!this._vertexBufferPositions || !!this.texturePositions;
              }
              get morphNormals() {
                return !!this._vertexBufferNormals || !!this.textureNormals;
              }
              clone() {
                return new d(this.options);
              }
              _postInit() {
                this.options.preserveData || (this.options = null),
                  (this.used = !0);
              }
              _initVertexBuffers(f) {
                const s = this.options;
                (this._vertexBufferPositions = this._createVertexBuffer(
                  f,
                  s.deltaPositions,
                  s.deltaPositionsType
                )),
                  (this._vertexBufferNormals = this._createVertexBuffer(
                    f,
                    s.deltaNormals,
                    s.deltaNormalsType
                  )),
                  this._vertexBufferPositions &&
                    (this.deltaPositions = this._vertexBufferPositions.lock());
              }
              _createVertexBuffer(f, s, l = x.n$B) {
                if (s) {
                  const n = [{ semantic: x.NFm, components: 3, type: l }];
                  return new y.R(f, new c.y(f, n), s.length / 3, x.y1K, s);
                }
                return null;
              }
              _setTexture(f, s) {
                this[f] = s;
              }
            }
          },
          528: (xe, V, a) => {
            "use strict";
            a.d(V, { T: () => n });
            var A = a(4460),
              x = a(7481),
              y = a(3064),
              c = a(7915),
              d = a(1208),
              h = a(5860),
              f = a(6089),
              s = a(1630),
              l = a(8136);
            class n extends A.p {
              constructor(i, e, { preferHighPrecision: t = !1 } = {}) {
                super(),
                  (this._aabb = void 0),
                  (this.preferHighPrecision = void 0),
                  (this.device = e || l.A.get()),
                  (this.preferHighPrecision = t),
                  (this._targets = i.slice());
                const r = this.device;
                if (r.supportsMorphTargetTexturesCore) {
                  const u =
                      r.extTextureHalfFloat && r.textureHalfFloatRenderable
                        ? s.WBN
                        : void 0,
                    v =
                      r.extTextureFloat && r.textureFloatRenderable
                        ? s.s7h
                        : void 0;
                  this._renderTextureFormat = this.preferHighPrecision
                    ? v != null
                      ? v
                      : u
                    : u != null
                    ? u
                    : v;
                  const _ =
                      r.extTextureHalfFloat && r.textureHalfFloatUpdatable
                        ? s.WBN
                        : void 0,
                    m = r.extTextureFloat ? s.FQW : void 0;
                  (this._textureFormat = this.preferHighPrecision
                    ? m != null
                      ? m
                      : _
                    : _ != null
                    ? _
                    : m),
                    this._renderTextureFormat !== void 0 &&
                      this._textureFormat !== void 0 &&
                      (this._useTextureMorph = !0);
                }
                this._init(), this._updateMorphFlags();
              }
              get aabb() {
                if (!this._aabb) {
                  const i = new x.e(),
                    e = new x.e();
                  for (let t = 0; t < this._targets.length; t++) {
                    const r = this._targets[t].aabb;
                    i.min(r.getMin()), e.max(r.getMax());
                  }
                  (this._aabb = new c.I()), this._aabb.setMinMax(i, e);
                }
                return this._aabb;
              }
              get morphPositions() {
                return this._morphPositions;
              }
              get morphNormals() {
                return this._morphNormals;
              }
              get maxActiveTargets() {
                return this._useTextureMorph
                  ? this._targets.length
                  : this._morphPositions && this._morphNormals
                  ? 4
                  : 8;
              }
              get useTextureMorph() {
                return this._useTextureMorph;
              }
              _init() {
                if (
                  (this._useTextureMorph &&
                    (this._useTextureMorph = this._initTextureBased()),
                  !this._useTextureMorph)
                )
                  for (let i = 0; i < this._targets.length; i++)
                    this._targets[i]._initVertexBuffers(this.device);
                for (let i = 0; i < this._targets.length; i++)
                  this._targets[i]._postInit();
              }
              _findSparseSet(i, e, t, r) {
                let u = 1;
                const v = i[0].length;
                for (let _ = 0; _ < v; _ += 3) {
                  let m = !1;
                  for (let g = 0; g < i.length; g++) {
                    const T = i[g];
                    if (T[_] !== 0 || T[_ + 1] !== 0 || T[_ + 2] !== 0) {
                      m = !0;
                      break;
                    }
                  }
                  m ? (e.push(u + r), t.push(_ / 3), u++) : e.push(0 + r);
                }
                return u;
              }
              _initTextureBased() {
                const i = this.device.isWebGPU,
                  e = i ? 0 : 0.2,
                  t = [],
                  r = [];
                for (let b = 0; b < this._targets.length; b++) {
                  const D = this._targets[b];
                  D.options.deltaPositions &&
                    (t.push(D.options.deltaPositions),
                    r.push({ target: D, name: "texturePositions" })),
                    D.options.deltaNormals &&
                      (t.push(D.options.deltaNormals),
                      r.push({ target: D, name: "textureNormals" }));
                }
                const u = [],
                  v = [],
                  _ = this._findSparseSet(t, u, v, e),
                  m = Math.min(this.device.maxTextureSize, 4096);
                let g = Math.ceil(Math.sqrt(_));
                g = Math.min(g, m);
                const T = Math.ceil(_ / g);
                if (T > m) return !1;
                (this.morphTextureWidth = g), (this.morphTextureHeight = T);
                let E = !1,
                  M = 3;
                const R = y.A.float2Half;
                this._textureFormat === s.WBN && ((E = !0), (M = 4));
                const P = [];
                for (let b = 0; b < t.length; b++)
                  P.push(
                    this._createTexture("MorphTarget", this._textureFormat)
                  );
                for (let b = 0; b < t.length; b++) {
                  const D = t[b],
                    G = P[b],
                    X = G.lock();
                  if (E)
                    for (let Q = 0; Q < v.length; Q++) {
                      const te = v[Q] * 3,
                        ae = Q * M + M;
                      (X[ae] = R(D[te])),
                        (X[ae + 1] = R(D[te + 1])),
                        (X[ae + 2] = R(D[te + 2]));
                    }
                  else
                    for (let Q = 0; Q < v.length; Q++) {
                      const te = v[Q] * 3,
                        ae = Q * M + M;
                      (X[ae] = D[te]),
                        (X[ae + 1] = D[te + 1]),
                        (X[ae + 2] = D[te + 2]);
                    }
                  G.unlock(), r[b].target._setTexture(r[b].name, G);
                }
                const F = [
                  { semantic: s.FHg, components: 1, type: i ? s.Bz3 : s.n$B },
                ];
                return (
                  (this.vertexBufferIds = new h.R(
                    this.device,
                    new f.y(this.device, F, u.length),
                    u.length,
                    s.y1K,
                    i ? new Uint32Array(u) : new Float32Array(u)
                  )),
                  !0
                );
              }
              destroy() {
                var i;
                (i = this.vertexBufferIds) == null || i.destroy(),
                  (this.vertexBufferIds = null);
                for (let e = 0; e < this._targets.length; e++)
                  this._targets[e].destroy();
                this._targets.length = 0;
              }
              get targets() {
                return this._targets;
              }
              _updateMorphFlags() {
                (this._morphPositions = !1), (this._morphNormals = !1);
                for (let i = 0; i < this._targets.length; i++) {
                  const e = this._targets[i];
                  e.morphPositions && (this._morphPositions = !0),
                    e.morphNormals && (this._morphNormals = !0);
                }
              }
              _createTexture(i, e) {
                return new d.g(this.device, {
                  width: this.morphTextureWidth,
                  height: this.morphTextureHeight,
                  format: e,
                  cubemap: !1,
                  mipmaps: !1,
                  minFilter: s.uhC,
                  magFilter: s.uhC,
                  addressU: s.vq6,
                  addressV: s.vq6,
                  name: i,
                });
              }
            }
          },
          2863: (xe, V, a) => {
            "use strict";
            a.d(V, { v: () => Xt });
            var A = a(5567),
              x = a(2358),
              y = a(8484),
              c = a(8656),
              d = a(3021),
              h = a(7481),
              f = a(7915),
              s = a(1630),
              l = a(5950),
              n = a(970),
              o = a(9061),
              i = a(1208),
              e = a(5860),
              t = a(6089),
              r = a(8568),
              u = a(9391),
              v = a(7197),
              _ = a(3637),
              m = a(2658),
              g = a(783),
              T = a(333),
              E = a(2910),
              M = a(9855),
              R = a(4559);
            const P = {
              generateKey: function (yt) {
                let Pe = "particle";
                for (const $e in yt) yt.hasOwnProperty($e) && (Pe += yt[$e]);
                return Pe;
              },
              _animTex: function (yt) {
                let Pe = "";
                return (
                  (Pe += yt.animTexLoop
                    ? E.G.particleAnimFrameLoopVS
                    : E.G.particleAnimFrameClampVS),
                  (Pe += E.G.particleAnimTexVS),
                  Pe
                );
              },
              createShaderDefinition: function (yt, Pe) {
                const $e = `#define PARTICLE_${Pe.useCpu ? "CPU" : "GPU"}
`;
                let Je =
                    `#define PARTICLE
` + $e,
                  rt =
                    `#define VERTEXSHADER
` + $e;
                Pe.mesh &&
                  (rt += `#define USE_MESH
`),
                  Pe.localSpace &&
                    (rt += `#define LOCAL_SPACE
`),
                  Pe.screenSpace &&
                    (rt += `#define SCREEN_SPACE
`),
                  Pe.animTex &&
                    (rt += `
uniform vec2 animTexTilesParams;
`),
                  Pe.animTex &&
                    (rt += `
uniform vec4 animTexParams;
`),
                  Pe.animTex &&
                    (rt += `
uniform vec2 animTexIndexParams;
`),
                  Pe.normal === 2 &&
                    (rt += `
varying mat3 ParticleMat;
`),
                  Pe.normal === 1 &&
                    (rt += `
varying vec3 Normal;
`),
                  Pe.soft &&
                    (rt += `
varying float vDepth;
`);
                const ct = Pe.customFace
                  ? E.G.particle_customFaceVS
                  : E.G.particle_billboardVS;
                return (
                  Pe.useCpu
                    ? (Pe.soft > 0 && (rt += E.G.screenDepthPS),
                      (rt += E.G.particle_cpuVS),
                      Pe.localSpace && (rt += E.G.particle_localShiftVS),
                      Pe.animTex && (rt += this._animTex(Pe)),
                      Pe.alignToMotion && (rt += E.G.particle_pointAlongVS),
                      (rt += Pe.mesh ? E.G.particle_meshVS : ct),
                      Pe.normal === 1 && (rt += E.G.particle_normalVS),
                      Pe.normal === 2 && (rt += E.G.particle_TBNVS),
                      Pe.stretch > 0 && (rt += E.G.particle_stretchVS),
                      (rt += E.G.particle_cpu_endVS),
                      Pe.soft > 0 && (rt += E.G.particle_softVS))
                    : ((rt += E.G.particle_initVS),
                      (rt += Pe.pack8
                        ? E.G.particleInputRgba8PS
                        : E.G.particleInputFloatPS),
                      Pe.soft > 0 && (rt += E.G.screenDepthPS),
                      (rt += E.G.particleVS),
                      Pe.localSpace && (rt += E.G.particle_localShiftVS),
                      Pe.animTex && (rt += this._animTex(Pe)),
                      Pe.wrap && (rt += E.G.particle_wrapVS),
                      Pe.alignToMotion && (rt += E.G.particle_pointAlongVS),
                      (rt += Pe.mesh ? E.G.particle_meshVS : ct),
                      Pe.normal === 1 && (rt += E.G.particle_normalVS),
                      Pe.normal === 2 && (rt += E.G.particle_TBNVS),
                      Pe.stretch > 0 && (rt += E.G.particle_stretchVS),
                      (rt += E.G.particle_endVS),
                      Pe.soft > 0 && (rt += E.G.particle_softVS)),
                  (rt += `}
`),
                  Pe.normal > 0 &&
                    (Pe.normal === 1
                      ? (Je += `
varying vec3 Normal;
`)
                      : Pe.normal === 2 &&
                        (Je += `
varying mat3 ParticleMat;
`),
                    (Je += `
uniform vec3 lightCube[6];
`)),
                  Pe.soft &&
                    (Je += `
varying float vDepth;
`),
                  Pe.normal === 0 && Pe.fog === "none" && (Pe.srgb = !1),
                  (Je += E.G.decodePS),
                  (Je += (0, R.PY)(Pe.gamma)),
                  (Je += (0, R.K)(Pe.toneMap)),
                  Pe.fog === "linear"
                    ? (Je += E.G.fogLinearPS)
                    : Pe.fog === "exp"
                    ? (Je += E.G.fogExpPS)
                    : Pe.fog === "exp2"
                    ? (Je += E.G.fogExp2PS)
                    : (Je += E.G.fogNonePS),
                  Pe.normal === 2 &&
                    (Je += `
uniform sampler2D normalMap;
`),
                  Pe.soft > 0 && (Je += E.G.screenDepthPS),
                  (Je += E.G.particlePS),
                  Pe.soft > 0 && (Je += E.G.particle_softPS),
                  Pe.normal === 1 &&
                    (Je += `
vec3 normal = Normal;
`),
                  Pe.normal === 2 && (Je += E.G.particle_normalMapPS),
                  Pe.normal > 0 &&
                    (Je += Pe.halflambert
                      ? E.G.particle_halflambertPS
                      : E.G.particle_lambertPS),
                  Pe.normal > 0 && (Je += E.G.particle_lightingPS),
                  Pe.blend === u.i9
                    ? (Je += E.G.particle_blendNormalPS)
                    : Pe.blend === u.dc
                    ? (Je += E.G.particle_blendAddPS)
                    : Pe.blend === u.$M && (Je += E.G.particle_blendMultiplyPS),
                  (Je += E.G.particle_endPS),
                  M.l.createDefinition(yt, {
                    name: "ParticleShader",
                    vertexCode: rt,
                    fragmentCode: Je,
                  })
                );
              },
            };
            let F,
              b = 1;
            const D = 4,
              G = new y.$(),
              X = new y.$(),
              ie = new h.e(),
              Q = new h.e(),
              te = new h.e(),
              ae = new h.e(),
              Z = new h.e(),
              J = new h.e(),
              ve = new h.e(),
              _e = new h.e(),
              L = new h.e(),
              ge = new h.e(),
              k = new h.e(),
              j = new h.e(),
              B = new h.e();
            function $(yt) {
              return yt - Math.floor(yt);
            }
            function le(yt) {
              return Math.max(Math.min(yt, 1), 0);
            }
            function O(yt, Pe) {
              return yt - Pe * Math.floor(yt / Pe);
            }
            function Y(yt) {
              let Pe = $(yt),
                $e = $(255 * yt),
                Je = $(65025 * yt),
                rt = $(160581375 * yt);
              return (
                (Pe -= $e / 255),
                ($e -= Je / 255),
                (Je -= rt / 255),
                (rt -= rt / 255),
                [Pe, $e, Je, rt]
              );
            }
            function ne(yt) {
              let Pe = $(yt),
                $e = $(255 * yt);
              return (Pe -= $e / 255), ($e -= $e / 255), [Pe, $e];
            }
            class de {
              constructor(Pe) {
                this._emitter = Pe;
              }
              calcSpawnPosition(Pe, $e, Je, rt, ct) {
                const Ve = this._emitter,
                  wt = Math.random(),
                  at = Math.random(),
                  ce = Math.random(),
                  pe = Math.random();
                if (
                  (Ve.useCpu &&
                    ((Pe[ct * D + 0 + Ve.numParticlesPot * 2 * D] = wt),
                    (Pe[ct * D + 1 + Ve.numParticlesPot * 2 * D] = at),
                    (Pe[ct * D + 2 + Ve.numParticlesPot * 2 * D] = ce)),
                  (Q.x = wt - 0.5),
                  (Q.y = at - 0.5),
                  (Q.z = ce - 0.5),
                  Ve.emitterShape === u.Ql)
                ) {
                  const Ze = Math.max(
                      Math.abs(Q.x),
                      Math.max(Math.abs(Q.y), Math.abs(Q.z))
                    ),
                    Ne = Ze + (0.5 - Ze) * Je[0],
                    Ye = Ze + (0.5 - Ze) * Je[1],
                    Ke = Ze + (0.5 - Ze) * Je[2];
                  (Q.x =
                    Ne * (Ze === Math.abs(Q.x) ? Math.sign(Q.x) : 2 * Q.x)),
                    (Q.y =
                      Ye * (Ze === Math.abs(Q.y) ? Math.sign(Q.y) : 2 * Q.y)),
                    (Q.z =
                      Ke * (Ze === Math.abs(Q.z) ? Math.sign(Q.z) : 2 * Q.z)),
                    Ve.localSpace
                      ? ie.copy($e.transformPoint(Q))
                      : ie.copy(rt).add($e.transformPoint(Q));
                } else {
                  Q.normalize();
                  const Ze =
                      Ve.emitterRadius === 0
                        ? 0
                        : Ve.emitterRadiusInner / Ve.emitterRadius,
                    Ne = pe * (1 - Ze) + Ze;
                  Ve.localSpace
                    ? ie.copy(Q.mulScalar(Ne * Ve.emitterRadius))
                    : ie.copy(rt).add(Q.mulScalar(Ne * Ve.emitterRadius));
                }
                let fe = -c.D.lerp(Ve.rate, Ve.rate2, wt) * ct;
                if (Ve.pack8) {
                  const Ze =
                      (ie.x - Ve.worldBounds.center.x) / Ve.worldBoundsSize.x +
                      0.5,
                    Ne =
                      (ie.y - Ve.worldBounds.center.y) / Ve.worldBoundsSize.y +
                      0.5,
                    Ye =
                      (ie.z - Ve.worldBounds.center.z) / Ve.worldBoundsSize.z +
                      0.5;
                  let Ke = c.D.lerp(
                    Ve.startAngle * c.D.DEG_TO_RAD,
                    Ve.startAngle2 * c.D.DEG_TO_RAD,
                    wt
                  );
                  Ke = (Ke % (Math.PI * 2)) / (Math.PI * 2);
                  const nt = ne(Ze);
                  (Pe[ct * D] = nt[0]), (Pe[ct * D + 1] = nt[1]);
                  const ot = ne(Ne);
                  (Pe[ct * D + 2] = ot[0]), (Pe[ct * D + 3] = ot[1]);
                  const ze = ne(Ye);
                  (Pe[ct * D + 0 + Ve.numParticlesPot * D] = ze[0]),
                    (Pe[ct * D + 1 + Ve.numParticlesPot * D] = ze[1]);
                  const et = ne(Ke);
                  (Pe[ct * D + 2 + Ve.numParticlesPot * D] = et[0]),
                    (Pe[ct * D + 3 + Ve.numParticlesPot * D] = et[1]);
                  const _t = 1;
                  Pe[ct * D + 3 + Ve.numParticlesPot * D * 2] = _t;
                  const Qe = Math.max(
                      Ve.lifetime,
                      (Ve.numParticles - 1) * Math.max(Ve.rate, Ve.rate2)
                    ),
                    lt = Ve.lifetime + 1;
                  fe = (fe + Qe) / (Qe + lt);
                  const xt = Y(fe);
                  (Pe[ct * D + 0 + Ve.numParticlesPot * D * 3] = xt[0]),
                    (Pe[ct * D + 1 + Ve.numParticlesPot * D * 3] = xt[1]),
                    (Pe[ct * D + 2 + Ve.numParticlesPot * D * 3] = xt[2]),
                    (Pe[ct * D + 3 + Ve.numParticlesPot * D * 3] = xt[3]);
                } else
                  (Pe[ct * D] = ie.x),
                    (Pe[ct * D + 1] = ie.y),
                    (Pe[ct * D + 2] = ie.z),
                    (Pe[ct * D + 3] = c.D.lerp(
                      Ve.startAngle * c.D.DEG_TO_RAD,
                      Ve.startAngle2 * c.D.DEG_TO_RAD,
                      wt
                    )),
                    (Pe[ct * D + 3 + Ve.numParticlesPot * D] = fe);
              }
              update(Pe, $e, Je, rt, ct, Ve, wt, at) {
                let ce, pe, De;
                const fe = this._emitter;
                if (fe.meshInstance.node) {
                  const Tt = fe.meshInstance.node.worldTransform;
                  for (let ft = 0; ft < 12; ft++) G.data[ft] = Tt.data[ft];
                  X.copy(G),
                    X.invert(),
                    (F = fe.meshInstance.node.localScale),
                    (b = Math.max(Math.max(F.x, F.y), F.z));
                }
                Ve =
                  fe.meshInstance.node === null || fe.localSpace
                    ? h.e.ZERO
                    : fe.meshInstance.node.getPosition();
                const Ze = fe.camera ? fe.camera._node.getPosition() : h.e.ZERO,
                  Ne = fe.useMesh ? 17 : 15;
                let Ye, Ke, nt, ot, ze, et, _t, Qe, lt;
                const xt = fe.precision - 1;
                for (let Tt = 0; Tt < fe.numParticles; Tt++) {
                  const ft = Math.floor(
                      fe.vbCPU[
                        Tt * fe.numParticleVerts * (fe.useMesh ? 6 : 4) + 3
                      ]
                    ),
                    gt = Je[ft * D + 0 + fe.numParticlesPot * 2 * D];
                  (te.x = gt),
                    (te.y = Je[ft * D + 1 + fe.numParticlesPot * 2 * D]),
                    (te.z = Je[ft * D + 2 + fe.numParticlesPot * 2 * D]);
                  const Fe = fe.rate + (fe.rate2 - fe.rate) * gt,
                    Qt = fe.lifetime;
                  let zt = Je[ft * D + 3 + fe.numParticlesPot * D] + wt;
                  const Lt = le(zt / Qt);
                  let $t = 0,
                    Bt = 0;
                  const Nt = 0;
                  (zt - wt <= 0 || zt >= Qt) &&
                    this.calcSpawnPosition(Je, rt, ct, Ve, ft);
                  let kt = zt > 0 && zt < Qt;
                  kt &&
                    ((De = Lt * xt),
                    (Ye = Math.floor(De)),
                    (Ke = Math.ceil(De)),
                    (De %= 1),
                    (ce = fe.qRotSpeed[Ye]),
                    (pe = fe.qRotSpeed[Ke]),
                    (nt = ce + (pe - ce) * De),
                    (ce = fe.qRotSpeed2[Ye]),
                    (pe = fe.qRotSpeed2[Ke]),
                    (ot = ce + (pe - ce) * De),
                    (ce = fe.qScale[Ye]),
                    (pe = fe.qScale[Ke]),
                    ($t = ce + (pe - ce) * De),
                    (ce = fe.qScale2[Ye]),
                    (pe = fe.qScale2[Ke]),
                    (ze = ce + (pe - ce) * De),
                    (ce = fe.qAlpha[Ye]),
                    (pe = fe.qAlpha[Ke]),
                    (et = ce + (pe - ce) * De),
                    (ce = fe.qAlpha2[Ye]),
                    (pe = fe.qAlpha2[Ke]),
                    (_t = ce + (pe - ce) * De),
                    (ce = fe.qRadialSpeed[Ye]),
                    (pe = fe.qRadialSpeed[Ke]),
                    (Qe = ce + (pe - ce) * De),
                    (ce = fe.qRadialSpeed2[Ye]),
                    (pe = fe.qRadialSpeed2[Ke]),
                    (lt = ce + (pe - ce) * De),
                    (Qe += (lt - Qe) * ((gt * 100) % 1)),
                    (ae.x = Je[ft * D]),
                    (ae.y = Je[ft * D + 1]),
                    (ae.z = Je[ft * D + 2]),
                    fe.localSpace ? L.copy(ae) : L.copy(ae).sub(Ve),
                    L.normalize().mulScalar(Qe),
                    (Ye *= 3),
                    (Ke *= 3),
                    (ce = fe.qLocalVelocity[Ye]),
                    (pe = fe.qLocalVelocity[Ke]),
                    (J.x = ce + (pe - ce) * De),
                    (ce = fe.qLocalVelocity[Ye + 1]),
                    (pe = fe.qLocalVelocity[Ke + 1]),
                    (J.y = ce + (pe - ce) * De),
                    (ce = fe.qLocalVelocity[Ye + 2]),
                    (pe = fe.qLocalVelocity[Ke + 2]),
                    (J.z = ce + (pe - ce) * De),
                    (ce = fe.qLocalVelocity2[Ye]),
                    (pe = fe.qLocalVelocity2[Ke]),
                    (_e.x = ce + (pe - ce) * De),
                    (ce = fe.qLocalVelocity2[Ye + 1]),
                    (pe = fe.qLocalVelocity2[Ke + 1]),
                    (_e.y = ce + (pe - ce) * De),
                    (ce = fe.qLocalVelocity2[Ye + 2]),
                    (pe = fe.qLocalVelocity2[Ke + 2]),
                    (_e.z = ce + (pe - ce) * De),
                    (ce = fe.qVelocity[Ye]),
                    (pe = fe.qVelocity[Ke]),
                    (Z.x = ce + (pe - ce) * De),
                    (ce = fe.qVelocity[Ye + 1]),
                    (pe = fe.qVelocity[Ke + 1]),
                    (Z.y = ce + (pe - ce) * De),
                    (ce = fe.qVelocity[Ye + 2]),
                    (pe = fe.qVelocity[Ke + 2]),
                    (Z.z = ce + (pe - ce) * De),
                    (ce = fe.qVelocity2[Ye]),
                    (pe = fe.qVelocity2[Ke]),
                    (ve.x = ce + (pe - ce) * De),
                    (ce = fe.qVelocity2[Ye + 1]),
                    (pe = fe.qVelocity2[Ke + 1]),
                    (ve.y = ce + (pe - ce) * De),
                    (ce = fe.qVelocity2[Ye + 2]),
                    (pe = fe.qVelocity2[Ke + 2]),
                    (ve.z = ce + (pe - ce) * De),
                    (J.x += (_e.x - J.x) * te.x),
                    (J.y += (_e.y - J.y) * te.y),
                    (J.z += (_e.z - J.z) * te.z),
                    fe.initialVelocity > 0 &&
                      (fe.emitterShape === u.M2
                        ? (Q.copy(te).mulScalar(2).sub(h.e.ONE).normalize(),
                          J.add(Q.mulScalar(fe.initialVelocity)))
                        : J.add(h.e.FORWARD.mulScalar(fe.initialVelocity))),
                    (Z.x += (ve.x - Z.x) * te.x),
                    (Z.y += (ve.y - Z.y) * te.y),
                    (Z.z += (ve.z - Z.z) * te.z),
                    (nt += (ot - nt) * te.y),
                    ($t = ($t + (ze - $t) * ((gt * 1e4) % 1)) * b),
                    (Bt = (_t - et) * ((gt * 1e3) % 1)),
                    fe.meshInstance.node &&
                      (fe.localSpace
                        ? ((J.x /= F.x), (J.y /= F.y), (J.z /= F.z))
                        : G.transformPoint(J, J)),
                    fe.localSpace
                      ? (X.transformPoint(Z, Z), J.add(Z).add(L))
                      : (J.add(Z.mul(F)), J.add(L.mul(F))),
                    j.copy(J),
                    ge.copy(ae).add(J.mulScalar(wt)),
                    k.copy(ge),
                    (Je[ft * D] = k.x),
                    (Je[ft * D + 1] = k.y),
                    (Je[ft * D + 2] = k.z),
                    (Je[ft * D + 3] += nt * wt),
                    fe.wrap &&
                      fe.wrapBounds &&
                      (fe.localSpace || k.sub(Ve),
                      (k.x = O(k.x, fe.wrapBounds.x) - fe.wrapBounds.x * 0.5),
                      (k.y = O(k.y, fe.wrapBounds.y) - fe.wrapBounds.y * 0.5),
                      (k.z = O(k.z, fe.wrapBounds.z) - fe.wrapBounds.z * 0.5),
                      fe.localSpace || k.add(Ve)),
                    fe.sort > 0 &&
                      (fe.sort === 1
                        ? (B.copy(k).sub(Ze),
                          (fe.particleDistance[ft] = -(
                            B.x * B.x +
                            B.y * B.y +
                            B.z * B.z
                          )))
                        : fe.sort === 2
                        ? (fe.particleDistance[ft] = zt)
                        : fe.sort === 3 && (fe.particleDistance[ft] = -zt))),
                    at
                      ? zt < 0 &&
                        (Je[ft * D + 3 + fe.numParticlesPot * 2 * D] = -1)
                      : (zt >= Qt &&
                          ((zt -= Math.max(Qt, (fe.numParticles - 1) * Fe)),
                          (Je[ft * D + 3 + fe.numParticlesPot * 2 * D] = fe.loop
                            ? 1
                            : -1)),
                        zt < 0 &&
                          fe.loop &&
                          (Je[ft * D + 3 + fe.numParticlesPot * 2 * D] = 1)),
                    Je[ft * D + 3 + fe.numParticlesPot * 2 * D] < 0 &&
                      (kt = !1),
                    (Je[ft * D + 3 + fe.numParticlesPot * D] = zt);
                  for (let ds = 0; ds < fe.numParticleVerts; ds++) {
                    const os =
                      (Tt * fe.numParticleVerts + ds) * (fe.useMesh ? 6 : 4);
                    let ls = fe.vbCPU[os],
                      Ps = fe.vbCPU[os + 1],
                      us = fe.vbCPU[os + 2];
                    kt || (ls = Ps = us = 0);
                    const Xe = Tt * fe.numParticleVerts * Ne + ds * Ne;
                    (Pe[Xe] = k.x),
                      (Pe[Xe + 1] = k.y),
                      (Pe[Xe + 2] = k.z),
                      (Pe[Xe + 3] = Lt),
                      (Pe[Xe + 4] = fe.alignToMotion ? Nt : Je[ft * D + 3]),
                      (Pe[Xe + 5] = $t),
                      (Pe[Xe + 6] = Bt),
                      (Pe[Xe + 7] = j.x),
                      (Pe[Xe + 8] = ls),
                      (Pe[Xe + 9] = Ps),
                      (Pe[Xe + 10] = us),
                      (Pe[Xe + 11] = j.y),
                      (Pe[Xe + 12] = ft),
                      (Pe[Xe + 13] = j.z),
                      (Pe[Xe + 14] = fe.vbCPU[os + 3]),
                      fe.useMesh &&
                        ((Pe[Xe + 15] = fe.vbCPU[os + 4]),
                        (Pe[Xe + 16] = fe.vbCPU[os + 5]));
                  }
                }
                if (fe.sort > u.WL && fe.camera) {
                  const Tt = fe.useMesh ? 6 : 4,
                    ft = fe.particleDistance;
                  for (let gt = 0; gt < fe.numParticles; gt++)
                    ($e[gt][0] = gt),
                      ($e[gt][1] =
                        ft[
                          Math.floor(
                            fe.vbCPU[gt * fe.numParticleVerts * Tt + 3]
                          )
                        ]);
                  fe.vbOld.set(fe.vbCPU),
                    $e.sort(function (gt, Fe) {
                      return gt[1] - Fe[1];
                    });
                  for (let gt = 0; gt < fe.numParticles; gt++) {
                    const Fe = $e[gt][0] * fe.numParticleVerts * Tt,
                      Qt = gt * fe.numParticleVerts * Tt;
                    for (let zt = 0; zt < fe.numParticleVerts * Tt; zt++)
                      fe.vbCPU[Qt + zt] = fe.vbOld[Fe + zt];
                  }
                }
              }
            }
            var re = a(2209),
              I = a(1268),
              w = a(4870),
              N = a(8524);
            const W = new re.U(),
              he = new re.U(),
              ue = new re.U();
            class ye {
              constructor(Pe, $e) {
                (this._emitter = Pe),
                  (this.frameRandomUniform = new Float32Array(3)),
                  (this.emitterPosUniform = new Float32Array(3)),
                  (this.emitterScaleUniform = new Float32Array([1, 1, 1])),
                  (this.worldBoundsMulUniform = new Float32Array(3)),
                  (this.worldBoundsAddUniform = new Float32Array(3)),
                  (this.inBoundsSizeUniform = new Float32Array(3)),
                  (this.inBoundsCenterUniform = new Float32Array(3)),
                  (this.constantParticleTexIN =
                    $e.scope.resolve("particleTexIN")),
                  (this.constantParticleTexOUT =
                    $e.scope.resolve("particleTexOUT")),
                  (this.constantEmitterPos = $e.scope.resolve("emitterPos")),
                  (this.constantEmitterScale =
                    $e.scope.resolve("emitterScale")),
                  (this.constantSpawnBounds = $e.scope.resolve("spawnBounds")),
                  (this.constantSpawnPosInnerRatio =
                    $e.scope.resolve("spawnPosInnerRatio")),
                  (this.constantSpawnBoundsSphere =
                    $e.scope.resolve("spawnBoundsSphere")),
                  (this.constantSpawnBoundsSphereInnerRatio = $e.scope.resolve(
                    "spawnBoundsSphereInnerRatio"
                  )),
                  (this.constantInitialVelocity =
                    $e.scope.resolve("initialVelocity")),
                  (this.constantFrameRandom = $e.scope.resolve("frameRandom")),
                  (this.constantDelta = $e.scope.resolve("delta")),
                  (this.constantRate = $e.scope.resolve("rate")),
                  (this.constantRateDiv = $e.scope.resolve("rateDiv")),
                  (this.constantLifetime = $e.scope.resolve("lifetime")),
                  (this.constantGraphSampleSize =
                    $e.scope.resolve("graphSampleSize")),
                  (this.constantGraphNumSamples =
                    $e.scope.resolve("graphNumSamples")),
                  (this.constantInternalTex0 =
                    $e.scope.resolve("internalTex0")),
                  (this.constantInternalTex1 =
                    $e.scope.resolve("internalTex1")),
                  (this.constantInternalTex2 =
                    $e.scope.resolve("internalTex2")),
                  (this.constantInternalTex3 =
                    $e.scope.resolve("internalTex3")),
                  (this.constantEmitterMatrix =
                    $e.scope.resolve("emitterMatrix")),
                  (this.constantEmitterMatrixInv =
                    $e.scope.resolve("emitterMatrixInv")),
                  (this.constantNumParticles =
                    $e.scope.resolve("numParticles")),
                  (this.constantNumParticlesPot =
                    $e.scope.resolve("numParticlesPot")),
                  (this.constantLocalVelocityDivMult = $e.scope.resolve(
                    "localVelocityDivMult"
                  )),
                  (this.constantVelocityDivMult =
                    $e.scope.resolve("velocityDivMult")),
                  (this.constantRotSpeedDivMult =
                    $e.scope.resolve("rotSpeedDivMult")),
                  (this.constantSeed = $e.scope.resolve("seed")),
                  (this.constantStartAngle = $e.scope.resolve("startAngle")),
                  (this.constantStartAngle2 = $e.scope.resolve("startAngle2")),
                  (this.constantOutBoundsMul =
                    $e.scope.resolve("outBoundsMul")),
                  (this.constantOutBoundsAdd =
                    $e.scope.resolve("outBoundsAdd")),
                  (this.constantInBoundsSize =
                    $e.scope.resolve("inBoundsSize")),
                  (this.constantInBoundsCenter =
                    $e.scope.resolve("inBoundsCenter")),
                  (this.constantMaxVel = $e.scope.resolve("maxVel")),
                  (this.constantFaceTangent = $e.scope.resolve("faceTangent")),
                  (this.constantFaceBinorm = $e.scope.resolve("faceBinorm"));
              }
              _setInputBounds() {
                (this.inBoundsSizeUniform[0] =
                  this._emitter.prevWorldBoundsSize.x),
                  (this.inBoundsSizeUniform[1] =
                    this._emitter.prevWorldBoundsSize.y),
                  (this.inBoundsSizeUniform[2] =
                    this._emitter.prevWorldBoundsSize.z),
                  this.constantInBoundsSize.setValue(this.inBoundsSizeUniform),
                  (this.inBoundsCenterUniform[0] =
                    this._emitter.prevWorldBoundsCenter.x),
                  (this.inBoundsCenterUniform[1] =
                    this._emitter.prevWorldBoundsCenter.y),
                  (this.inBoundsCenterUniform[2] =
                    this._emitter.prevWorldBoundsCenter.z),
                  this.constantInBoundsCenter.setValue(
                    this.inBoundsCenterUniform
                  );
              }
              randomize() {
                (this.frameRandomUniform[0] = Math.random()),
                  (this.frameRandomUniform[1] = Math.random()),
                  (this.frameRandomUniform[2] = Math.random());
              }
              update(Pe, $e, Je, rt, ct) {
                const Ve = this._emitter;
                Pe.setBlendState(I.t.NOBLEND),
                  Pe.setDepthState(w.H.NODEPTH),
                  Pe.setCullMode(s.pLF),
                  this.randomize(),
                  this.constantGraphSampleSize.setValue(1 / Ve.precision),
                  this.constantGraphNumSamples.setValue(Ve.precision),
                  this.constantNumParticles.setValue(Ve.numParticles),
                  this.constantNumParticlesPot.setValue(Ve.numParticlesPot),
                  this.constantInternalTex0.setValue(Ve.internalTex0),
                  this.constantInternalTex1.setValue(Ve.internalTex1),
                  this.constantInternalTex2.setValue(Ve.internalTex2),
                  this.constantInternalTex3.setValue(Ve.internalTex3);
                const wt = Ve.meshInstance.node,
                  at = wt === null ? h.e.ONE : wt.localScale;
                if (Ve.pack8) {
                  (this.worldBoundsMulUniform[0] = Ve.worldBoundsMul.x),
                    (this.worldBoundsMulUniform[1] = Ve.worldBoundsMul.y),
                    (this.worldBoundsMulUniform[2] = Ve.worldBoundsMul.z),
                    this.constantOutBoundsMul.setValue(
                      this.worldBoundsMulUniform
                    ),
                    (this.worldBoundsAddUniform[0] = Ve.worldBoundsAdd.x),
                    (this.worldBoundsAddUniform[1] = Ve.worldBoundsAdd.y),
                    (this.worldBoundsAddUniform[2] = Ve.worldBoundsAdd.z),
                    this.constantOutBoundsAdd.setValue(
                      this.worldBoundsAddUniform
                    ),
                    this._setInputBounds();
                  let Ze = Ve.maxVel * Math.max(Math.max(at.x, at.y), at.z);
                  (Ze = Math.max(Ze, 1)), this.constantMaxVel.setValue(Ze);
                }
                const ce =
                    wt === null || Ve.localSpace ? h.e.ZERO : wt.getPosition(),
                  pe = wt === null ? y.$.IDENTITY : wt.getWorldTransform();
                Ve.emitterShape === u.Ql
                  ? (W.setFromMat4($e),
                    this.constantSpawnBounds.setValue(W.data),
                    this.constantSpawnPosInnerRatio.setValue(Je))
                  : (this.constantSpawnBoundsSphere.setValue(Ve.emitterRadius),
                    this.constantSpawnBoundsSphereInnerRatio.setValue(
                      Ve.emitterRadius === 0
                        ? 0
                        : Ve.emitterRadiusInner / Ve.emitterRadius
                    )),
                  this.constantInitialVelocity.setValue(Ve.initialVelocity),
                  he.setFromMat4(pe),
                  pe.invertTo3x3(ue),
                  (this.emitterPosUniform[0] = ce.x),
                  (this.emitterPosUniform[1] = ce.y),
                  (this.emitterPosUniform[2] = ce.z),
                  this.constantEmitterPos.setValue(this.emitterPosUniform),
                  this.constantFrameRandom.setValue(this.frameRandomUniform),
                  this.constantDelta.setValue(rt),
                  this.constantRate.setValue(Ve.rate),
                  this.constantRateDiv.setValue(Ve.rate2 - Ve.rate),
                  this.constantStartAngle.setValue(
                    Ve.startAngle * c.D.DEG_TO_RAD
                  ),
                  this.constantStartAngle2.setValue(
                    Ve.startAngle2 * c.D.DEG_TO_RAD
                  ),
                  this.constantSeed.setValue(Ve.seed),
                  this.constantLifetime.setValue(Ve.lifetime),
                  (this.emitterScaleUniform[0] = at.x),
                  (this.emitterScaleUniform[1] = at.y),
                  (this.emitterScaleUniform[2] = at.z),
                  this.constantEmitterScale.setValue(this.emitterScaleUniform),
                  this.constantEmitterMatrix.setValue(he.data),
                  this.constantEmitterMatrixInv.setValue(ue.data),
                  this.constantLocalVelocityDivMult.setValue(
                    Ve.localVelocityUMax
                  ),
                  this.constantVelocityDivMult.setValue(Ve.velocityUMax),
                  this.constantRotSpeedDivMult.setValue(Ve.rotSpeedUMax[0]);
                let De = Ve.swapTex ? Ve.particleTexOUT : Ve.particleTexIN;
                De = Ve.beenReset ? Ve.particleTexStart : De;
                const fe = Ve.swapTex ? Ve.particleTexIN : Ve.particleTexOUT;
                this.constantParticleTexIN.setValue(De),
                  (0, N.l)(
                    Pe,
                    Ve.swapTex ? Ve.rtParticleTexIN : Ve.rtParticleTexOUT,
                    ct
                      ? Ve.shaderParticleUpdateOnStop
                      : Ve.loop
                      ? Ve.shaderParticleUpdateRespawn
                      : Ve.shaderParticleUpdateNoRespawn
                  ),
                  Ve.material.setParameter("particleTexOUT", De),
                  Ve.material.setParameter("particleTexIN", fe),
                  (Ve.beenReset = !1),
                  (Ve.swapTex = !Ve.swapTex),
                  Ve.prevWorldBoundsSize.copy(Ve.worldBoundsSize),
                  Ve.prevWorldBoundsCenter.copy(Ve.worldBounds.center),
                  Ve.pack8 && this._setInputBounds();
              }
            }
            const Oe = [
              [-1, -1],
              [1, -1],
              [1, 1],
              [-1, 1],
            ];
            function Ae(yt, Pe, $e, Je, rt = s.s7h, ct, Ve) {
              let wt = s.uhC;
              Ve && rt === s.Lxj && (wt = s.DrA);
              const at = new i.g(yt, {
                  width: Pe,
                  height: $e,
                  format: rt,
                  cubemap: !1,
                  mipmaps: !1,
                  minFilter: wt,
                  magFilter: wt,
                  addressU: s.vq6,
                  addressV: s.vq6,
                  name: "ParticleSystemTexture",
                }),
                ce = at.lock();
              if (rt === s.Lxj) {
                const pe = new Uint8Array(Je.length);
                for (let De = 0; De < Je.length; De++)
                  pe[De] = Je[De] * ct * 255;
                Je = pe;
              }
              return ce.set(Je), at.unlock(), at;
            }
            function ke(yt) {
              return Math.max(Math.min(yt, 1), 0);
            }
            const Ue = new A.I([0, 0, 1, 0]),
              Ge = new A.I([0, 1, 1, 1]),
              ht = new x.K([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]),
              me = new x.K([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
            let z = 2;
            const K = 4,
              Te = new Float32Array(3),
              H = new y.$(),
              q = new h.e(),
              se = new h.e(),
              Ce = new h.e();
            let we, Me;
            function Ie(yt, Pe) {
              Me[yt] !== void 0 && Me[yt] !== null
                ? (we[yt] = Me[yt])
                : (we[yt] = Pe);
            }
            function Le(yt, Pe, $e) {
              return (
                (((yt * 255) << 16) | ((Pe * 255) << 8) | ($e * 255)) / 16777216
              );
            }
            function tt(yt, Pe) {
              const $e = yt.length / 3,
                Je = new Array($e * 4);
              for (let rt = 0; rt < $e; rt++)
                (Je[rt * 4] = yt[rt * 3]),
                  (Je[rt * 4 + 1] = yt[rt * 3 + 1]),
                  (Je[rt * 4 + 2] = yt[rt * 3 + 2]),
                  (Je[rt * 4 + 3] = Le(
                    Pe[rt * 3],
                    Pe[rt * 3 + 1],
                    Pe[rt * 3 + 2]
                  ));
              return Je;
            }
            function vt(yt, Pe) {
              const $e = new Array(Pe.length * 4);
              for (let Je = 0; Je < Pe.length; Je++)
                ($e[Je * 4] = yt[Je * 3]),
                  ($e[Je * 4 + 1] = yt[Je * 3 + 1]),
                  ($e[Je * 4 + 2] = yt[Je * 3 + 2]),
                  ($e[Je * 4 + 3] = Pe[Je]);
              return $e;
            }
            function it(yt, Pe, $e, Je, rt) {
              const ct = new Array(yt.length * 4);
              for (let Ve = 0; Ve < yt.length; Ve++)
                (ct[Ve * 4] = yt[Ve]),
                  (ct[Ve * 4 + 1] = Pe[Ve]),
                  (ct[Ve * 4 + 2] = 0),
                  (ct[Ve * 4 + 3] = Le($e[Ve], Je[Ve], rt[Ve]));
              return ct;
            }
            function At(yt, Pe) {
              const $e = new Array(yt.length * 4);
              for (let Je = 0; Je < yt.length; Je++)
                ($e[Je * 4] = yt[Je]),
                  ($e[Je * 4 + 1] = Pe[Je]),
                  ($e[Je * 4 + 2] = 0),
                  ($e[Je * 4 + 3] = 0);
              return $e;
            }
            function Rt(yt) {
              const Pe =
                Math.max(yt.rate, yt.rate2) * yt.numParticles + yt.lifetime;
              return Date.now() + Pe * 1e3;
            }
            function Ft(yt, Pe) {
              const $e = new Float32Array(yt.length);
              for (let Je = 0; Je < yt.length; Je++) $e[Je] = yt[Je] - Pe[Je];
              return $e;
            }
            function ut(yt, Pe) {
              const $e = Pe.length,
                Je = yt.length / $e;
              for (let rt = 0; rt < Je; rt++)
                for (let ct = 0; ct < $e; ct++) {
                  const Ve = Math.abs(yt[rt * $e + ct]);
                  Pe[ct] = Math.max(Pe[ct], Ve);
                }
            }
            function Pt(yt, Pe) {
              const $e = Pe.length,
                Je = yt.length / $e;
              for (let rt = 0; rt < Je; rt++)
                for (let ct = 0; ct < $e; ct++)
                  (yt[rt * $e + ct] /= Pe[ct] === 0 ? 1 : Pe[ct]),
                    (yt[rt * $e + ct] *= 0.5),
                    (yt[rt * $e + ct] += 0.5);
            }
            function bt(yt, Pe, $e) {
              const Je = Ft(Pe, yt);
              return ut(Je, $e), Pt(Je, $e), Je;
            }
            const Zt = new l.N();
            class Xt {
              constructor(Pe, $e) {
                this.graphicsDevice = Pe;
                const Je = Pe,
                  rt = 32;
                (this.precision = rt),
                  (this._addTimeTime = 0),
                  (we = this),
                  (Me = $e),
                  Ie("numParticles", 1),
                  this.numParticles > Pe.maxTextureSize &&
                    (this.numParticles = Pe.maxTextureSize),
                  Ie("rate", 1),
                  Ie("rate2", this.rate),
                  Ie("lifetime", 50),
                  Ie("emitterExtents", new h.e(0, 0, 0)),
                  Ie("emitterExtentsInner", new h.e(0, 0, 0)),
                  Ie("emitterRadius", 0),
                  Ie("emitterRadiusInner", 0),
                  Ie("emitterShape", u.Ql),
                  Ie("initialVelocity", 1),
                  Ie("wrap", !1),
                  Ie("localSpace", !1),
                  Ie("screenSpace", !1),
                  Ie("wrapBounds", null),
                  Ie("colorMap", this.defaultParamTexture),
                  Ie("normalMap", null),
                  Ie("loop", !0),
                  Ie("preWarm", !1),
                  Ie("sort", u.WL),
                  Ie("mode", u.JQ),
                  Ie("scene", null),
                  Ie("lighting", !1),
                  Ie("halfLambert", !1),
                  Ie("intensity", 1),
                  Ie("stretch", 0),
                  Ie("alignToMotion", !1),
                  Ie("depthSoftening", 0),
                  Ie("mesh", null),
                  Ie("particleNormal", new h.e(0, 1, 0)),
                  Ie("orientation", u.gp),
                  Ie("depthWrite", !1),
                  Ie("noFog", !1),
                  Ie("blendType", u.i9),
                  Ie("node", null),
                  Ie("startAngle", 0),
                  Ie("startAngle2", this.startAngle),
                  Ie("animTilesX", 1),
                  Ie("animTilesY", 1),
                  Ie("animStartFrame", 0),
                  Ie("animNumFrames", 1),
                  Ie("animNumAnimations", 1),
                  Ie("animIndex", 0),
                  Ie("randomizeAnimIndex", !1),
                  Ie("animSpeed", 1),
                  Ie("animLoop", !0),
                  (this._gpuUpdater = new ye(this, Je)),
                  (this._cpuUpdater = new de(this)),
                  (this.constantLightCube = Je.scope.resolve("lightCube[0]")),
                  (this.emitterPosUniform = new Float32Array(3)),
                  (this.wrapBoundsUniform = new Float32Array(3)),
                  (this.emitterScaleUniform = new Float32Array([1, 1, 1])),
                  Ie("colorGraph", me),
                  Ie("colorGraph2", this.colorGraph),
                  Ie("scaleGraph", Ge),
                  Ie("scaleGraph2", this.scaleGraph),
                  Ie("alphaGraph", Ge),
                  Ie("alphaGraph2", this.alphaGraph),
                  Ie("localVelocityGraph", ht),
                  Ie("localVelocityGraph2", this.localVelocityGraph),
                  Ie("velocityGraph", ht),
                  Ie("velocityGraph2", this.velocityGraph),
                  Ie("rotationSpeedGraph", Ue),
                  Ie("rotationSpeedGraph2", this.rotationSpeedGraph),
                  Ie("radialSpeedGraph", Ue),
                  Ie("radialSpeedGraph2", this.radialSpeedGraph),
                  (this.lightCube = new Float32Array(18)),
                  (this.lightCubeDir = new Array(6)),
                  (this.lightCubeDir[0] = new h.e(-1, 0, 0)),
                  (this.lightCubeDir[1] = new h.e(1, 0, 0)),
                  (this.lightCubeDir[2] = new h.e(0, -1, 0)),
                  (this.lightCubeDir[3] = new h.e(0, 1, 0)),
                  (this.lightCubeDir[4] = new h.e(0, 0, -1)),
                  (this.lightCubeDir[5] = new h.e(0, 0, 1)),
                  (this.animTilesParams = new Float32Array(2)),
                  (this.animParams = new Float32Array(4)),
                  (this.animIndexParams = new Float32Array(2)),
                  (this.internalTex0 = null),
                  (this.internalTex1 = null),
                  (this.internalTex2 = null),
                  (this.colorParam = null),
                  (this.vbToSort = null),
                  (this.vbOld = null),
                  (this.particleDistance = null),
                  (this.camera = null),
                  (this.swapTex = !1),
                  (this.useMesh = !0),
                  (this.useCpu = !Pe.supportsGpuParticles),
                  (this.pack8 = !0),
                  (this.localBounds = new f.I()),
                  (this.worldBoundsNoTrail = new f.I()),
                  (this.worldBoundsTrail = [new f.I(), new f.I()]),
                  (this.worldBounds = new f.I()),
                  (this.worldBoundsSize = new h.e()),
                  (this.prevWorldBoundsSize = new h.e()),
                  (this.prevWorldBoundsCenter = new h.e()),
                  (this.prevEmitterExtents = this.emitterExtents),
                  (this.prevEmitterRadius = this.emitterRadius),
                  (this.worldBoundsMul = new h.e()),
                  (this.worldBoundsAdd = new h.e()),
                  (this.timeToSwitchBounds = 0),
                  (this.shaderParticleUpdateRespawn = null),
                  (this.shaderParticleUpdateNoRespawn = null),
                  (this.shaderParticleUpdateOnStop = null),
                  (this.numParticleVerts = 0),
                  (this.numParticleIndices = 0),
                  (this.material = null),
                  (this.meshInstance = null),
                  (this.drawOrder = 0),
                  (this.seed = Math.random()),
                  (this.fixedTimeStep = 0.016666666666666666),
                  (this.maxSubSteps = 10),
                  (this.simTime = 0),
                  (this.simTimeTotal = 0),
                  (this.beenReset = !1),
                  (this._layer = null),
                  this.rebuild();
              }
              get defaultParamTexture() {
                return Zt.get(this.graphicsDevice, () => {
                  const Je = new Float32Array(1024);
                  for (let ct = 0; ct < 16; ct++)
                    for (let Ve = 0; Ve < 16; Ve++) {
                      const wt = Ve + 1 - 8.5,
                        at = ct + 1 - 8.5,
                        ce = ke(
                          1 - ke(Math.sqrt(wt * wt + at * at) / 16) - 0.5
                        ),
                        pe = ct * 16 + Ve;
                      (Je[pe * 4] = 1),
                        (Je[pe * 4 + 1] = 1),
                        (Je[pe * 4 + 2] = 1),
                        (Je[pe * 4 + 3] = ce);
                    }
                  const rt = Ae(this.graphicsDevice, 16, 16, Je, s.Lxj, 1, !0);
                  return (rt.minFilter = s.DrA), (rt.magFilter = s.DrA), rt;
                });
              }
              onChangeCamera() {
                this.regenShader(), this.resetMaterial();
              }
              calculateBoundsMad() {
                (this.worldBoundsMul.x = 1 / this.worldBoundsSize.x),
                  (this.worldBoundsMul.y = 1 / this.worldBoundsSize.y),
                  (this.worldBoundsMul.z = 1 / this.worldBoundsSize.z),
                  this.worldBoundsAdd
                    .copy(this.worldBounds.center)
                    .mul(this.worldBoundsMul)
                    .mulScalar(-1),
                  (this.worldBoundsAdd.x += 0.5),
                  (this.worldBoundsAdd.y += 0.5),
                  (this.worldBoundsAdd.z += 0.5);
              }
              calculateWorldBounds() {
                if (!this.node) return;
                if (
                  (this.prevWorldBoundsSize.copy(this.worldBoundsSize),
                  this.prevWorldBoundsCenter.copy(this.worldBounds.center),
                  !this.useCpu)
                ) {
                  let Je = !1;
                  this.emitterShape === u.Ql
                    ? (Je = !this.emitterExtents.equals(
                        this.prevEmitterExtents
                      ))
                    : (Je = this.emitterRadius !== this.prevEmitterRadius),
                    Je && this.calculateLocalBounds();
                }
                const Pe = this.node.getWorldTransform();
                this.localSpace
                  ? this.worldBoundsNoTrail.copy(this.localBounds)
                  : this.worldBoundsNoTrail.setFromTransformedAabb(
                      this.localBounds,
                      Pe
                    ),
                  this.worldBoundsTrail[0].add(this.worldBoundsNoTrail),
                  this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
                const $e = this.simTimeTotal;
                $e >= this.timeToSwitchBounds &&
                  (this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]),
                  this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
                  (this.timeToSwitchBounds = $e + this.lifetime)),
                  this.worldBounds.copy(this.worldBoundsTrail[0]),
                  this.worldBoundsSize
                    .copy(this.worldBounds.halfExtents)
                    .mulScalar(2),
                  this.localSpace
                    ? (this.meshInstance.aabb.setFromTransformedAabb(
                        this.worldBounds,
                        Pe
                      ),
                      this.meshInstance.mesh.aabb.setFromTransformedAabb(
                        this.worldBounds,
                        Pe
                      ))
                    : (this.meshInstance.aabb.copy(this.worldBounds),
                      this.meshInstance.mesh.aabb.copy(this.worldBounds)),
                  (this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer),
                  this.pack8 && this.calculateBoundsMad();
              }
              resetWorldBounds() {
                this.node &&
                  (this.worldBoundsNoTrail.setFromTransformedAabb(
                    this.localBounds,
                    this.localSpace
                      ? y.$.IDENTITY
                      : this.node.getWorldTransform()
                  ),
                  this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail),
                  this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
                  this.worldBounds.copy(this.worldBoundsTrail[0]),
                  this.worldBoundsSize
                    .copy(this.worldBounds.halfExtents)
                    .mulScalar(2),
                  this.prevWorldBoundsSize.copy(this.worldBoundsSize),
                  this.prevWorldBoundsCenter.copy(this.worldBounds.center),
                  (this.simTimeTotal = 0),
                  (this.timeToSwitchBounds = 0));
              }
              calculateLocalBounds() {
                let Pe = Number.MAX_VALUE,
                  $e = Number.MAX_VALUE,
                  Je = Number.MAX_VALUE,
                  rt = -Number.MAX_VALUE,
                  ct = -Number.MAX_VALUE,
                  Ve = -Number.MAX_VALUE,
                  wt = 0,
                  at = 0;
                const ce = this.lifetime / this.precision,
                  pe = [this.qVelocity, this.qVelocity2],
                  De = [this.qLocalVelocity, this.qLocalVelocity2],
                  fe = [0, 0],
                  Ze = [0, 0],
                  Ne = [0, 0],
                  Ye = [0, 0],
                  Ke = [0, 0];
                let nt, ot, ze;
                for (let _t = 0; _t < this.precision + 1; _t++) {
                  const Qe = Math.min(_t, this.precision - 1);
                  for (let lt = 0; lt < 2; lt++)
                    (nt = De[lt][Qe * 3 + 0] * ce + fe[lt]),
                      (ot = De[lt][Qe * 3 + 1] * ce + Ze[lt]),
                      (ze = De[lt][Qe * 3 + 2] * ce + Ne[lt]),
                      (Pe = Math.min(nt, Pe)),
                      ($e = Math.min(ot, $e)),
                      (Je = Math.min(ze, Je)),
                      (rt = Math.max(nt, rt)),
                      (ct = Math.max(ot, ct)),
                      (Ve = Math.max(ze, Ve)),
                      (fe[lt] = nt),
                      (Ze[lt] = ot),
                      (Ne[lt] = ze);
                  for (let lt = 0; lt < 2; lt++)
                    Ke[lt] +=
                      ce *
                      Math.sqrt(
                        pe[lt][Qe * 3 + 0] * pe[lt][Qe * 3 + 0] +
                          pe[lt][Qe * 3 + 1] * pe[lt][Qe * 3 + 1] +
                          pe[lt][Qe * 3 + 2] * pe[lt][Qe * 3 + 2]
                      );
                  (Ye[0] += this.qRadialSpeed[Qe] * ce),
                    (Ye[1] += this.qRadialSpeed2[Qe] * ce),
                    (wt = Math.max(
                      wt,
                      Math.max(Math.abs(Ye[0]), Math.abs(Ye[1]))
                    )),
                    (at = Math.max(at, this.qScale[Qe]));
                }
                this.emitterShape === u.Ql
                  ? ((nt = this.emitterExtents.x * 0.5),
                    (ot = this.emitterExtents.y * 0.5),
                    (ze = this.emitterExtents.z * 0.5))
                  : ((nt = this.emitterRadius),
                    (ot = this.emitterRadius),
                    (ze = this.emitterRadius));
                const et = Math.max(Ke[0], Ke[1]);
                (se.x = Pe - at - nt - wt - et),
                  (se.y = $e - at - ot - wt - et),
                  (se.z = Je - at - ze - wt - et),
                  (Ce.x = rt + at + nt + wt + et),
                  (Ce.y = ct + at + ot + wt + et),
                  (Ce.z = Ve + at + ze + wt + et),
                  this.localBounds.setMinMax(se, Ce);
              }
              rebuild() {
                const Pe = this.graphicsDevice;
                this.colorMap === null &&
                  (this.colorMap = this.defaultParamTexture),
                  (this.spawnBounds =
                    this.emitterShape === u.Ql
                      ? this.emitterExtents
                      : this.emitterRadius),
                  (this.useCpu =
                    this.useCpu ||
                    this.sort > u.WL ||
                    Pe.maxVertexTextures <= 1 ||
                    Pe.fragmentUniformsCount < 64 ||
                    Pe.forceCpuParticles ||
                    !Pe.extTextureFloat),
                  this._destroyResources(),
                  (this.pack8 =
                    (this.pack8 || !Pe.textureFloatRenderable) && !this.useCpu),
                  (z = this.useCpu || this.pack8 ? 4 : 2),
                  (this.useMesh = !1),
                  this.mesh &&
                    (this.numParticles * this.mesh.vertexBuffer.numVertices >
                      65535 ||
                      (this.useMesh = !0)),
                  (this.numParticlesPot = c.D.nextPowerOfTwo(
                    this.numParticles
                  )),
                  this.rebuildGraphs(),
                  this.calculateLocalBounds(),
                  this.resetWorldBounds(),
                  this.node &&
                    (this.worldBounds.setFromTransformedAabb(
                      this.localBounds,
                      this.localSpace
                        ? y.$.IDENTITY
                        : this.node.getWorldTransform()
                    ),
                    this.worldBoundsTrail[0].copy(this.worldBounds),
                    this.worldBoundsTrail[1].copy(this.worldBounds),
                    this.worldBoundsSize
                      .copy(this.worldBounds.halfExtents)
                      .mulScalar(2),
                    this.prevWorldBoundsSize.copy(this.worldBoundsSize),
                    this.prevWorldBoundsCenter.copy(this.worldBounds.center),
                    this.pack8 && this.calculateBoundsMad()),
                  (this.vbToSort = new Array(this.numParticles));
                for (let pe = 0; pe < this.numParticles; pe++)
                  this.vbToSort[pe] = [0, 0];
                (this.particleDistance = new Float32Array(this.numParticles)),
                  this._gpuUpdater.randomize(),
                  (this.particleTex = new Float32Array(
                    this.numParticlesPot * z * K
                  ));
                const $e =
                  this.node === null || this.localSpace
                    ? h.e.ZERO
                    : this.node.getPosition();
                this.emitterShape === u.Ql &&
                  (this.node === null || this.localSpace
                    ? H.setTRS(h.e.ZERO, d.k.IDENTITY, this.spawnBounds)
                    : H.setTRS(
                        h.e.ZERO,
                        this.node.getRotation(),
                        q.copy(this.spawnBounds).mul(this.node.localScale)
                      ),
                  (Te[0] =
                    this.emitterExtents.x !== 0
                      ? this.emitterExtentsInner.x / this.emitterExtents.x
                      : 0),
                  (Te[1] =
                    this.emitterExtents.y !== 0
                      ? this.emitterExtentsInner.y / this.emitterExtents.y
                      : 0),
                  (Te[2] =
                    this.emitterExtents.z !== 0
                      ? this.emitterExtentsInner.z / this.emitterExtents.z
                      : 0));
                for (let pe = 0; pe < this.numParticles; pe++)
                  this._cpuUpdater.calcSpawnPosition(
                    this.particleTex,
                    H,
                    Te,
                    $e,
                    pe
                  ),
                    this.useCpu &&
                      (this.particleTex[
                        pe * K + 3 + this.numParticlesPot * 2 * K
                      ] = 1);
                this.particleTexStart = new Float32Array(
                  this.numParticlesPot * z * K
                );
                for (let pe = 0; pe < this.particleTexStart.length; pe++)
                  this.particleTexStart[pe] = this.particleTex[pe];
                this.useCpu ||
                  (this.pack8
                    ? ((this.particleTexIN = Ae(
                        Pe,
                        this.numParticlesPot,
                        z,
                        this.particleTex,
                        s.Lxj,
                        1,
                        !1
                      )),
                      (this.particleTexOUT = Ae(
                        Pe,
                        this.numParticlesPot,
                        z,
                        this.particleTex,
                        s.Lxj,
                        1,
                        !1
                      )),
                      (this.particleTexStart = Ae(
                        Pe,
                        this.numParticlesPot,
                        z,
                        this.particleTexStart,
                        s.Lxj,
                        1,
                        !1
                      )))
                    : ((this.particleTexIN = Ae(
                        Pe,
                        this.numParticlesPot,
                        z,
                        this.particleTex
                      )),
                      (this.particleTexOUT = Ae(
                        Pe,
                        this.numParticlesPot,
                        z,
                        this.particleTex
                      )),
                      (this.particleTexStart = Ae(
                        Pe,
                        this.numParticlesPot,
                        z,
                        this.particleTexStart
                      ))),
                  (this.rtParticleTexIN = new o.O({
                    colorBuffer: this.particleTexIN,
                    depth: !1,
                  })),
                  (this.rtParticleTexOUT = new o.O({
                    colorBuffer: this.particleTexOUT,
                    depth: !1,
                  })),
                  (this.swapTex = !1));
                const Je =
                    (this.localSpace
                      ? `#define LOCAL_SPACE
`
                      : "") +
                    E.G.particleUpdaterInitPS +
                    (this.pack8
                      ? E.G.particleInputRgba8PS + E.G.particleOutputRgba8PS
                      : E.G.particleInputFloatPS + E.G.particleOutputFloatPS) +
                    (this.emitterShape === u.Ql
                      ? E.G.particleUpdaterAABBPS
                      : E.G.particleUpdaterSpherePS) +
                    E.G.particleUpdaterStartPS,
                  rt =
                    Je +
                    E.G.particleUpdaterRespawnPS +
                    E.G.particleUpdaterEndPS,
                  ct =
                    Je +
                    E.G.particleUpdaterNoRespawnPS +
                    E.G.particleUpdaterEndPS,
                  Ve =
                    Je + E.G.particleUpdaterOnStopPS + E.G.particleUpdaterEndPS,
                  wt = this.emitterShape + "" + this.pack8 + this.localSpace;
                (this.shaderParticleUpdateRespawn = (0, T.$$)(
                  Pe,
                  E.G.fullscreenQuadVS,
                  rt,
                  "fsQuad0" + wt
                )),
                  (this.shaderParticleUpdateNoRespawn = (0, T.$$)(
                    Pe,
                    E.G.fullscreenQuadVS,
                    ct,
                    "fsQuad1" + wt
                  )),
                  (this.shaderParticleUpdateOnStop = (0, T.$$)(
                    Pe,
                    E.G.fullscreenQuadVS,
                    Ve,
                    "fsQuad2" + wt
                  )),
                  (this.numParticleVerts = this.useMesh
                    ? this.mesh.vertexBuffer.numVertices
                    : 4),
                  (this.numParticleIndices = this.useMesh
                    ? this.mesh.indexBuffer[0].numIndices
                    : 6),
                  this._allocate(this.numParticles);
                const at = new v.e(Pe);
                (at.vertexBuffer = this.vertexBuffer),
                  (at.indexBuffer[0] = this.indexBuffer),
                  (at.primitive[0].type = s.Qpk),
                  (at.primitive[0].base = 0),
                  (at.primitive[0].count =
                    this.numParticles * this.numParticleIndices),
                  (at.primitive[0].indexed = !0),
                  (this.material = new m.i()),
                  (this.material.name = this.node.name),
                  (this.material.cull = s.pLF),
                  (this.material.alphaWrite = !1),
                  (this.material.blendType = this.blendType),
                  (this.material.depthWrite = this.depthWrite),
                  (this.material.emitter = this),
                  this.regenShader(),
                  this.resetMaterial();
                const ce = this.meshInstance ? this.meshInstance.visible : !0;
                (this.meshInstance = new _.F(at, this.material, this.node)),
                  (this.meshInstance.pick = !1),
                  this.meshInstance.updateKey(),
                  (this.meshInstance.cull = !0),
                  (this.meshInstance._noDepthDrawGl1 = !0),
                  this.localSpace
                    ? this.meshInstance.aabb.setFromTransformedAabb(
                        this.worldBounds,
                        this.node.getWorldTransform()
                      )
                    : this.meshInstance.aabb.copy(this.worldBounds),
                  (this.meshInstance._updateAabb = !1),
                  (this.meshInstance.visible = ce),
                  this._initializeTextures(),
                  this.resetTime(),
                  this.addTime(0, !1),
                  this.preWarm && this.prewarm(this.lifetime);
              }
              _isAnimated() {
                return (
                  this.animNumFrames >= 1 &&
                  (this.animTilesX > 1 || this.animTilesY > 1) &&
                  ((this.colorMap &&
                    this.colorMap !== this.defaultParamTexture) ||
                    this.normalMap)
                );
              }
              rebuildGraphs() {
                const Pe = this.precision,
                  $e = this.graphicsDevice;
                (this.qLocalVelocity = this.localVelocityGraph.quantize(Pe)),
                  (this.qVelocity = this.velocityGraph.quantize(Pe)),
                  (this.qColor = this.colorGraph.quantizeClamped(Pe, 0, 1)),
                  (this.qRotSpeed = this.rotationSpeedGraph.quantize(Pe)),
                  (this.qScale = this.scaleGraph.quantize(Pe)),
                  (this.qAlpha = this.alphaGraph.quantize(Pe)),
                  (this.qRadialSpeed = this.radialSpeedGraph.quantize(Pe)),
                  (this.qLocalVelocity2 =
                    this.localVelocityGraph2.quantize(Pe)),
                  (this.qVelocity2 = this.velocityGraph2.quantize(Pe)),
                  (this.qColor2 = this.colorGraph2.quantizeClamped(Pe, 0, 1)),
                  (this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(Pe)),
                  (this.qScale2 = this.scaleGraph2.quantize(Pe)),
                  (this.qAlpha2 = this.alphaGraph2.quantize(Pe)),
                  (this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(Pe));
                for (let Je = 0; Je < Pe; Je++)
                  (this.qRotSpeed[Je] *= c.D.DEG_TO_RAD),
                    (this.qRotSpeed2[Je] *= c.D.DEG_TO_RAD);
                if (
                  ((this.localVelocityUMax = new Float32Array(3)),
                  (this.velocityUMax = new Float32Array(3)),
                  (this.colorUMax = new Float32Array(3)),
                  (this.rotSpeedUMax = [0]),
                  (this.scaleUMax = [0]),
                  (this.alphaUMax = [0]),
                  (this.radialSpeedUMax = [0]),
                  (this.qLocalVelocityDiv = bt(
                    this.qLocalVelocity,
                    this.qLocalVelocity2,
                    this.localVelocityUMax
                  )),
                  (this.qVelocityDiv = bt(
                    this.qVelocity,
                    this.qVelocity2,
                    this.velocityUMax
                  )),
                  (this.qColorDiv = bt(
                    this.qColor,
                    this.qColor2,
                    this.colorUMax
                  )),
                  (this.qRotSpeedDiv = bt(
                    this.qRotSpeed,
                    this.qRotSpeed2,
                    this.rotSpeedUMax
                  )),
                  (this.qScaleDiv = bt(
                    this.qScale,
                    this.qScale2,
                    this.scaleUMax
                  )),
                  (this.qAlphaDiv = bt(
                    this.qAlpha,
                    this.qAlpha2,
                    this.alphaUMax
                  )),
                  (this.qRadialSpeedDiv = bt(
                    this.qRadialSpeed,
                    this.qRadialSpeed2,
                    this.radialSpeedUMax
                  )),
                  this.pack8)
                ) {
                  const Je = [0, 0, 0];
                  ut(this.qVelocity, Je);
                  const rt = [0, 0, 0];
                  ut(this.qVelocity2, rt);
                  const ct = [0, 0, 0];
                  ut(this.qLocalVelocity, ct);
                  const Ve = [0, 0, 0];
                  ut(this.qLocalVelocity2, Ve);
                  const wt = [0];
                  ut(this.qRadialSpeed, wt);
                  const at = [0];
                  ut(this.qRadialSpeed2, at);
                  let ce = Math.max(Je[0], rt[0]);
                  (ce = Math.max(ce, Je[1])),
                    (ce = Math.max(ce, rt[1])),
                    (ce = Math.max(ce, Je[2])),
                    (ce = Math.max(ce, rt[2]));
                  let pe = Math.max(ct[0], Ve[0]);
                  (pe = Math.max(pe, ct[1])),
                    (pe = Math.max(pe, Ve[1])),
                    (pe = Math.max(pe, ct[2])),
                    (pe = Math.max(pe, Ve[2]));
                  const De = Math.max(wt[0], at[0]);
                  this.maxVel = ce + pe + De;
                }
                this.useCpu ||
                  ((this.internalTex0 = Ae(
                    $e,
                    Pe,
                    1,
                    tt(this.qLocalVelocity, this.qLocalVelocityDiv)
                  )),
                  (this.internalTex1 = Ae(
                    $e,
                    Pe,
                    1,
                    tt(this.qVelocity, this.qVelocityDiv)
                  )),
                  (this.internalTex2 = Ae(
                    $e,
                    Pe,
                    1,
                    it(
                      this.qRotSpeed,
                      this.qScale,
                      this.qScaleDiv,
                      this.qRotSpeedDiv,
                      this.qAlphaDiv
                    )
                  )),
                  (this.internalTex3 = Ae(
                    $e,
                    Pe,
                    1,
                    At(this.qRadialSpeed, this.qRadialSpeedDiv)
                  ))),
                  (this.colorParam = Ae(
                    $e,
                    Pe,
                    1,
                    vt(this.qColor, this.qAlpha),
                    s.Lxj,
                    1,
                    !0
                  ));
              }
              _initializeTextures() {
                this.colorMap &&
                  (this.material.setParameter("colorMap", this.colorMap),
                  this.lighting &&
                    this.normalMap &&
                    this.material.setParameter("normalMap", this.normalMap));
              }
              regenShader() {
                const Pe = (0, g.k)(this.graphicsDevice);
                Pe.register("particle", P);
                const $e = this.normalMap !== null;
                (this.normalOption = 0),
                  this.lighting && (this.normalOption = $e ? 2 : 1),
                  (this.material.getShaderVariant = function (
                    Je,
                    rt,
                    ct,
                    Ve,
                    wt,
                    at,
                    ce,
                    pe
                  ) {
                    this.emitter.scene &&
                      this.emitter.camera !==
                        this.emitter.scene._activeCamera &&
                      ((this.emitter.camera = this.emitter.scene._activeCamera),
                      this.emitter.onChangeCamera());
                    const De = this.emitter.inTools,
                      fe = new r.c(ce, pe);
                    return Pe.getProgram(
                      "particle",
                      {
                        pass: u.OP,
                        useCpu: this.emitter.useCpu,
                        normal: this.emitter.normalOption,
                        halflambert: this.emitter.halfLambert,
                        stretch: this.emitter.stretch,
                        alignToMotion: this.emitter.alignToMotion,
                        soft: this.emitter.depthSoftening,
                        mesh: this.emitter.useMesh,
                        gamma: this.emitter.scene
                          ? this.emitter.scene.gammaCorrection
                          : 0,
                        toneMap: this.emitter.scene
                          ? this.emitter.scene.toneMapping
                          : 0,
                        fog:
                          this.emitter.scene && !this.emitter.noFog
                            ? this.emitter.scene.fog
                            : "none",
                        wrap: this.emitter.wrap && this.emitter.wrapBounds,
                        localSpace: this.emitter.localSpace,
                        screenSpace: De ? !1 : this.emitter.screenSpace,
                        blend: this.blendType,
                        animTex: this.emitter._isAnimated(),
                        animTexLoop: this.emitter.animLoop,
                        pack8: this.emitter.pack8,
                        customFace: this.emitter.orientation !== u.gp,
                      },
                      fe
                    );
                  }),
                  (this.material.shader = this.material.getShaderVariant());
              }
              resetMaterial() {
                const Pe = this.material;
                Pe.setParameter("stretch", this.stretch),
                  this._isAnimated() &&
                    (Pe.setParameter(
                      "animTexTilesParams",
                      this.animTilesParams
                    ),
                    Pe.setParameter("animTexParams", this.animParams),
                    Pe.setParameter(
                      "animTexIndexParams",
                      this.animIndexParams
                    )),
                  Pe.setParameter("colorMult", this.intensity),
                  this.useCpu ||
                    (Pe.setParameter("internalTex0", this.internalTex0),
                    Pe.setParameter("internalTex1", this.internalTex1),
                    Pe.setParameter("internalTex2", this.internalTex2),
                    Pe.setParameter("internalTex3", this.internalTex3)),
                  Pe.setParameter("colorParam", this.colorParam),
                  Pe.setParameter("numParticles", this.numParticles),
                  Pe.setParameter("numParticlesPot", this.numParticlesPot),
                  Pe.setParameter("lifetime", this.lifetime),
                  Pe.setParameter("rate", this.rate),
                  Pe.setParameter("rateDiv", this.rate2 - this.rate),
                  Pe.setParameter("seed", this.seed),
                  Pe.setParameter("scaleDivMult", this.scaleUMax[0]),
                  Pe.setParameter("alphaDivMult", this.alphaUMax[0]),
                  Pe.setParameter(
                    "radialSpeedDivMult",
                    this.radialSpeedUMax[0]
                  ),
                  Pe.setParameter("graphNumSamples", this.precision),
                  Pe.setParameter("graphSampleSize", 1 / this.precision),
                  Pe.setParameter("emitterScale", new Float32Array([1, 1, 1])),
                  this.pack8 &&
                    (this._gpuUpdater._setInputBounds(),
                    Pe.setParameter(
                      "inBoundsSize",
                      this._gpuUpdater.inBoundsSizeUniform
                    ),
                    Pe.setParameter(
                      "inBoundsCenter",
                      this._gpuUpdater.inBoundsCenterUniform
                    ),
                    Pe.setParameter("maxVel", this.maxVel)),
                  this.wrap &&
                    this.wrapBounds &&
                    ((this.wrapBoundsUniform[0] = this.wrapBounds.x),
                    (this.wrapBoundsUniform[1] = this.wrapBounds.y),
                    (this.wrapBoundsUniform[2] = this.wrapBounds.z),
                    Pe.setParameter("wrapBounds", this.wrapBoundsUniform)),
                  this.colorMap && Pe.setParameter("colorMap", this.colorMap),
                  this.lighting &&
                    this.normalMap &&
                    Pe.setParameter("normalMap", this.normalMap),
                  this.depthSoftening > 0 &&
                    Pe.setParameter(
                      "softening",
                      1 / (this.depthSoftening * this.depthSoftening * 100)
                    ),
                  this.stretch > 0 && (Pe.cull = s.pLF),
                  this._compParticleFaceParams();
              }
              _compParticleFaceParams() {
                let Pe, $e;
                if (this.orientation === u.gp)
                  (Pe = new Float32Array([1, 0, 0])),
                    ($e = new Float32Array([0, 0, 1]));
                else {
                  let Je;
                  this.orientation === u.KQ
                    ? (Je = this.particleNormal.normalize())
                    : (Je = (
                        this.node === null
                          ? y.$.IDENTITY
                          : this.node.getWorldTransform()
                      )
                        .transformVector(this.particleNormal)
                        .normalize());
                  const rt = new h.e(1, 0, 0);
                  Math.abs(rt.dot(Je)) === 1 && rt.set(0, 0, 1);
                  const ct = new h.e().cross(Je, rt).normalize();
                  rt.cross(ct, Je).normalize(),
                    (Pe = new Float32Array([rt.x, rt.y, rt.z])),
                    ($e = new Float32Array([ct.x, ct.y, ct.z]));
                }
                this.material.setParameter("faceTangent", Pe),
                  this.material.setParameter("faceBinorm", $e);
              }
              _allocate(Pe) {
                const $e = Pe * this.numParticleVerts,
                  Je = Pe * this.numParticleIndices;
                if (
                  this.vertexBuffer === void 0 ||
                  this.vertexBuffer.getNumVertices() !== $e
                ) {
                  if (this.useCpu) {
                    const pe = [
                        { semantic: s.NFm, components: 4, type: s.n$B },
                        { semantic: s.UhA, components: 4, type: s.n$B },
                        { semantic: s.$1R, components: 4, type: s.n$B },
                        { semantic: s.G3_, components: 1, type: s.n$B },
                        {
                          semantic: s.NLq,
                          components: this.useMesh ? 4 : 2,
                          type: s.n$B,
                        },
                      ],
                      De = new t.y(this.graphicsDevice, pe);
                    (this.vertexBuffer = new e.R(
                      this.graphicsDevice,
                      De,
                      $e,
                      s.pCO
                    )),
                      (this.indexBuffer = new n.h(
                        this.graphicsDevice,
                        s.c02,
                        Je
                      ));
                  } else {
                    const pe = [
                      { semantic: s.NFm, components: 4, type: s.n$B },
                    ];
                    this.useMesh &&
                      pe.push({ semantic: s.UhA, components: 2, type: s.n$B });
                    const De = new t.y(this.graphicsDevice, pe);
                    (this.vertexBuffer = new e.R(
                      this.graphicsDevice,
                      De,
                      $e,
                      s.pCO
                    )),
                      (this.indexBuffer = new n.h(
                        this.graphicsDevice,
                        s.c02,
                        Je
                      ));
                  }
                  const rt = new Float32Array(this.vertexBuffer.lock());
                  let ct, Ve, wt;
                  if (this.useMesh) {
                    (ct = new Float32Array(this.mesh.vertexBuffer.lock())),
                      (Ve = ct.length / this.mesh.vertexBuffer.numVertices);
                    for (
                      let pe = 0;
                      pe < this.mesh.vertexBuffer.format.elements.length;
                      pe++
                    )
                      if (
                        this.mesh.vertexBuffer.format.elements[pe].name ===
                        s.slc
                      ) {
                        wt =
                          this.mesh.vertexBuffer.format.elements[pe].offset / 4;
                        break;
                      }
                  }
                  for (let pe = 0; pe < $e; pe++) {
                    const De = Math.floor(pe / this.numParticleVerts);
                    if (this.useMesh) {
                      const fe = pe % this.numParticleVerts;
                      (rt[pe * 6] = ct[fe * Ve]),
                        (rt[pe * 6 + 1] = ct[fe * Ve + 1]),
                        (rt[pe * 6 + 2] = ct[fe * Ve + 2]),
                        (rt[pe * 6 + 3] = De),
                        (rt[pe * 6 + 4] = ct[fe * Ve + wt + 0]),
                        (rt[pe * 6 + 5] = 1 - ct[fe * Ve + wt + 1]);
                    } else {
                      const fe = pe % 4;
                      (rt[pe * 4] = Oe[fe][0]),
                        (rt[pe * 4 + 1] = Oe[fe][1]),
                        (rt[pe * 4 + 2] = 0),
                        (rt[pe * 4 + 3] = De);
                    }
                  }
                  this.useCpu &&
                    ((this.vbCPU = new Float32Array(rt)),
                    (this.vbOld = new Float32Array(this.vbCPU.length))),
                    this.vertexBuffer.unlock(),
                    this.useMesh && this.mesh.vertexBuffer.unlock();
                  let at = 0;
                  const ce = new Uint16Array(this.indexBuffer.lock());
                  this.useMesh &&
                    (ct = new Uint16Array(this.mesh.indexBuffer[0].lock()));
                  for (let pe = 0; pe < Pe; pe++)
                    if (this.useMesh)
                      for (let De = 0; De < this.numParticleIndices; De++)
                        ce[pe * this.numParticleIndices + De] =
                          ct[De] + pe * this.numParticleVerts;
                    else {
                      const De = pe * 4;
                      (ce[at++] = De),
                        (ce[at++] = De + 1),
                        (ce[at++] = De + 2),
                        (ce[at++] = De),
                        (ce[at++] = De + 2),
                        (ce[at++] = De + 3);
                    }
                  this.indexBuffer.unlock(),
                    this.useMesh && this.mesh.indexBuffer[0].unlock();
                }
              }
              reset() {
                if (
                  ((this.beenReset = !0),
                  (this.seed = Math.random()),
                  this.material.setParameter("seed", this.seed),
                  this.useCpu)
                )
                  for (let $e = 0; $e < this.particleTexStart.length; $e++)
                    this.particleTex[$e] = this.particleTexStart[$e];
                else this._initializeTextures();
                this.resetWorldBounds(), this.resetTime();
                const Pe = this.loop;
                (this.loop = !0),
                  this.addTime(0, !1),
                  (this.loop = Pe),
                  this.preWarm && this.prewarm(this.lifetime);
              }
              prewarm(Pe) {
                const $e = Pe / this.lifetime,
                  Je = Math.min(
                    Math.floor($e * this.precision),
                    this.precision
                  ),
                  rt = Pe / Je;
                for (let ct = 0; ct < Je; ct++) this.addTime(rt, !1);
              }
              resetTime() {
                this.endTime = Rt(this);
              }
              finishFrame() {
                this.useCpu && this.vertexBuffer.unlock();
              }
              addTime(Pe, $e) {
                const Je = this.graphicsDevice;
                if (
                  ((this.simTimeTotal += Pe),
                  this.calculateWorldBounds(),
                  this._isAnimated())
                ) {
                  const Ve = this.animTilesParams;
                  (Ve[0] = 1 / this.animTilesX), (Ve[1] = 1 / this.animTilesY);
                  const wt = this.animParams;
                  (wt[0] = this.animStartFrame),
                    (wt[1] = this.animNumFrames * this.animSpeed),
                    (wt[2] = this.animNumFrames - 1),
                    (wt[3] = this.animNumAnimations - 1);
                  const at = this.animIndexParams;
                  (at[0] = this.animIndex), (at[1] = this.randomizeAnimIndex);
                }
                this.scene &&
                  this.camera !== this.scene._activeCamera &&
                  ((this.camera = this.scene._activeCamera),
                  this.onChangeCamera()),
                  this.emitterShape === u.Ql &&
                    ((Te[0] =
                      this.emitterExtents.x !== 0
                        ? this.emitterExtentsInner.x / this.emitterExtents.x
                        : 0),
                    (Te[1] =
                      this.emitterExtents.y !== 0
                        ? this.emitterExtentsInner.y / this.emitterExtents.y
                        : 0),
                    (Te[2] =
                      this.emitterExtents.z !== 0
                        ? this.emitterExtentsInner.z / this.emitterExtents.z
                        : 0),
                    this.meshInstance.node === null
                      ? H.setTRS(h.e.ZERO, d.k.IDENTITY, this.emitterExtents)
                      : H.setTRS(
                          h.e.ZERO,
                          this.meshInstance.node.getRotation(),
                          q
                            .copy(this.emitterExtents)
                            .mul(this.meshInstance.node.localScale)
                        ));
                let rt;
                const ct =
                  this.meshInstance.node === null
                    ? h.e.ONE
                    : this.meshInstance.node.localScale;
                if (
                  ((this.emitterScaleUniform[0] = ct.x),
                  (this.emitterScaleUniform[1] = ct.y),
                  (this.emitterScaleUniform[2] = ct.z),
                  this.material.setParameter(
                    "emitterScale",
                    this.emitterScaleUniform
                  ),
                  this.localSpace &&
                    this.meshInstance.node &&
                    ((rt = this.meshInstance.node.getPosition()),
                    (this.emitterPosUniform[0] = rt.x),
                    (this.emitterPosUniform[1] = rt.y),
                    (this.emitterPosUniform[2] = rt.z),
                    this.material.setParameter(
                      "emitterPos",
                      this.emitterPosUniform
                    )),
                  this._compParticleFaceParams(),
                  !this.useCpu)
                )
                  this._gpuUpdater.update(Je, H, Te, Pe, $e);
                else {
                  const Ve = new Float32Array(this.vertexBuffer.lock());
                  this._cpuUpdater.update(
                    Ve,
                    this.vbToSort,
                    this.particleTex,
                    H,
                    Te,
                    rt,
                    Pe,
                    $e
                  );
                }
                this.loop ||
                  (Date.now() > this.endTime &&
                    (this.onFinished && this.onFinished(),
                    (this.meshInstance.visible = !1))),
                  this.meshInstance &&
                    (this.meshInstance.drawOrder = this.drawOrder);
              }
              _destroyResources() {
                this.particleTexIN &&
                  (this.particleTexIN.destroy(), (this.particleTexIN = null)),
                  this.particleTexOUT &&
                    (this.particleTexOUT.destroy(),
                    (this.particleTexOUT = null)),
                  this.particleTexStart &&
                    this.particleTexStart.destroy &&
                    (this.particleTexStart.destroy(),
                    (this.particleTexStart = null)),
                  this.rtParticleTexIN &&
                    (this.rtParticleTexIN.destroy(),
                    (this.rtParticleTexIN = null)),
                  this.rtParticleTexOUT &&
                    (this.rtParticleTexOUT.destroy(),
                    (this.rtParticleTexOUT = null)),
                  this.internalTex0 &&
                    (this.internalTex0.destroy(), (this.internalTex0 = null)),
                  this.internalTex1 &&
                    (this.internalTex1.destroy(), (this.internalTex1 = null)),
                  this.internalTex2 &&
                    (this.internalTex2.destroy(), (this.internalTex2 = null)),
                  this.internalTex3 &&
                    (this.internalTex3.destroy(), (this.internalTex3 = null)),
                  this.colorParam &&
                    (this.colorParam.destroy(), (this.colorParam = null)),
                  this.vertexBuffer &&
                    (this.vertexBuffer.destroy(), (this.vertexBuffer = void 0)),
                  this.indexBuffer &&
                    (this.indexBuffer.destroy(), (this.indexBuffer = void 0)),
                  this.material &&
                    (this.material.destroy(), (this.material = null));
              }
              destroy() {
                (this.camera = null), this._destroyResources();
              }
            }
          },
          8531: (xe, V, a) => {
            "use strict";
            a.d(V, {
              Eu: () => r,
              FK: () => v,
              LT: () => m,
              T8: () => e,
              Tj: () => s,
              ge: () => _,
              hS: () => l,
              qY: () => t,
              qk: () => n,
              s6: () => o,
              wh: () => u,
            });
            var A = a(7994),
              x = a(7481),
              y = a(1630),
              c = a(7197);
            const d = 4 / 64,
              h = 1 - d * 2,
              f = [];
            function s(g, T) {
              const E = T.length / 3,
                M = g.length / 3,
                R = new x.e(),
                P = new x.e(),
                F = new x.e(),
                b = new x.e(),
                D = new x.e(),
                G = new x.e(),
                X = [];
              for (let ie = 0; ie < g.length; ie++) X[ie] = 0;
              for (let ie = 0; ie < E; ie++) {
                const Q = T[ie * 3],
                  te = T[ie * 3 + 1],
                  ae = T[ie * 3 + 2];
                R.set(g[Q * 3], g[Q * 3 + 1], g[Q * 3 + 2]),
                  P.set(g[te * 3], g[te * 3 + 1], g[te * 3 + 2]),
                  F.set(g[ae * 3], g[ae * 3 + 1], g[ae * 3 + 2]),
                  b.sub2(P, R),
                  D.sub2(F, R),
                  G.cross(b, D).normalize(),
                  (X[Q * 3] += G.x),
                  (X[Q * 3 + 1] += G.y),
                  (X[Q * 3 + 2] += G.z),
                  (X[te * 3] += G.x),
                  (X[te * 3 + 1] += G.y),
                  (X[te * 3 + 2] += G.z),
                  (X[ae * 3] += G.x),
                  (X[ae * 3 + 1] += G.y),
                  (X[ae * 3 + 2] += G.z);
              }
              for (let ie = 0; ie < M; ie++) {
                const Q = X[ie * 3],
                  te = X[ie * 3 + 1],
                  ae = X[ie * 3 + 2],
                  Z = 1 / Math.sqrt(Q * Q + te * te + ae * ae);
                (X[ie * 3] *= Z), (X[ie * 3 + 1] *= Z), (X[ie * 3 + 2] *= Z);
              }
              return X;
            }
            function l(g, T, E, M) {
              const R = M.length / 3,
                P = g.length / 3,
                F = new x.e(),
                b = new x.e(),
                D = new x.e(),
                G = new A.Z(),
                X = new A.Z(),
                ie = new A.Z(),
                Q = new x.e(),
                te = new x.e(),
                ae = new Float32Array(P * 3),
                Z = new Float32Array(P * 3),
                J = [];
              for (let k = 0; k < R; k++) {
                const j = M[k * 3],
                  B = M[k * 3 + 1],
                  $ = M[k * 3 + 2];
                F.set(g[j * 3], g[j * 3 + 1], g[j * 3 + 2]),
                  b.set(g[B * 3], g[B * 3 + 1], g[B * 3 + 2]),
                  D.set(g[$ * 3], g[$ * 3 + 1], g[$ * 3 + 2]),
                  G.set(E[j * 2], E[j * 2 + 1]),
                  X.set(E[B * 2], E[B * 2 + 1]),
                  ie.set(E[$ * 2], E[$ * 2 + 1]);
                const le = b.x - F.x,
                  O = D.x - F.x,
                  Y = b.y - F.y,
                  ne = D.y - F.y,
                  de = b.z - F.z,
                  re = D.z - F.z,
                  I = X.x - G.x,
                  w = ie.x - G.x,
                  N = X.y - G.y,
                  W = ie.y - G.y,
                  he = I * W - w * N;
                if (he === 0) Q.set(0, 1, 0), te.set(1, 0, 0);
                else {
                  const ue = 1 / he;
                  Q.set(
                    (W * le - N * O) * ue,
                    (W * Y - N * ne) * ue,
                    (W * de - N * re) * ue
                  ),
                    te.set(
                      (I * O - w * le) * ue,
                      (I * ne - w * Y) * ue,
                      (I * re - w * de) * ue
                    );
                }
                (ae[j * 3 + 0] += Q.x),
                  (ae[j * 3 + 1] += Q.y),
                  (ae[j * 3 + 2] += Q.z),
                  (ae[B * 3 + 0] += Q.x),
                  (ae[B * 3 + 1] += Q.y),
                  (ae[B * 3 + 2] += Q.z),
                  (ae[$ * 3 + 0] += Q.x),
                  (ae[$ * 3 + 1] += Q.y),
                  (ae[$ * 3 + 2] += Q.z),
                  (Z[j * 3 + 0] += te.x),
                  (Z[j * 3 + 1] += te.y),
                  (Z[j * 3 + 2] += te.z),
                  (Z[B * 3 + 0] += te.x),
                  (Z[B * 3 + 1] += te.y),
                  (Z[B * 3 + 2] += te.z),
                  (Z[$ * 3 + 0] += te.x),
                  (Z[$ * 3 + 1] += te.y),
                  (Z[$ * 3 + 2] += te.z);
              }
              const ve = new x.e(),
                _e = new x.e(),
                L = new x.e(),
                ge = new x.e();
              for (let k = 0; k < P; k++) {
                L.set(T[k * 3], T[k * 3 + 1], T[k * 3 + 2]),
                  ve.set(ae[k * 3], ae[k * 3 + 1], ae[k * 3 + 2]),
                  _e.set(Z[k * 3], Z[k * 3 + 1], Z[k * 3 + 2]);
                const j = L.dot(ve);
                ge.copy(L).mulScalar(j),
                  ge.sub2(ve, ge).normalize(),
                  (J[k * 4] = ge.x),
                  (J[k * 4 + 1] = ge.y),
                  (J[k * 4 + 2] = ge.z),
                  ge.cross(L, ve),
                  (J[k * 4 + 3] = ge.dot(_e) < 0 ? -1 : 1);
              }
              return J;
            }
            function n(g, T, E) {
              const M = new c.e(g);
              return (
                M.setPositions(T),
                E &&
                  (E.normals && M.setNormals(E.normals),
                  E.tangents && M.setVertexStream(y.h3u, E.tangents, 4),
                  E.colors && M.setColors32(E.colors),
                  E.uvs && M.setUvs(0, E.uvs),
                  E.uvs1 && M.setUvs(1, E.uvs1),
                  E.blendIndices &&
                    M.setVertexStream(
                      y.aVd,
                      E.blendIndices,
                      4,
                      E.blendIndices.length / 4,
                      y.EUX
                    ),
                  E.blendWeights && M.setVertexStream(y.Hn_, E.blendWeights, 4),
                  E.indices && M.setIndices(E.indices)),
                M.update(),
                M
              );
            }
            function o(g, T = {}) {
              var E, M, R, P, F;
              const b = (E = T.tubeRadius) != null ? E : 0.2,
                D = (M = T.ringRadius) != null ? M : 0.3,
                G = (R = T.segments) != null ? R : 30,
                X = (P = T.sides) != null ? P : 20,
                ie = (F = T.calculateTangents) != null ? F : !1,
                Q = [],
                te = [],
                ae = [],
                Z = [];
              for (let ve = 0; ve <= X; ve++)
                for (let _e = 0; _e <= G; _e++) {
                  const L =
                      Math.cos((2 * Math.PI * _e) / G) *
                      (D + b * Math.cos((2 * Math.PI * ve) / X)),
                    ge = Math.sin((2 * Math.PI * ve) / X) * b,
                    k =
                      Math.sin((2 * Math.PI * _e) / G) *
                      (D + b * Math.cos((2 * Math.PI * ve) / X)),
                    j =
                      Math.cos((2 * Math.PI * _e) / G) *
                      Math.cos((2 * Math.PI * ve) / X),
                    B = Math.sin((2 * Math.PI * ve) / X),
                    $ =
                      Math.sin((2 * Math.PI * _e) / G) *
                      Math.cos((2 * Math.PI * ve) / X),
                    le = ve / X,
                    O = 1 - _e / G;
                  if (
                    (Q.push(L, ge, k),
                    te.push(j, B, $),
                    ae.push(le, 1 - O),
                    ve < X && _e < G)
                  ) {
                    const Y = ve * (G + 1) + _e,
                      ne = (ve + 1) * (G + 1) + _e,
                      de = ve * (G + 1) + (_e + 1),
                      re = (ve + 1) * (G + 1) + (_e + 1);
                    Z.push(Y, ne, de), Z.push(ne, re, de);
                  }
                }
              const J = { normals: te, uvs: ae, uvs1: ae, indices: Z };
              return ie && (J.tangents = l(Q, te, ae, Z)), n(g, Q, J);
            }
            function i(g, T, E, M, R, P) {
              const F = new x.e(),
                b = new x.e(),
                D = new x.e(),
                G = new x.e(),
                X = new x.e(),
                ie = new x.e(),
                Q = [],
                te = [],
                ae = [],
                Z = [],
                J = [];
              let ve;
              if (E > 0)
                for (let _e = 0; _e <= M; _e++)
                  for (let L = 0; L <= R; L++) {
                    const ge = (L / R) * 2 * Math.PI - Math.PI,
                      k = Math.sin(ge),
                      j = Math.cos(ge);
                    X.set(k * g, -E / 2, j * g),
                      G.set(k * T, E / 2, j * T),
                      F.lerp(X, G, _e / M),
                      b.sub2(G, X).normalize(),
                      ie.set(j, 0, -k),
                      D.cross(ie, b).normalize(),
                      Q.push(F.x, F.y, F.z),
                      te.push(D.x, D.y, D.z);
                    let B = L / R,
                      $ = _e / M;
                    ae.push(B, 1 - $);
                    const le = $;
                    if (
                      (($ = B),
                      (B = le),
                      (B = B * h + d),
                      ($ = $ * h + d),
                      (B /= 3),
                      Z.push(B, 1 - $),
                      _e < M && L < R)
                    ) {
                      const O = _e * (R + 1) + L,
                        Y = _e * (R + 1) + (L + 1),
                        ne = (_e + 1) * (R + 1) + L,
                        de = (_e + 1) * (R + 1) + (L + 1);
                      J.push(O, Y, ne), J.push(Y, de, ne);
                    }
                  }
              if (P) {
                const _e = Math.floor(R / 2),
                  L = R,
                  ge = E / 2;
                for (let k = 0; k <= _e; k++) {
                  const j = (k * Math.PI * 0.5) / _e,
                    B = Math.sin(j),
                    $ = Math.cos(j);
                  for (let le = 0; le <= L; le++) {
                    const O = (le * 2 * Math.PI) / L - Math.PI / 2,
                      Y = Math.sin(O),
                      de = Math.cos(O) * B,
                      re = $,
                      I = Y * B;
                    let w = 1 - le / L,
                      N = 1 - k / _e;
                    Q.push(de * T, re * T + ge, I * T),
                      te.push(de, re, I),
                      ae.push(w, 1 - N),
                      (w = w * h + d),
                      (N = N * h + d),
                      (w /= 3),
                      (N /= 3),
                      (w += 0.3333333333333333),
                      Z.push(w, 1 - N);
                  }
                }
                ve = (M + 1) * (R + 1);
                for (let k = 0; k < _e; ++k)
                  for (let j = 0; j < L; ++j) {
                    const B = k * (L + 1) + j,
                      $ = B + L + 1;
                    J.push(ve + B + 1, ve + $, ve + B),
                      J.push(ve + B + 1, ve + $ + 1, ve + $);
                  }
                for (let k = 0; k <= _e; k++) {
                  const j = Math.PI * 0.5 + (k * Math.PI * 0.5) / _e,
                    B = Math.sin(j),
                    $ = Math.cos(j);
                  for (let le = 0; le <= L; le++) {
                    const O = (le * 2 * Math.PI) / L - Math.PI / 2,
                      Y = Math.sin(O),
                      de = Math.cos(O) * B,
                      re = $,
                      I = Y * B;
                    let w = 1 - le / L,
                      N = 1 - k / _e;
                    Q.push(de * T, re * T - ge, I * T),
                      te.push(de, re, I),
                      ae.push(w, 1 - N),
                      (w = w * h + d),
                      (N = N * h + d),
                      (w /= 3),
                      (N /= 3),
                      (w += 0.6666666666666666),
                      Z.push(w, 1 - N);
                  }
                }
                ve = (M + 1) * (R + 1) + (L + 1) * (_e + 1);
                for (let k = 0; k < _e; ++k)
                  for (let j = 0; j < L; ++j) {
                    const B = k * (L + 1) + j,
                      $ = B + L + 1;
                    J.push(ve + B + 1, ve + $, ve + B),
                      J.push(ve + B + 1, ve + $ + 1, ve + $);
                  }
              } else {
                if (((ve = (M + 1) * (R + 1)), g > 0))
                  for (let _e = 0; _e < R; _e++) {
                    const L = (_e / R) * 2 * Math.PI,
                      ge = Math.sin(L),
                      k = -E / 2,
                      j = Math.cos(L);
                    let B = 1 - (ge + 1) / 2,
                      $ = (j + 1) / 2;
                    Q.push(ge * g, k, j * g),
                      te.push(0, -1, 0),
                      ae.push(B, 1 - $),
                      (B = B * h + d),
                      ($ = $ * h + d),
                      (B /= 3),
                      ($ /= 3),
                      (B += 0.3333333333333333),
                      Z.push(B, 1 - $),
                      _e > 1 && J.push(ve, ve + _e, ve + _e - 1);
                  }
                if (((ve += R), T > 0))
                  for (let _e = 0; _e < R; _e++) {
                    const L = (_e / R) * 2 * Math.PI,
                      ge = Math.sin(L),
                      k = E / 2,
                      j = Math.cos(L);
                    let B = 1 - (ge + 1) / 2,
                      $ = (j + 1) / 2;
                    Q.push(ge * T, k, j * T),
                      te.push(0, 1, 0),
                      ae.push(B, 1 - $),
                      (B = B * h + d),
                      ($ = $ * h + d),
                      (B /= 3),
                      ($ /= 3),
                      (B += 0.6666666666666666),
                      Z.push(B, 1 - $),
                      _e > 1 && J.push(ve, ve + _e - 1, ve + _e);
                  }
              }
              return {
                positions: Q,
                normals: te,
                uvs: ae,
                uvs1: Z,
                indices: J,
              };
            }
            function e(g, T = {}) {
              var E, M, R, P, F;
              const b = (E = T.radius) != null ? E : 0.5,
                D = (M = T.height) != null ? M : 1,
                G = (R = T.heightSegments) != null ? R : 5,
                X = (P = T.capSegments) != null ? P : 20,
                ie = (F = T.calculateTangents) != null ? F : !1,
                Q = i(b, b, D, G, X, !1);
              return (
                ie &&
                  (Q.tangents = l(Q.positions, Q.normals, Q.uvs, Q.indices)),
                n(g, Q.positions, Q)
              );
            }
            function t(g, T = {}) {
              var E, M, R, P, F;
              const b = (E = T.radius) != null ? E : 0.3,
                D = (M = T.height) != null ? M : 1,
                G = (R = T.heightSegments) != null ? R : 1,
                X = (P = T.sides) != null ? P : 20,
                ie = (F = T.calculateTangents) != null ? F : !1,
                Q = i(b, b, D - 2 * b, G, X, !0);
              return (
                ie &&
                  (Q.tangents = l(Q.positions, Q.normals, Q.uvs, Q.indices)),
                n(g, Q.positions, Q)
              );
            }
            function r(g, T = {}) {
              var E, M, R, P, F, b;
              const D = (E = T.baseRadius) != null ? E : 0.5,
                G = (M = T.peakRadius) != null ? M : 0,
                X = (R = T.height) != null ? R : 1,
                ie = (P = T.heightSegments) != null ? P : 5,
                Q = (F = T.capSegments) != null ? F : 18,
                te = (b = T.calculateTangents) != null ? b : !1,
                ae = i(D, G, X, ie, Q, !1);
              return (
                te &&
                  (ae.tangents = l(
                    ae.positions,
                    ae.normals,
                    ae.uvs,
                    ae.indices
                  )),
                n(g, ae.positions, ae)
              );
            }
            function u(g, T = {}) {
              var E, M, R, P;
              const F = (E = T.radius) != null ? E : 0.5,
                b = (M = T.latitudeBands) != null ? M : 16,
                D = (R = T.longitudeBands) != null ? R : 16,
                G = (P = T.calculateTangents) != null ? P : !1,
                X = [],
                ie = [],
                Q = [],
                te = [];
              for (let Z = 0; Z <= b; Z++) {
                const J = (Z * Math.PI) / b,
                  ve = Math.sin(J),
                  _e = Math.cos(J);
                for (let L = 0; L <= D; L++) {
                  const ge = (L * 2 * Math.PI) / D - Math.PI / 2,
                    k = Math.sin(ge),
                    B = Math.cos(ge) * ve,
                    $ = _e,
                    le = k * ve,
                    O = 1 - L / D,
                    Y = 1 - Z / b;
                  X.push(B * F, $ * F, le * F),
                    ie.push(B, $, le),
                    Q.push(O, 1 - Y);
                }
              }
              for (let Z = 0; Z < b; ++Z)
                for (let J = 0; J < D; ++J) {
                  const ve = Z * (D + 1) + J,
                    _e = ve + D + 1;
                  te.push(ve + 1, _e, ve), te.push(ve + 1, _e + 1, _e);
                }
              const ae = { normals: ie, uvs: Q, uvs1: Q, indices: te };
              return G && (ae.tangents = l(X, ie, Q, te)), n(g, X, ae);
            }
            function v(g, T = {}) {
              var E, M, R, P;
              const F = (E = T.halfExtents) != null ? E : new A.Z(0.5, 0.5),
                b = (M = T.widthSegments) != null ? M : 5,
                D = (R = T.lengthSegments) != null ? R : 5,
                G = (P = T.calculateTangents) != null ? P : !1,
                X = [],
                ie = [],
                Q = [],
                te = [];
              let ae = 0;
              for (let J = 0; J <= b; J++)
                for (let ve = 0; ve <= D; ve++) {
                  const _e = -F.x + (2 * F.x * J) / b,
                    L = 0,
                    ge = -(-F.y + (2 * F.y * ve) / D),
                    k = J / b,
                    j = ve / D;
                  X.push(_e, L, ge),
                    ie.push(0, 1, 0),
                    Q.push(k, 1 - j),
                    J < b &&
                      ve < D &&
                      (te.push(ae + D + 1, ae + 1, ae),
                      te.push(ae + D + 1, ae + D + 2, ae + 1)),
                    ae++;
                }
              const Z = { normals: ie, uvs: Q, uvs1: Q, indices: te };
              return G && (Z.tangents = l(X, ie, Q, te)), n(g, X, Z);
            }
            function _(g, T = {}) {
              var E, M, R, P, F;
              const b =
                  (E = T.halfExtents) != null ? E : new x.e(0.5, 0.5, 0.5),
                D = (M = T.widthSegments) != null ? M : 1,
                G = (R = T.lengthSegments) != null ? R : 1,
                X = (P = T.heightSegments) != null ? P : 1,
                ie = (F = T.calculateTangents) != null ? F : !1,
                Q = [
                  new x.e(-b.x, -b.y, b.z),
                  new x.e(b.x, -b.y, b.z),
                  new x.e(b.x, b.y, b.z),
                  new x.e(-b.x, b.y, b.z),
                  new x.e(b.x, -b.y, -b.z),
                  new x.e(-b.x, -b.y, -b.z),
                  new x.e(-b.x, b.y, -b.z),
                  new x.e(b.x, b.y, -b.z),
                ],
                te = [
                  [0, 1, 3],
                  [4, 5, 7],
                  [3, 2, 6],
                  [1, 0, 4],
                  [1, 4, 2],
                  [5, 0, 6],
                ],
                ae = [
                  [0, 0, 1],
                  [0, 0, -1],
                  [0, 1, 0],
                  [0, -1, 0],
                  [1, 0, 0],
                  [-1, 0, 0],
                ],
                Z = { FRONT: 0, BACK: 1, TOP: 2, BOTTOM: 3, RIGHT: 4, LEFT: 5 },
                J = [],
                ve = [],
                _e = [],
                L = [],
                ge = [];
              let k = 0;
              const j = ($, le, O) => {
                const Y = new x.e(),
                  ne = new x.e(),
                  de = new x.e(),
                  re = new x.e();
                for (let I = 0; I <= le; I++)
                  for (let w = 0; w <= O; w++) {
                    Y.lerp(Q[te[$][0]], Q[te[$][1]], I / le),
                      ne.lerp(Q[te[$][0]], Q[te[$][2]], w / O),
                      de.sub2(ne, Q[te[$][0]]),
                      re.add2(Y, de);
                    let N = I / le,
                      W = w / O;
                    J.push(re.x, re.y, re.z),
                      ve.push(ae[$][0], ae[$][1], ae[$][2]),
                      _e.push(N, 1 - W),
                      (N = N * h + d),
                      (W = W * h + d),
                      (N /= 3),
                      (W /= 3),
                      (N += ($ % 3) / 3),
                      (W += Math.floor($ / 3) / 3),
                      L.push(N, 1 - W),
                      I < le &&
                        w < O &&
                        (ge.push(k + O + 1, k + 1, k),
                        ge.push(k + O + 1, k + O + 2, k + 1)),
                      k++;
                  }
              };
              j(Z.FRONT, D, X),
                j(Z.BACK, D, X),
                j(Z.TOP, D, G),
                j(Z.BOTTOM, D, G),
                j(Z.RIGHT, G, X),
                j(Z.LEFT, G, X);
              const B = { normals: ve, uvs: _e, uvs1: L, indices: ge };
              return ie && (B.tangents = l(J, ve, _e, ge)), n(g, J, B);
            }
            function m(g, T) {
              let E = null;
              for (let M = 0; M < f.length; M++)
                f[M].type === T && f[M].device === g && (E = f[M].primData);
              if (!E) {
                let M, R;
                switch (T) {
                  case "box":
                    (M = _(g)),
                      (R = { x: 2, y: 2, z: 2, uv: 0.6666666666666666 });
                    break;
                  case "capsule":
                    (M = t(g, { radius: 0.5, height: 2 })),
                      (R = {
                        x: Math.PI * 2,
                        y: Math.PI,
                        z: Math.PI * 2,
                        uv: 0.5555555555555556,
                      });
                    break;
                  case "cone":
                    (M = r(g, { baseRadius: 0.5, peakRadius: 0, height: 1 })),
                      (R = {
                        x: 2.54,
                        y: 2.54,
                        z: 2.54,
                        uv: 0.4444444444444444,
                      });
                    break;
                  case "cylinder":
                    (M = e(g, { radius: 0.5, height: 1 })),
                      (R = {
                        x: Math.PI,
                        y: 1.58,
                        z: Math.PI,
                        uv: 0.5555555555555556,
                      });
                    break;
                  case "plane":
                    (M = v(g, {
                      halfExtents: new A.Z(0.5, 0.5),
                      widthSegments: 1,
                      lengthSegments: 1,
                    })),
                      (R = { x: 0, y: 1, z: 0, uv: 1 });
                    break;
                  case "sphere":
                    (M = u(g, { radius: 0.5 })),
                      (R = { x: Math.PI, y: Math.PI, z: Math.PI, uv: 1 });
                    break;
                  case "torus":
                    (M = o(g, { tubeRadius: 0.2, ringRadius: 0.3 })),
                      (R = {
                        x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
                        y: 0.4,
                        z: 0.4,
                        uv: 1,
                      });
                    break;
                  default:
                    throw new Error("Invalid primitive type: " + T);
                }
                M.incRefCount(),
                  (E = { mesh: M, area: R }),
                  f.push({ type: T, device: g, primData: E });
              }
              return E;
            }
          },
          6768: (xe, V, a) => {
            "use strict";
            a.d(V, { d: () => x });
            var A = a(8976);
            class x extends A.J {
              constructor() {
                super(), (this._meshes = null);
              }
              set meshes(c) {
                this.decRefMeshes(),
                  (this._meshes = c),
                  this.incRefMeshes(),
                  this.fire("set:meshes", c);
              }
              get meshes() {
                return this._meshes;
              }
              destroy() {
                this.meshes = null;
              }
              decRefMeshes() {
                if (this._meshes) {
                  const c = this._meshes.length;
                  for (let d = 0; d < c; d++) {
                    const h = this._meshes[d];
                    h &&
                      (h.decRefCount(),
                      h.refCount < 1 &&
                        (h.destroy(), (this._meshes[d] = null)));
                  }
                }
              }
              incRefMeshes() {
                if (this._meshes) {
                  const c = this._meshes.length;
                  for (let d = 0; d < c; d++)
                    this._meshes[d] && this._meshes[d].incRefCount();
                }
              }
            }
          },
          600: (xe, V, a) => {
            "use strict";
            a.d(V, { v: () => K });
            var A = a(7481),
              x = a(5227),
              y = a(2485),
              c = a(9391),
              d = a(2209),
              h = a(8484),
              f = a(5145),
              s = a(7994),
              l = a(5596),
              n = a(9061),
              o = a(1630),
              i = a(8524),
              e = a(1208),
              t = a(333),
              r = a(222),
              u = a(1268);
            const v = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
				#ifndef WEBGPU
						uv0.y = 1.0 - uv0.y;
				#endif
		}`,
              _ = `
		varying vec2 uv0;
		uniform sampler2D blitTexture;
		void main(void) {
				gl_FragColor = texture2D(blitTexture, uv0);
		}`,
              m = `
		varying vec2 uv0;
		uniform samplerCube blitTexture;
		uniform mat4 invViewProj;
		void main(void) {
				vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
				vec4 worldPos = invViewProj * projPos;
				gl_FragColor = textureCube(blitTexture, worldPos.xyz);
		}`,
              g = new l.Z();
            class T {
              constructor(H, q) {
                (this.device = H),
                  (this.lightTextureAtlas = q),
                  (this.blitShader2d = null),
                  (this.blitShaderCube = null),
                  (this.blitTextureId = null),
                  (this.invViewProjId = null);
              }
              destroy() {}
              getShader(H, q) {
                return (
                  this[H] ||
                    (this[H] = (0, t.$$)(
                      this.device,
                      v,
                      q,
                      `cookie_renderer_${H}`
                    )),
                  this.blitTextureId ||
                    (this.blitTextureId =
                      this.device.scope.resolve("blitTexture")),
                  this.invViewProjId ||
                    (this.invViewProjId =
                      this.device.scope.resolve("invViewProj")),
                  this[H]
                );
              }
              get shader2d() {
                return this.getShader("blitShader2d", _);
              }
              get shaderCube() {
                return this.getShader("blitShaderCube", m);
              }
              static createTexture(H, q) {
                return new e.g(H, {
                  name: "CookieAtlas",
                  width: q,
                  height: q,
                  format: o.Lxj,
                  cubemap: !1,
                  mipmaps: !1,
                  minFilter: o.uhC,
                  magFilter: o.uhC,
                  addressU: o.vq6,
                  addressV: o.vq6,
                });
              }
              initInvViewProjMatrices() {
                if (!T._invViewProjMatrices) {
                  T._invViewProjMatrices = [];
                  for (let H = 0; H < 6; H++) {
                    const q = r.S.create(null, c.dG, H),
                      se = q.projectionMatrix,
                      Ce = q.node.getLocalTransform().clone().invert();
                    T._invViewProjMatrices[H] = new h.$().mul2(se, Ce).invert();
                  }
                }
              }
              render(H, q) {
                if (H.enabled && H.cookie && H.visibleThisFrame) {
                  const se = H.numShadowFaces,
                    Ce = se > 1 ? this.shaderCube : this.shader2d,
                    we = this.device;
                  se > 1 && this.initInvViewProjMatrices(),
                    this.blitTextureId.setValue(H.cookie),
                    we.setBlendState(u.t.NOBLEND);
                  for (let Me = 0; Me < se; Me++) {
                    if ((g.copy(H.atlasViewport), se > 1)) {
                      const Ie = g.z / 3,
                        Le = this.lightTextureAtlas.cubeSlotsOffsets[Me];
                      (g.x += Ie * Le.x),
                        (g.y += Ie * Le.y),
                        (g.z = Ie),
                        (g.w = Ie),
                        this.invViewProjId.setValue(
                          T._invViewProjMatrices[Me].data
                        );
                    }
                    g.mulScalar(q.colorBuffer.width), (0, i.l)(we, q, Ce, g);
                  }
                }
              }
            }
            T._invViewProjMatrices = null;
            class E {
              constructor(H, q) {
                (this.texture = H),
                  (this.cached = !1),
                  (this.renderTargets = q);
              }
              destroy() {
                this.texture && (this.texture.destroy(), (this.texture = null));
                const H = this.renderTargets;
                for (let q = 0; q < H.length; q++) H[q].destroy();
                this.renderTargets.length = 0;
              }
              static getShadowFormat(H, q) {
                return q === c.DT
                  ? o.s7h
                  : q === c.xv
                  ? o.WBN
                  : q === c.Mq ||
                    ((q === c.Mk || q === c.MF) && H.supportsDepthShadow)
                  ? o.Wbd
                  : q === c.vJ && (H.webgl2 || H.isWebGPU)
                  ? o.IQA
                  : o.Lxj;
              }
              static getShadowFiltering(H, q) {
                return (q === c.Mk || q === c.MF || q === c.vJ) &&
                  !H.supportsDepthShadow
                  ? o.uhC
                  : q === c.DT
                  ? H.extTextureFloatLinear
                    ? o.DrA
                    : o.uhC
                  : q === c.xv
                  ? H.extTextureHalfFloatLinear
                    ? o.DrA
                    : o.uhC
                  : o.DrA;
              }
              static create(H, q) {
                let se = null;
                return (
                  q._type === c.dG
                    ? (se = this.createCubemap(
                        H,
                        q._shadowResolution,
                        q._shadowType
                      ))
                    : (se = this.create2dMap(
                        H,
                        q._shadowResolution,
                        q._shadowType
                      )),
                  se
                );
              }
              static createAtlas(H, q, se) {
                const Ce = this.create2dMap(H, q, se),
                  we = Ce.renderTargets,
                  Me = we[0];
                for (let Ie = 0; Ie < 5; Ie++) we.push(Me);
                return Ce;
              }
              static create2dMap(H, q, se) {
                const Ce = this.getShadowFormat(H, se),
                  we = this.getShadowFiltering(H, se),
                  Me = new e.g(H, {
                    format: Ce,
                    width: q,
                    height: q,
                    mipmaps: !1,
                    minFilter: we,
                    magFilter: we,
                    addressU: o.vq6,
                    addressV: o.vq6,
                    name: "ShadowMap2D",
                  });
                let Ie = null;
                return (
                  se === c.Mq ||
                  ((se === c.Mk || se === c.MF) && H.supportsDepthShadow)
                    ? ((Me.compareOnRead = !0),
                      (Me.compareFunc = o.v1A),
                      (Ie = new n.O({ depthBuffer: Me })))
                    : (Ie = new n.O({ colorBuffer: Me, depth: !0 })),
                  H.isWebGPU && (Ie.flipY = !0),
                  new E(Me, [Ie])
                );
              }
              static createCubemap(H, q, se) {
                const Ce =
                    se === c.vJ && (H.webgl2 || H.isWebGPU) ? o.IQA : o.Lxj,
                  we = new e.g(H, {
                    format: Ce,
                    width: q,
                    height: q,
                    cubemap: !0,
                    mipmaps: !1,
                    minFilter: o.uhC,
                    magFilter: o.uhC,
                    addressU: o.vq6,
                    addressV: o.vq6,
                    name: "ShadowMapCube",
                  }),
                  Me = [];
                for (let Ie = 0; Ie < 6; Ie++) {
                  const Le = new n.O({ colorBuffer: we, face: Ie, depth: !0 });
                  Me.push(Le);
                }
                return new E(we, Me);
              }
            }
            const M = [],
              R = [],
              P = new l.Z(),
              F = new l.Z();
            class b {
              constructor(H) {
                (this.size = Math.floor(H.w * 1024)),
                  (this.used = !1),
                  (this.lightId = -1),
                  (this.rect = H);
              }
            }
            class D {
              constructor(H) {
                (this.device = H),
                  (this.version = 1),
                  (this.shadowAtlasResolution = 2048),
                  (this.shadowAtlas = null),
                  (this.shadowEdgePixels = 3),
                  (this.cookieAtlasResolution = 2048),
                  (this.cookieAtlas = null),
                  (this.cookieRenderTarget = null),
                  (this.slots = []),
                  (this.atlasSplit = []),
                  (this.cubeSlotsOffsets = [
                    new s.Z(0, 0),
                    new s.Z(0, 1),
                    new s.Z(1, 0),
                    new s.Z(1, 1),
                    new s.Z(2, 0),
                    new s.Z(2, 1),
                  ]),
                  (this.scissorVec = new l.Z()),
                  this.allocateShadowAtlas(1),
                  this.allocateCookieAtlas(1),
                  this.allocateUniforms();
              }
              destroy() {
                this.destroyShadowAtlas(), this.destroyCookieAtlas();
              }
              destroyShadowAtlas() {
                this.shadowAtlas &&
                  (this.shadowAtlas.destroy(), (this.shadowAtlas = null));
              }
              destroyCookieAtlas() {
                this.cookieAtlas &&
                  (this.cookieAtlas.destroy(), (this.cookieAtlas = null)),
                  this.cookieRenderTarget &&
                    (this.cookieRenderTarget.destroy(),
                    (this.cookieRenderTarget = null));
              }
              allocateShadowAtlas(H) {
                if (!this.shadowAtlas || this.shadowAtlas.texture.width !== H) {
                  this.version++,
                    this.destroyShadowAtlas(),
                    (this.shadowAtlas = E.createAtlas(this.device, H, c.MF)),
                    (this.shadowAtlas.cached = !0);
                  const q = 4 / this.shadowAtlasResolution;
                  this.scissorVec.set(q, q, -2 * q, -2 * q);
                }
              }
              allocateCookieAtlas(H) {
                (!this.cookieAtlas || this.cookieAtlas.width !== H) &&
                  (this.version++,
                  this.destroyCookieAtlas(),
                  (this.cookieAtlas = T.createTexture(this.device, H)),
                  (this.cookieRenderTarget = new n.O({
                    colorBuffer: this.cookieAtlas,
                    depth: !1,
                    flipY: !0,
                  })));
              }
              allocateUniforms() {
                (this._shadowAtlasTextureId =
                  this.device.scope.resolve("shadowAtlasTexture")),
                  (this._shadowAtlasParamsId =
                    this.device.scope.resolve("shadowAtlasParams")),
                  (this._shadowAtlasParams = new Float32Array(2)),
                  (this._cookieAtlasTextureId =
                    this.device.scope.resolve("cookieAtlasTexture"));
              }
              updateUniforms() {
                const q = this.shadowAtlas.renderTargets[0],
                  Ce =
                    (this.device.isWebGPU || this.device.webgl2) && !0
                      ? q.depthBuffer
                      : q.colorBuffer;
                this._shadowAtlasTextureId.setValue(Ce),
                  (this._shadowAtlasParams[0] = this.shadowAtlasResolution),
                  (this._shadowAtlasParams[1] = this.shadowEdgePixels),
                  this._shadowAtlasParamsId.setValue(this._shadowAtlasParams),
                  this._cookieAtlasTextureId.setValue(this.cookieAtlas);
              }
              subdivide(H, q) {
                let se = q.atlasSplit;
                if (!se) {
                  const we = Math.ceil(Math.sqrt(H));
                  (se = R), (se[0] = we), (se.length = 1);
                }
                if (
                  !((we, Me) =>
                    we.length === Me.length &&
                    we.every((Ie, Le) => Ie === Me[Le]))(se, this.atlasSplit)
                ) {
                  this.version++,
                    (this.slots.length = 0),
                    (this.atlasSplit.length = 0),
                    this.atlasSplit.push(...se);
                  const we = this.atlasSplit[0];
                  if (we > 1) {
                    const Me = 1 / we;
                    for (let Ie = 0; Ie < we; Ie++)
                      for (let Le = 0; Le < we; Le++) {
                        const tt = new l.Z(Ie * Me, Le * Me, Me, Me),
                          vt = this.atlasSplit[1 + Ie * we + Le];
                        if (vt > 1)
                          for (let it = 0; it < vt; it++)
                            for (let At = 0; At < vt; At++) {
                              const Rt = Me / vt,
                                Ft = new l.Z(
                                  tt.x + it * Rt,
                                  tt.y + At * Rt,
                                  Rt,
                                  Rt
                                );
                              this.slots.push(new b(Ft));
                            }
                        else this.slots.push(new b(tt));
                      }
                  } else this.slots.push(new b(new l.Z(0, 0, 1, 1)));
                  this.slots.sort((Me, Ie) => Ie.size - Me.size);
                }
              }
              collectLights(H, q, se) {
                const Ce = se.cookiesEnabled,
                  we = se.shadowsEnabled;
                let Me = !1,
                  Ie = !1;
                const Le = M;
                Le.length = 0;
                const tt = (vt) => {
                  for (let it = 0; it < vt.length; it++) {
                    const At = vt[it];
                    if (At.visibleThisFrame) {
                      const Rt = we && At.castShadows,
                        Ft = Ce && !!At.cookie;
                      Me || (Me = Rt),
                        Ie || (Ie = Ft),
                        (Rt || Ft) && Le.push(At);
                    }
                  }
                };
                return (
                  (Ce || we) && (tt(H), tt(q)),
                  Le.sort((vt, it) => it.maxScreenSize - vt.maxScreenSize),
                  Me && this.allocateShadowAtlas(this.shadowAtlasResolution),
                  Ie && this.allocateCookieAtlas(this.cookieAtlasResolution),
                  (Me || Ie) && this.subdivide(Le.length, se),
                  Le
                );
              }
              setupSlot(H, q) {
                H.atlasViewport.copy(q);
                const se = H.numShadowFaces;
                for (let Ce = 0; Ce < se; Ce++)
                  if (H.castShadows || H._cookie) {
                    if (
                      (P.copy(q),
                      F.copy(q),
                      H._type === c.Gy && P.add(this.scissorVec),
                      H._type === c.dG)
                    ) {
                      const we = P.z / 3,
                        Me = this.cubeSlotsOffsets[Ce];
                      (P.x += we * Me.x),
                        (P.y += we * Me.y),
                        (P.z = we),
                        (P.w = we),
                        F.copy(P);
                    }
                    if (H.castShadows) {
                      const we = H.getRenderData(null, Ce);
                      we.shadowViewport.copy(P), we.shadowScissor.copy(F);
                    }
                  }
              }
              assignSlot(H, q, se) {
                H.atlasViewportAllocated = !0;
                const Ce = this.slots[q];
                (Ce.lightId = H.id),
                  (Ce.used = !0),
                  se &&
                    ((H.atlasSlotUpdated = !0),
                    (H.atlasVersion = this.version),
                    (H.atlasSlotIndex = q));
              }
              update(H, q, se) {
                (this.shadowAtlasResolution = se.shadowAtlasResolution),
                  (this.cookieAtlasResolution = se.cookieAtlasResolution);
                const Ce = this.collectLights(H, q, se);
                if (Ce.length > 0) {
                  const we = this.slots;
                  for (let Le = 0; Le < we.length; Le++) we[Le].used = !1;
                  const Me = Math.min(Ce.length, we.length);
                  for (let Le = 0; Le < Me; Le++) {
                    const tt = Ce[Le];
                    tt.castShadows && (tt._shadowMap = this.shadowAtlas);
                    const vt = we[tt.atlasSlotIndex];
                    if (
                      tt.atlasVersion === this.version &&
                      tt.id === (vt == null ? void 0 : vt.lightId)
                    ) {
                      const it = we[tt.atlasSlotIndex];
                      it.size === we[Le].size &&
                        !it.used &&
                        this.assignSlot(tt, tt.atlasSlotIndex, !1);
                    }
                  }
                  let Ie = 0;
                  for (let Le = 0; Le < Me; Le++) {
                    for (; Ie < we.length && we[Ie].used; ) Ie++;
                    const tt = Ce[Le];
                    tt.atlasViewportAllocated || this.assignSlot(tt, Ie, !0);
                    const vt = we[tt.atlasSlotIndex];
                    this.setupSlot(tt, vt.rect);
                  }
                }
                this.updateUniforms();
              }
            }
            var G = a(2658),
              X = a(5006),
              ie = a(2978),
              Q = a(5224),
              te = a(6252);
            class ae {
              constructor() {
                this.cache = new Map();
              }
              destroy() {
                this.clear(), (this.cache = null);
              }
              clear() {
                this.cache.forEach((H) => {
                  H.forEach((q) => {
                    q.destroy();
                  });
                }),
                  this.cache.clear();
              }
              getKey(H) {
                const q = H._type === c.dG,
                  se = H._shadowType,
                  Ce = H._shadowResolution;
                return `${q}-${se}-${Ce}`;
              }
              get(H, q) {
                const se = this.getKey(q),
                  Ce = this.cache.get(se);
                if (Ce && Ce.length) return Ce.pop();
                const we = E.create(H, q);
                return (we.cached = !0), we;
              }
              add(H, q) {
                const se = this.getKey(H),
                  Ce = this.cache.get(se);
                Ce ? Ce.push(q) : this.cache.set(se, [q]);
              }
            }
            var Z = a(8656);
            class J {
              constructor(H, q) {
                (this.shadowLights = []),
                  (this.renderer = void 0),
                  (this.shadowRenderer = void 0),
                  (this.device = void 0),
                  (this.renderer = H),
                  (this.shadowRenderer = q),
                  (this.device = H.device);
              }
              cull(H, q) {
                const se = this.renderer.scene.clusteredLightingEnabled;
                (H.visibleThisFrame = !0),
                  se ||
                    H._shadowMap ||
                    (H._shadowMap = E.create(this.device, H));
                const Ce = H._type,
                  we = Ce === c.Gy ? 1 : 6;
                for (let Me = 0; Me < we; Me++) {
                  const Ie = H.getRenderData(null, Me),
                    Le = Ie.shadowCamera;
                  (Le.nearClip = H.attenuationEnd / 1e3),
                    (Le.farClip = H.attenuationEnd),
                    (Ie.depthRangeCompensation = Le.farClip - Le.nearClip);
                  const tt = Le._node,
                    vt = H._node;
                  if ((tt.setPosition(vt.getPosition()), Ce === c.Gy))
                    (Le.fov = H._outerConeAngle * 2),
                      tt.setRotation(vt.getRotation()),
                      tt.rotateLocal(-90, 0, 0);
                  else if (Ce === c.dG)
                    if (se) {
                      const Rt =
                        (2 /
                          ((this.shadowRenderer.lightTextureAtlas
                            .shadowAtlasResolution *
                            H.atlasViewport.z) /
                            3)) *
                        this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
                      Le.fov = Math.atan(1 + Rt) * Z.D.RAD_TO_DEG * 2;
                    } else Le.fov = 90;
                  this.renderer.updateCameraFrustum(Le),
                    this.shadowRenderer.cullShadowCasters(
                      q,
                      Ie.visibleCasters,
                      Le
                    );
                }
              }
              prepareLights(H, q) {
                let se;
                for (let Ce = 0; Ce < q.length; Ce++) {
                  const we = q[Ce];
                  if (
                    this.shadowRenderer.needsShadowRendering(we) &&
                    we.atlasViewportAllocated
                  ) {
                    H.push(we);
                    for (let Me = 0; Me < we.numShadowFaces; Me++)
                      se = this.shadowRenderer.prepareFace(we, null, Me);
                  }
                }
                return se;
              }
              prepareClusteredRenderPass(H, q, se) {
                const Ce = this.shadowLights,
                  we = this.prepareLights(Ce, q),
                  Me = this.prepareLights(Ce, se),
                  Ie = we != null ? we : Me,
                  Le = Ce.length;
                Le &&
                  (this.shadowRenderer.setupRenderPass(H, Ie, !1),
                  (H.execute = () => {
                    for (let tt = 0; tt < Le; tt++) {
                      const vt = Ce[tt];
                      for (let it = 0; it < vt.numShadowFaces; it++)
                        this.shadowRenderer.renderFace(vt, null, it, !0);
                    }
                    Ce.length = 0;
                  }));
              }
              setupNonClusteredFaceRenderPass(H, q, se, Ce) {
                const we = this.shadowRenderer.prepareFace(q, null, se),
                  Me = new y.AH(this.device, () => {
                    this.shadowRenderer.renderFace(q, null, se, !1);
                  });
                this.shadowRenderer.setupRenderPass(Me, we, !0),
                  Ce &&
                    (Me.after = () => {
                      this.shadowRenderer.renderVsm(q, we);
                    }),
                  H.addRenderPass(Me);
              }
              buildNonClusteredRenderPasses(H, q, se) {
                for (let Ce = 0; Ce < q.length; Ce++) {
                  const we = q[Ce];
                  this.shadowRenderer.needsShadowRendering(we) &&
                    this.setupNonClusteredFaceRenderPass(H, we, 0, !0);
                }
                for (let Ce = 0; Ce < se.length; Ce++) {
                  const we = se[Ce];
                  if (this.shadowRenderer.needsShadowRendering(we)) {
                    const Me = we.numShadowFaces;
                    for (let Ie = 0; Ie < Me; Ie++)
                      this.setupNonClusteredFaceRenderPass(H, we, Ie, !1);
                  }
                }
              }
            }
            var ve = a(7915);
            const _e = new ve.I(),
              L = new A.e(),
              ge = new h.$(),
              k = [
                new A.e(),
                new A.e(),
                new A.e(),
                new A.e(),
                new A.e(),
                new A.e(),
                new A.e(),
                new A.e(),
              ],
              j = { min: 0, max: 0 };
            function B(Te, H, q) {
              (k[0].x = k[1].x = k[2].x = k[3].x = H.x),
                (k[1].y = k[3].y = k[7].y = k[5].y = H.y),
                (k[2].z = k[3].z = k[6].z = k[7].z = H.z),
                (k[4].x = k[5].x = k[6].x = k[7].x = q.x),
                (k[0].y = k[2].y = k[4].y = k[6].y = q.y),
                (k[0].z = k[1].z = k[4].z = k[5].z = q.z);
              let se = 9999999999,
                Ce = -9999999999;
              for (let we = 0; we < 8; ++we) {
                Te.transformPoint(k[we], k[we]);
                const Me = k[we].z;
                Me < se && (se = Me), Me > Ce && (Ce = Me);
              }
              return (j.min = se), (j.max = Ce), j;
            }
            class $ {
              constructor(H, q) {
                (this.renderer = void 0),
                  (this.shadowRenderer = void 0),
                  (this.device = void 0),
                  (this.renderer = H),
                  (this.shadowRenderer = q),
                  (this.device = H.device);
              }
              cull(H, q, se) {
                (H.visibleThisFrame = !0),
                  H._shadowMap || (H._shadowMap = E.create(this.device, H));
                const Ce = se._nearClip;
                this.generateSplitDistances(
                  H,
                  Ce,
                  Math.min(se._farClip, H.shadowDistance)
                );
                const we = H.shadowUpdateOverrides;
                for (
                  let Me = 0;
                  Me < H.numCascades && (we == null ? void 0 : we[Me]) !== c.Jb;
                  Me++
                ) {
                  const Ie = H.getRenderData(se, Me),
                    Le = Ie.shadowCamera;
                  (Le.renderTarget = H._shadowMap.renderTargets[0]),
                    Ie.shadowViewport.copy(H.cascades[Me]),
                    Ie.shadowScissor.copy(H.cascades[Me]);
                  const tt = Le._node,
                    vt = H._node;
                  tt.setPosition(vt.getPosition()),
                    tt.setRotation(vt.getRotation()),
                    tt.rotateLocal(-90, 0, 0);
                  const it = Me === 0 ? Ce : H._shadowCascadeDistances[Me - 1],
                    At = H._shadowCascadeDistances[Me],
                    Rt = se.getFrustumCorners(it, At);
                  L.set(0, 0, 0);
                  const Ft = se.node.getWorldTransform();
                  for (let ce = 0; ce < 8; ce++)
                    Ft.transformPoint(Rt[ce], Rt[ce]), L.add(Rt[ce]);
                  L.mulScalar(0.125);
                  let ut = 0;
                  for (let ce = 0; ce < 8; ce++) {
                    const pe = Rt[ce].sub(L).length();
                    pe > ut && (ut = pe);
                  }
                  const Pt = tt.right,
                    bt = tt.up,
                    Zt = tt.forward,
                    Xt = (0.25 * H._shadowResolution) / ut,
                    yt = Math.ceil(L.dot(bt) * Xt) / Xt,
                    Pe = Math.ceil(L.dot(Pt) * Xt) / Xt,
                    $e = bt.mulScalar(yt),
                    Je = Pt.mulScalar(Pe),
                    rt = L.dot(Zt),
                    ct = Zt.mulScalar(rt);
                  L.add2($e, Je).add(ct),
                    tt.setPosition(L),
                    tt.translateLocal(0, 0, 1e6),
                    (Le.nearClip = 0.01),
                    (Le.farClip = 2e6),
                    (Le.orthoHeight = ut),
                    this.renderer.updateCameraFrustum(Le),
                    this.shadowRenderer.cullShadowCasters(
                      q,
                      Ie.visibleCasters,
                      Le
                    );
                  let Ve = !0;
                  const wt = Ie.visibleCasters;
                  for (let ce = 0; ce < wt.length; ce++) {
                    const pe = wt[ce];
                    Ve ? ((Ve = !1), _e.copy(pe.aabb)) : _e.add(pe.aabb);
                  }
                  ge.copy(tt.getWorldTransform()).invert();
                  const at = B(ge, _e.getMin(), _e.getMax());
                  tt.translateLocal(0, 0, at.max + 0.1),
                    (Le.farClip = at.max - at.min + 0.2),
                    (Ie.depthRangeCompensation = Le.farClip),
                    (Ie.projectionCompensation = ut);
                }
              }
              generateSplitDistances(H, q, se) {
                H._shadowCascadeDistances.fill(se);
                for (let Ce = 1; Ce < H.numCascades; Ce++) {
                  const we = Ce / H.numCascades,
                    Me = q + (se - q) * we,
                    Ie = q * Rs(se / q, we),
                    Le = Z.D.lerp(Me, Ie, H.cascadeDistribution);
                  H._shadowCascadeDistances[Ce - 1] = Le;
                }
              }
              addLightRenderPasses(H, q, se) {
                const Ce = q.numShadowFaces,
                  we = q.shadowUpdateOverrides;
                let Me = !0,
                  Ie;
                for (let tt = 0; tt < Ce; tt++)
                  (we == null ? void 0 : we[tt]) === c.Jb && (Me = !1),
                    (Ie = this.shadowRenderer.prepareFace(q, se, tt));
                const Le = new y.AH(this.device, () => {
                  for (let tt = 0; tt < Ce; tt++)
                    (we == null ? void 0 : we[tt]) !== c.Jb &&
                      this.shadowRenderer.renderFace(q, se, tt, !Me),
                      (we == null ? void 0 : we[tt]) === c.e3 &&
                        (we[tt] = c.Jb);
                });
                (Le.after = () => {
                  this.shadowRenderer.renderVsm(q, se);
                }),
                  this.shadowRenderer.setupRenderPass(Le, Ie, Me),
                  H.addRenderPass(Le);
              }
              buildFrameGraph(H, q, se) {
                const Ce = q.directionalLights;
                for (let we = 0; we < Ce.length; we++) {
                  const Me = Ce[we];
                  this.shadowRenderer.needsShadowRendering(Me) &&
                    this.addLightRenderPasses(H, Me, se.camera);
                }
              }
            }
            var le = a(5520);
            let O = 0;
            const Y = [0, 0, 0, 0],
              ne = new h.$(),
              de = new h.$(),
              re = new h.$(),
              I = new d.U(),
              w = new f.i(),
              N = new h.$().setScale(1, -1, 1),
              W = new h.$().set([
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1,
              ]),
              he = new h.$(),
              ue = new h.$(),
              ye = new h.$(),
              Oe = new h.$(),
              Ae = new Set();
            class ke {
              constructor(H) {
                (this.clustersDebugRendered = !1),
                  (this.device = H),
                  (this.scene = null),
                  (this.lightTextureAtlas = new D(H)),
                  (this.shadowMapCache = new ae()),
                  (this.shadowRenderer = new le.u(
                    this,
                    this.lightTextureAtlas
                  )),
                  (this._shadowRendererLocal = new J(
                    this,
                    this.shadowRenderer
                  )),
                  (this._shadowRendererDirectional = new $(
                    this,
                    this.shadowRenderer
                  )),
                  (this._cookieRenderer = new T(H, this.lightTextureAtlas)),
                  (this.viewUniformFormat = null),
                  (this.viewBindGroupFormat = null),
                  (this._skinTime = 0),
                  (this._morphTime = 0),
                  (this._cullTime = 0),
                  (this._shadowMapTime = 0),
                  (this._lightClustersTime = 0),
                  (this._layerCompositionUpdateTime = 0),
                  (this._shadowDrawCalls = 0),
                  (this._skinDrawCalls = 0),
                  (this._instancedDrawCalls = 0),
                  (this._shadowMapUpdates = 0),
                  (this._numDrawCallsCulled = 0),
                  (this._camerasRendered = 0),
                  (this._lightClusters = 0);
                const q = H.scope;
                (this.boneTextureId = q.resolve("texture_poseMap")),
                  (this.boneTextureSizeId = q.resolve("texture_poseMapSize")),
                  (this.poseMatrixId = q.resolve("matrix_pose[0]")),
                  (this.modelMatrixId = q.resolve("matrix_model")),
                  (this.normalMatrixId = q.resolve("matrix_normal")),
                  (this.viewInvId = q.resolve("matrix_viewInverse")),
                  (this.viewPos = new Float32Array(3)),
                  (this.viewPosId = q.resolve("view_position")),
                  (this.projId = q.resolve("matrix_projection")),
                  (this.projSkyboxId = q.resolve("matrix_projectionSkybox")),
                  (this.viewId = q.resolve("matrix_view")),
                  (this.viewId3 = q.resolve("matrix_view3")),
                  (this.viewProjId = q.resolve("matrix_viewProjection")),
                  (this.flipYId = q.resolve("projectionFlipY")),
                  (this.tbnBasis = q.resolve("tbnBasis")),
                  (this.nearClipId = q.resolve("camera_near")),
                  (this.farClipId = q.resolve("camera_far")),
                  (this.cameraParams = new Float32Array(4)),
                  (this.cameraParamsId = q.resolve("camera_params")),
                  (this.alphaTestId = q.resolve("alpha_ref")),
                  (this.opacityMapId = q.resolve("texture_opacityMap")),
                  (this.exposureId = q.resolve("exposure")),
                  (this.twoSidedLightingNegScaleFactorId = q.resolve(
                    "twoSidedLightingNegScaleFactor"
                  )),
                  this.twoSidedLightingNegScaleFactorId.setValue(0),
                  (this.morphWeightsA = q.resolve("morph_weights_a")),
                  (this.morphWeightsB = q.resolve("morph_weights_b")),
                  (this.morphPositionTex = q.resolve("morphPositionTex")),
                  (this.morphNormalTex = q.resolve("morphNormalTex")),
                  (this.morphTexParams = q.resolve("morph_tex_params"));
              }
              destroy() {
                (this.shadowRenderer = null),
                  (this._shadowRendererLocal = null),
                  (this._shadowRendererDirectional = null),
                  this.shadowMapCache.destroy(),
                  (this.shadowMapCache = null),
                  this._cookieRenderer.destroy(),
                  (this._cookieRenderer = null),
                  this.lightTextureAtlas.destroy(),
                  (this.lightTextureAtlas = null);
              }
              sortCompare(H, q) {
                if (H.layer === q.layer) {
                  if (H.drawOrder && q.drawOrder)
                    return H.drawOrder - q.drawOrder;
                  if (H.zdist && q.zdist) return q.zdist - H.zdist;
                  if (H.zdist2 && q.zdist2) return H.zdist2 - q.zdist2;
                }
                return q._key[c.Gn] - H._key[c.Gn];
              }
              sortCompareMesh(H, q) {
                if (H.layer === q.layer) {
                  if (H.drawOrder && q.drawOrder)
                    return H.drawOrder - q.drawOrder;
                  if (H.zdist && q.zdist) return q.zdist - H.zdist;
                }
                const se = H._key[c.Gn],
                  Ce = q._key[c.Gn];
                return se === Ce && H.mesh && q.mesh
                  ? q.mesh.id - H.mesh.id
                  : Ce - se;
              }
              sortCompareDepth(H, q) {
                const se = H._key[c.pB],
                  Ce = q._key[c.pB];
                return se === Ce && H.mesh && q.mesh
                  ? q.mesh.id - H.mesh.id
                  : Ce - se;
              }
              setupViewport(H, q) {
                const se = this.device,
                  Ce = q ? q.width : se.width,
                  we = q ? q.height : se.height,
                  Me = H.rect;
                let Ie = Math.floor(Me.x * Ce),
                  Le = Math.floor(Me.y * we),
                  tt = Math.floor(Me.z * Ce),
                  vt = Math.floor(Me.w * we);
                if ((se.setViewport(Ie, Le, tt, vt), H._scissorRectClear)) {
                  const it = H.scissorRect;
                  (Ie = Math.floor(it.x * Ce)),
                    (Le = Math.floor(it.y * we)),
                    (tt = Math.floor(it.z * Ce)),
                    (vt = Math.floor(it.w * we));
                }
                se.setScissor(Ie, Le, tt, vt);
              }
              setCameraUniforms(H, q) {
                const se = q == null ? void 0 : q.flipY;
                let Ce = 1;
                if (H.xr && H.xr.session) {
                  let Ie;
                  const Le = H._node.parent;
                  Le && (Ie = Le.getWorldTransform());
                  const tt = H.xr.views;
                  Ce = tt.length;
                  for (let vt = 0; vt < Ce; vt++) {
                    const it = tt[vt];
                    Le
                      ? (it.viewInvOffMat.mul2(Ie, it.viewInvMat),
                        it.viewOffMat.copy(it.viewInvOffMat).invert())
                      : (it.viewInvOffMat.copy(it.viewInvMat),
                        it.viewOffMat.copy(it.viewMat)),
                      it.viewMat3.setFromMat4(it.viewOffMat),
                      it.projViewOffMat.mul2(it.projMat, it.viewOffMat),
                      (it.position[0] = it.viewInvOffMat.data[12]),
                      (it.position[1] = it.viewInvOffMat.data[13]),
                      (it.position[2] = it.viewInvOffMat.data[14]),
                      H.frustum.setFromMat4(it.projViewOffMat);
                  }
                } else {
                  let Ie = H.projectionMatrix;
                  H.calculateProjection && H.calculateProjection(Ie, c._S);
                  let Le = H.getProjectionMatrixSkybox();
                  if (
                    (se && ((Ie = he.mul2(N, Ie)), (Le = ue.mul2(N, Le))),
                    this.device.isWebGPU &&
                      ((Ie = ye.mul2(W, Ie)), (Le = Oe.mul2(W, Le))),
                    this.projId.setValue(Ie.data),
                    this.projSkyboxId.setValue(Le.data),
                    H.calculateTransform)
                  )
                    H.calculateTransform(de, c._S);
                  else {
                    const tt = H._node.getPosition(),
                      vt = H._node.getRotation();
                    de.setTRS(tt, vt, A.e.ONE);
                  }
                  this.viewInvId.setValue(de.data),
                    re.copy(de).invert(),
                    this.viewId.setValue(re.data),
                    I.setFromMat4(re),
                    this.viewId3.setValue(I.data),
                    ne.mul2(Ie, re),
                    this.viewProjId.setValue(ne.data),
                    this.flipYId.setValue(se ? -1 : 1),
                    this.dispatchViewPos(H._node.getPosition()),
                    H.frustum.setFromMat4(ne);
                }
                this.tbnBasis.setValue(se ? -1 : 1);
                const we = H._nearClip,
                  Me = H._farClip;
                return (
                  this.nearClipId.setValue(we),
                  this.farClipId.setValue(Me),
                  (this.cameraParams[0] = 1 / Me),
                  (this.cameraParams[1] = Me),
                  (this.cameraParams[2] = we),
                  (this.cameraParams[3] = H.projection === c.RD ? 1 : 0),
                  this.cameraParamsId.setValue(this.cameraParams),
                  this.exposureId.setValue(
                    this.scene.physicalUnits
                      ? H.getExposure()
                      : this.scene.exposure
                  ),
                  Ce
                );
              }
              clear(H, q, se, Ce) {
                const we =
                  ((q != null ? q : H._clearColorBuffer) ? o.Sue : 0) |
                  ((se != null ? se : H._clearDepthBuffer) ? o.YKI : 0) |
                  ((Ce != null ? Ce : H._clearStencilBuffer) ? o.zwO : 0);
                we &&
                  this.device.clear({
                    color: [
                      H._clearColor.r,
                      H._clearColor.g,
                      H._clearColor.b,
                      H._clearColor.a,
                    ],
                    depth: H._clearDepth,
                    stencil: H._clearStencil,
                    flags: we,
                  });
              }
              setCamera(H, q, se, Ce = null) {
                this.setCameraUniforms(H, q), this.clearView(H, q, se, !1);
              }
              clearView(H, q, se, Ce) {
                const we = this.device;
                if (
                  (we.setRenderTarget(q),
                  we.updateBegin(),
                  Ce &&
                    (we.setColorWrite(!0, !0, !0, !0), we.setDepthWrite(!0)),
                  this.setupViewport(H, q),
                  se)
                ) {
                  const Me = H._clearOptions;
                  we.clear(
                    Me || {
                      color: [
                        H._clearColor.r,
                        H._clearColor.g,
                        H._clearColor.b,
                        H._clearColor.a,
                      ],
                      depth: H._clearDepth,
                      flags:
                        (H._clearColorBuffer ? o.Sue : 0) |
                        (H._clearDepthBuffer ? o.YKI : 0) |
                        (H._clearStencilBuffer ? o.zwO : 0),
                      stencil: H._clearStencil,
                    }
                  );
                }
              }
              setupCullMode(H, q, se) {
                const Ce = se.material;
                let we = o.pLF;
                if (H) {
                  let Me = 1;
                  (Ce.cull === o.CWw || Ce.cull === o.K1r) &&
                    (Me = q * se.flipFacesFactor * se.node.worldScaleSign),
                    Me < 0
                      ? (we = Ce.cull === o.CWw ? o.K1r : o.CWw)
                      : (we = Ce.cull);
                }
                this.device.setCullMode(we),
                  we === o.pLF &&
                    Ce.cull === o.pLF &&
                    this.twoSidedLightingNegScaleFactorId.setValue(
                      se.node.worldScaleSign
                    );
              }
              updateCameraFrustum(H) {
                if (H.xr && H.xr.views.length) {
                  const se = H.xr.views[0];
                  ne.mul2(se.projMat, se.viewOffMat), H.frustum.setFromMat4(ne);
                  return;
                }
                const q = H.projectionMatrix;
                if (
                  (H.calculateProjection && H.calculateProjection(q, c._S),
                  H.calculateTransform)
                )
                  H.calculateTransform(de, c._S);
                else {
                  const se = H._node.getPosition(),
                    Ce = H._node.getRotation();
                  de.setTRS(se, Ce, A.e.ONE), this.viewInvId.setValue(de.data);
                }
                re.copy(de).invert(), ne.mul2(q, re), H.frustum.setFromMat4(ne);
              }
              setBaseConstants(H, q) {
                H.setCullMode(q.cull),
                  q.opacityMap && this.opacityMapId.setValue(q.opacityMap),
                  (q.opacityMap || q.alphaTest > 0) &&
                    this.alphaTestId.setValue(q.alphaTest);
              }
              updateCpuSkinMatrices(H) {
                O++;
                const q = H.length;
                if (q !== 0)
                  for (let se = 0; se < q; se++) {
                    const Ce = H[se].skinInstance;
                    Ce && (Ce.updateMatrices(H[se].node, O), (Ce._dirty = !0));
                  }
              }
              updateGpuSkinMatrices(H) {
                const q = H.length;
                for (let se = 0; se < q; se++) {
                  const Ce = H[se];
                  if (Ce.visibleThisFrame) {
                    const we = Ce.skinInstance;
                    we &&
                      we._dirty &&
                      (we.updateMatrixPalette(Ce.node, O), (we._dirty = !1));
                  }
                }
              }
              updateMorphing(H) {
                const q = H.length;
                for (let se = 0; se < q; se++) {
                  const Ce = H[se],
                    we = Ce.morphInstance;
                  we && we._dirty && Ce.visibleThisFrame && we.update();
                }
              }
              gpuUpdate(H) {
                this.updateGpuSkinMatrices(H), this.updateMorphing(H);
              }
              setVertexBuffers(H, q) {
                H.setVertexBuffer(q.vertexBuffer);
              }
              setMorphing(H, q) {
                if (q)
                  if (q.morph.useTextureMorph)
                    H.setVertexBuffer(q.morph.vertexBufferIds),
                      this.morphPositionTex.setValue(q.texturePositions),
                      this.morphNormalTex.setValue(q.textureNormals),
                      this.morphTexParams.setValue(q._textureParams);
                  else {
                    for (let se = 0; se < q._activeVertexBuffers.length; se++) {
                      const Ce = q._activeVertexBuffers[se];
                      if (Ce) {
                        const we = o.pY7 + (se + 8);
                        (Ce.format.elements[0].name = we),
                          (Ce.format.elements[0].scopeId = H.scope.resolve(we)),
                          Ce.format.update(),
                          H.setVertexBuffer(Ce);
                      }
                    }
                    this.morphWeightsA.setValue(q._shaderMorphWeightsA),
                      this.morphWeightsB.setValue(q._shaderMorphWeightsB);
                  }
              }
              setSkinning(H, q) {
                if (q.skinInstance)
                  if ((this._skinDrawCalls++, H.supportsBoneTextures)) {
                    const se = q.skinInstance.boneTexture;
                    this.boneTextureId.setValue(se),
                      (Y[0] = se.width),
                      (Y[1] = se.height),
                      (Y[2] = 1 / se.width),
                      (Y[3] = 1 / se.height),
                      this.boneTextureSizeId.setValue(Y);
                  } else
                    this.poseMatrixId.setValue(q.skinInstance.matrixPalette);
              }
              dispatchViewPos(H) {
                const q = this.viewPos;
                (q[0] = H.x),
                  (q[1] = H.y),
                  (q[2] = H.z),
                  this.viewPosId.setValue(q);
              }
              initViewBindGroupFormat(H) {
                if (
                  this.device.supportsUniformBuffers &&
                  !this.viewUniformFormat
                ) {
                  const q = [
                    new Q.g("matrix_viewProjection", o.CPw),
                    new Q.g("cubeMapRotationMatrix", o.xzR),
                    new Q.g("view_position", o.XAr),
                    new Q.g("skyboxIntensity", o.GF5),
                    new Q.g("exposure", o.GF5),
                    new Q.g("textureBias", o.GF5),
                  ];
                  H &&
                    q.push(
                      new Q.g("clusterCellsCountByBoundsSize", o.XAr),
                      new Q.g("clusterTextureSize", o.XAr),
                      new Q.g("clusterBoundsMin", o.XAr),
                      new Q.g("clusterBoundsDelta", o.XAr),
                      new Q.g("clusterCellsDot", o.XAr),
                      new Q.g("clusterCellsMax", o.XAr),
                      new Q.g("clusterCompressionLimit0", o.Qhq),
                      new Q.g("shadowAtlasParams", o.Qhq),
                      new Q.g("clusterMaxCells", o.pG9),
                      new Q.g("clusterSkip", o.GF5)
                    ),
                    (this.viewUniformFormat = new Q.Q(this.device, q));
                  const se = [new te.Xq(o.rb7, o.rXb | o.Jnj)],
                    Ce = [
                      new te.GN("lightsTextureFloat", o.Jnj, o.HeG, o.cRA),
                      new te.GN("lightsTexture8", o.Jnj, o.HeG, o.cRA),
                      new te.GN("shadowAtlasTexture", o.Jnj, o.HeG, o.pqC),
                      new te.GN("cookieAtlasTexture", o.Jnj, o.HeG, o.CZm),
                      new te.GN("areaLightsLutTex1", o.Jnj, o.HeG, o.CZm),
                      new te.GN("areaLightsLutTex2", o.Jnj, o.HeG, o.CZm),
                    ];
                  H &&
                    Ce.push(
                      new te.GN("clusterWorldTexture", o.Jnj, o.HeG, o.cRA)
                    ),
                    (this.viewBindGroupFormat = new te.a$(this.device, se, Ce));
                }
              }
              setupViewUniformBuffers(H, q, se, Ce) {
                const we = this.device;
                for (; H.length < Ce; ) {
                  const Ie = new X.D(we, q, !1),
                    Le = new ie.T(we, se, Ie);
                  H.push(Le);
                }
                const Me = H[0];
                Me.defaultUniformBuffer.update(),
                  Me.update(),
                  we.setBindGroup(o.PyI, Me);
              }
              setupMeshUniformBuffers(H, q) {
                const se = this.device;
                if (se.supportsUniformBuffers) {
                  this.modelMatrixId.setValue(q.node.worldTransform.data),
                    this.normalMatrixId.setValue(q.node.normalMatrix.data);
                  const Ce = H.getBindGroup(se);
                  Ce.defaultUniformBuffer.update(),
                    Ce.update(),
                    se.setBindGroup(o.pNk, Ce);
                }
              }
              drawInstance(H, q, se, Ce, we) {
                const Me = q.instancingData;
                if (Me)
                  Me.count > 0 &&
                    (this._instancedDrawCalls++,
                    H.setVertexBuffer(Me.vertexBuffer),
                    H.draw(se.primitive[Ce], Me.count));
                else {
                  const Ie = q.node.worldTransform;
                  this.modelMatrixId.setValue(Ie.data),
                    we &&
                      this.normalMatrixId.setValue(q.node.normalMatrix.data),
                    H.draw(se.primitive[Ce]);
                }
              }
              drawInstance2(H, q, se, Ce) {
                const we = q.instancingData;
                we
                  ? we.count > 0 &&
                    (this._instancedDrawCalls++,
                    H.draw(se.primitive[Ce], we.count, !0))
                  : H.draw(se.primitive[Ce], void 0, !0);
              }
              cull(H, q, se) {
                let Ce = 0;
                const we = q.length;
                if (!H.frustumCulling) {
                  for (let Me = 0; Me < we; Me++) {
                    const Ie = q[Me];
                    (!Ie.visible && !Ie.command) ||
                      ((se[Ce] = Ie), Ce++, (Ie.visibleThisFrame = !0));
                  }
                  return Ce;
                }
                for (let Me = 0; Me < we; Me++) {
                  const Ie = q[Me];
                  if (Ie.command)
                    (se[Ce] = Ie), Ce++, (Ie.visibleThisFrame = !0);
                  else {
                    if (!Ie.visible) continue;
                    let Le = !0;
                    Ie.cull && (Le = Ie._isVisible(H)),
                      Le && ((se[Ce] = Ie), Ce++, (Ie.visibleThisFrame = !0));
                  }
                }
                return Ce;
              }
              cullLights(H, q) {
                const se = this.scene.clusteredLightingEnabled,
                  Ce = this.scene.physicalUnits;
                for (let we = 0; we < q.length; we++) {
                  const Me = q[we];
                  if (Me.enabled)
                    if (Me._type !== c.kx)
                      if (
                        (Me.getBoundingSphere(w), H.frustum.containsSphere(w))
                      ) {
                        (Me.visibleThisFrame = !0), (Me.usePhysicalUnits = Ce);
                        const Ie = H.getScreenSize(w);
                        Me.maxScreenSize = Math.max(Me.maxScreenSize, Ie);
                      } else
                        se ||
                          (Me.castShadows &&
                            !Me.shadowMap &&
                            (Me.visibleThisFrame = !0));
                    else Me.usePhysicalUnits = this.scene.physicalUnits;
                }
              }
              cullShadowmaps(H) {
                const q = this.scene.clusteredLightingEnabled;
                for (let Ce = 0; Ce < H._lights.length; Ce++) {
                  const we = H._lights[Ce];
                  if (
                    we._type !== c.kx &&
                    (q &&
                      we.atlasSlotUpdated &&
                      we.shadowUpdateMode === c.Jb &&
                      (we.shadowUpdateMode = c.e3),
                    we.visibleThisFrame &&
                      we.castShadows &&
                      we.shadowUpdateMode !== c.Jb)
                  ) {
                    const Me = H._lightCompositionData[Ce].shadowCastersList;
                    this._shadowRendererLocal.cull(we, Me);
                  }
                }
                const se = H._renderActions;
                for (let Ce = 0; Ce < se.length; Ce++) {
                  const we = se[Ce],
                    Me = we.directionalLightsIndices.length;
                  for (let Ie = 0; Ie < Me; Ie++) {
                    const Le = we.directionalLightsIndices[Ie],
                      tt = H._lights[Le],
                      vt = H._lightCompositionData[Le].shadowCastersList;
                    this._shadowRendererDirectional.cull(
                      tt,
                      vt,
                      we.camera.camera
                    );
                  }
                }
              }
              cullComposition(H) {
                const q = H._renderActions;
                for (let se = 0; se < q.length; se++) {
                  const Ce = q[se],
                    we = Ce.layerIndex,
                    Me = H.layerList[we];
                  if (!Me.enabled || !H.subLayerEnabled[we]) continue;
                  const Ie = H.subLayerList[we],
                    Le = Ce.cameraIndex,
                    tt = Me.cameras[Le];
                  if (tt) {
                    tt.frameUpdate(Ce.renderTarget),
                      Ce.firstCameraUse &&
                        (this.updateCameraFrustum(tt.camera),
                        this._camerasRendered++),
                      this.cullLights(tt.camera, Me._lights);
                    const vt = Me.instances,
                      it = Ie
                        ? vt.visibleTransparent[Le]
                        : vt.visibleOpaque[Le];
                    if (!it.done) {
                      Me.onPreCull && Me.onPreCull(Le);
                      const At = Ie
                        ? Me.transparentMeshInstances
                        : Me.opaqueMeshInstances;
                      (it.length = this.cull(tt.camera, At, it.list)),
                        (it.done = !0),
                        Me.onPostCull && Me.onPostCull(Le);
                    }
                  }
                }
                this.scene.clusteredLightingEnabled &&
                  this.updateLightTextureAtlas(H),
                  this.cullShadowmaps(H);
              }
              updateShaders(H, q) {
                const se = H.length;
                for (let Ce = 0; Ce < se; Ce++) {
                  const we = H[Ce].material;
                  if (
                    we &&
                    !Ae.has(we) &&
                    (Ae.add(we),
                    we.getShaderVariant !== G.i.prototype.getShaderVariant)
                  ) {
                    if (
                      q &&
                      (!we.useLighting || (we.emitter && !we.emitter.lighting))
                    )
                      continue;
                    we.clearVariants();
                  }
                }
                Ae.clear();
              }
              renderCookies(H) {
                const q = this.lightTextureAtlas.cookieRenderTarget;
                for (let se = 0; se < H.length; se++) {
                  const Ce = H[se];
                  Ce.atlasViewportAllocated &&
                    Ce.atlasSlotUpdated &&
                    this._cookieRenderer.render(Ce, q);
                }
              }
              beginFrame(H, q) {
                const se = H._meshInstances,
                  Ce = this.scene;
                if (Ce.updateShaders || q) {
                  const Le = !Ce.updateShaders && q;
                  this.updateShaders(se, Le),
                    (Ce.updateShaders = !1),
                    Ce._shaderVersion++;
                }
                this.updateCpuSkinMatrices(se);
                const we = se.length;
                for (let Le = 0; Le < we; Le++) se[Le].visibleThisFrame = !1;
                const Me = H._lights,
                  Ie = Me.length;
                for (let Le = 0; Le < Ie; Le++) Me[Le].beginFrame();
              }
              updateLightTextureAtlas(H) {
                this.lightTextureAtlas.update(
                  H._splitLights[c.Gy],
                  H._splitLights[c.dG],
                  this.scene.lighting
                );
              }
              updateClusters(H) {
                const q = H.getEmptyWorldClusters(this.device),
                  se = H._renderActions;
                for (let Ce = 0; Ce < se.length; Ce++) {
                  const we = se[Ce],
                    Me = we.lightClusters;
                  if (Me && Me !== q && !Ae.has(Me)) {
                    Ae.add(Me);
                    const Ie = H.layerList[we.layerIndex];
                    Me.update(
                      Ie.clusteredLightsSet,
                      this.scene.gammaCorrection,
                      this.scene.lighting
                    );
                  }
                }
                Ae.clear();
              }
              updateLayerComposition(H, q) {
                const se = H.layerList.length;
                for (let Ie = 0; Ie < se; Ie++)
                  H.layerList[Ie]._postRenderCounter = 0;
                const we = this.scene._shaderVersion;
                for (let Ie = 0; Ie < se; Ie++) {
                  const Le = H.layerList[Ie];
                  (Le._shaderVersion = we),
                    (Le._preRenderCalledForCameras = 0),
                    (Le._postRenderCalledForCameras = 0),
                    H.subLayerList[Ie]
                      ? (Le._postRenderCounter |= 2)
                      : (Le._postRenderCounter |= 1),
                    (Le._postRenderCounterMax = Le._postRenderCounter);
                  for (let vt = 0; vt < Le.cameras.length; vt++)
                    Le.instances.prepare(vt);
                }
                return H._update(this.device, q);
              }
              frameUpdate() {
                (this.clustersDebugRendered = !1),
                  this.initViewBindGroupFormat(
                    this.scene.clusteredLightingEnabled
                  );
              }
            }
            var Ue = a(8197);
            const Ge = new x.Q(254 / 255, 254 / 255, 254 / 255, 254 / 255),
              ht = {
                drawCalls: [],
                shaderInstances: [],
                isNewMaterial: [],
                lightMaskChanged: [],
                clear: function () {
                  (this.drawCalls.length = 0),
                    (this.shaderInstances.length = 0),
                    (this.isNewMaterial.length = 0),
                    (this.lightMaskChanged.length = 0);
                },
              };
            function me(Te) {
              const H = [];
              for (let q = 0; q < Te; ++q) {
                const se = Math.sqrt(q + 0.5) / Math.sqrt(Te);
                H.push(se);
              }
              return H;
            }
            function z(Te) {
              const H = [];
              for (let q = 0; q < Te; q++) {
                const se = q / Te,
                  Ce = Math.sqrt(1 - se * se);
                H.push(Ce);
              }
              return H;
            }
            class K extends ke {
              constructor(H) {
                super(H);
                const q = this.device;
                (this._forwardDrawCalls = 0),
                  (this._materialSwitches = 0),
                  (this._depthMapTime = 0),
                  (this._forwardTime = 0),
                  (this._sortTime = 0);
                const se = q.scope;
                (this.fogColorId = se.resolve("fog_color")),
                  (this.fogStartId = se.resolve("fog_start")),
                  (this.fogEndId = se.resolve("fog_end")),
                  (this.fogDensityId = se.resolve("fog_density")),
                  (this.ambientId = se.resolve("light_globalAmbient")),
                  (this.skyboxIntensityId = se.resolve("skyboxIntensity")),
                  (this.cubeMapRotationMatrixId = se.resolve(
                    "cubeMapRotationMatrix"
                  )),
                  (this.pcssDiskSamplesId = se.resolve("pcssDiskSamples[0]")),
                  (this.pcssSphereSamplesId = se.resolve(
                    "pcssSphereSamples[0]"
                  )),
                  (this.lightColorId = []),
                  (this.lightDir = []),
                  (this.lightDirId = []),
                  (this.lightShadowMapId = []),
                  (this.lightShadowMatrixId = []),
                  (this.lightShadowParamsId = []),
                  (this.lightShadowIntensity = []),
                  (this.lightRadiusId = []),
                  (this.lightPos = []),
                  (this.lightPosId = []),
                  (this.lightWidth = []),
                  (this.lightWidthId = []),
                  (this.lightHeight = []),
                  (this.lightHeightId = []),
                  (this.lightInAngleId = []),
                  (this.lightOutAngleId = []),
                  (this.lightCookieId = []),
                  (this.lightCookieIntId = []),
                  (this.lightCookieMatrixId = []),
                  (this.lightCookieOffsetId = []),
                  (this.lightShadowSearchAreaId = []),
                  (this.lightCameraParamsId = []),
                  (this.shadowMatrixPaletteId = []),
                  (this.shadowCascadeDistancesId = []),
                  (this.shadowCascadeCountId = []),
                  (this.screenSizeId = se.resolve("uScreenSize")),
                  (this._screenSize = new Float32Array(4)),
                  (this.fogColor = new Float32Array(3)),
                  (this.ambientColor = new Float32Array(3)),
                  (this.pcssDiskSamples = me(16)),
                  (this.pcssSphereSamples = z(16));
              }
              destroy() {
                super.destroy();
              }
              dispatchGlobalLights(H) {
                if (
                  ((this.ambientColor[0] = H.ambientLight.r),
                  (this.ambientColor[1] = H.ambientLight.g),
                  (this.ambientColor[2] = H.ambientLight.b),
                  H.gammaCorrection)
                )
                  for (let q = 0; q < 3; q++)
                    this.ambientColor[q] = Math.pow(this.ambientColor[q], 2.2);
                if (H.physicalUnits)
                  for (let q = 0; q < 3; q++)
                    this.ambientColor[q] *= H.ambientLuminance;
                this.ambientId.setValue(this.ambientColor),
                  this.skyboxIntensityId.setValue(
                    H.physicalUnits ? H.skyboxLuminance : H.skyboxIntensity
                  ),
                  this.cubeMapRotationMatrixId.setValue(
                    H._skyboxRotationMat3.data
                  );
              }
              _resolveLight(H, q) {
                const se = "light" + q;
                (this.lightColorId[q] = H.resolve(se + "_color")),
                  (this.lightDir[q] = new Float32Array(3)),
                  (this.lightDirId[q] = H.resolve(se + "_direction")),
                  (this.lightShadowMapId[q] = H.resolve(se + "_shadowMap")),
                  (this.lightShadowMatrixId[q] = H.resolve(
                    se + "_shadowMatrix"
                  )),
                  (this.lightShadowParamsId[q] = H.resolve(
                    se + "_shadowParams"
                  )),
                  (this.lightShadowIntensity[q] = H.resolve(
                    se + "_shadowIntensity"
                  )),
                  (this.lightShadowSearchAreaId[q] = H.resolve(
                    se + "_shadowSearchArea"
                  )),
                  (this.lightRadiusId[q] = H.resolve(se + "_radius")),
                  (this.lightPos[q] = new Float32Array(3)),
                  (this.lightPosId[q] = H.resolve(se + "_position")),
                  (this.lightWidth[q] = new Float32Array(3)),
                  (this.lightWidthId[q] = H.resolve(se + "_halfWidth")),
                  (this.lightHeight[q] = new Float32Array(3)),
                  (this.lightHeightId[q] = H.resolve(se + "_halfHeight")),
                  (this.lightInAngleId[q] = H.resolve(se + "_innerConeAngle")),
                  (this.lightOutAngleId[q] = H.resolve(se + "_outerConeAngle")),
                  (this.lightCookieId[q] = H.resolve(se + "_cookie")),
                  (this.lightCookieIntId[q] = H.resolve(
                    se + "_cookieIntensity"
                  )),
                  (this.lightCookieMatrixId[q] = H.resolve(
                    se + "_cookieMatrix"
                  )),
                  (this.lightCookieOffsetId[q] = H.resolve(
                    se + "_cookieOffset"
                  )),
                  (this.lightCameraParamsId[q] = H.resolve(
                    se + "_cameraParams"
                  )),
                  (this.shadowMatrixPaletteId[q] = H.resolve(
                    se + "_shadowMatrixPalette[0]"
                  )),
                  (this.shadowCascadeDistancesId[q] = H.resolve(
                    se + "_shadowCascadeDistances[0]"
                  )),
                  (this.shadowCascadeCountId[q] = H.resolve(
                    se + "_shadowCascadeCount"
                  ));
              }
              setLTCDirectionalLight(H, q, se, Ce, we) {
                (this.lightPos[q][0] = Ce.x - se.x * we),
                  (this.lightPos[q][1] = Ce.y - se.y * we),
                  (this.lightPos[q][2] = Ce.z - se.z * we),
                  this.lightPosId[q].setValue(this.lightPos[q]);
                const Me = H.transformVector(new A.e(-0.5, 0, 0));
                (this.lightWidth[q][0] = Me.x * we),
                  (this.lightWidth[q][1] = Me.y * we),
                  (this.lightWidth[q][2] = Me.z * we),
                  this.lightWidthId[q].setValue(this.lightWidth[q]);
                const Ie = H.transformVector(new A.e(0, 0, 0.5));
                (this.lightHeight[q][0] = Ie.x * we),
                  (this.lightHeight[q][1] = Ie.y * we),
                  (this.lightHeight[q][2] = Ie.z * we),
                  this.lightHeightId[q].setValue(this.lightHeight[q]);
              }
              dispatchDirectLights(H, q, se, Ce) {
                let we = 0;
                const Me = this.device.scope;
                for (let Ie = 0; Ie < H.length; Ie++) {
                  if (!(H[Ie].mask & se)) continue;
                  const Le = H[Ie],
                    tt = Le._node.getWorldTransform();
                  if (
                    (this.lightColorId[we] || this._resolveLight(Me, we),
                    this.lightColorId[we].setValue(
                      q.gammaCorrection ? Le._linearFinalColor : Le._finalColor
                    ),
                    tt.getY(Le._direction).mulScalar(-1),
                    Le._direction.normalize(),
                    (this.lightDir[we][0] = Le._direction.x),
                    (this.lightDir[we][1] = Le._direction.y),
                    (this.lightDir[we][2] = Le._direction.z),
                    this.lightDirId[we].setValue(this.lightDir[we]),
                    Le.shape !== c.j0 &&
                      this.setLTCDirectionalLight(
                        tt,
                        we,
                        Le._direction,
                        Ce._node.getPosition(),
                        Ce.farClip
                      ),
                    Le.castShadows)
                  ) {
                    const vt = Le.getRenderData(Ce, 0),
                      it = Le._getUniformBiasValues(vt);
                    this.lightShadowMapId[we].setValue(vt.shadowBuffer),
                      this.lightShadowMatrixId[we].setValue(
                        vt.shadowMatrix.data
                      ),
                      this.shadowMatrixPaletteId[we].setValue(
                        Le._shadowMatrixPalette
                      ),
                      this.shadowCascadeDistancesId[we].setValue(
                        Le._shadowCascadeDistances
                      ),
                      this.shadowCascadeCountId[we].setValue(Le.numCascades),
                      this.lightShadowIntensity[we].setValue(
                        Le.shadowIntensity
                      );
                    const At = 50 / vt.projectionCompensation,
                      Rt =
                        1 /
                        (vt.shadowCamera.renderTarget.width / Le.penumbraSize);
                    this.lightShadowSearchAreaId[we].setValue(Rt * At);
                    const Ft = Le._shadowCameraParams;
                    (Ft.length = 4),
                      (Ft[0] = vt.depthRangeCompensation),
                      (Ft[1] = vt.shadowCamera._farClip),
                      (Ft[2] = vt.shadowCamera._nearClip),
                      (Ft[3] = 1),
                      this.lightCameraParamsId[we].setValue(Ft);
                    const ut = Le._shadowRenderParams;
                    (ut.length = 4),
                      (ut[0] = Le._shadowResolution),
                      (ut[1] = it.normalBias),
                      (ut[2] = it.bias),
                      (ut[3] = 0),
                      this.lightShadowParamsId[we].setValue(ut);
                  }
                  we++;
                }
                return we;
              }
              setLTCPositionalLight(H, q) {
                const se = H.transformVector(new A.e(-0.5, 0, 0));
                (this.lightWidth[q][0] = se.x),
                  (this.lightWidth[q][1] = se.y),
                  (this.lightWidth[q][2] = se.z),
                  this.lightWidthId[q].setValue(this.lightWidth[q]);
                const Ce = H.transformVector(new A.e(0, 0, 0.5));
                (this.lightHeight[q][0] = Ce.x),
                  (this.lightHeight[q][1] = Ce.y),
                  (this.lightHeight[q][2] = Ce.z),
                  this.lightHeightId[q].setValue(this.lightHeight[q]);
              }
              dispatchOmniLight(H, q, se, Ce) {
                const we = se._node.getWorldTransform();
                if (
                  (this.lightColorId[Ce] || this._resolveLight(q, Ce),
                  this.lightRadiusId[Ce].setValue(se.attenuationEnd),
                  this.lightColorId[Ce].setValue(
                    H.gammaCorrection ? se._linearFinalColor : se._finalColor
                  ),
                  we.getTranslation(se._position),
                  (this.lightPos[Ce][0] = se._position.x),
                  (this.lightPos[Ce][1] = se._position.y),
                  (this.lightPos[Ce][2] = se._position.z),
                  this.lightPosId[Ce].setValue(this.lightPos[Ce]),
                  se.shape !== c.j0 && this.setLTCPositionalLight(we, Ce),
                  se.castShadows)
                ) {
                  const Me = se.getRenderData(null, 0);
                  this.lightShadowMapId[Ce].setValue(Me.shadowBuffer);
                  const Ie = se._getUniformBiasValues(Me),
                    Le = se._shadowRenderParams;
                  (Le.length = 4),
                    (Le[0] = se._shadowResolution),
                    (Le[1] = Ie.normalBias),
                    (Le[2] = Ie.bias),
                    (Le[3] = 1 / se.attenuationEnd),
                    this.lightShadowParamsId[Ce].setValue(Le),
                    this.lightShadowIntensity[Ce].setValue(se.shadowIntensity);
                  const tt =
                    1 / (Me.shadowCamera.renderTarget.width / se.penumbraSize);
                  this.lightShadowSearchAreaId[Ce].setValue(tt);
                  const vt = se._shadowCameraParams;
                  (vt.length = 4),
                    (vt[0] = Me.depthRangeCompensation),
                    (vt[1] = Me.shadowCamera._farClip),
                    (vt[2] = Me.shadowCamera._nearClip),
                    (vt[3] = 0),
                    this.lightCameraParamsId[Ce].setValue(vt);
                }
                se._cookie &&
                  (this.lightCookieId[Ce].setValue(se._cookie),
                  this.lightShadowMatrixId[Ce].setValue(we.data),
                  this.lightCookieIntId[Ce].setValue(se.cookieIntensity));
              }
              dispatchSpotLight(H, q, se, Ce) {
                const we = se._node.getWorldTransform();
                if (
                  (this.lightColorId[Ce] || this._resolveLight(q, Ce),
                  this.lightInAngleId[Ce].setValue(se._innerConeAngleCos),
                  this.lightOutAngleId[Ce].setValue(se._outerConeAngleCos),
                  this.lightRadiusId[Ce].setValue(se.attenuationEnd),
                  this.lightColorId[Ce].setValue(
                    H.gammaCorrection ? se._linearFinalColor : se._finalColor
                  ),
                  we.getTranslation(se._position),
                  (this.lightPos[Ce][0] = se._position.x),
                  (this.lightPos[Ce][1] = se._position.y),
                  (this.lightPos[Ce][2] = se._position.z),
                  this.lightPosId[Ce].setValue(this.lightPos[Ce]),
                  se.shape !== c.j0 && this.setLTCPositionalLight(we, Ce),
                  we.getY(se._direction).mulScalar(-1),
                  se._direction.normalize(),
                  (this.lightDir[Ce][0] = se._direction.x),
                  (this.lightDir[Ce][1] = se._direction.y),
                  (this.lightDir[Ce][2] = se._direction.z),
                  this.lightDirId[Ce].setValue(this.lightDir[Ce]),
                  se.castShadows)
                ) {
                  const Me = se.getRenderData(null, 0);
                  this.lightShadowMapId[Ce].setValue(Me.shadowBuffer),
                    this.lightShadowMatrixId[Ce].setValue(Me.shadowMatrix.data);
                  const Ie = se._getUniformBiasValues(Me),
                    Le = se._shadowRenderParams;
                  (Le.length = 4),
                    (Le[0] = se._shadowResolution),
                    (Le[1] = Ie.normalBias),
                    (Le[2] = Ie.bias),
                    (Le[3] = 1 / se.attenuationEnd),
                    this.lightShadowParamsId[Ce].setValue(Le),
                    this.lightShadowIntensity[Ce].setValue(se.shadowIntensity);
                  const tt =
                      1 /
                      (Me.shadowCamera.renderTarget.width / se.penumbraSize),
                    vt = (Me.shadowCamera._fov * Math.PI) / 180,
                    it = 1 / Math.tan(vt / 2);
                  this.lightShadowSearchAreaId[Ce].setValue(tt * it);
                  const At = se._shadowCameraParams;
                  (At.length = 4),
                    (At[0] = Me.depthRangeCompensation),
                    (At[1] = Me.shadowCamera._farClip),
                    (At[2] = Me.shadowCamera._nearClip),
                    (At[3] = 0),
                    this.lightCameraParamsId[Ce].setValue(At);
                }
                if (se._cookie) {
                  if (!se.castShadows) {
                    const Me = r.S.evalSpotCookieMatrix(se);
                    this.lightShadowMatrixId[Ce].setValue(Me.data);
                  }
                  this.lightCookieId[Ce].setValue(se._cookie),
                    this.lightCookieIntId[Ce].setValue(se.cookieIntensity),
                    se._cookieTransform &&
                      ((se._cookieTransformUniform[0] = se._cookieTransform.x),
                      (se._cookieTransformUniform[1] = se._cookieTransform.y),
                      (se._cookieTransformUniform[2] = se._cookieTransform.z),
                      (se._cookieTransformUniform[3] = se._cookieTransform.w),
                      this.lightCookieMatrixId[Ce].setValue(
                        se._cookieTransformUniform
                      ),
                      (se._cookieOffsetUniform[0] = se._cookieOffset.x),
                      (se._cookieOffsetUniform[1] = se._cookieOffset.y),
                      this.lightCookieOffsetId[Ce].setValue(
                        se._cookieOffsetUniform
                      ));
                }
              }
              dispatchLocalLights(H, q, se, Ce) {
                let we = Ce;
                const Me = this.device.scope,
                  Ie = H[c.dG],
                  Le = Ie.length;
                for (let it = 0; it < Le; it++) {
                  const At = Ie[it];
                  At.mask & se && (this.dispatchOmniLight(q, Me, At, we), we++);
                }
                const tt = H[c.Gy],
                  vt = tt.length;
                for (let it = 0; it < vt; it++) {
                  const At = tt[it];
                  At.mask & se && (this.dispatchSpotLight(q, Me, At, we), we++);
                }
              }
              renderForwardPrepareMaterials(H, q, se, Ce, we, Me) {
                const Ie = (ut, Pt, bt, Zt) => {
                  ht.drawCalls.push(ut),
                    ht.shaderInstances.push(Pt),
                    ht.isNewMaterial.push(bt),
                    ht.lightMaskChanged.push(Zt);
                };
                ht.clear();
                const Le = this.device,
                  tt = this.scene,
                  vt = tt.clusteredLightingEnabled,
                  it = we ? we.getLightHash(vt) : 0;
                let At = null,
                  Rt,
                  Ft;
                for (let ut = 0; ut < se; ut++) {
                  const Pt = q[ut];
                  if (Pt.command) Ie(Pt, null, !1, !1);
                  else {
                    Pt.ensureMaterial(Le);
                    const bt = Pt.material,
                      Zt = Pt._shaderDefs,
                      Xt = Pt.mask;
                    bt && bt === At && Zt !== Rt && (At = null),
                      bt !== At &&
                        (this._materialSwitches++,
                        (bt._scene = tt),
                        bt.dirty &&
                          (bt.updateUniforms(Le, tt), (bt.dirty = !1)),
                        bt._dirtyBlend && (tt.layers._dirtyBlend = !0));
                    const yt = Pt.getShaderInstance(
                      Me,
                      it,
                      tt,
                      this.viewUniformFormat,
                      this.viewBindGroupFormat,
                      Ce
                    );
                    Ie(Pt, yt, bt !== At, !At || Xt !== Ft),
                      (At = bt),
                      (Rt = Zt),
                      (Ft = Xt);
                  }
                }
                return Le.endShaderBatch == null || Le.endShaderBatch(), ht;
              }
              renderForwardInternal(H, q, se, Ce, we, Me) {
                const Ie = this.device,
                  Le = this.scene,
                  tt = 1 << Ce,
                  vt = Me ? -1 : 1,
                  it = this.scene.clusteredLightingEnabled;
                let At = !1;
                const Rt = q.drawCalls.length;
                for (let Pt = 0; Pt < Rt; Pt++) {
                  const bt = q.drawCalls[Pt];
                  if (bt.command) bt.command();
                  else {
                    var Ft, ut;
                    const Zt = q.isNewMaterial[Pt],
                      Xt = q.lightMaskChanged[Pt],
                      yt = q.shaderInstances[Pt],
                      Pe = bt.material;
                    bt._shaderDefs;
                    const $e = bt.mask;
                    if (Zt) {
                      const wt = yt.shader;
                      if (
                        (!wt.failed && Ie.setShader(wt), (At = wt.failed), At)
                      )
                        break;
                      if ((Pe.setParameters(Ie), Xt)) {
                        const at = this.dispatchDirectLights(
                          se[c.kx],
                          Le,
                          $e,
                          H
                        );
                        it || this.dispatchLocalLights(se, Le, $e, at);
                      }
                      this.alphaTestId.setValue(Pe.alphaTest),
                        Ie.setBlendState(Pe.blendState),
                        Ie.setDepthState(Pe.depthState),
                        Ie.setAlphaToCoverage(Pe.alphaToCoverage),
                        Pe.depthBias || Pe.slopeDepthBias
                          ? (Ie.setDepthBias(!0),
                            Ie.setDepthBiasValues(
                              Pe.depthBias,
                              Pe.slopeDepthBias
                            ))
                          : Ie.setDepthBias(!1);
                    }
                    this.setupCullMode(H._cullFaces, vt, bt);
                    const Je =
                        (Ft = bt.stencilFront) != null ? Ft : Pe.stencilFront,
                      rt = (ut = bt.stencilBack) != null ? ut : Pe.stencilBack;
                    Ie.setStencilState(Je, rt);
                    const ct = bt.mesh;
                    bt.setParameters(Ie, tt),
                      this.setVertexBuffers(Ie, ct),
                      this.setMorphing(Ie, bt.morphInstance),
                      this.setSkinning(Ie, bt),
                      this.setupMeshUniformBuffers(yt, bt);
                    const Ve = bt.renderStyle;
                    if (
                      (Ie.setIndexBuffer(ct.indexBuffer[Ve]),
                      we == null || we(bt, Pt),
                      H.xr && H.xr.session && H.xr.views.length)
                    ) {
                      const wt = H.xr.views;
                      for (let at = 0; at < wt.length; at++) {
                        const ce = wt[at];
                        Ie.setViewport(
                          ce.viewport.x,
                          ce.viewport.y,
                          ce.viewport.z,
                          ce.viewport.w
                        ),
                          this.projId.setValue(ce.projMat.data),
                          this.projSkyboxId.setValue(ce.projMat.data),
                          this.viewId.setValue(ce.viewOffMat.data),
                          this.viewInvId.setValue(ce.viewInvOffMat.data),
                          this.viewId3.setValue(ce.viewMat3.data),
                          this.viewProjId.setValue(ce.projViewOffMat.data),
                          this.viewPosId.setValue(ce.position),
                          at === 0
                            ? this.drawInstance(Ie, bt, ct, Ve, !0)
                            : this.drawInstance2(Ie, bt, ct, Ve),
                          this._forwardDrawCalls++;
                      }
                    } else
                      this.drawInstance(Ie, bt, ct, Ve, !0),
                        this._forwardDrawCalls++;
                    Pt < Rt - 1 &&
                      !q.isNewMaterial[Pt + 1] &&
                      Pe.setParameters(Ie, bt.parameters);
                  }
                }
              }
              renderForward(H, q, se, Ce, we, Me, Ie, Le) {
                const tt = this.renderForwardPrepareMaterials(
                  H,
                  q,
                  se,
                  Ce,
                  Ie,
                  we
                );
                this.renderForwardInternal(H, tt, Ce, we, Me, Le), ht.clear();
              }
              setSceneConstants() {
                const H = this.scene;
                if ((this.dispatchGlobalLights(H), H.fog !== c.qX)) {
                  if (
                    ((this.fogColor[0] = H.fogColor.r),
                    (this.fogColor[1] = H.fogColor.g),
                    (this.fogColor[2] = H.fogColor.b),
                    H.gammaCorrection)
                  )
                    for (let se = 0; se < 3; se++)
                      this.fogColor[se] = Math.pow(this.fogColor[se], 2.2);
                  this.fogColorId.setValue(this.fogColor),
                    H.fog === c.ZS
                      ? (this.fogStartId.setValue(H.fogStart),
                        this.fogEndId.setValue(H.fogEnd))
                      : this.fogDensityId.setValue(H.fogDensity);
                }
                const q = this.device;
                (this._screenSize[0] = q.width),
                  (this._screenSize[1] = q.height),
                  (this._screenSize[2] = 1 / q.width),
                  (this._screenSize[3] = 1 / q.height),
                  this.screenSizeId.setValue(this._screenSize),
                  this.pcssDiskSamplesId.setValue(this.pcssDiskSamples),
                  this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);
              }
              updateLightStats(H, q) {}
              buildFrameGraph(H, q) {
                const se = this.scene.clusteredLightingEnabled;
                if ((H.reset(), this.update(q), se)) {
                  {
                    const Le = new y.AH(this.device, () => {
                      this.scene.lighting.cookiesEnabled &&
                        (this.renderCookies(q._splitLights[c.Gy]),
                        this.renderCookies(q._splitLights[c.dG]));
                    });
                    (Le.requiresCubemaps = !1), H.addRenderPass(Le);
                  }
                  {
                    const Le = new y.AH(this.device);
                    if (
                      ((Le.requiresCubemaps = !1),
                      H.addRenderPass(Le),
                      this.scene.lighting.shadowsEnabled)
                    ) {
                      const tt = q._splitLights;
                      this._shadowRendererLocal.prepareClusteredRenderPass(
                        Le,
                        tt[c.Gy],
                        tt[c.dG]
                      );
                    }
                    Le.after = () => {
                      this.updateClusters(q);
                    };
                  }
                } else {
                  const Le = q._splitLights;
                  this._shadowRendererLocal.buildNonClusteredRenderPasses(
                    H,
                    Le[c.Gy],
                    Le[c.dG]
                  );
                }
                let Ce = 0,
                  we = !0,
                  Me = null;
                const Ie = q._renderActions;
                for (let Le = Ce; Le < Ie.length; Le++) {
                  const tt = Ie[Le],
                    vt = q.layerList[tt.layerIndex],
                    it = vt.cameras[tt.cameraIndex];
                  if (!tt.isLayerEnabled(q)) continue;
                  const Rt =
                    vt.id === c.$9 &&
                    (it.renderSceneColorMap || it.renderSceneDepthMap);
                  tt.hasDirectionalShadowLights &&
                    it &&
                    this._shadowRendererDirectional.buildFrameGraph(H, tt, it),
                    we && ((we = !1), (Ce = Le), (Me = tt.renderTarget));
                  let Ft = Le + 1;
                  for (; Ie[Ft] && !Ie[Ft].isLayerEnabled(q); ) Ft++;
                  const ut = Ie[Ft],
                    bt =
                      (ut ? q.layerList[ut.layerIndex].id === c.$9 : !1) &&
                      (it.renderSceneColorMap || it.renderSceneDepthMap);
                  if (
                    !ut ||
                    ut.renderTarget !== Me ||
                    ut.hasDirectionalShadowLights ||
                    bt ||
                    Rt
                  ) {
                    if (
                      (this.addMainRenderPass(H, q, Me, Ce, Le, Rt),
                      tt.triggerPostprocess &&
                        it != null &&
                        it.onPostprocessing)
                    ) {
                      const Zt = new y.AH(this.device, () => {
                        this.renderPassPostprocessing(tt, q);
                      });
                      (Zt.requiresCubemaps = !1), H.addRenderPass(Zt);
                    }
                    we = !0;
                  }
                }
              }
              addMainRenderPass(H, q, se, Ce, we, Me) {
                const Ie = { start: Ce, end: we },
                  Le = new y.AH(this.device, () => {
                    this.renderPassRenderActions(q, Ie);
                  }),
                  tt = q._renderActions,
                  vt = tt[Ce],
                  it = tt[we],
                  Rt = q.layerList[vt.layerIndex].cameras[vt.cameraIndex];
                Rt &&
                  (vt.firstCameraUse &&
                    Rt.onPreRender &&
                    (Le.before = () => {
                      Rt.onPreRender();
                    }),
                  it.lastCameraUse &&
                    Rt.onPostRender &&
                    (Le.after = () => {
                      Rt.onPostRender();
                    }));
                const Ft = Me && Ue.f.requiresRenderPass(this.device, Rt);
                (!Me || Ft) &&
                  (Le.init(se),
                  (Le.fullSizeClearRect = Rt.camera.fullSizeClearRect),
                  Ft
                    ? (Le.setClearColor(Ge), Le.setClearDepth(1))
                    : Le.fullSizeClearRect &&
                      (vt.clearColor && Le.setClearColor(Rt.camera.clearColor),
                      vt.clearDepth && Le.setClearDepth(Rt.camera.clearDepth),
                      vt.clearStencil &&
                        Le.setClearStencil(Rt.camera.clearStencil))),
                  H.addRenderPass(Le);
              }
              update(H) {
                this.frameUpdate(), this.shadowRenderer.frameUpdate();
                const q = this.scene.clusteredLightingEnabled;
                this.scene._updateSky(this.device);
                const se = this.updateLayerComposition(H, q),
                  Ce = (se & c.DA) !== 0;
                this.updateLightStats(H, se),
                  this.beginFrame(H, Ce),
                  this.setSceneConstants(),
                  this.cullComposition(H),
                  this.gpuUpdate(H._meshInstances);
              }
              renderPassPostprocessing(H, q) {
                q.layerList[H.layerIndex].cameras[
                  H.cameraIndex
                ].onPostprocessing();
              }
              renderPassRenderActions(H, q) {
                const se = H._renderActions;
                for (let Ce = q.start; Ce <= q.end; Ce++)
                  this.renderRenderAction(H, se[Ce], Ce === q.start);
              }
              renderRenderAction(H, q, se) {
                const Ce = this.scene.clusteredLightingEnabled,
                  we = this.device,
                  Me = q.layerIndex,
                  Ie = H.layerList[Me],
                  Le = H.subLayerList[Me],
                  tt = q.cameraIndex,
                  vt = Ie.cameras[tt];
                if (q.isLayerEnabled(H)) {
                  if (
                    (!Le && Ie.onPreRenderOpaque
                      ? Ie.onPreRenderOpaque(tt)
                      : Le &&
                        Ie.onPreRenderTransparent &&
                        Ie.onPreRenderTransparent(tt),
                    Ie._preRenderCalledForCameras & (1 << tt) ||
                      (Ie.onPreRender && Ie.onPreRender(tt),
                      (Ie._preRenderCalledForCameras |= 1 << tt)),
                    vt)
                  ) {
                    var it, At, Rt;
                    this.setupViewport(vt.camera, q.renderTarget),
                      (!se || !vt.camera.fullSizeClearRect) &&
                        this.clear(
                          vt.camera,
                          q.clearColor,
                          q.clearDepth,
                          q.clearStencil
                        ),
                      Ie._sortVisible(Le, vt.camera.node, tt);
                    const Ft = Ie.instances,
                      ut = Le
                        ? Ft.visibleTransparent[tt]
                        : Ft.visibleOpaque[tt];
                    this.scene.immediate.onPreRenderLayer(Ie, ut, Le),
                      Ce &&
                        q.lightClusters &&
                        (q.lightClusters.activate(),
                        !this.clustersDebugRendered &&
                          this.scene.lighting.debugLayer === Ie.id &&
                          (this.clustersDebugRendered = !0)),
                      (this.scene._activeCamera = vt.camera);
                    const Pt = this.setCameraUniforms(
                      vt.camera,
                      q.renderTarget
                    );
                    we.supportsUniformBuffers &&
                      this.setupViewUniformBuffers(
                        q.viewBindGroups,
                        this.viewUniformFormat,
                        this.viewBindGroupFormat,
                        Pt
                      );
                    const bt = !!(
                        vt.camera._flipFaces ^
                        (q == null || (it = q.renderTarget) == null
                          ? void 0
                          : it.flipY)
                      ),
                      Zt =
                        (At =
                          (Rt = vt.camera.shaderPassInfo) == null
                            ? void 0
                            : Rt.index) != null
                          ? At
                          : Ie.shaderPass,
                      Xt = this._forwardDrawCalls;
                    this.renderForward(
                      vt.camera,
                      ut.list,
                      ut.length,
                      Ie._splitLights,
                      Zt,
                      Ie.onDrawCall,
                      Ie,
                      bt
                    ),
                      (Ie._forwardDrawCalls += this._forwardDrawCalls - Xt),
                      we.setBlendState(u.t.NOBLEND),
                      we.setStencilState(null, null),
                      we.setAlphaToCoverage(!1),
                      we.setDepthBias(!1);
                  }
                  !Le && Ie.onPostRenderOpaque
                    ? Ie.onPostRenderOpaque(tt)
                    : Le &&
                      Ie.onPostRenderTransparent &&
                      Ie.onPostRenderTransparent(tt),
                    Ie.onPostRender &&
                      !(Ie._postRenderCalledForCameras & (1 << tt)) &&
                      ((Ie._postRenderCounter &= ~(Le ? 2 : 1)),
                      Ie._postRenderCounter === 0 &&
                        (Ie.onPostRender(tt),
                        (Ie._postRenderCalledForCameras |= 1 << tt),
                        (Ie._postRenderCounter = Ie._postRenderCounterMax)));
                }
              }
            }
          },
          222: (xe, V, a) => {
            "use strict";
            a.d(V, { S: () => n });
            var A = a(3021),
              x = a(7481),
              y = a(8484),
              c = a(9391),
              d = a(5463),
              h = a(3035);
            const f = new y.$(),
              s = new y.$(),
              l = new y.$();
            class n {
              static create(i, e, t) {
                const r = new d.i();
                switch (
                  ((r.node = new h.t(i)),
                  (r.aspectRatio = 1),
                  (r.aspectRatioMode = c.E5),
                  (r._scissorRectClear = !0),
                  e)
                ) {
                  case c.dG:
                    r.node.setRotation(n.pointLightRotations[t]),
                      (r.fov = 90),
                      (r.projection = c.$J);
                    break;
                  case c.Gy:
                    r.projection = c.$J;
                    break;
                  case c.kx:
                    r.projection = c.RD;
                    break;
                }
                return r;
              }
              static evalSpotCookieMatrix(i) {
                let e = n._spotCookieCamera;
                e ||
                  ((e = n.create("SpotCookieCamera", c.Gy)),
                  (n._spotCookieCamera = e)),
                  (e.fov = i._outerConeAngle * 2);
                const t = e._node;
                t.setPosition(i._node.getPosition()),
                  t.setRotation(i._node.getRotation()),
                  t.rotateLocal(-90, 0, 0),
                  f.setTRS(t.getPosition(), t.getRotation(), x.e.ONE).invert(),
                  s.mul2(e.projectionMatrix, f);
                const r = i.cookieMatrix,
                  u = i.atlasViewport;
                return l.setViewport(u.x, u.y, u.z, u.w), r.mul2(l, s), r;
              }
            }
            (n.pointLightRotations = [
              new A.k().setFromEulerAngles(0, 90, 180),
              new A.k().setFromEulerAngles(0, -90, 180),
              new A.k().setFromEulerAngles(90, 0, 0),
              new A.k().setFromEulerAngles(-90, 0, 0),
              new A.k().setFromEulerAngles(0, 180, 180),
              new A.k().setFromEulerAngles(0, 0, 180),
            ]),
              (n._spotCookieCamera = null);
          },
          5520: (xe, V, a) => {
            "use strict";
            a.d(V, { u: () => M });
            var A = a(5227),
              x = a(8484),
              y = a(7481),
              c = a(5596),
              d = a(1630),
              h = a(8524),
              f = a(9391),
              s = a(4639),
              l = a(2910),
              n = a(333),
              o = a(222),
              i = a(5224),
              e = a(6252),
              t = a(1268),
              r = a(4870);
            function u(R, P) {
              return Math.exp(-(R * R) / (2 * P * P));
            }
            function v(R) {
              const P = (R - 1) / 6,
                F = (R - 1) * 0.5,
                b = new Array(R);
              let D = 0;
              for (let G = 0; G < R; ++G) (b[G] = u(G - F, P)), (D += b[G]);
              for (let G = 0; G < R; ++G) b[G] /= D;
              return b;
            }
            const _ = new x.$(),
              m = new x.$(),
              g = new Float32Array(2),
              T = new c.Z(1, 1, 0, 0),
              E = new x.$();
            class M {
              constructor(P, F) {
                (this.shadowPassCache = []),
                  (this.device = P.device),
                  (this.renderer = P),
                  (this.lightTextureAtlas = F);
                const b = this.device.scope;
                (this.polygonOffsetId = b.resolve("polygonOffset")),
                  (this.polygonOffset = new Float32Array(2)),
                  (this.sourceId = b.resolve("source")),
                  (this.pixelOffsetId = b.resolve("pixelOffset")),
                  (this.weightId = b.resolve("weight[0]")),
                  (this.blurVsmShaderCode = [
                    l.G.blurVSMPS,
                    `#define GAUSS
` + l.G.blurVSMPS,
                  ]);
                const D = `#define PACKED
`;
                (this.blurPackedVsmShaderCode = [
                  D + this.blurVsmShaderCode[0],
                  D + this.blurVsmShaderCode[1],
                ]),
                  (this.blurVsmShader = [{}, {}]),
                  (this.blurPackedVsmShader = [{}, {}]),
                  (this.blurVsmWeights = {}),
                  (this.shadowMapLightRadiusId = b.resolve("light_radius")),
                  (this.viewUniformFormat = null),
                  (this.viewBindGroupFormat = null),
                  (this.blendStateWrite = new t.t()),
                  (this.blendStateNoWrite = new t.t()),
                  this.blendStateNoWrite.setColorWrite(!1, !1, !1, !1);
              }
              static createShadowCamera(P, F, b, D) {
                const G = o.S.create("ShadowCamera", b, D);
                return (
                  F >= f.oR && F <= f.DT
                    ? (G.clearColor = new A.Q(0, 0, 0, 0))
                    : (G.clearColor = new A.Q(1, 1, 1, 1)),
                  (G.clearDepthBuffer = !0),
                  (G.clearStencilBuffer = !1),
                  G
                );
              }
              static setShadowCameraSettings(P, F, b, D, G) {
                let X =
                  b === f.Mq ||
                  ((b === f.Mk || b === f.MF) && F.supportsDepthShadow);
                D === f.dG && !G && (X = !1), (P.clearColorBuffer = !X);
              }
              cullShadowCasters(P, F, b) {
                let D = 0;
                const G = P.length;
                for (let X = 0; X < G; X++) {
                  const ie = P[X];
                  ie.castShadow &&
                    (!ie.cull || ie._isVisible(b)) &&
                    ((ie.visibleThisFrame = !0), (F[D] = ie), D++);
                }
                (F.length = D), F.sort(this.renderer.sortCompareDepth);
              }
              setupRenderState(P, F) {
                const b = this.renderer.scene.clusteredLightingEnabled;
                P.webgl2 || P.isWebGPU
                  ? F._type === f.dG && !b
                    ? P.setDepthBias(!1)
                    : (P.setDepthBias(!0),
                      P.setDepthBiasValues(
                        F.shadowBias * -1e3,
                        F.shadowBias * -1e3
                      ))
                  : P.extStandardDerivatives &&
                    (F._type === f.dG
                      ? ((this.polygonOffset[0] = 0),
                        (this.polygonOffset[1] = 0),
                        this.polygonOffsetId.setValue(this.polygonOffset))
                      : ((this.polygonOffset[0] = F.shadowBias * -1e3),
                        (this.polygonOffset[1] = F.shadowBias * -1e3),
                        this.polygonOffsetId.setValue(this.polygonOffset)));
                const D = P.webgl2 || P.isWebGPU,
                  G = b ? F._isPcf && D : F._isPcf && D && F._type !== f.dG;
                P.setBlendState(
                  G ? this.blendStateNoWrite : this.blendStateWrite
                ),
                  P.setDepthState(r.H.DEFAULT),
                  P.setStencilState(null, null);
              }
              restoreRenderState(P) {
                P.webgl2 || P.isWebGPU
                  ? P.setDepthBias(!1)
                  : P.extStandardDerivatives &&
                    ((this.polygonOffset[0] = 0),
                    (this.polygonOffset[1] = 0),
                    this.polygonOffsetId.setValue(this.polygonOffset));
              }
              dispatchUniforms(P, F, b, D) {
                const G = F._node;
                P._type !== f.kx &&
                  (this.renderer.dispatchViewPos(G.getPosition()),
                  this.shadowMapLightRadiusId.setValue(P.attenuationEnd)),
                  _.setTRS(G.getPosition(), G.getRotation(), y.e.ONE).invert(),
                  m.mul2(F.projectionMatrix, _);
                const X = b.shadowViewport;
                (F.rect = X),
                  (F.scissorRect = b.shadowScissor),
                  E.setViewport(X.x, X.y, X.z, X.w),
                  b.shadowMatrix.mul2(E, m),
                  P._type === f.kx &&
                    P._shadowMatrixPalette.set(b.shadowMatrix.data, D * 16);
              }
              getShadowPass(P) {
                var F;
                const b = P._type,
                  D = P._shadowType;
                let G = (F = this.shadowPassCache[b]) == null ? void 0 : F[D];
                if (!G) {
                  const X = `ShadowPass_${b}_${D}`;
                  (G = s.p
                    .get(this.device)
                    .allocate(X, {
                      isShadow: !0,
                      lightType: b,
                      shadowType: D,
                    })),
                    this.shadowPassCache[b] || (this.shadowPassCache[b] = []),
                    (this.shadowPassCache[b][D] = G);
                }
                return G.index;
              }
              submitCasters(P, F) {
                const b = this.device,
                  D = this.renderer,
                  G = D.scene,
                  X = 1 << f.vT,
                  ie = this.getShadowPass(F),
                  Q = P.length;
                for (let te = 0; te < Q; te++) {
                  const ae = P[te],
                    Z = ae.mesh;
                  ae.ensureMaterial(b);
                  const J = ae.material;
                  D.setBaseConstants(b, J),
                    D.setSkinning(b, ae),
                    J.dirty && (J.updateUniforms(b, G), (J.dirty = !1)),
                    J.chunks &&
                      (D.setupCullMode(!0, 1, ae),
                      J.setParameters(b),
                      ae.setParameters(b, X));
                  const ve = ae.getShaderInstance(
                      ie,
                      0,
                      G,
                      this.viewUniformFormat,
                      this.viewBindGroupFormat
                    ),
                    _e = ve.shader;
                  (ae._key[f.pB] = _e.id),
                    !_e.failed && b.setShader(_e),
                    D.setVertexBuffers(b, Z),
                    D.setMorphing(b, ae.morphInstance),
                    this.renderer.setupMeshUniformBuffers(ve, ae);
                  const L = ae.renderStyle;
                  b.setIndexBuffer(Z.indexBuffer[L]),
                    D.drawInstance(b, ae, Z, L),
                    D._shadowDrawCalls++;
                }
              }
              needsShadowRendering(P) {
                const F =
                  P.enabled &&
                  P.castShadows &&
                  P.shadowUpdateMode !== f.Jb &&
                  P.visibleThisFrame;
                return (
                  P.shadowUpdateMode === f.e3 && (P.shadowUpdateMode = f.Jb),
                  F && (this.renderer._shadowMapUpdates += P.numShadowFaces),
                  F
                );
              }
              getLightRenderData(P, F, b) {
                return P.getRenderData(P._type === f.kx ? F : null, b);
              }
              setupRenderPass(P, F, b) {
                const D = F.renderTarget;
                P.init(D),
                  (P.depthStencilOps.clearDepthValue = 1),
                  (P.depthStencilOps.clearDepth = b),
                  D.depthBuffer
                    ? (P.depthStencilOps.storeDepth = !0)
                    : (P.colorOps.clearValue.copy(F.clearColor),
                      (P.colorOps.clear = b),
                      (P.depthStencilOps.storeDepth = !1)),
                  (P.requiresCubemaps = !1);
              }
              prepareFace(P, F, b) {
                const D = P._type,
                  G = P._shadowType,
                  X = this.renderer.scene.clusteredLightingEnabled,
                  Q = this.getLightRenderData(P, F, b).shadowCamera;
                M.setShadowCameraSettings(Q, this.device, G, D, X);
                const te = D === f.kx ? 0 : b;
                return (Q.renderTarget = P._shadowMap.renderTargets[te]), Q;
              }
              renderFace(P, F, b, D, G = !0) {
                const X = this.device,
                  ie = this.getLightRenderData(P, F, b),
                  Q = ie.shadowCamera;
                this.dispatchUniforms(P, Q, ie, b);
                const te = Q.renderTarget,
                  ae = this.renderer;
                ae.setCameraUniforms(Q, te),
                  X.supportsUniformBuffers &&
                    ae.setupViewUniformBuffers(
                      ie.viewBindGroups,
                      this.viewUniformFormat,
                      this.viewBindGroupFormat,
                      1
                    ),
                  G
                    ? (ae.setupViewport(Q, te), D && ae.clear(Q))
                    : ae.clearView(Q, te, !0, !1),
                  this.setupRenderState(X, P),
                  this.submitCasters(ie.visibleCasters, P),
                  this.restoreRenderState(X);
              }
              render(P, F, b = !0) {
                if (this.needsShadowRendering(P)) {
                  const D = P.numShadowFaces;
                  for (let G = 0; G < D; G++)
                    this.prepareFace(P, F, G), this.renderFace(P, F, G, !0, b);
                  this.renderVsm(P, F);
                }
              }
              renderVsm(P, F) {
                P._isVsm &&
                  P._vsmBlurSize > 1 &&
                  (!this.renderer.scene.clusteredLightingEnabled ||
                    P._type === f.kx) &&
                  this.applyVsmBlur(P, F);
              }
              getVsmBlurShader(P, F, b) {
                let D = (P ? this.blurPackedVsmShader : this.blurVsmShader)[F][
                  b
                ];
                if (!D) {
                  this.blurVsmWeights[b] = v(b);
                  const G = l.G.fullscreenQuadVS;
                  let X =
                    "#define SAMPLES " +
                    b +
                    `
`;
                  P
                    ? (X += this.blurPackedVsmShaderCode[F])
                    : (X += this.blurVsmShaderCode[F]);
                  const ie = "blurVsm" + F + b + P;
                  (D = (0, n.$$)(this.device, G, X, ie)),
                    P
                      ? (this.blurPackedVsmShader[F][b] = D)
                      : (this.blurVsmShader[F][b] = D);
                }
                return D;
              }
              applyVsmBlur(P, F) {
                const b = this.device;
                b.setBlendState(t.t.NOBLEND);
                const X = P.getRenderData(P._type === f.kx ? F : null, 0)
                    .shadowCamera.renderTarget,
                  ie = this.renderer.shadowMapCache.get(b, P),
                  Q = ie.renderTargets[0],
                  te = P._shadowType === f.oR,
                  ae = P.vsmBlurMode,
                  Z = P._vsmBlurSize,
                  J = this.getVsmBlurShader(te, ae, Z);
                (T.z = P._shadowResolution - 2),
                  (T.w = T.z),
                  this.sourceId.setValue(X.colorBuffer),
                  (g[0] = 1 / P._shadowResolution),
                  (g[1] = 0),
                  this.pixelOffsetId.setValue(g),
                  ae === f.wA && this.weightId.setValue(this.blurVsmWeights[Z]),
                  (0, h.l)(b, Q, J, null, T),
                  this.sourceId.setValue(Q.colorBuffer),
                  (g[1] = g[0]),
                  (g[0] = 0),
                  this.pixelOffsetId.setValue(g),
                  (0, h.l)(b, X, J, null, T),
                  this.renderer.shadowMapCache.add(P, ie);
              }
              initViewBindGroupFormat() {
                this.device.supportsUniformBuffers &&
                  !this.viewUniformFormat &&
                  ((this.viewUniformFormat = new i.Q(this.device, [
                    new i.g("matrix_viewProjection", d.CPw),
                  ])),
                  (this.viewBindGroupFormat = new e.a$(
                    this.device,
                    [new e.Xq(d.rb7, d.rXb | d.Jnj)],
                    []
                  )));
              }
              frameUpdate() {
                this.initViewBindGroupFormat();
              }
            }
          },
          1036: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => te });
            var A = a(8976),
              x = a(5227),
              y = a(7481),
              c = a(3021),
              d = a(8656),
              h = a(2209),
              f = a(8484),
              s = a(8136),
              l = a(1630),
              n = a(9391),
              o = a(8568),
              i = a(8531),
              e = a(3035),
              t = a(2658),
              r = a(3637),
              u = a(783),
              v = a(2910),
              _ = a(725),
              m = a(4559),
              g = a(9855);
            const T = {
              generateKey: function (ae) {
                return ae.type === "cubemap"
                  ? `skybox-${ae.type}-${ae.encoding}-${ae.useIntensity}-${ae.gamma}-${ae.toneMapping}-${ae.fixSeams}-${ae.mip}`
                  : `skybox-${ae.type}-${ae.encoding}-${ae.useIntensity}-${ae.gamma}-${ae.toneMapping}`;
              },
              createShaderDefinition: function (ae, Z) {
                let J = "";
                if (Z.type === "cubemap") {
                  const ve = [128, 64, 16, 8, 4, 2];
                  (J += Z.mip
                    ? v.G.fixCubemapSeamsStretchPS
                    : v.G.fixCubemapSeamsNonePS),
                    (J += Z.useIntensity ? v.G.envMultiplyPS : v.G.envConstPS),
                    (J += v.G.decodePS),
                    (J += (0, m.PY)(Z.gamma)),
                    (J += (0, m.K)(Z.toneMapping)),
                    (J += v.G.skyboxHDRPS
                      .replace(/\$DECODE/g, _.N.decodeFunc(Z.encoding))
                      .replace(/\$FIXCONST/g, 1 - 1 / ve[Z.mip] + ""));
                } else
                  (J += Z.useIntensity ? v.G.envMultiplyPS : v.G.envConstPS),
                    (J += v.G.decodePS),
                    (J += (0, m.PY)(Z.gamma)),
                    (J += (0, m.K)(Z.toneMapping)),
                    (J += v.G.sphericalPS),
                    (J += v.G.envAtlasPS),
                    (J += v.G.skyboxEnvPS.replace(
                      /\$DECODE/g,
                      _.N.decodeFunc(Z.encoding)
                    ));
                return g.l.createDefinition(ae, {
                  name: "SkyboxShader",
                  attributes: { aPosition: l.JYe },
                  vertexCode: v.G.skyboxVS,
                  fragmentCode: J,
                });
              },
            };
            class E {
              constructor(Z, J, ve) {
                this.meshInstance = void 0;
                const _e = new t.i();
                (_e.getShaderVariant = function (ge, k, j, B, $, le, O, Y) {
                  const ne = {
                    pass: $,
                    encoding: ve.encoding,
                    useIntensity: J.skyboxIntensity !== 1 || J.physicalUnits,
                    gamma:
                      $ === n.Su
                        ? J.gammaCorrection
                          ? n.Rz
                          : n.hc
                        : J.gammaCorrection,
                    toneMapping: $ === n.Su ? n.ll : J.toneMapping,
                  };
                  ve.cubemap
                    ? ((ne.type = "cubemap"),
                      (ne.mip = ve.fixCubemapSeams ? J.skyboxMip : 0),
                      (ne.fixSeams = ve.fixCubemapSeams))
                    : (ne.type = "envAtlas");
                  const de = new o.c(O, Y),
                    re = (0, u.k)(Z);
                  return (
                    re.register("skybox", T), re.getProgram("skybox", ne, de)
                  );
                }),
                  ve.cubemap
                    ? _e.setParameter("texture_cubeMap", ve)
                    : (_e.setParameter("texture_envAtlas", ve),
                      _e.setParameter("mipLevel", J._skyboxMip)),
                  (_e.cull = l.CWw),
                  (_e.depthWrite = !1);
                const L = J.layers.getLayerById(n.CT);
                if (L) {
                  const ge = new e.t("Skybox"),
                    k = (0, i.ge)(Z),
                    j = new r.F(k, _e, ge);
                  (this.meshInstance = j),
                    (j.cull = !1),
                    (j._noDepthDrawGl1 = !0),
                    (j.pick = !1),
                    L.addMeshInstances([j]),
                    (this.skyLayer = L);
                }
              }
              destroy() {
                this.meshInstance &&
                  (this.skyLayer &&
                    this.skyLayer.removeMeshInstances([this.meshInstance]),
                  this.meshInstance.destroy(),
                  (this.meshInstance = null));
              }
            }
            var M = a(818),
              R = a(7197),
              P = a(597),
              F = a(333);
            const b = new e.t();
            (b.worldTransform = f.$.IDENTITY),
              (b._dirtyWorld = b._dirtyNormal = !1);
            class D {
              constructor(Z, J, ve) {
                (this.material = J),
                  (this.layer = ve),
                  (this.positions = []),
                  (this.colors = []),
                  (this.mesh = new R.e(Z)),
                  (this.meshInstance = null);
              }
              addLines(Z, J) {
                const ve = this.positions,
                  _e = Z.length;
                for (let ge = 0; ge < _e; ge++) {
                  const k = Z[ge];
                  ve.push(k.x, k.y, k.z);
                }
                const L = this.colors;
                if (J.length)
                  for (let ge = 0; ge < _e; ge++) {
                    const k = J[ge];
                    L.push(k.r, k.g, k.b, k.a);
                  }
                else for (let ge = 0; ge < _e; ge++) L.push(J.r, J.g, J.b, J.a);
              }
              addLinesArrays(Z, J) {
                const ve = this.positions;
                for (let L = 0; L < Z.length; L += 3)
                  ve.push(Z[L], Z[L + 1], Z[L + 2]);
                const _e = this.colors;
                if (J.length)
                  for (let L = 0; L < J.length; L += 4)
                    _e.push(J[L], J[L + 1], J[L + 2], J[L + 3]);
                else {
                  const L = Z.length / 3;
                  for (let ge = 0; ge < L; ge++) _e.push(J.r, J.g, J.b, J.a);
                }
              }
              onPreRender(Z, J) {
                this.positions.length > 0 &&
                  this.material.transparent === J &&
                  (this.mesh.setPositions(this.positions),
                  this.mesh.setColors(this.colors),
                  this.mesh.update(l.EEU, !1),
                  this.meshInstance ||
                    (this.meshInstance = new r.F(this.mesh, this.material, b)),
                  (this.positions.length = 0),
                  (this.colors.length = 0),
                  Z.list.push(this.meshInstance),
                  Z.length++);
              }
            }
            class G {
              constructor(Z) {
                (this.device = Z), (this.map = new Map());
              }
              getBatch(Z, J) {
                let ve = this.map.get(Z);
                return (
                  ve || ((ve = new D(this.device, Z, J)), this.map.set(Z, ve)),
                  ve
                );
              }
              onPreRender(Z, J) {
                this.map.forEach((ve) => {
                  ve.onPreRender(Z, J);
                });
              }
            }
            const X = [];
            class ie {
              constructor(Z) {
                (this.device = Z),
                  (this.quadMesh = null),
                  (this.textureShader = null),
                  (this.depthTextureShader = null),
                  (this.cubeLocalPos = null),
                  (this.cubeWorldPos = null),
                  (this.batchesMap = new Map()),
                  (this.allBatches = new Set()),
                  (this.updatedLayers = new Set()),
                  (this._materialDepth = null),
                  (this._materialNoDepth = null),
                  (this.layerMeshInstances = new Map());
              }
              createMaterial(Z) {
                const J = new P.E();
                return (
                  (J.vertexColors = !0),
                  (J.blendType = n.i9),
                  (J.depthTest = Z),
                  J.update(),
                  J
                );
              }
              get materialDepth() {
                return (
                  this._materialDepth ||
                    (this._materialDepth = this.createMaterial(!0)),
                  this._materialDepth
                );
              }
              get materialNoDepth() {
                return (
                  this._materialNoDepth ||
                    (this._materialNoDepth = this.createMaterial(!1)),
                  this._materialNoDepth
                );
              }
              getBatch(Z, J) {
                let ve = this.batchesMap.get(Z);
                ve || ((ve = new G(this.device)), this.batchesMap.set(Z, ve)),
                  this.allBatches.add(ve);
                const _e = J ? this.materialDepth : this.materialNoDepth;
                return ve.getBatch(_e, Z);
              }
              getShader(Z, J) {
                if (!this[Z]) {
                  const ve = `
								attribute vec2 vertex_position;
								uniform mat4 matrix_model;
								varying vec2 uv0;
								void main(void) {
										gl_Position = matrix_model * vec4(vertex_position, 0, 1);
										uv0 = vertex_position.xy + 0.5;
								}
						`;
                  this[Z] = (0, F.$$)(this.device, ve, J, `DebugShader:${Z}`);
                }
                return this[Z];
              }
              getTextureShader() {
                return this.getShader(
                  "textureShader",
                  `
						varying vec2 uv0;
						uniform sampler2D colorMap;
						void main (void) {
								gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);
						}
				`
                );
              }
              getUnfilterableTextureShader() {
                return this.getShader(
                  "textureShaderUnfilterable",
                  `
						varying vec2 uv0;
						uniform highp sampler2D colorMap;
						void main (void) {
								ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));
								gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);
						}
				`
                );
              }
              getDepthTextureShader() {
                return this.getShader(
                  "depthTextureShader",
                  `
						${v.G.screenDepthPS}
						varying vec2 uv0;
						void main() {
								float depth = getLinearScreenDepth(uv0) * camera_params.x;
								gl_FragColor = vec4(vec3(depth), 1.0);
						}
				`
                );
              }
              getQuadMesh() {
                return (
                  this.quadMesh ||
                    ((this.quadMesh = new R.e(this.device)),
                    this.quadMesh.setPositions([
                      -0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0,
                    ]),
                    this.quadMesh.update(l.SF$)),
                  this.quadMesh
                );
              }
              drawMesh(Z, J, ve, _e, L) {
                if (!_e) {
                  const k = this.getGraphNode(J);
                  _e = new r.F(ve, Z, k);
                }
                let ge = this.layerMeshInstances.get(L);
                ge || ((ge = []), this.layerMeshInstances.set(L, ge)),
                  ge.push(_e);
              }
              drawWireAlignedBox(Z, J, ve, _e, L) {
                X.push(
                  Z.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  J.y,
                  Z.z,
                  Z.x,
                  J.y,
                  Z.z,
                  J.x,
                  J.y,
                  Z.z,
                  J.x,
                  J.y,
                  Z.z,
                  J.x,
                  Z.y,
                  Z.z,
                  J.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Z.y,
                  J.z,
                  Z.x,
                  J.y,
                  J.z,
                  Z.x,
                  J.y,
                  J.z,
                  J.x,
                  J.y,
                  J.z,
                  J.x,
                  J.y,
                  J.z,
                  J.x,
                  Z.y,
                  J.z,
                  J.x,
                  Z.y,
                  J.z,
                  Z.x,
                  Z.y,
                  J.z,
                  Z.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Z.y,
                  J.z,
                  Z.x,
                  J.y,
                  Z.z,
                  Z.x,
                  J.y,
                  J.z,
                  J.x,
                  J.y,
                  Z.z,
                  J.x,
                  J.y,
                  J.z,
                  J.x,
                  Z.y,
                  Z.z,
                  J.x,
                  Z.y,
                  J.z
                ),
                  this.getBatch(L, _e).addLinesArrays(X, ve),
                  (X.length = 0);
              }
              drawWireSphere(Z, J, ve, _e, L, ge) {
                const k = (2 * Math.PI) / _e;
                let j = 0;
                for (let $ = 0; $ < _e; $++) {
                  const le = Math.sin(j),
                    O = Math.cos(j);
                  j += k;
                  const Y = Math.sin(j),
                    ne = Math.cos(j);
                  X.push(Z.x + J * le, Z.y, Z.z + J * O),
                    X.push(Z.x + J * Y, Z.y, Z.z + J * ne),
                    X.push(Z.x + J * le, Z.y + J * O, Z.z),
                    X.push(Z.x + J * Y, Z.y + J * ne, Z.z),
                    X.push(Z.x, Z.y + J * le, Z.z + J * O),
                    X.push(Z.x, Z.y + J * Y, Z.z + J * ne);
                }
                this.getBatch(ge, L).addLinesArrays(X, ve), (X.length = 0);
              }
              getGraphNode(Z) {
                const J = new e.t("ImmediateDebug");
                return (
                  (J.worldTransform = Z),
                  (J._dirtyWorld = J._dirtyNormal = !1),
                  J
                );
              }
              onPreRenderLayer(Z, J, ve) {
                if (
                  (this.batchesMap.forEach((_e, L) => {
                    L === Z && _e.onPreRender(J, ve);
                  }),
                  !this.updatedLayers.has(Z))
                ) {
                  this.updatedLayers.add(Z);
                  const _e = this.layerMeshInstances.get(Z);
                  if (_e) {
                    for (let L = 0; L < _e.length; L++)
                      J.list[J.length + L] = _e[L];
                    (J.length += _e.length), (_e.length = 0);
                  }
                }
              }
              onPostRender() {
                this.allBatches.clear(), this.updatedLayers.clear();
              }
            }
            var Q = a(3362);
            class te extends A.J {
              constructor(Z) {
                super(),
                  (this.ambientBake = !1),
                  (this.ambientBakeOcclusionBrightness = 0),
                  (this.ambientBakeOcclusionContrast = 0),
                  (this.ambientLight = new x.Q(0, 0, 0)),
                  (this.ambientLuminance = 0),
                  (this.exposure = 1),
                  (this.fogColor = new x.Q(0, 0, 0)),
                  (this.fogDensity = 0),
                  (this.fogEnd = 1e3),
                  (this.fogStart = 1),
                  (this.lightmapSizeMultiplier = 1),
                  (this.lightmapMaxResolution = 2048),
                  (this.lightmapMode = n.N9),
                  (this.lightmapFilterEnabled = !1),
                  (this.lightmapHDR = !1),
                  (this.root = null),
                  (this.sky = null),
                  (this.physicalUnits = !1),
                  (this.device = Z || s.A.get()),
                  (this._gravity = new y.e(0, -9.8, 0)),
                  (this._layers = null),
                  (this._fog = n.qX),
                  (this._gammaCorrection = n.Jd),
                  (this._toneMapping = 0),
                  (this._skyboxCubeMap = null),
                  (this._prefilteredCubemaps = []),
                  (this._envAtlas = null),
                  (this._internalEnvAtlas = null),
                  (this._skyboxIntensity = 1),
                  (this._skyboxLuminance = 0),
                  (this._skyboxMip = 0),
                  (this._skyboxRotationShaderInclude = !1),
                  (this._skyboxRotation = new c.k()),
                  (this._skyboxRotationMat3 = new h.U()),
                  (this._skyboxRotationMat4 = new f.$()),
                  (this._ambientBakeNumSamples = 1),
                  (this._ambientBakeSpherePart = 0.4),
                  (this._lightmapFilterRange = 10),
                  (this._lightmapFilterSmoothness = 0.2),
                  (this._clusteredLightingEnabled = !0),
                  (this._lightingParams = new M.p(
                    this.device.supportsAreaLights,
                    this.device.maxTextureSize,
                    () => {
                      this._layers._dirtyLights = !0;
                    }
                  )),
                  (this._stats = {
                    meshInstances: 0,
                    lights: 0,
                    dynamicLights: 0,
                    bakedLights: 0,
                    updateShadersTime: 0,
                  }),
                  (this.updateShaders = !0),
                  (this._shaderVersion = 0),
                  (this._statsUpdated = !1),
                  (this.immediate = new ie(this.device));
              }
              get defaultDrawLayer() {
                return this.layers.getLayerById(n.t0);
              }
              set ambientBakeNumSamples(Z) {
                this._ambientBakeNumSamples = d.D.clamp(Math.floor(Z), 1, 255);
              }
              get ambientBakeNumSamples() {
                return this._ambientBakeNumSamples;
              }
              set ambientBakeSpherePart(Z) {
                this._ambientBakeSpherePart = d.D.clamp(Z, 0.001, 1);
              }
              get ambientBakeSpherePart() {
                return this._ambientBakeSpherePart;
              }
              set clusteredLightingEnabled(Z) {
                if (!(this.device.isWebGPU && !Z)) {
                  if (!this._clusteredLightingEnabled && Z) {
                    console.error(
                      "Turning on disabled clustered lighting is not currently supported"
                    );
                    return;
                  }
                  this._clusteredLightingEnabled = Z;
                }
              }
              get clusteredLightingEnabled() {
                return this._clusteredLightingEnabled;
              }
              set drawCalls(Z) {}
              get drawCalls() {
                let Z = this.layers._meshInstances;
                return (
                  Z.length ||
                    (this.layers._update(
                      this.device,
                      this.clusteredLightingEnabled
                    ),
                    (Z = this.layers._meshInstances)),
                  Z
                );
              }
              set envAtlas(Z) {
                Z !== this._envAtlas &&
                  ((this._envAtlas = Z),
                  Z &&
                    ((Z.addressU = l.vq6),
                    (Z.addressV = l.vq6),
                    (Z.minFilter = l.DrA),
                    (Z.magFilter = l.DrA),
                    (Z.mipmaps = !1)),
                  (this._prefilteredCubemaps = []),
                  this._internalEnvAtlas &&
                    (this._internalEnvAtlas.destroy(),
                    (this._internalEnvAtlas = null)),
                  this._resetSky());
              }
              get envAtlas() {
                return this._envAtlas;
              }
              set fog(Z) {
                Z !== this._fog && ((this._fog = Z), (this.updateShaders = !0));
              }
              get fog() {
                return this._fog;
              }
              set gammaCorrection(Z) {
                Z !== this._gammaCorrection &&
                  ((this._gammaCorrection = Z), (this.updateShaders = !0));
              }
              get gammaCorrection() {
                return this._gammaCorrection;
              }
              set layers(Z) {
                const J = this._layers;
                (this._layers = Z), this.fire("set:layers", J, Z);
              }
              get layers() {
                return this._layers;
              }
              get lighting() {
                return this._lightingParams;
              }
              set lightmapFilterRange(Z) {
                this._lightmapFilterRange = Math.max(Z, 0.001);
              }
              get lightmapFilterRange() {
                return this._lightmapFilterRange;
              }
              set lightmapFilterSmoothness(Z) {
                this._lightmapFilterSmoothness = Math.max(Z, 0.001);
              }
              get lightmapFilterSmoothness() {
                return this._lightmapFilterSmoothness;
              }
              set prefilteredCubemaps(Z) {
                Z = Z || [];
                const J = this._prefilteredCubemaps;
                (J.length !== Z.length || J.some((_e, L) => _e !== Z[L])) &&
                  (Z.length === 6 && Z.every((L) => !!L)
                    ? ((this._internalEnvAtlas = Q.S.generatePrefilteredAtlas(
                        Z,
                        { target: this._internalEnvAtlas }
                      )),
                      (this._envAtlas = this._internalEnvAtlas))
                    : (this._internalEnvAtlas &&
                        (this._internalEnvAtlas.destroy(),
                        (this._internalEnvAtlas = null)),
                      (this._envAtlas = null)),
                  (this._prefilteredCubemaps = Z.slice()),
                  this._resetSky());
              }
              get prefilteredCubemaps() {
                return this._prefilteredCubemaps;
              }
              set skybox(Z) {
                Z !== this._skyboxCubeMap &&
                  ((this._skyboxCubeMap = Z), this._resetSky());
              }
              get skybox() {
                return this._skyboxCubeMap;
              }
              set skyboxIntensity(Z) {
                Z !== this._skyboxIntensity &&
                  ((this._skyboxIntensity = Z), this._resetSky());
              }
              get skyboxIntensity() {
                return this._skyboxIntensity;
              }
              set skyboxLuminance(Z) {
                Z !== this._skyboxLuminance &&
                  ((this._skyboxLuminance = Z), this._resetSky());
              }
              get skyboxLuminance() {
                return this._skyboxLuminance;
              }
              set skyboxMip(Z) {
                Z !== this._skyboxMip &&
                  ((this._skyboxMip = Z), this._resetSky());
              }
              get skyboxMip() {
                return this._skyboxMip;
              }
              set skyboxRotation(Z) {
                if (!this._skyboxRotation.equals(Z)) {
                  const J = Z.equals(c.k.IDENTITY);
                  this._skyboxRotation.copy(Z),
                    J
                      ? this._skyboxRotationMat3.setIdentity()
                      : (this._skyboxRotationMat4.setTRS(y.e.ZERO, Z, y.e.ONE),
                        this._skyboxRotationMat4.invertTo3x3(
                          this._skyboxRotationMat3
                        )),
                    !this._skyboxRotationShaderInclude &&
                      !J &&
                      ((this._skyboxRotationShaderInclude = !0),
                      this._resetSky());
                }
              }
              get skyboxRotation() {
                return this._skyboxRotation;
              }
              set toneMapping(Z) {
                Z !== this._toneMapping &&
                  ((this._toneMapping = Z), (this.updateShaders = !0));
              }
              get toneMapping() {
                return this._toneMapping;
              }
              destroy() {
                this._resetSky(), (this.root = null), this.off();
              }
              drawLine(
                Z,
                J,
                ve = x.Q.WHITE,
                _e = !0,
                L = this.defaultDrawLayer
              ) {
                this.immediate.getBatch(L, _e).addLines([Z, J], [ve, ve]);
              }
              drawLines(Z, J, ve = !0, _e = this.defaultDrawLayer) {
                this.immediate.getBatch(_e, ve).addLines(Z, J);
              }
              drawLineArrays(Z, J, ve = !0, _e = this.defaultDrawLayer) {
                this.immediate.getBatch(_e, ve).addLinesArrays(Z, J);
              }
              applySettings(Z) {
                var J, ve, _e;
                const L = Z.physics,
                  ge = Z.render;
                this._gravity.set(L.gravity[0], L.gravity[1], L.gravity[2]),
                  this.ambientLight.set(
                    ge.global_ambient[0],
                    ge.global_ambient[1],
                    ge.global_ambient[2]
                  ),
                  (this.ambientLuminance = ge.ambientLuminance),
                  (this._fog = ge.fog),
                  this.fogColor.set(
                    ge.fog_color[0],
                    ge.fog_color[1],
                    ge.fog_color[2]
                  ),
                  (this.fogStart = ge.fog_start),
                  (this.fogEnd = ge.fog_end),
                  (this.fogDensity = ge.fog_density),
                  (this._gammaCorrection = ge.gamma_correction),
                  (this._toneMapping = ge.tonemapping),
                  (this.lightmapSizeMultiplier = ge.lightmapSizeMultiplier),
                  (this.lightmapMaxResolution = ge.lightmapMaxResolution),
                  (this.lightmapMode = ge.lightmapMode),
                  (this.exposure = ge.exposure),
                  (this._skyboxIntensity =
                    (J = ge.skyboxIntensity) != null ? J : 1),
                  (this._skyboxLuminance =
                    (ve = ge.skyboxLuminance) != null ? ve : 2e4),
                  (this._skyboxMip = (_e = ge.skyboxMip) != null ? _e : 0),
                  ge.skyboxRotation &&
                    (this.skyboxRotation = new c.k().setFromEulerAngles(
                      ge.skyboxRotation[0],
                      ge.skyboxRotation[1],
                      ge.skyboxRotation[2]
                    )),
                  (this.clusteredLightingEnabled = ge.clusteredLightingEnabled),
                  this.lighting.applySettings(ge),
                  [
                    "lightmapFilterEnabled",
                    "lightmapFilterRange",
                    "lightmapFilterSmoothness",
                    "ambientBake",
                    "ambientBakeNumSamples",
                    "ambientBakeSpherePart",
                    "ambientBakeOcclusionBrightness",
                    "ambientBakeOcclusionContrast",
                  ].forEach((k) => {
                    ge.hasOwnProperty(k) && (this[k] = ge[k]);
                  }),
                  this._resetSky();
              }
              _getSkyboxTex() {
                const Z = this._prefilteredCubemaps;
                return this._skyboxMip
                  ? Z[[0, 1, 3, 4, 5, 6][this._skyboxMip]] ||
                      this._envAtlas ||
                      Z[0] ||
                      this._skyboxCubeMap
                  : this._skyboxCubeMap || Z[0] || this._envAtlas;
              }
              _updateSky(Z) {
                if (!this.sky) {
                  const J = this._getSkyboxTex();
                  J &&
                    ((this.sky = new E(Z, this, J)),
                    this.fire("set:skybox", J));
                }
              }
              _resetSky() {
                var Z;
                (Z = this.sky) == null || Z.destroy(),
                  (this.sky = null),
                  (this.updateShaders = !0);
              }
              setSkybox(Z) {
                Z
                  ? ((this.skybox = Z[0] || null),
                    Z[1] && !Z[1].cubemap
                      ? (this.envAtlas = Z[1])
                      : (this.prefilteredCubemaps = Z.slice(1)))
                  : ((this.skybox = null), (this.envAtlas = null));
              }
              get lightmapPixelFormat() {
                return (
                  (this.lightmapHDR &&
                    this.device.getHdrFormat(!1, !0, !1, !0)) ||
                  l.Lxj
                );
              }
            }
          },
          7835: (xe, V, a) => {
            "use strict";
            a.d(V, { v: () => A });
            class A {
              constructor() {
                this.code = "";
              }
              append(...y) {
                y.forEach((c) => {
                  c.endsWith(`
`)
                    ? (this.code += c)
                    : (this.code +=
                        c +
                        `
`);
                });
              }
              prepend(...y) {
                y.forEach((c) => {
                  c.endsWith(`
`)
                    ? (this.code = c + this.code)
                    : (this.code =
                        c +
                        `
` +
                        this.code);
                });
              }
            }
          },
          725: (xe, V, a) => {
            "use strict";
            a.d(V, { N: () => y });
            const A = {
                linear: "decodeLinear",
                srgb: "decodeGamma",
                rgbm: "decodeRGBM",
                rgbe: "decodeRGBE",
                rgbp: "decodeRGBP",
              },
              x = {
                linear: "encodeLinear",
                srgb: "encodeGamma",
                rgbm: "encodeRGBM",
                rgbe: "encodeRGBE",
                rgbp: "encodeRGBP",
              };
            class y {
              static decodeFunc(d) {
                return A[d] || "decodeGamma";
              }
              static encodeFunc(d) {
                return x[d] || "encodeGamma";
              }
            }
          },
          7638: (xe, V, a) => {
            "use strict";
            a.d(V, { f: () => d });
            var A = `
		vec4 dirLm = texture2D(texture_dirLightMap, vUv1);

		if (bakeDir > 0.5) {
				if (dAtten > 0.00001) {
						dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);
						dAtten = saturate(dAtten);
						gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);
						gl_FragColor.a = dirLm.w + dAtten;
						gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);
				} else {
						gl_FragColor = dirLm;
				}
		} else {
				gl_FragColor.rgb = dirLm.xyz;
				gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);
		}
`,
              x = `
#ifdef LIGHTMAP_RGBM
		gl_FragColor.rgb = dDiffuseLight;
		gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));
		gl_FragColor.rgb /= 8.0;
		gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );
		gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;
		gl_FragColor.rgb /= gl_FragColor.a;
#else
		gl_FragColor = vec4(dDiffuseLight, 1.0);
#endif
`,
              y = `

varying vec2 vUv0;

uniform sampler2D source;
uniform vec2 pixelOffset;

void main(void) {
		vec4 c = texture2D(source, vUv0);
		c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);
		gl_FragColor = c;
}
`,
              c = `
// bilateral filter, based on https://www.shadertoy.com/view/4dfGDH# and
// http://people.csail.mit.edu/sparis/bf_course/course_notes.pdf

// A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images.
// It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.
// This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on
// Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such
// as color intensity, depth distance, etc.). This preserves sharp edges.

float normpdf3(in vec3 v, in float sigma) {
		return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}

vec3 decodeRGBM(vec4 rgbm) {
		vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
		return color * color;
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec4 encodeRGBM(vec3 color) { // modified RGBM
		vec4 encoded;
		encoded.rgb = pow(color.rgb, vec3(0.5));
		encoded.rgb *= 1.0 / 8.0;

		encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );
		encoded.a = ceil(encoded.a * 255.0) / 255.0;

		encoded.rgb /= encoded.a;
		return encoded;
}

// filter size
#define MSIZE 15

varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
uniform vec2 sigmas;
uniform float bZnorm;
uniform float kernel[MSIZE];

void main(void) {
		
		vec4 pixelRgbm = texture2D(source, vUv0);

		// lightmap specific optimization - skip pixels that were not baked
		// this also allows dilate filter that work on the output of this to work correctly, as it depends on .a being zero
		// to dilate, which the following blur filter would otherwise modify
		if (pixelRgbm.a <= 0.0) {
				gl_FragColor = pixelRgbm;
				return ;
		}

		// range sigma - controls blurriness based on a pixel distance
		float sigma = sigmas.x;

		// domain sigma - controls blurriness based on a pixel similarity (to preserve edges)
		float bSigma = sigmas.y;

		vec3 pixelHdr = decodeRGBM(pixelRgbm);
		vec3 accumulatedHdr = vec3(0.0);
		float accumulatedFactor = 0.0;

		// read out the texels
		const int kSize = (MSIZE-1)/2;
		for (int i = -kSize; i <= kSize; ++i) {
				for (int j = -kSize; j <= kSize; ++j) {
						
						// sample the pixel with offset
						vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;
						vec4 rgbm = texture2D(source, coord);

						// lightmap - only use baked pixels
						if (rgbm.a > 0.0) {
								vec3 hdr = decodeRGBM(rgbm);

								// bilateral factors
								float factor = kernel[kSize + j] * kernel[kSize + i];
								factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;

								// accumulate
								accumulatedHdr += factor * hdr;
								accumulatedFactor += factor;
						}
				}
		}

		gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);
}
`;
            const d = {
              bakeDirLmEndPS: A,
              bakeLmEndPS: x,
              dilatePS: y,
              bilateralDeNoisePS: c,
            };
          },
          2910: (xe, V, a) => {
            "use strict";
            a.d(V, { G: () => gn });
            var A = `
uniform float alpha_ref;

void alphaTest(float a) {
		if (a < alpha_ref) discard;
}
`,
              x = `
void addAmbient(vec3 worldNormal) {
		dDiffuseLight += light_globalAmbient;
}
`,
              y = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif

void addAmbient(vec3 worldNormal) {
		vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));
		vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);

		vec4 raw = texture2D(texture_envAtlas, uv);
		vec3 linear = $DECODE(raw);
		dDiffuseLight += processEnvironment(linear);
}
`,
              c = `
uniform vec3 ambientSH[9];

void addAmbient(vec3 worldNormal) {
		vec3 n = cubeMapRotate(worldNormal);

		vec3 color =
				ambientSH[0] +
				ambientSH[1] * n.x +
				ambientSH[2] * n.y +
				ambientSH[3] * n.z +
				ambientSH[4] * n.x * n.z +
				ambientSH[5] * n.z * n.y +
				ambientSH[6] * n.y * n.x +
				ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
				ambientSH[8] * (n.x * n.x - n.y * n.y);

		dDiffuseLight += processEnvironment(max(color, vec3(0.0)));
}
`,
              d = `

void getAO() {
		dAo = 1.0;

		#ifdef MAPTEXTURE
		float aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		dAo *= addAoDetail(aoBase);
		#endif

		#ifdef MAPVERTEX
		dAo *= saturate(vVertexColor.$VC);
		#endif
}
`,
              h = `
float addAoDetail(float ao) {
#ifdef MAPTEXTURE
		float aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		return detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;
#else
		return ao;
#endif
}
`,
              f = `
void occludeDiffuse(float ao) {
		dDiffuseLight *= ao;
}
`,
              s = `
uniform float material_occludeSpecularIntensity;

void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		// approximated specular occlusion from AO
		float specPow = exp2(gloss * 11.0);
		// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx
		float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
		specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);

		dSpecularLight *= specOcc;
		dReflection *= specOcc;
		
#ifdef LIT_SHEEN
		sSpecularLight *= specOcc;
		sReflection *= specOcc;
#endif
}
`,
              l = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		// approximated specular occlusion from AO
		float specPow = exp2(gloss * 11.0);
		// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx
		float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);

		dSpecularLight *= specOcc;
		dReflection *= specOcc;
		
#ifdef LIT_SHEEN
		sSpecularLight *= specOcc;
		sReflection *= specOcc;
#endif
}
`,
              n = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		dSpecularLight *= ao;
		dReflection *= ao;

#ifdef LIT_SHEEN
		sSpecularLight *= ao;
		sReflection *= ao;
#endif
}
`,
              o = `
uniform float material_occludeSpecularIntensity;

void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);
		dSpecularLight *= specOcc;
		dReflection *= specOcc;

#ifdef LIT_SHEEN
		sSpecularLight *= specOcc;
		sReflection *= specOcc;
#endif
}
`,
              i = `
uniform vec3 view_position;

uniform vec3 light_globalAmbient;

float square(float x) {
		return x*x;
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec3 saturate(vec3 x) {
		return clamp(x, vec3(0.0), vec3(1.0));
}
`,
              e = `
attribute vec3 vertex_position;
attribute vec3 vertex_normal;
attribute vec4 vertex_tangent;
attribute vec2 vertex_texCoord0;
attribute vec2 vertex_texCoord1;
attribute vec4 vertex_color;

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;

vec3 dPositionW;
mat4 dModelMatrix;
mat3 dNormalMatrix;
`,
              t = `
#define NINESLICED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;

vec2 nineSlicedUv;
`,
              r = `
#define NINESLICED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
`,
              u = `
#define NINESLICED
#define NINESLICETILED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;

vec2 nineSlicedUv;
`,
              v = `
#define SHADOWBIAS
#define SHADOW_SAMPLE_Z_BIAS

float getShadowBias(float resolution, float maxBias) {
		return maxBias;
}
`,
              _ = `
varying vec2 vUv0;

uniform sampler2D source;
uniform vec2 pixelOffset;

#ifdef GAUSS
uniform float weight[SAMPLES];
#endif

#ifdef PACKED
float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

vec2 encodeFloatRG( float v ) {
		vec2 enc = vec2(1.0, 255.0) * v;
		enc = fract(enc);
		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
		return enc;
}
#endif

void main(void) {
		vec3 moments = vec3(0.0);
		vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);
		for (int i=0; i<SAMPLES; i++) {
				vec4 c = texture2D(source, uv + pixelOffset * float(i));

				#ifdef PACKED
				c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));
				#endif

				#ifdef GAUSS
				moments += c.xyz * weight[i];
				#else
				moments += c.xyz;
				#endif
		}

		#ifndef GAUSS
		moments /= float(SAMPLES);
		#endif

		#ifdef PACKED
		gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));
		#else
		gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);
		#endif
}
`,
              m = `
#ifdef MAPFLOAT
uniform float material_clearCoat;
#endif

void getClearCoat() {
		ccSpecularity = 1.0;

		#ifdef MAPFLOAT
		ccSpecularity *= material_clearCoat;
		#endif

		#ifdef MAPTEXTURE
		ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		ccSpecularity *= saturate(vVertexColor.$VC);
		#endif
}
`,
              g = `
#ifdef MAPFLOAT
uniform float material_clearCoatGloss;
#endif

void getClearCoatGlossiness() {
		ccGlossiness = 1.0;

		#ifdef MAPFLOAT
		ccGlossiness *= material_clearCoatGloss;
		#endif

		#ifdef MAPTEXTURE
		ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		ccGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		ccGlossiness = 1.0 - ccGlossiness;
		#endif

		ccGlossiness += 0.0000001;
}
`,
              T = `
#ifdef MAPTEXTURE
uniform float material_clearCoatBumpiness;
#endif

void getClearCoatNormal() {
#ifdef MAPTEXTURE
		vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);
		ccNormalW = normalize(dTBN * normalMap);
#else
		ccNormalW = dVertexNormalW;
#endif
}
`,
              E = `
// Converts unnormalized direction vector to a cubemap face index [0..5] and uv coordinates within the face in [0..1] range.
// Additionally offset to a tile in atlas within 3x3 subdivision is provided
vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)
{
		vec3 vAbs = abs(dir);
		float ma;
		vec2 uv;
		if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {   // front / back

				faceIndex = dir.z < 0.0 ? 5.0 : 4.0;
				ma = 0.5 / vAbs.z;
				uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);

				tileOffset.x = 2.0;
				tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;

		} else if(vAbs.y >= vAbs.x) {  // top index 2, bottom index 3

				faceIndex = dir.y < 0.0 ? 3.0 : 2.0;
				ma = 0.5 / vAbs.y;
				uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);

				tileOffset.x = 1.0;
				tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;

		} else {    // left / right

				faceIndex = dir.x < 0.0 ? 1.0 : 0.0;
				ma = 0.5 / vAbs.x;
				uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);

				tileOffset.x = 0.0;
				tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;

		}
		return uv * ma + 0.5;
}

// converts unnormalized direction vector to a texture coordinate for a cubemap face stored within texture atlas described by the viewport
vec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {

		float faceIndex;
		vec2 tileOffset;
		vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);

		// move uv coordinates inwards inside to compensate for larger fov when rendering shadow into atlas
		float atlasFaceSize = omniAtlasViewport.z;
		float tileSize = shadowTextureResolution * atlasFaceSize;
		float offset = shadowEdgePixels / tileSize;
		uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);

		// scale uv coordinates to cube face area within the viewport
		uv *= atlasFaceSize;

		// offset into face of the atlas (3x3 grid)
		uv += tileOffset * atlasFaceSize;

		// offset into the atlas viewport
		uv += omniAtlasViewport.xy;

		return uv;
}
`,
              M = `
vec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {
		vec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);
		return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));
}

// getCookie2D for clustered lighting including channel selector
vec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {
		vec4 projPos = transform * vec4(worldPosition, 1.0);
		return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);
}

// getCookie for clustered omni light with the cookie texture being stored in the cookie atlas
vec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
		return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);
}
`,
              R = `
// Clustered Omni Sampling using atlas


void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
		vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
		projPos.xyz /= projPos.w;
		dShadowCoord = projPos.xyz;
		// depth bias is already applied on render
}

void getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {
		vec3 wPos = vPositionW + normal * shadowParams.y;
		_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}

vec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
		float distScale = length(lightDir);
		vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale; //0.02
		vec3 dir = wPos - lightPos;
		return dir;
}

#ifdef GL2

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				return textureShadow(shadowMap, vec3(uv, shadowZ));
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		float getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}

		#endif

#else

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				// no filter shadow sampling
				float depth = unpackFloat(textureShadow(shadowMap, uv));
				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				return depth > shadowZ ? 1.0 : 0.0;
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				// pcf3
				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		// we don't have PCF5 implementation for webgl1, use PCF3
		float getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				// pcf3
				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

#endif


// Clustered Spot Sampling using atlas

#ifdef GL2

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
				return textureShadow(shadowMap, shadowCoord);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
				return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		float getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
				return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}
		#endif

#else

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowSpotClusteredPCF1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {

				float depth = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));

				return depth > shadowCoord.z ? 1.0 : 0.0;

		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowSpotClusteredPCF3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
				return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		// we don't have PCF5 implementation for webgl1, use PCF3
		float getShadowSpotClusteredPCF5(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
				return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

#endif
`,
              P = `
uniform highp sampler2D clusterWorldTexture;
uniform highp sampler2D lightsTexture8;
uniform highp sampler2D lightsTextureFloat;

// complex ifdef expression are not supported, handle it here
// defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)
#if defined(CLUSTER_COOKIES)
		#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#if defined(CLUSTER_SHADOWS)
		#define CLUSTER_COOKIES_OR_SHADOWS
#endif

#ifdef CLUSTER_SHADOWS
		#ifdef GL2
				// TODO: when VSM shadow is supported, it needs to use sampler2D in webgl2
				uniform sampler2DShadow shadowAtlasTexture;
		#else
				uniform sampler2D shadowAtlasTexture;
		#endif
#endif

#ifdef CLUSTER_COOKIES
		uniform sampler2D cookieAtlasTexture;
#endif

#ifdef GL2
		uniform int clusterMaxCells;
#else
		uniform float clusterMaxCells;
		uniform vec4 lightsTextureInvSize;
#endif

// 1.0 if clustered lighting can be skipped (0 lights in the clusters)
uniform float clusterSkip;

uniform vec3 clusterCellsCountByBoundsSize;
uniform vec3 clusterTextureSize;
uniform vec3 clusterBoundsMin;
uniform vec3 clusterBoundsDelta;
uniform vec3 clusterCellsDot;
uniform vec3 clusterCellsMax;
uniform vec2 clusterCompressionLimit0;
uniform vec2 shadowAtlasParams;

// structure storing light properties of a clustered light
// it's sorted to have all vectors aligned to 4 floats to limit padding
struct ClusterLightData {

		// area light sizes / orientation
		vec3 halfWidth;

		// type of the light (spot or omni)
		float lightType;

		// area light sizes / orientation
		vec3 halfHeight;

		#ifdef GL2
				// light index
				int lightIndex;
		#else
				// v coordinate to look up the light textures - this is the same as lightIndex but in 0..1 range
				float lightV;
		#endif

		// world space position
		vec3 position;

		// area light shape
		float shape;

		// world space direction (spot light only)
		vec3 direction;

		// light follow mode
		float falloffMode;

		// color
		vec3 color;

		// 0.0 if the light doesn't cast shadows
		float shadowIntensity;

		// atlas viewport for omni light shadow and cookie (.xy is offset to the viewport slot, .z is size of the face in the atlas)
		vec3 omniAtlasViewport;

		// range of the light
		float range;

		// channel mask - one of the channels has 1, the others are 0
		vec4 cookieChannelMask;

		// shadow bias values
		float shadowBias;
		float shadowNormalBias;

		// spot light inner and outer angle cosine
		float innerConeAngleCos;
		float outerConeAngleCos;

		// 1.0 if the light has a cookie texture
		float cookie;

		// 1.0 if cookie texture is rgb, otherwise it is using a single channel selectable by cookieChannelMask
		float cookieRgb;

		// intensity of the cookie
		float cookieIntensity;

		// light mask
		float mask;
};

// Note: on some devices (tested on Pixel 3A XL), this matrix when stored inside the light struct has lower precision compared to
// when stored outside, so we store it outside to avoid spot shadow flickering. This might need to be done to other / all members
// of the structure if further similar issues are observed.

// shadow (spot light only) / cookie projection matrix
mat4 lightProjectionMatrix;

// macros for light properties
#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )
#define isClusteredLightCookie(light) (light.cookie > 0.5 )
#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )
#define isClusteredLightSpot(light) ( light.lightType > 0.5 )
#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )

// macros to test light shape
// Note: Following functions need to be called serially in listed order as they do not test both '>' and '<'
#define isClusteredLightArea(light) ( light.shape > 0.1 )
#define isClusteredLightRect(light) ( light.shape < 0.3 )
#define isClusteredLightDisk(light) ( light.shape < 0.6 )

// macro to test light mask (mesh accepts dynamic vs lightmapped lights)
#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
		// accept lights marked as dynamic or both dynamic and lightmapped
		#define acceptLightMask(light) ( light.mask < 0.75)
#else
		// accept lights marked as lightmapped or both dynamic and lightmapped
		#define acceptLightMask(light) ( light.mask > 0.25)
#endif

vec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {
		return vec4(
				bytes2floatRange4(d0, -2.0, 2.0),
				bytes2floatRange4(d1, -2.0, 2.0),
				bytes2floatRange4(d2, -2.0, 2.0),
				bytes2floatRange4(d3, -2.0, 2.0)
		);
}

#ifdef GL2

		vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {
				return texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);
		}

		vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {
				return texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);
		}

#else

		vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {
				return texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);
		}

		vec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {
				return texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);
		}

#endif

void decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {

		// light index
		#ifdef GL2
				clusterLightData.lightIndex = int(lightIndex);
		#else
				clusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;
		#endif

		// shared data from 8bit texture
		vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);
		clusterLightData.lightType = lightInfo.x;
		clusterLightData.shape = lightInfo.y;
		clusterLightData.falloffMode = lightInfo.z;
		clusterLightData.shadowIntensity = lightInfo.w;

		// color
		vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);
		vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);
		clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;

		// cookie
		clusterLightData.cookie = colorB.z;

		// light mask
		clusterLightData.mask = colorB.w;

		#ifdef CLUSTER_TEXTURE_FLOAT

				vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);
				clusterLightData.position = lightPosRange.xyz;
				clusterLightData.range = lightPosRange.w;

				// spot light direction
				vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);
				clusterLightData.direction = lightDir_Unused.xyz;

		#else   // 8bit

				vec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);
				vec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);
				vec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);
				clusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;

				vec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);
				clusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;

				// spot light direction
				vec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);
				vec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);
				vec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);
				clusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;

		#endif
}

void decodeClusterLightSpot(inout ClusterLightData clusterLightData) {

		// spot light cos angles
		vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);
		clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;
		clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;
}

void decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {
		#ifdef CLUSTER_TEXTURE_FLOAT
				clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;
		#else
				vec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);
				vec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);
				clusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));
		#endif
}

void decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {
		#ifdef CLUSTER_TEXTURE_FLOAT
				clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;
				clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;
		#else
				vec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);
				vec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);
				vec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);
				clusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));

				vec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);
				vec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);
				vec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);
				clusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));
		#endif
}

void decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {
		
		// shadow matrix
		#ifdef CLUSTER_TEXTURE_FLOAT
				vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);
				vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);
				vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);
				vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);
		#else
				vec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);
				vec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);
				vec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);
				vec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);
				vec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);

				vec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);
				vec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);
				vec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);
				vec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);
				vec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);

				vec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);
				vec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);
				vec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);
				vec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);
				vec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);

				vec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);
				vec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);
				vec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);
				vec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);
				vec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));
		#endif
		
		lightProjectionMatrix = mat4(m0, m1, m2, m3);
}

void decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {
		
		// shadow biases
		vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);
		clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),
		clusterLightData.shadowNormalBias = bytes2float2(biases.zw);
}

void decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {

		vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);
		clusterLightData.cookieIntensity = cookieA.x;
		clusterLightData.cookieRgb = cookieA.y;

		clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);
}

void evaluateLight(
		ClusterLightData light, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir,
#if defined(LIT_CLEARCOAT)
		vec3 clearcoatReflectionDir,
#endif
		float gloss, 
		vec3 specularity, 
		vec3 geometricNormal, 
		mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel,
#endif
		vec3 clearcoat_worldNormal,
		float clearcoat_gloss,
		float sheen_gloss,
		float iridescence_intensity
) {

		vec3 cookieAttenuation = vec3(1.0);
		float diffuseAttenuation = 1.0;
		float falloffAttenuation = 1.0;

		// evaluate omni part of the light
		getLightDirPoint(light.position);

		#ifdef CLUSTER_AREALIGHTS

		// distance attenuation
		if (isClusteredLightArea(light)) { // area light

				// area lights
				decodeClusterLightAreaData(light);

				// handle light shape
				if (isClusteredLightRect(light)) {
						calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
				} else if (isClusteredLightDisk(light)) {
						calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
				} else { // sphere
						calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
				}

				falloffAttenuation = getFalloffWindow(light.range, dLightDirW);

		} else

		#endif

		{   // punctual light

				if (isClusteredLightFalloffLinear(light))
						falloffAttenuation = getFalloffLinear(light.range, dLightDirW);
				else
						falloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);
		}

		if (falloffAttenuation > 0.00001) {

				#ifdef CLUSTER_AREALIGHTS

				if (isClusteredLightArea(light)) { // area light

						// handle light shape
						if (isClusteredLightRect(light)) {
								diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
						} else if (isClusteredLightDisk(light)) {
								diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
						} else { // sphere
								diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
						}

				} else

				#endif

				{
						falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); 
				}

				// spot light falloff
				if (isClusteredLightSpot(light)) {
						decodeClusterLightSpot(light);
						falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);
				}

				#if defined(CLUSTER_COOKIES_OR_SHADOWS)

				if (falloffAttenuation > 0.00001) {

						// shadow / cookie
						if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {

								// shared shadow / cookie data depends on light type
								if (isClusteredLightSpot(light)) {
										decodeClusterLightProjectionMatrixData(light);
								} else {
										decodeClusterLightOmniAtlasViewport(light);
								}

								float shadowTextureResolution = shadowAtlasParams.x;
								float shadowEdgePixels = shadowAtlasParams.y;

								#ifdef CLUSTER_COOKIES

								// cookie
								if (isClusteredLightCookie(light)) {
										decodeClusterLightCookieData(light);

										if (isClusteredLightSpot(light)) {
												cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);
										} else {
												cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
										}
								}

								#endif

								#ifdef CLUSTER_SHADOWS

								// shadow
								if (isClusteredLightCastShadow(light)) {
										decodeClusterLightShadowData(light);

										vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);

										if (isClusteredLightSpot(light)) {

												// spot shadow
												getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);
												
												#if defined(CLUSTER_SHADOW_TYPE_PCF1)
														float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
														float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
														float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCSS)
														float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#endif
												falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);

										} else {

												// omni shadow
												vec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);  // normalBias adjusted for distance

												#if defined(CLUSTER_SHADOW_TYPE_PCF1)
														float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
														float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
														float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
												#endif
												falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
										}
								}

								#endif
						}
				}

				#endif

				// diffuse / specular / clearcoat
				#ifdef CLUSTER_AREALIGHTS

				if (isClusteredLightArea(light)) { // area light

						// area light diffuse
						{
								vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;

								#if defined(LIT_SPECULAR)
										#if defined(LIT_CONSERVE_ENERGY)
												areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);
										#endif
								#endif

								// area light diffuse - it does not mix diffuse lighting into specular attenuation
								dDiffuseLight += areaDiffuse;
						}

						// specular and clear coat are material settings and get included by a define based on the material
						#ifdef LIT_SPECULAR

								// area light specular
								float areaLightSpecular;

								if (isClusteredLightRect(light)) {
										areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);
								} else if (isClusteredLightDisk(light)) {
										areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);
								} else { // sphere
										areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);
								}

								dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;

								#ifdef LIT_CLEARCOAT

										// area light specular clear coat
										float areaLightSpecularCC;

										if (isClusteredLightRect(light)) {
												areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);
										} else if (isClusteredLightDisk(light)) {
												areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);
										} else { // sphere
												areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);
										}

										ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;

								#endif

						#endif

				} else

				#endif

				{    // punctual light

						// punctual light diffuse
						{
								vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;

								#if defined(CLUSTER_AREALIGHTS)
								#if defined(LIT_SPECULAR)
								#if defined(LIT_CONSERVE_ENERGY)
										punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);
								#endif
								#endif
								#endif

								dDiffuseLight += punctualDiffuse;
						}
	 
						// specular and clear coat are material settings and get included by a define based on the material
						#ifdef LIT_SPECULAR

								vec3 halfDir = normalize(-dLightDirNormW + viewDir);
								
								// specular
								#ifdef LIT_SPECULAR_FRESNEL
										dSpecularLight += 
												getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * 
												getFresnel(
														dot(viewDir, halfDir), 
														gloss, 
														specularity
												#if defined(LIT_IRIDESCENCE)
														, iridescenceFresnel,
														iridescence_intensity
												#endif
														);
								#else
										dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;
								#endif

								#ifdef LIT_CLEARCOAT
										#ifdef LIT_SPECULAR_FRESNEL
												ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));
										#else
												ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; 
										#endif
								#endif

								#ifdef LIT_SHEEN
										sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;
								#endif

						#endif
				}
		}

		// Write to global attenuation values (for lightmapper)
		dAtten = falloffAttenuation;
		dAttenD = diffuseAttenuation;
		dAtten3 = cookieAttenuation;
}

void evaluateClusterLight(
		float lightIndex, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
		vec3 clearcoatReflectionDir,
#endif
		float gloss, 
		vec3 specularity, 
		vec3 geometricNormal, 
		mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel,
#endif
		vec3 clearcoat_worldNormal,
		float clearcoat_gloss,
		float sheen_gloss,
		float iridescence_intensity
) {

		// decode core light data from textures
		ClusterLightData clusterLightData;
		decodeClusterLightCore(clusterLightData, lightIndex);

		// evaluate light if it uses accepted light mask
		if (acceptLightMask(clusterLightData))
				evaluateLight(
						clusterLightData, 
						worldNormal, 
						viewDir, 
						reflectionDir, 
#if defined(LIT_CLEARCOAT)
						clearcoatReflectionDir, 
#endif
						gloss, 
						specularity, 
						geometricNormal, 
						tbn, 
#if defined(LIT_IRIDESCENCE)
						iridescenceFresnel,
#endif
						clearcoat_worldNormal,
						clearcoat_gloss,
						sheen_gloss,
						iridescence_intensity
				);
}

void addClusteredLights(
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
		vec3 clearcoatReflectionDir,
#endif
		float gloss, 
		vec3 specularity, 
		vec3 geometricNormal, 
		mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel,
#endif
		vec3 clearcoat_worldNormal,
		float clearcoat_gloss,
		float sheen_gloss,
		float iridescence_intensity
) {

		// skip lights if no lights at all
		if (clusterSkip > 0.5)
				return;

		// world space position to 3d integer cell cordinates in the cluster structure
		vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);

		// no lighting when cell coordinate is out of range
		if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {

				// cell index (mapping from 3d cell coordinates to linear memory)
				float cellIndex = dot(clusterCellsDot, cellCoords);

				// convert cell index to uv coordinates
				float clusterV = floor(cellIndex * clusterTextureSize.y);
				float clusterU = cellIndex - (clusterV * clusterTextureSize.x);

				#ifdef GL2

						// loop over maximum number of light cells
						for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {

								// using a single channel texture with data in alpha channel
								float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;

								if (lightIndex <= 0.0)
												return;

								evaluateClusterLight(
										lightIndex * 255.0, 
										worldNormal, 
										viewDir, 
										reflectionDir,
#if defined(LIT_CLEARCOAT)
										clearcoatReflectionDir,
#endif
										gloss, 
										specularity, 
										geometricNormal, 
										tbn, 
#if defined(LIT_IRIDESCENCE)
										iridescenceFresnel,
#endif
										clearcoat_worldNormal,
										clearcoat_gloss,
										sheen_gloss,
										iridescence_intensity
								); 
						}

				#else

						clusterV = (clusterV + 0.5) * clusterTextureSize.z;

						// loop over maximum possible number of supported light cells
						const float maxLightCells = 256.0;
						for (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {

								float lightIndex = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0).x;

								if (lightIndex <= 0.0)
										return;
								
								evaluateClusterLight(
										lightIndex * 255.0, 
										worldNormal, 
										viewDir, 
										reflectionDir,
#if defined(LIT_CLEARCOAT)
										clearcoatReflectionDir,
#endif
										gloss, 
										specularity, 
										geometricNormal, 
										tbn, 
#if defined(LIT_IRIDESCENCE)
										iridescenceFresnel,
#endif
										clearcoat_worldNormal,
										clearcoat_gloss,
										sheen_gloss,
										iridescence_intensity
								); 
								// end of the cell array
								if (lightCellIndex >= clusterMaxCells) {
										break;
								}
						}

				#endif
		}
}
`,
              F = `
vec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {
		vec3 ret = vec3(0);
#ifdef LIT_OLD_AMBIENT
		ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;
#else
		ret += albedo * dDiffuseLight;
#endif
#ifdef LIT_SPECULAR
		ret += dSpecularLight;
#endif
#ifdef LIT_REFLECTIONS
		ret += dReflection.rgb * dReflection.a;
#endif

#ifdef LIT_SHEEN
		float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;
		ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;
#endif
#ifdef LIT_CLEARCOAT
		float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;
		ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;
#endif

		return ret;
}
`,
              b = `
// light cookie functionality for non-clustered lights
vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}

vec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
		return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}

vec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		projPos.xy += cookieOffset;
		vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
		return mix(vec4(1.0), texture2D(tex, uv), intensity);
}

vec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		projPos.xy += cookieOffset;
		if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
		vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
		return mix(vec4(1.0), texture2D(tex, uv), intensity);
}

vec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {
		return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);
}
`,
              D = `
uniform vec3 envBoxMin;
uniform vec3 envBoxMax;

vec3 cubeMapProject(vec3 nrdir) {
		nrdir = cubeMapRotate(nrdir);

		vec3 rbmax = (envBoxMax - vPositionW) / nrdir;
		vec3 rbmin = (envBoxMin - vPositionW) / nrdir;

		vec3 rbminmax;
		rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;
		rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;
		rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;

		float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);

		vec3 posonbox = vPositionW + nrdir * fa;
		vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;
		return normalize(posonbox - envBoxPos);
}
`,
              G = `
vec3 cubeMapProject(vec3 dir) {
		return cubeMapRotate(dir);
}
`,
              X = `
#ifdef CUBEMAP_ROTATION
uniform mat3 cubeMapRotationMatrix;
#endif

vec3 cubeMapRotate(vec3 refDir) {
#ifdef CUBEMAP_ROTATION
		return refDir * cubeMapRotationMatrix;
#else
		return refDir;
#endif
}
`,
              ie = `
#ifdef DEBUG_ALBEDO_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_albedo), 1.0);
#endif

#ifdef DEBUG_UV0_PASS
gl_FragColor = vec4(litArgs_albedo , 1.0);
#endif

#ifdef DEBUG_WORLD_NORMAL_PASS
gl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);
#endif

#ifdef DEBUG_OPACITY_PASS
gl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);
#endif

#ifdef DEBUG_SPECULARITY_PASS
gl_FragColor = vec4(litArgs_specularity, 1.0);
#endif

#ifdef DEBUG_GLOSS_PASS
gl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);
#endif

#ifdef DEBUG_METALNESS_PASS
gl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);
#endif

#ifdef DEBUG_AO_PASS
gl_FragColor = vec4(vec3(litArgs_ao) , 1.0);
#endif

#ifdef DEBUG_EMISSION_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);
#endif
`,
              Q = `
#ifdef DEBUG_LIGHTING_PASS
litArgs_albedo = vec3(0.5);
#endif

#ifdef DEBUG_UV0_PASS
#ifdef VARYING_VUV0
litArgs_albedo = vec3(vUv0, 0);
#else
litArgs_albedo = vec3(0);
#endif
#endif
`,
              te = `
vec3 decodeLinear(vec4 raw) {
		return raw.rgb;
}

float decodeGamma(float raw) {
		return pow(raw, 2.2);
}

vec3 decodeGamma(vec3 raw) {
		return pow(raw, vec3(2.2));
}

vec3 decodeGamma(vec4 raw) {
		return pow(raw.xyz, vec3(2.2));
}

vec3 decodeRGBM(vec4 raw) {
		vec3 color = (8.0 * raw.a) * raw.rgb;
		return color * color;
}

vec3 decodeRGBP(vec4 raw) {
		vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);
		return color * color;
}

vec3 decodeRGBE(vec4 raw) {
		if (raw.a == 0.0) {
				return vec3(0.0, 0.0, 0.0);
		} else {
				return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);
		}
}

vec4 passThrough(vec4 raw) {
		return raw;
}
`,
              ae = `
vec3 detailMode_mul(vec3 c1, vec3 c2) {
		return c1 * c2;
}

vec3 detailMode_add(vec3 c1, vec3 c2) {
		return c1 + c2;
}

// https://en.wikipedia.org/wiki/Blend_modes#Screen
vec3 detailMode_screen(vec3 c1, vec3 c2) {
		return 1.0 - (1.0 - c1)*(1.0 - c2);
}

// https://en.wikipedia.org/wiki/Blend_modes#Overlay
vec3 detailMode_overlay(vec3 c1, vec3 c2) {
		return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));
}

vec3 detailMode_min(vec3 c1, vec3 c2) {
		return min(c1, c2);
}

vec3 detailMode_max(vec3 c1, vec3 c2) {
		return max(c1, c2);
}
`,
              Z = `
#ifdef MAPCOLOR
uniform vec3 material_diffuse;
#endif

void getAlbedo() {
		dAlbedo = vec3(1.0);

#ifdef MAPCOLOR
		dAlbedo *= material_diffuse.rgb;
#endif

#ifdef MAPTEXTURE
		vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		dAlbedo *= addAlbedoDetail(albedoBase);
#endif

#ifdef MAPVERTEX
		dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));
#endif
}
`,
              J = `
vec3 addAlbedoDetail(vec3 albedo) {
#ifdef MAPTEXTURE
		vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		return detailMode_$DETAILMODE(albedo, albedoDetail);
#else
		return albedo;
#endif
}
`,
              ve = `
#ifdef MAPCOLOR
uniform vec3 material_emissive;
#endif

#ifdef MAPFLOAT
uniform float material_emissiveIntensity;
#endif

void getEmission() {
		dEmission = vec3(1.0);

		#ifdef MAPFLOAT
		dEmission *= material_emissiveIntensity;
		#endif

		#ifdef MAPCOLOR
		dEmission *= material_emissive;
		#endif

		#ifdef MAPTEXTURE
		dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));
		#endif
}
`,
              _e = `
vec4 encodeLinear(vec3 source) {
		return vec4(source, 1.0);
}

vec4 encodeGamma(vec3 source) {
		return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);
}

vec4 encodeRGBM(vec3 source) { // modified RGBM
		vec4 result;
		result.rgb = pow(source.rgb, vec3(0.5));
		result.rgb *= 1.0 / 8.0;

		result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );
		result.a = ceil(result.a * 255.0) / 255.0;

		result.rgb /= result.a;
		return result;
}

vec4 encodeRGBP(vec3 source) {
		// convert incoming linear to gamma(ish)
		vec3 gamma = pow(source, vec3(0.5));

		// calculate the maximum component clamped to 1..8
		float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));

		// calculate storage factor
		float v = 1.0 - ((maxVal - 1.0) / 7.0);

		// round the value for storage in 8bit channel
		v = ceil(v * 255.0) / 255.0;

		return vec4(gamma / (-v * 7.0 + 8.0), v);    
}

vec4 encodeRGBE(vec3 source) {
		float maxVal = max(source.x, max(source.y, source.z));
		if (maxVal < 1e-32) {
				return vec4(0, 0, 0, 0);
		} else {
				float e = ceil(log2(maxVal));
				return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);
		}
}
`,
              L = `
		gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);

		gl_FragColor.rgb += litArgs_emission;
		gl_FragColor.rgb = addFog(gl_FragColor.rgb);

		#ifndef HDR
		gl_FragColor.rgb = toneMap(gl_FragColor.rgb);
		gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);
		#endif
`,
              ge = `
`,
              k = `
// the envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.
const float atlasSize = 512.0;
const float seamSize = 1.0 / atlasSize;

// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).
vec2 mapUv(vec2 uv, vec4 rect) {
		return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
								mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}

// map a normalized equirect UV and roughness level to the correct atlas rect.
vec2 mapRoughnessUv(vec2 uv, float level) {
		float t = 1.0 / exp2(level);
		return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));
}

// map shiny level UV
vec2 mapShinyUv(vec2 uv, float level) {
		float t = 1.0 / exp2(level);
		return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));
}
`,
              j = `
vec3 processEnvironment(vec3 color) {
		return color;
}
`,
              B = `
uniform float skyboxIntensity;

vec3 processEnvironment(vec3 color) {
		return color * skyboxIntensity;
}
`,
              $ = `
`,
              le = `
`,
              O = `
float getFalloffWindow(float lightRadius, vec3 lightDir) {
		float sqrDist = dot(lightDir, lightDir);
		float invRadius = 1.0 / lightRadius;
		return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
}

float getFalloffInvSquared(float lightRadius, vec3 lightDir) {
		float sqrDist = dot(lightDir, lightDir);
		float falloff = 1.0 / (sqrDist + 1.0);
		float invRadius = 1.0 / lightRadius;

		falloff *= 16.0;
		falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );

		return falloff;
}
`,
              Y = `
float getFalloffLinear(float lightRadius, vec3 lightDir) {
		float d = length(lightDir);
		return max(((lightRadius - d) / lightRadius), 0.0);
}
`,
              ne = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
		return vec;
}

vec3 fixSeams(vec3 vec) {
		return vec;
}

vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
		return vec;
}

vec3 calcSeam(vec3 vec) {
		return vec3(0);
}

vec3 applySeam(vec3 vec, vec3 seam, float scale) {
		return vec;
}
`,
              de = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
		vec3 avec = abs(vec);
		float scale = 1.0 - exp2(mipmapIndex) / 128.0;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 fixSeams(vec3 vec) {
		vec3 avec = abs(vec);
		float scale = 1.0 - 1.0 / 128.0;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
		vec3 avec = abs(vec);
		float scale = invRecMipSize;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 calcSeam(vec3 vec) {
		vec3 avec = abs(vec);
		float M = max(avec.x, max(avec.y, avec.z));
		return vec3(avec.x != M ? 1.0 : 0.0,
								avec.y != M ? 1.0 : 0.0,
								avec.z != M ? 1.0 : 0.0);
}

vec3 applySeam(vec3 vec, vec3 seam, float scale) {
		return vec * (seam * -scale + vec3(1.0));
}
`,
              re = `
// float unpacking functionality, complimentary to float-packing.js
float bytes2float2(vec2 data) {
		return dot(data, vec2(1.0, 1.0 / 255.0));
}

float bytes2float3(vec3 data) {
		return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));
}

float bytes2float4(vec4 data) {
		return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}

float bytes2floatRange2(vec2 data, float min, float max) {
		return mix(min, max, bytes2float2(data));
}

float bytes2floatRange3(vec3 data, float min, float max) {
		return mix(min, max, bytes2float3(data));
}

float bytes2floatRange4(vec4 data, float min, float max) {
		return mix(min, max, bytes2float4(data));
}

float mantissaExponent2Float(vec4 pack)
{
		float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);
		float exponent = floor(pack.w * 255.0 - 127.0);
		return value * exp2(exponent);
}
`,
              I = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = exp(-depth * fog_density);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`,
              w = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = exp(-depth * depth * fog_density * fog_density);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`,
              N = `
uniform vec3 fog_color;
uniform float fog_start;
uniform float fog_end;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = (fog_end - depth) / (fog_end - fog_start);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`,
              W = `
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		return color;
}
`,
              he = `
// Schlick's approximation
vec3 getFresnel(
				float cosTheta, 
				float gloss, 
				vec3 specularity
#if defined(LIT_IRIDESCENCE)
				, vec3 iridescenceFresnel, 
				float iridescenceIntensity
#endif
		) {
		float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
		float glossSq = gloss * gloss;
		vec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;
#if defined(LIT_IRIDESCENCE)
		return mix(ret, iridescenceFresnel, iridescenceIntensity);
#else
		return ret;
#endif    
}

float getFresnelCC(float cosTheta) {
		float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
		return 0.04 + (1.0 - 0.04) * fresnel;
}
`,
              ue = `
varying vec2 vUv0;

uniform sampler2D source;

void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`,
              ye = `
attribute vec2 vertex_position;

varying vec2 vUv0;

void main(void)
{
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = vertex_position.xy*0.5+0.5;
}
`,
              Oe = `
float gammaCorrectInput(float color) {
		return color;
}

vec3 gammaCorrectInput(vec3 color) {
		return color;
}

vec4 gammaCorrectInput(vec4 color) {
		return color;
}

vec3 gammaCorrectOutput(vec3 color) {
		return color;
}
`,
              Ae = `
float gammaCorrectInput(float color) {
		return decodeGamma(color);
}

vec3 gammaCorrectInput(vec3 color) {
		return decodeGamma(color);
}

vec4 gammaCorrectInput(vec4 color) {
		return vec4(decodeGamma(color.xyz), color.w);
}

vec3 gammaCorrectOutput(vec3 color) {
#ifdef HDR
		return color;
#else
		return pow(color + 0.0000001, vec3(1.0 / 2.2));
#endif
}
`,
              ke = a(120),
              Ue = a(4047),
              Ge = a(9812),
              ht = `
#ifdef MAPFLOAT
uniform float material_gloss;
#endif

void getGlossiness() {
		dGlossiness = 1.0;

		#ifdef MAPFLOAT
		dGlossiness *= material_gloss;
		#endif

		#ifdef MAPTEXTURE
		dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		dGlossiness = 1.0 - dGlossiness;
		#endif

		dGlossiness += 0.0000001;
}
`,
              me = `
uniform float material_iridescenceRefractionIndex;

#ifndef PI
#define PI 3.14159265
#endif

float iridescence_iorToFresnel(float transmittedIor, float incidentIor) {
		return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}

vec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {
		return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));
}

vec3 iridescence_fresnelToIor(vec3 f0) {
		vec3 sqrtF0 = sqrt(f0);
		return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

vec3 iridescence_sensitivity(float opd, vec3 shift) {
		float phase = 2.0 * PI * opd * 1.0e-9;
		const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
		const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
		const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

		vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);
		xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
		xyz /= vec3(1.0685e-07);

		const mat3 XYZ_TO_REC709 = mat3(
				3.2404542, -0.9692660,  0.0556434,
			 -1.5371385,  1.8760108, -0.2040259,
			 -0.4985314,  0.0415560,  1.0572252
		);

		return XYZ_TO_REC709 * xyz;
}

float iridescence_fresnel(float cosTheta, float f0) {
		float x = clamp(1.0 - cosTheta, 0.0, 1.0);
		float x2 = x * x;
		float x5 = x * x2 * x2;
		return f0 + (1.0 - f0) * x5;
} 

vec3 iridescence_fresnel(float cosTheta, vec3 f0) {
		float x = clamp(1.0 - cosTheta, 0.0, 1.0);
		float x2 = x * x;
		float x5 = x * x2 * x2; 
		return f0 + (vec3(1.0) - f0) * x5;
}

vec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {

		float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));
		float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
		float cosTheta2Sq = 1.0 - sinTheta2Sq;

		if (cosTheta2Sq < 0.0) {
				return vec3(1.0);
		}

		float cosTheta2 = sqrt(cosTheta2Sq);

		float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);
		float r12 = iridescence_fresnel(cosTheta, r0);
		float r21 = r12;
		float t121 = 1.0 - r12;

		float phi12 = iridescenceIor < outsideIor ? PI : 0.0;
		float phi21 = PI - phi12;

		vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));
		vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);
		vec3 r23 = iridescence_fresnel(cosTheta2, r1);

		vec3 phi23 = vec3(0.0);
		if (baseIor[0] < iridescenceIor) phi23[0] = PI;
		if (baseIor[1] < iridescenceIor) phi23[1] = PI;
		if (baseIor[2] < iridescenceIor) phi23[2] = PI;
		float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;
		vec3 phi = vec3(phi21) + phi23; 

		vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);
		vec3 r123 = sqrt(r123Sq);
		vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);

		vec3 c0 = r12 + rs;
		vec3 i = c0;

		vec3 cm = rs - t121;
		for (int m = 1; m <= 2; m++) {
				cm *= r123;
				vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);
				i += cm * sm;
		}
		return max(i, vec3(0.0));
}

vec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {
		return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);
}
`,
              z = `
#ifdef MAPFLOAT
uniform float material_iridescence;
#endif

void getIridescence() {
		float iridescence = 1.0;

		#ifdef MAPFLOAT
		iridescence *= material_iridescence;
		#endif

		#ifdef MAPTEXTURE
		iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		dIridescence = iridescence; 
}
`,
              K = `
uniform float material_iridescenceThicknessMax;

#ifdef MAPTEXTURE
uniform float material_iridescenceThicknessMin;
#endif

void getIridescenceThickness() {

		#ifdef MAPTEXTURE
		float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);
		#else
		float iridescenceThickness = material_iridescenceThicknessMax;
		#endif

		dIridescenceThickness = iridescenceThickness; 
}
`,
              Te = `
attribute vec4 instance_line1;
attribute vec4 instance_line2;
attribute vec4 instance_line3;
attribute vec4 instance_line4;
`,
              H = `
#ifdef MAPFLOAT
uniform float material_refractionIndex;
#endif

void getIor() {
#ifdef MAPFLOAT
		dIor = material_refractionIndex;
#else
		dIor = 1.0 / 1.5;
#endif
}
`,
              q = `
float getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		return max(dot(worldNormal, -lightDirNorm), 0.0);
}
`,
              se = `
void getLightDirPoint(vec3 lightPosW) {
		dLightDirW = vPositionW - lightPosW;
		dLightDirNormW = normalize(dLightDirW);
		dLightPosW = lightPosW;
}
`,
              Ce = `
void addLightMap(
		vec3 lightmap, 
		vec3 dir, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
		float gloss, 
		vec3 specularity, 
		vec3 vertexNormal, 
		mat3 tbn
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
) {
		dDiffuseLight += lightmap;
}
`,
              we = `
void addLightMap(
		vec3 lightmap, 
		vec3 dir, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
		float gloss, 
		vec3 specularity, 
		vec3 vertexNormal, 
		mat3 tbn
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
) {
		if (dot(dir, dir) < 0.0001) {
				dDiffuseLight += lightmap;
		} else {
				float vlight = saturate(dot(dir, -vertexNormal));
				float flight = saturate(dot(dir, -worldNormal));
				float nlight = (flight / max(vlight, 0.01)) * 0.5;

				dDiffuseLight += lightmap * nlight * 2.0;

				vec3 halfDir = normalize(-dir + viewDir);
				vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);

#ifdef LIT_SPECULAR_FRESNEL
				specularLight *= 
						getFresnel(dot(viewDir, halfDir), 
						gloss, 
						specularity
				#if defined(LIT_IRIDESCENCE)
						, iridescenceFresnel,
						iridescenceIntensity
				#endif
						);
#endif

				dSpecularLight += specularLight;
		}
}
`,
              Me = `
uniform sampler2D texture_lightMap;
uniform sampler2D texture_dirLightMap;

void getLightMap() {
		dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;

		vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;
		float dirDot = dot(dir, dir);
		dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);
}
`,
              Ie = `
void getLightMap() {
		dLightmap = vec3(1.0);

		#ifdef MAPTEXTURE
		dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		dLightmap *= saturate(vVertexColor.$VC);
		#endif
}
`,
              Le = `
// Anisotropic GGX
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {
		float PI = 3.141592653589793;
		float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
		float anisotropy = material_anisotropy * roughness;
 
		float at = max((roughness + anisotropy), roughness / 4.0);
		float ab = max((roughness - anisotropy), roughness / 4.0);

		float NoH = dot(worldNormal, h);
		float ToH = dot(tbn[0], h);
		float BoH = dot(tbn[1], h);

		float a2 = at * ab;
		vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
		float v2 = dot(v, v);
		float w2 = a2 / v2;
		float D = a2 * w2 * w2 * (1.0 / PI);

		float ToV = dot(tbn[0], viewDir);
		float BoV = dot(tbn[1], viewDir);
		float ToL = dot(tbn[0], -lightDirNorm);
		float BoL = dot(tbn[1], -lightDirNorm);
		float NoV = dot(worldNormal, viewDir);
		float NoL = dot(worldNormal, -lightDirNorm);

		float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
		float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
		float G = 0.5 / (lambdaV + lambdaL);

		return D * G;
}

float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
		return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);
}
`,
              tt = `
// Energy-conserving (hopefully) Blinn-Phong
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {
		float nh = max( dot( h, worldNormal ), 0.0 );

		float specPow = exp2(gloss * 11.0); // glossiness is linear, power is not; 0 - 2048

		// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little
		specPow = max(specPow, 0.0001);

		return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}

float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
		return calcLightSpecular(gloss, worldNormal, h);
}
`,
              vt = `
float calcLightSpecular(float gloss, vec3 reflDir, vec3 lightDirNorm) {
		float specPow = gloss;

		// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little
		return pow(max(dot(reflDir, -lightDirNorm), 0.0), specPow + 0.0001);
}

float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
		return calcLightSpecular(gloss, reflDir, lightDirNorm);
}
`,
              it = `

float sheenD(vec3 normal, vec3 h, float roughness) {
		float invR = 1.0 / (roughness * roughness);
		float cos2h = max(dot(normal, h), 0.0);
		cos2h *= cos2h;
		float sin2h = max(1.0 - cos2h, 0.0078125);
		return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}

float sheenV(vec3 normal, vec3 viewDir, vec3 light) {
		float NoV = max(dot(normal, viewDir), 0.000001);
		float NoL = max(dot(normal, light), 0.000001);
		return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}

float getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {
		float D = sheenD(worldNormal, h, sheenGloss);
		float V = sheenV(worldNormal, viewDir, -lightDirNorm);
		return D * V;
}
`,
              At = `

#ifndef LINEARIZE_DEPTH
#define LINEARIZE_DEPTH

float linearizeDepth(float z, vec4 cameraParams) {
		if (cameraParams.w == 0.0)
				return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));
		else
				return cameraParams.z + z * (cameraParams.y - cameraParams.z);
}

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params; // x: 1 / camera_far,      y: camera_far,     z: camera_near,        w: is_ortho
#endif

#ifdef GL2
float linearizeDepth(float z) {
		return linearizeDepth(z, camera_params);
}
#else
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif
`,
              Rt = `

// Surface albedo absorbance
vec3 litArgs_albedo;

// Transparency
float litArgs_opacity;

// Emission color
vec3 litArgs_emission;

// Normal direction in world space
vec3 litArgs_worldNormal;

// Ambient occlusion amount, range [0..1]
float litArgs_ao;

// Light map color
vec3 litArgs_lightmap;

// Light map direction
vec3 litArgs_lightmapDir;

// Surface metalness factor, range [0..1]
float litArgs_metalness;

// The f0 specularity factor
vec3 litArgs_specularity;

// Specularity intensity factor, range [0..1]
float litArgs_specularityFactor;

// The microfacet glossiness factor, range [0..1]
float litArgs_gloss;

// Glossiness of the sheen layer, range [0..1]
float litArgs_sheen_gloss;

// The color of the f0 specularity factor for the sheen layer
vec3 litArgs_sheen_specularity;

// Transmission factor (refraction), range [0..1]
float litArgs_transmission;

// Uniform thickness of medium, used by transmission, range [0..inf]
float litArgs_thickness;

// Index of refraction
float litArgs_ior;

// Iridescence effect intensity, range [0..1]
float litArgs_iridescence_intensity;

// Thickness of the iridescent microfilm layer, value is in nanometers, range [0..1000]
float litArgs_iridescence_thickness;

// The normal used for the clearcoat layer
vec3 litArgs_clearcoat_worldNormal;

// Intensity of the clearcoat layer, range [0..1]
float litArgs_clearcoat_specularity;

// Glossiness of clearcoat layer, range [0..1]
float litArgs_clearcoat_gloss;

`,
              Ft = `
// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

mat3 transposeMat3( const in mat3 m ) {
		mat3 tmp;
		tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
		tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
		tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
		return tmp;
}

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
		const float LUT_SIZE = 64.0;
		const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
		const float LUT_BIAS = 0.5 / LUT_SIZE;
		float dotNV = saturate( dot( N, V ) );
		// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
		vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
		uv = uv * LUT_SCALE + LUT_BIAS;
		return uv;
}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {
		// Real-Time Area Lighting: a Journey from Research to Production (p.102)
		// An approximation of the form factor of a horizon-clipped rectangle.
		float l = length( f );
		return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
		float x = dot( v1, v2 );
		float y = abs( x );
		// rational polynomial approximation to theta / sin( theta ) / 2PI
		float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
		float b = 3.4175940 + ( 4.1616724 + y ) * y;
		float v = a / b;
		float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
		return cross( v1, v2 ) * theta_sintheta;
}

struct Coords {
		vec3 coord0;
		vec3 coord1;
		vec3 coord2;
		vec3 coord3;
};

float LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {
		// bail if point is on back side of plane of light
		// assumes ccw winding order of light vertices
		vec3 v1 = rectCoords.coord1 - rectCoords.coord0;
		vec3 v2 = rectCoords.coord3 - rectCoords.coord0;
		
		vec3 lightNormal = cross( v1, v2 );
		// if( dot( lightNormal, P - rectCoords.coord0 ) < 0.0 ) return 0.0;
		float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));

		// construct orthonormal basis around N
		vec3 T1, T2;
		T1 = normalize( V - N * dot( V, N ) );
		T2 =  factor * cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system
		// compute transform
		mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
		// transform rect
		vec3 coords[ 4 ];
		coords[ 0 ] = mat * ( rectCoords.coord0 - P );
		coords[ 1 ] = mat * ( rectCoords.coord1 - P );
		coords[ 2 ] = mat * ( rectCoords.coord2 - P );
		coords[ 3 ] = mat * ( rectCoords.coord3 - P );
		// project rect onto sphere
		coords[ 0 ] = normalize( coords[ 0 ] );
		coords[ 1 ] = normalize( coords[ 1 ] );
		coords[ 2 ] = normalize( coords[ 2 ] );
		coords[ 3 ] = normalize( coords[ 3 ] );
		// calculate vector form factor
		vec3 vectorFormFactor = vec3( 0.0 );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
		// adjust for horizon clipping
		float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

		return result;
}

Coords dLTCCoords;
Coords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
		Coords coords;
		coords.coord0 = lightPos + halfWidth - halfHeight;
		coords.coord1 = lightPos - halfWidth - halfHeight;
		coords.coord2 = lightPos - halfWidth + halfHeight;
		coords.coord3 = lightPos + halfWidth + halfHeight;
		return coords;
}

float dSphereRadius;
Coords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
		// used for simple sphere light falloff
		// also, the code only handles a spherical light, it cannot be non-uniformly scaled in world space, and so we enforce it here
		dSphereRadius = max(length(halfWidth), length(halfHeight));

		// Billboard the 2d light quad to reflection vector, as it's used for specular. This allows us to use disk math for the sphere.
		vec3 f = reflect(normalize(lightPos - view_position), vNormalW);
		vec3 w = normalize(cross(f, halfHeight));
		vec3 h = normalize(cross(f, w));

		return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}

// used for LTC LUT texture lookup
vec2 dLTCUV;
#ifdef LIT_CLEARCOAT
vec2 ccLTCUV;
#endif
vec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)
{
		float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
		return LTC_Uv( worldNormal, viewDir, roughness );
}

//used for energy conservation and to modulate specular
vec3 dLTCSpecFres;
#ifdef LIT_CLEARCOAT
vec3 ccLTCSpecFres;
#endif
vec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)
{
		vec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);

		#ifdef AREA_R8_G8_B8_A8_LUTS
		t2 *= vec4(0.693103,1,1,1);
		t2 += vec4(0.306897,0,0,0);
		#endif

		return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;
}

void calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)
{
		dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);
		dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); 

#ifdef LIT_CLEARCOAT
		ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);
		ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));
#endif
}

void calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
void calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		calcRectLightValues(lightPos, halfWidth, halfHeight);
}
void calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}

// An extended version of the implementation from
// "How to solve a cubic equation, revisited"
// http://momentsingraphics.de/?p=105
vec3 SolveCubic(vec4 Coefficient)
{
		float pi = 3.14159;
		// Normalize the polynomial
		Coefficient.xyz /= Coefficient.w;
		// Divide middle coefficients by three
		Coefficient.yz /= 3.0;

		float A = Coefficient.w;
		float B = Coefficient.z;
		float C = Coefficient.y;
		float D = Coefficient.x;

		// Compute the Hessian and the discriminant
		vec3 Delta = vec3(
				-Coefficient.z * Coefficient.z + Coefficient.y,
				-Coefficient.y * Coefficient.z + Coefficient.x,
				dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)
		);

		float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);

		vec3 RootsA, RootsD;

		vec2 xlc, xsc;

		// Algorithm A
		{
				float A_a = 1.0;
				float C_a = Delta.x;
				float D_a = -2.0 * B * Delta.x + Delta.y;

				// Take the cubic root of a normalized complex number
				float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;

				float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);
				float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);

				float xl;
				if ((x_1a + x_3a) > 2.0 * B)
						xl = x_1a;
				else
						xl = x_3a;

				xlc = vec2(xl - B, A);
		}

		// Algorithm D
		{
				float A_d = D;
				float C_d = Delta.z;
				float D_d = -D * Delta.y + 2.0 * C * Delta.z;

				// Take the cubic root of a normalized complex number
				float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;

				float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);
				float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);

				float xs;
				if (x_1d + x_3d < 2.0 * C)
						xs = x_1d;
				else
						xs = x_3d;

				xsc = vec2(-D, xs + C);
		}

		float E =  xlc.y * xsc.y;
		float F = -xlc.x * xsc.y - xlc.y * xsc.x;
		float G =  xlc.x * xsc.x;

		vec2 xmc = vec2(C * F - B * G, -B * F + C * E);

		vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);

		if (Root.x < Root.y && Root.x < Root.z)
				Root.xyz = Root.yxz;
		else if (Root.z < Root.x && Root.z < Root.y)
				Root.xyz = Root.xzy;

		return Root;
}

float LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)
{
		// construct orthonormal basis around N
		vec3 T1, T2;
		T1 = normalize(V - N * dot(V, N));
		T2 = cross(N, T1);

		// rotate area light in (T1, T2, N) basis
		//mat3 R = transpose(mat3(T1, T2, N));
		mat3 R = transposeMat3( mat3( T1, T2, N ) );
		// polygon (allocate 5 vertices for clipping)
		vec3 L_[ 3 ];
		L_[ 0 ] = R * ( points.coord0 - P );
		L_[ 1 ] = R * ( points.coord1 - P );
		L_[ 2 ] = R * ( points.coord2 - P );

		vec3 Lo_i = vec3(0);

		// init ellipse
		vec3 C  = 0.5 * (L_[0] + L_[2]);
		vec3 V1 = 0.5 * (L_[1] - L_[2]);
		vec3 V2 = 0.5 * (L_[1] - L_[0]);

		C  = Minv * C;
		V1 = Minv * V1;
		V2 = Minv * V2;

		//if(dot(cross(V1, V2), C) > 0.0)
		//    return 0.0;

		// compute eigenvectors of ellipse
		float a, b;
		float d11 = dot(V1, V1);
		float d22 = dot(V2, V2);
		float d12 = dot(V1, V2);
		if (abs(d12) / sqrt(d11 * d22) > 0.0001)
		{
				float tr = d11 + d22;
				float det = -d12 * d12 + d11 * d22;

				// use sqrt matrix to solve for eigenvalues
				det = sqrt(det);
				float u = 0.5 * sqrt(tr - 2.0 * det);
				float v = 0.5 * sqrt(tr + 2.0 * det);
				float e_max = (u + v) * (u + v);
				float e_min = (u - v) * (u - v);

				vec3 V1_, V2_;

				if (d11 > d22)
				{
						V1_ = d12 * V1 + (e_max - d11) * V2;
						V2_ = d12 * V1 + (e_min - d11) * V2;
				}
				else
				{
						V1_ = d12*V2 + (e_max - d22)*V1;
						V2_ = d12*V2 + (e_min - d22)*V1;
				}

				a = 1.0 / e_max;
				b = 1.0 / e_min;
				V1 = normalize(V1_);
				V2 = normalize(V2_);
		}
		else
		{
				a = 1.0 / dot(V1, V1);
				b = 1.0 / dot(V2, V2);
				V1 *= sqrt(a);
				V2 *= sqrt(b);
		}

		vec3 V3 = cross(V1, V2);
		if (dot(C, V3) < 0.0)
				V3 *= -1.0;

		float L  = dot(V3, C);
		float x0 = dot(V1, C) / L;
		float y0 = dot(V2, C) / L;

		float E1 = inversesqrt(a);
		float E2 = inversesqrt(b);

		a *= L * L;
		b *= L * L;

		float c0 = a * b;
		float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;
		float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);
		float c3 = 1.0;

		vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));
		float e1 = roots.x;
		float e2 = roots.y;
		float e3 = roots.z;

		vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);

		mat3 rotate = mat3(V1, V2, V3);

		avgDir = rotate * avgDir;
		avgDir = normalize(avgDir);

		float L1 = sqrt(-e2 / e3);
		float L2 = sqrt(-e2 / e1);

		float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));
		
		const float LUT_SIZE = 64.0;
		const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
		const float LUT_BIAS = 0.5 / LUT_SIZE;

		// use tabulated horizon-clipped sphere
		vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);
		uv = uv*LUT_SCALE + LUT_BIAS;

		float scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;

		return formFactor*scale;
}

float getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}

float getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}

float getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		// NB: this could be improved further with distance based wrap lighting
		float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);
		return getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;
}

mat3 getLTCLightInvMat(vec2 uv)
{
		vec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);

		#ifdef AREA_R8_G8_B8_A8_LUTS
		t1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);
		t1 += vec4(0.0, -0.2976, -0.01381, 0.0);
		#endif

		return mat3(
				vec3( t1.x, 0, t1.y ),
				vec3(    0, 1,    0 ),
				vec3( t1.z, 0, t1.w )
		);
}

float calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
		mat3 mInv = getLTCLightInvMat(uv);
		return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}

float getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {
		return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);
}

float calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
		mat3 mInv = getLTCLightInvMat(uv);
		return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}

float getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {
		return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}

float getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {
		return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
`,
              ut = `
#ifdef MAPFLOAT
uniform float material_metalness;
#endif

void getMetalness() {
		float metalness = 1.0;

		#ifdef MAPFLOAT
		metalness *= material_metalness;
		#endif

		#ifdef MAPTEXTURE
		metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		metalness *= saturate(vVertexColor.$VC);
		#endif

		dMetalness = metalness;
}
`,
              Pt = `
uniform sampler2D texture_msdfMap;

#ifdef GL_OES_standard_derivatives
#define USE_FWIDTH
#endif

#ifdef GL2
#define USE_FWIDTH
#endif

float median(float r, float g, float b) {
		return max(min(r, g), min(max(r, g), b));
}

float map (float min, float max, float v) {
		return (v - min) / (max - min);
}

uniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost
uniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF
uniform float font_textureWidth; // the width of the texture atlas

#ifdef UNIFORM_TEXT_PARAMETERS
uniform vec4 outline_color;
uniform float outline_thickness;
uniform vec4 shadow_color;
uniform vec2 shadow_offset;
#else
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
#endif

vec4 applyMsdf(vec4 color) {
		// sample the field
		vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;
		vec2 uvShdw = vUv0 - shadow_offset;
		vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;
		// get the signed distance value
		float sigDist = median(tsample.r, tsample.g, tsample.b);
		float sigDistShdw = median(ssample.r, ssample.g, ssample.b);

		// smoothing limit - smaller value makes for sharper but more aliased text, especially on angles
		// too large value (0.5) creates a dark glow around the letters
		float smoothingMax = 0.2;

		#ifdef USE_FWIDTH
		// smoothing depends on size of texture on screen
		vec2 w = fwidth(vUv0);
		float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);
		#else
		float font_size = 16.0; // TODO fix this
		// smoothing gets smaller as the font size gets bigger
		// don't have fwidth we can approximate from font size, this doesn't account for scaling
		// so a big font scaled down will be wrong...
		float smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);
		#endif

		float mapMin = 0.05;
		float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);

		// remap to a smaller range (used on smaller font sizes)
		float sigDistInner = map(mapMin, mapMax, sigDist);
		float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);
		sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);

		float center = 0.5;
		// calculate smoothing and use to generate opacity
		float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);
		float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);
		float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);

		vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);
		tcolor = mix(tcolor, color, inside);

		vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;
		tcolor = mix(scolor, tcolor, outline);
		
		return tcolor;
}
`,
              bt = `

vec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {
		vec3 dielectricF0 = f0 * specularity;
		return mix(dielectricF0, albedo, metalness);
}

vec3 getAlbedoModulate(in vec3 albedo, in float metalness) {
		return albedo * (1.0 - metalness);
}
`,
              Zt = `
attribute vec3 vertex_outlineParameters;
attribute vec3 vertex_shadowParameters;

varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;

void unpackMsdfParams() {
		vec3 little = mod(vertex_outlineParameters, 256.);
		vec3 big = (vertex_outlineParameters - little) / 256.;

		outline_color.rb = little.xy / 255.;
		outline_color.ga = big.xy / 255.;

		// _outlineThicknessScale === 0.2
		outline_thickness = little.z / 255. * 0.2;

		little = mod(vertex_shadowParameters, 256.);
		big = (vertex_shadowParameters - little) / 256.;

		shadow_color.rb = little.xy / 255.;
		shadow_color.ga = big.xy / 255.;

		// vec2(little.z, big.z) / 127. - 1. remaps shadow offset from [0, 254] to [-1, 1]
		// _shadowOffsetScale === 0.005
		shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;
}
`,
              Xt = `
#ifdef MORPHING_TEXTURE_BASED_NORMAL
uniform highp sampler2D morphNormalTex;
#endif

vec3 getNormal() {
		#ifdef SKIN
		dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
		#elif defined(INSTANCING)
		dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
		#else
		dNormalMatrix = matrix_normal;
		#endif

		vec3 tempNormal = vertex_normal;

		#ifdef MORPHING
		#ifdef MORPHING_NRM03
		tempNormal += morph_weights_a[0] * morph_nrm0;
		tempNormal += morph_weights_a[1] * morph_nrm1;
		tempNormal += morph_weights_a[2] * morph_nrm2;
		tempNormal += morph_weights_a[3] * morph_nrm3;
		#endif
		#ifdef MORPHING_NRM47
		tempNormal += morph_weights_b[0] * morph_nrm4;
		tempNormal += morph_weights_b[1] * morph_nrm5;
		tempNormal += morph_weights_b[2] * morph_nrm6;
		tempNormal += morph_weights_b[3] * morph_nrm7;
		#endif
		#endif

		#ifdef MORPHING_TEXTURE_BASED_NORMAL

				#ifdef WEBGPU
						ivec2 morphUV = getTextureMorphCoords();
						vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;
				#else
						vec2 morphUV = getTextureMorphCoords();
						vec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;
				#endif

		// apply morph offset from texture
		tempNormal += morphNormal;
		#endif

		return normalize(dNormalMatrix * tempNormal);
}
`,
              yt = `
#ifdef MAPTEXTURE
uniform float material_normalDetailMapBumpiness;

vec3 blendNormals(vec3 n1, vec3 n2) {
		// https://blog.selfshadow.com/publications/blending-in-detail/#detail-oriented
		n1 += vec3(0, 0, 1);
		n2 *= vec3(-1, -1, 1);
		return n1 * dot(n1, n2) / n1.z - n2;
}
#endif

vec3 addNormalDetail(vec3 normalMap) {
#ifdef MAPTEXTURE
		vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);
		return blendNormals(normalMap, normalDetailMap);
#else
		return normalMap;
#endif
}
`,
              Pe = `
vec3 getNormal() {
		dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
		return normalize(dNormalMatrix * vertex_normal);
}
`,
              $e = `
#ifdef MAPTEXTURE
uniform float material_bumpiness;
#endif

void getNormal() {
#ifdef MAPTEXTURE
		vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);
		dNormalW = normalize(dTBN * addNormalDetail(normalMap));
#else
		dNormalW = dVertexNormalW;
#endif
}
`,
              Je = `
vec3 getNormal() {
		dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
		return normalize(dNormalMatrix * vertex_normal);
}
`,
              rt = `
vec3 unpackNormal(vec4 nmap) {
		vec3 normal;
		normal.xy = nmap.wy * 2.0 - 1.0;
		normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
		return normal;
}
`,
              ct = `
vec3 unpackNormal(vec4 nmap) {
		return nmap.xyz * 2.0 - 1.0;
}
`,
              Ve = `
#ifdef MAPFLOAT
uniform float material_opacity;
#endif

void getOpacity() {
		dAlpha = 1.0;

		#ifdef MAPFLOAT
		dAlpha *= material_opacity;
		#endif

		#ifdef MAPTEXTURE
		dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);
		#endif
}
`,
              wt = `
`,
              at = `
gl_FragColor.a = litArgs_opacity;
`,
              ce = `
		gl_FragColor.a = 1.0;
`,
              pe = `
gl_FragColor.rgb *= litArgs_opacity;
gl_FragColor.a = litArgs_opacity;
`,
              De = `
varying vec2 vUv0;

uniform sampler2D source;

void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`,
              fe = `
// Packing a float in GLSL with multiplication and mod
// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement
vec4 packFloat(float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);

		// combination of mod and multiplication and division works better
		vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
		res -= res.xxyz * bit_mask;
		return res;
}
`,
              Ze = `

#ifdef MAPCOLOR
uniform vec3 material_sheen;
#endif

void getSheen() {
		vec3 sheenColor = vec3(1, 1, 1);

		#ifdef MAPCOLOR
		sheenColor *= material_sheen;
		#endif

		#ifdef MAPTEXTURE
		sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		sheenColor *= saturate(vVertexColor.$VC);
		#endif

		sSpecularity = sheenColor;
}
`,
              Ne = `
#ifdef MAPFLOAT
uniform float material_sheenGloss;
#endif

void getSheenGlossiness() {
		float sheenGlossiness = 1.0;

		#ifdef MAPFLOAT
		sheenGlossiness *= material_sheenGloss;
		#endif

		#ifdef MAPTEXTURE
		sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		sheenGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		sheenGlossiness = 1.0 - sheenGlossiness;
		#endif

		sheenGlossiness += 0.0000001;
		sGlossiness = sheenGlossiness;
}
`,
              Ye = `
uniform float material_heightMapFactor;

void getParallax() {
		float parallaxScale = material_heightMapFactor;

		float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		height = height * parallaxScale - parallaxScale*0.5;
		vec3 viewDirT = dViewDirW * dTBN;

		viewDirT.z += 0.42;
		dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`,
              Ke = `
varying vec4 texCoordsAlphaLife;

uniform sampler2D colorMap;
uniform sampler2D colorParam;
uniform float graphSampleSize;
uniform float graphNumSamples;

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif

uniform float softening;
uniform float colorMult;

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		float depth = dot(rgbaDepth, bitShift);
		return depth;
}
#endif

void main(void) {
		vec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));
		vec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));
		ramp.rgb *= colorMult;

		ramp.a += texCoordsAlphaLife.z;

		vec3 rgb = tex.rgb * ramp.rgb;
		float a  = tex.a * ramp.a;
`,
              nt = `
vec3 unpack3NFloats(float src) {
		float r = fract(src);
		float g = fract(src * 256.0);
		float b = fract(src * 65536.0);
		return vec3(r, g, b);
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {
		return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );
}

vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
		vec4 a = texture2D(tex,tc);
		vec4 b = texture2D(tex,tc + graphSampleSize);
		float c = fract(tc.x*graphNumSamples);

		vec3 unpackedA = unpack3NFloats(a.w);
		vec3 unpackedB = unpack3NFloats(b.w);
		w = mix(unpackedA, unpackedB, c);

		return mix(a, b, c);
}

vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {
		float c = cos(pRotation);
		float s = sin(pRotation);

		mat2 m = mat2(c, -s, s, c);
		rotMatrix = m;

		return m * quadXY;
}

vec3 billboard(vec3 InstanceCoords, vec2 quadXY) {
		#ifdef SCREEN_SPACE
				vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
		#else
				vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
		#endif

		return pos;
}

vec3 customFace(vec3 InstanceCoords, vec2 quadXY) {
		vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
		return pos;
}

vec2 safeNormalize(vec2 v) {
		float l = length(v);
		return (l > 1e-06) ? v / l : v;
}

void main(void) {
		vec3 meshLocalPos = particle_vertexData.xyz;
		float id = floor(particle_vertexData.w);

		float rndFactor = fract(sin(id + 1.0 + seed));
		vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));

		float uv = id / numParticlesPot;
		readInput(uv);

#ifdef LOCAL_SPACE
		inVel = mat3(matrix_model) * inVel;
#endif
		vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used

		float particleLifetime = lifetime;

		if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);
		vec2 quadXY = meshLocalPos.xy;
		float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);

		vec3 paramDiv;
		vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
		float scale = params.y;
		float scaleDiv = paramDiv.x;
		float alphaDiv = paramDiv.z;

		scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);

#ifndef USE_MESH
		texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#else
		texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#endif

		vec3 particlePos = inPos;
		vec3 particlePosMoved = vec3(0.0);

		mat2 rotMatrix;
`,
              ot = `
		float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);
`,
              ze = `
		float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));
`,
              et = `
		float animationIndex;

		if (animTexIndexParams.y == 1.0) {
				animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);
		} else {
				animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);
		}

		float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;
		float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;
		atlasX = fract(atlasX);

		texCoordsAlphaLife.xy *= animTexTilesParams.xy;
		texCoordsAlphaLife.xy += vec2(atlasX, atlasY);
`,
              _t = `
void readInput(float uv) {
		vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));
		vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));

		inPos = tex.xyz;
		inVel = tex2.xyz;
		inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;
		inShow = tex.w >= 0.0;
		inLife = tex2.w;
}
`,
              Qe = `
//RG=X, BA=Y
//RG=Z, BA=A
//RGB=V, A=visMode
//RGBA=life

#define PI2 6.283185307179586

uniform vec3 inBoundsSize;
uniform vec3 inBoundsCenter;

uniform float maxVel;

float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

float decodeFloatRGBA( vec4 rgba ) {
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );
}

void readInput(float uv) {
		vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));
		vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));
		vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));
		vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));

		inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
		inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;

		inVel = tex2.xyz;
		inVel = (inVel - vec3(0.5)) * maxVel;

		inAngle = decodeFloatRG(tex1.ba) * PI2;
		inShow = tex2.a > 0.5;

		inLife = decodeFloatRGBA(tex3);
		float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
		float maxPosLife = lifetime+1.0;
		inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;
}
`,
              lt = `
void writeOutput() {
		if (gl_FragCoord.y<1.0) {
				gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);
		} else {
				gl_FragColor = vec4(outVel, outLife);
		}
}
`,
              xt = `
uniform vec3 outBoundsMul;
uniform vec3 outBoundsAdd;

vec2 encodeFloatRG( float v ) {
		vec2 enc = vec2(1.0, 255.0) * v;
		enc = fract(enc);
		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
		return enc;
}

vec4 encodeFloatRGBA( float v ) {
		vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
		enc = fract(enc);
		enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
		return enc;
}

void writeOutput() {
		outPos = outPos * outBoundsMul + outBoundsAdd;
		outAngle = fract(outAngle / PI2);

		outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul

		float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
		float maxPosLife = lifetime+1.0;
		outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);

		if (gl_FragCoord.y < 1.0) {
				gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
		} else if (gl_FragCoord.y < 2.0) {
				gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
		} else if (gl_FragCoord.y < 3.0) {
				gl_FragColor = vec4(outVel, visMode*0.5+0.5);
		} else {
				gl_FragColor = encodeFloatRGBA(outLife);
		}
}
`,
              Tt = `
uniform mat3 spawnBounds;
uniform vec3 spawnPosInnerRatio;

vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
		vec3 pos = inBounds - vec3(0.5);

		vec3 posAbs = abs(pos);
		vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));

		vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;

		pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);
		pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);
		pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);

#ifndef LOCAL_SPACE
		return emitterPos + spawnBounds * pos;
#else
		return spawnBounds * pos;
#endif
}

void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
		localVelocity -= vec3(0, 0, initialVelocity);
}
`,
              ft = `
		writeOutput();
}
`,
              gt = `
varying vec2 vUv0;

uniform highp sampler2D particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform highp sampler2D internalTex3;

uniform mat3 emitterMatrix, emitterMatrixInv;
uniform vec3 emitterScale;

uniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;
uniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;
uniform float startAngle, startAngle2;
uniform float initialVelocity;

uniform float graphSampleSize;
uniform float graphNumSamples;

vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
float visMode;

vec3 outPos;
vec3 outVel;
float outAngle;
bool outShow;
float outLife;
`,
              Fe = `
		if (outLife >= lifetime) {
				outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
				visMode = -1.0;
		}
`,
              Qt = `
		visMode = outLife < 0.0? -1.0: visMode;
`,
              zt = `
		if (outLife >= lifetime) {
				outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
				visMode = 1.0;
		}
		visMode = outLife < 0.0? 1.0: visMode;
`,
              Lt = `
uniform float spawnBoundsSphere;
uniform float spawnBoundsSphereInnerRatio;

vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
		float rnd4 = fract(rndFactor * 1000.0);
		vec3 norm = normalize(inBounds.xyz - vec3(0.5));
		float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
#ifndef LOCAL_SPACE
		return emitterPos + norm * r * spawnBoundsSphere;
#else
		return norm * r * spawnBoundsSphere;
#endif
}

void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
		localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;
}
`,
              $t = `
float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec3 unpack3NFloats(float src) {
		float r = fract(src);
		float g = fract(src * 256.0);
		float b = fract(src * 65536.0);
		return vec3(r, g, b);
}

vec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
		vec4 a = texture2D(tex, tc);
		vec4 b = texture2D(tex, tc + graphSampleSize);
		float c = fract(tc.x * graphNumSamples);

		vec3 unpackedA = unpack3NFloats(a.w);
		vec3 unpackedB = unpack3NFloats(b.w);
		w = mix(unpackedA, unpackedB, c);

		return mix(a.xyz, b.xyz, c);
}

#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)
vec4 hash41(float p) {
		vec4 p4 = fract(vec4(p) * HASHSCALE4);
		p4 += dot(p4, p4.wzxy+19.19);
		return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}

void main(void) {
		if (gl_FragCoord.x > numParticles) discard;

		readInput(vUv0.x);
		visMode = inShow? 1.0 : -1.0;

		vec4 rndFactor = hash41(gl_FragCoord.x + seed);

		float particleRate = rate + rateDiv * rndFactor.x;

		outLife = inLife + delta;
		float nlife = clamp(outLife / lifetime, 0.0, 1.0);

		vec3 localVelocityDiv;
		vec3 velocityDiv;
		vec3 paramDiv;
		vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);
		vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);
		vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
		float rotSpeed = params.x;
		float rotSpeedDiv = paramDiv.y;

		vec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);
		float radialSpeed = radialParams.x;
		float radialSpeedDiv = radialParams.y;

		bool respawn = inLife <= 0.0 || outLife >= lifetime;
		inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;
		inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;

#ifndef LOCAL_SPACE
		vec3 radialVel = inPos - emitterPos;
#else
		vec3 radialVel = inPos;
#endif
		radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);
		radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;

		localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;
		velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;
		rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;

		addInitialVelocity(localVelocity, rndFactor.xyz);

#ifndef LOCAL_SPACE
		outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;
#else
		outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;
#endif

		outPos = inPos + outVel * delta;
		outAngle = inAngle + rotSpeed * delta;
`,
              Bt = `
		quadXY = rotate(quadXY, inAngle, rotMatrix);
		vec3 localPos = billboard(particlePos, quadXY);
`,
              Nt = `
		dBlendModeFogFactor = 0.0;
		rgb *= saturate(gammaCorrectInput(max(a, 0.0)));
		if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;
`,
              es = `
		rgb = mix(vec3(1.0), rgb, vec3(a));
		if (rgb.r + rgb.g + rgb.b > 2.99) discard;
`,
              kt = `
		if (a < 0.01) discard;
`,
              ds = `
attribute vec4 particle_vertexData;   // XYZ = world pos, W = life
attribute vec4 particle_vertexData2;  // X = angle, Y = scale, Z = alpha, W = velocity.x
attribute vec4 particle_vertexData3;  // XYZ = particle local pos, W = velocity.y
attribute float particle_vertexData4; // particle id

// type depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y
#ifndef USE_MESH
attribute vec2 particle_vertexData5;
#else
attribute vec4 particle_vertexData5;
#endif

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;

uniform float numParticles;
uniform float lifetime;
uniform float stretch;
uniform float seed;
uniform vec3 wrapBounds;
uniform vec3 emitterScale;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform vec3 emitterPos;

varying vec4 texCoordsAlphaLife;

vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)
{
		float c = cos(pRotation);
		float s = sin(pRotation);
		//vec4 rotationMatrix = vec4(c, -s, s, c);

		mat2 m = mat2(c, -s, s, c);
		rotMatrix = m;

		return m * quadXY;
}

vec3 billboard(vec3 InstanceCoords, vec2 quadXY)
{
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
		return pos;
}

vec3 customFace(vec3 InstanceCoords, vec2 quadXY)
{
		vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
		return pos;
}

void main(void)
{
		vec3 particlePos = particle_vertexData.xyz;
		vec3 inPos = particlePos;
		vec3 vertPos = particle_vertexData3.xyz;
		vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);

		float id = floor(particle_vertexData4);
		float rndFactor = fract(sin(id + 1.0 + seed));
		vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));

#ifdef LOCAL_SPACE
		inVel = mat3(matrix_model) * inVel;
#endif
		vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used

		vec2 quadXY = vertPos.xy;

#ifdef USE_MESH
		texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);
#else
		texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);
#endif
		mat2 rotMatrix;

		float inAngle = particle_vertexData2.x;
		vec3 particlePosMoved = vec3(0.0);
		vec3 meshLocalPos = particle_vertexData3.xyz;
`,
              os = `
		localPos *= particle_vertexData2.y * emitterScale;
		localPos += particlePos;

		gl_Position = matrix_viewProjection * vec4(localPos, 1.0);
`,
              ls = `
		quadXY = rotate(quadXY, inAngle, rotMatrix);
		vec3 localPos = customFace(particlePos, quadXY);
`,
              Ps = `
		rgb = addFog(rgb);
		rgb = toneMap(rgb);
		rgb = gammaCorrectOutput(rgb);
		gl_FragColor = vec4(rgb, a);
}
`,
              us = `
		localPos *= scale * emitterScale;
		localPos += particlePos;

		#ifdef SCREEN_SPACE
		gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
		#else
		gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);
		#endif
`,
              Xe = `
		vec3 negNormal = normal*0.5+0.5;
		vec3 posNormal = -normal*0.5+0.5;
		negNormal *= negNormal;
		posNormal *= posNormal;
`,
              vs = `
attribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor
#ifdef USE_MESH
attribute vec2 particle_uv;         // mesh UV
#endif

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform float numParticles, numParticlesPot;
uniform float graphSampleSize;
uniform float graphNumSamples;
uniform float stretch;
uniform vec3 wrapBounds;
uniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;
uniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;
uniform sampler2D particleTexOUT, particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif

varying vec4 texCoordsAlphaLife;

vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
`,
              fs = `
		vec3 negNormal = max(normal, vec3(0.0));
		vec3 posNormal = max(-normal, vec3(0.0));
`,
              bs = `
		vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +
												negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +
												negNormal.z*lightCube[4] + posNormal.z*lightCube[5];

		rgb *= light;
`,
              Ms = `
		particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;
`,
              Ts = `
		vec3 localPos = meshLocalPos;
		localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);
		localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);

		billboard(particlePos, quadXY);
`,
              Js = `
		Normal = normalize(localPos + matrix_viewInverse[2].xyz);
`,
              Os = `
		vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);
		vec3 normal = ParticleMat * normalMap;
`,
              li = `
		inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors

`,
              $s = `
		float depth = getLinearScreenDepth();
		float particleDepth = vDepth;
		float depthDiff = saturate(abs(particleDepth - depth) * softening);
		a *= depthDiff;
`,
              Cs = `
		vDepth = getLinearDepth(localPos);
`,
              Gs = `
		vec3 moveDir = inVel * stretch;
		vec3 posPrev = particlePos - moveDir;
		posPrev += particlePosMoved;

		vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);

		float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;

		particlePos = mix(particlePos, posPrev, interpolation);
`,
              hi = `
		mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);
		ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;
`,
              ci = `
		vec3 origParticlePos = particlePos;
		particlePos -= matrix_model[3].xyz;
		particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;
		particlePos += matrix_model[3].xyz;
		particlePosMoved = particlePos - origParticlePos;
`,
              ii = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
		dReflDirW = normalize(-reflect(viewDir, worldNormal));
}
`,
              je = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
		float roughness = sqrt(1.0 - min(gloss, 1.0));
		float anisotropy = material_anisotropy * roughness;
		vec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];
		vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);
		vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
		vec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));
		dReflDirW = reflect(-viewDir, bentNormal);
}
`,
              mt = `
#ifdef LIT_CLEARCOAT
void addReflectionCC(vec3 reflDir, float gloss) {
		ccReflection += calcReflection(reflDir, gloss);
}
#endif
`,
              Ot = `
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 lookupVec = fixSeams(cubeMapProject(reflDir));
		lookupVec.x *= -1.0;
		return $DECODE(textureCube(texture_cubeMap, lookupVec));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              ss = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(dir);

		// calculate roughness level
		float level = saturate(1.0 - gloss) * 5.0;
		float ilevel = floor(level);
		float flevel = level - ilevel;

		vec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, fixSeams(dir)));
		vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));
		vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));

		return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              qt = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform float material_reflectivity;

// calculate mip level for shiny reflection given equirect coords uv.
float shinyMipLevel(vec2 uv) {
		vec2 dx = dFdx(uv);
		vec2 dy = dFdy(uv);

		// calculate second dF at 180 degrees
		vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);
		vec2 dx2 = dFdx(uv2);
		vec2 dy2 = dFdy(uv2);

		// calculate min of both sets of dF to handle discontinuity at the azim edge
		float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));

		return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);
}

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(dir);

		// calculate roughness level
		float level = saturate(1.0 - gloss) * 5.0;
		float ilevel = floor(level);

		// accessing the shiny (top level) reflection - perform manual mipmap lookup
		float level2 = shinyMipLevel(uv * atlasSize);
		float ilevel2 = floor(level2);

		vec2 uv0, uv1;
		float weight;
		if (ilevel == 0.0) {
				uv0 = mapShinyUv(uv, ilevel2);
				uv1 = mapShinyUv(uv, ilevel2 + 1.0);
				weight = level2 - ilevel2;
		} else {
				// accessing rough reflection - just sample the same part twice
				uv0 = uv1 = mapRoughnessUv(uv, ilevel);
				weight = 0.0;
		}

		vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));
		vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));
		vec3 linear0 = mix(linearA, linearB, weight);
		vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));

		return processEnvironment(mix(linear0, linear1, level - ilevel));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              is = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;

		float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );
		vec2 sphereMapUv = reflDirV.xy / m + 0.5;

		return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              Ls = `
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 reflDirV = vNormalV;

		vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;
		return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              js = `

void addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {
		float NoV = dot(worldNormal, viewDir);
		float alphaG = gloss * gloss;

		// Avoid using a LUT and approximate the values analytically
		float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;
		float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;
		float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );
		sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);
}
`,
              fi = `
vec3 refract2(vec3 viewVec, vec3 normal, float IOR) {
		float vn = dot(viewVec, normal);
		float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
		vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;
		return refrVec;
}

void addRefraction(
		vec3 worldNormal, 
		vec3 viewDir, 
		float thickness, 
		float gloss, 
		vec3 specularity, 
		vec3 albedo, 
		float transmission,
		float refractionIndex
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel,
		float iridescenceIntensity
#endif 
) {
		// use same reflection code with refraction vector
		vec4 tmpRefl = dReflection;
		vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);
		dReflection = vec4(0);
		addReflection(reflectionDir, gloss);
		dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);
		dReflection = tmpRefl;
}
`,
              pi = `
uniform float material_invAttenuationDistance;
uniform vec3 material_attenuation;

void addRefraction(
		vec3 worldNormal, 
		vec3 viewDir, 
		float thickness, 
		float gloss, 
		vec3 specularity, 
		vec3 albedo, 
		float transmission,
		float refractionIndex
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel,
		float iridescenceIntensity
#endif
) {

		// Extract scale from the model transform
		vec3 modelScale;
		modelScale.x = length(vec3(matrix_model[0].xyz));
		modelScale.y = length(vec3(matrix_model[1].xyz));
		modelScale.z = length(vec3(matrix_model[2].xyz));

		// Calculate the refraction vector, scaled by the thickness and scale of the object
		vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * thickness * modelScale;

		// The refraction point is the entry point + vector to exit point
		vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);

		// Project to texture space so we can sample it
		vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;

		// use built-in getGrabScreenPos function to convert screen position to grab texture uv coords
		vec2 uv = getGrabScreenPos(projectionPoint);

		#ifdef SUPPORTS_TEXLOD
				// Use IOR and roughness to select mip
				float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
				float refractionLod = log2(uScreenSize.x) * iorToRoughness;
				vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;
		#else
				vec3 refraction = texture2D(uSceneColorMap, uv).rgb;
		#endif

		// Transmittance is our final refraction color
		vec3 transmittance;
		if (material_invAttenuationDistance != 0.0)
		{
				vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;
				transmittance = exp(-attenuation * length(refractionVector));
		}
		else
		{
				transmittance = refraction;
		}

		// Apply fresnel effect on refraction
		vec3 fresnel = vec3(1.0) - 
				getFresnel(
						dot(viewDir, worldNormal), 
						gloss, 
						specularity
				#if defined(LIT_IRIDESCENCE)
						, iridescenceFresnel,
						iridescenceIntensity
				#endif
				);
		dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);
}
`,
              _i = `
// This shader requires the following #DEFINEs:
//
// PROCESS_FUNC - must be one of reproject, prefilter
// DECODE_FUNC - must be one of decodeRGBM, decodeRGBE, decodeGamma or decodeLinear
// ENCODE_FUNC - must be one of encodeRGBM, encodeRGBE, encideGamma or encodeLinear
// SOURCE_FUNC - must be one of sampleCubemap, sampleEquirect, sampleOctahedral
// TARGET_FUNC - must be one of getDirectionCubemap, getDirectionEquirect, getDirectionOctahedral
//
// When filtering:
// NUM_SAMPLES - number of samples
// NUM_SAMPLES_SQRT - sqrt of number of samples

varying vec2 vUv0;

// source
#ifdef CUBEMAP_SOURCE
		uniform samplerCube sourceCube;
#else
		uniform sampler2D sourceTex;
#endif

#ifdef USE_SAMPLES_TEX
		// samples
		uniform sampler2D samplesTex;
		uniform vec2 samplesTexInverseSize;
#endif

// params:
// x - target cubemap face 0..6
// y - specular power (when prefiltering)
// z - source cubemap seam scale (0 to disable)
// w - target cubemap size for seam calc (0 to disable)
uniform vec4 params;

// params2:
// x - target image total pixels
// y - source cubemap size
uniform vec2 params2;

float targetFace() { return params.x; }
float specularPower() { return params.y; }
float sourceCubeSeamScale() { return params.z; }
float targetCubeSeamScale() { return params.w; }

float targetTotalPixels() { return params2.x; }
float sourceTotalPixels() { return params2.y; }

float PI = 3.141592653589793;

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

${te}
${_e}

//-- supported projections

vec3 modifySeams(vec3 dir, float scale) {
		vec3 adir = abs(dir);
		float M = max(max(adir.x, adir.y), adir.z);
		return dir / M * vec3(
				adir.x == M ? 1.0 : scale,
				adir.y == M ? 1.0 : scale,
				adir.z == M ? 1.0 : scale
		);
}

vec2 toSpherical(vec3 dir) {
		return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}

vec3 fromSpherical(vec2 uv) {
		return vec3(cos(uv.y) * sin(uv.x),
								sin(uv.y),
								cos(uv.y) * cos(uv.x));
}

vec3 getDirectionEquirect() {
		return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));
}

// octahedral code, based on http://jcgt.org/published/0003/02/01
// "Survey of Efficient Representations for Independent Unit Vectors" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer

float signNotZero(float k){
		return(k >= 0.0) ? 1.0 : -1.0;
}

vec2 signNotZero(vec2 v) {
		return vec2(signNotZero(v.x), signNotZero(v.y));
}

// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square
vec3 octDecode(vec2 o) {
		vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
		if (v.y < 0.0) {
				v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);
		}
		return normalize(v);
}

vec3 getDirectionOctahedral() {
		return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);
}

// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square
vec2 octEncode(in vec3 v) {
		float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
		vec2 result = v.xz * (1.0 / l1norm);
		if (v.y < 0.0) {
				result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
		}
		return result;
}

/////////////////////////////////////////////////////////////////////

#ifdef CUBEMAP_SOURCE
		vec4 sampleCubemap(vec3 dir) {
				return textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));
		}

		vec4 sampleCubemap(vec2 sph) {
		return sampleCubemap(fromSpherical(sph));
}

		vec4 sampleCubemap(vec3 dir, float mipLevel) {
				return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);
		}

		vec4 sampleCubemap(vec2 sph, float mipLevel) {
				return sampleCubemap(fromSpherical(sph), mipLevel);
		}
#else

		vec4 sampleEquirect(vec2 sph) {
				vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
				return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
		}

		vec4 sampleEquirect(vec3 dir) {
				return sampleEquirect(toSpherical(dir));
		}

		vec4 sampleEquirect(vec2 sph, float mipLevel) {
				vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
				return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
		}

		vec4 sampleEquirect(vec3 dir, float mipLevel) {
				return sampleEquirect(toSpherical(dir), mipLevel);
		}

		vec4 sampleOctahedral(vec3 dir) {
				vec2 uv = octEncode(dir) * 0.5 + 0.5;
				return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
		}

		vec4 sampleOctahedral(vec2 sph) {
				return sampleOctahedral(fromSpherical(sph));
		}

		vec4 sampleOctahedral(vec3 dir, float mipLevel) {
				vec2 uv = octEncode(dir) * 0.5 + 0.5;
				return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
		}

		vec4 sampleOctahedral(vec2 sph, float mipLevel) {
				return sampleOctahedral(fromSpherical(sph), mipLevel);
		}

#endif

vec3 getDirectionCubemap() {
		vec2 st = vUv0 * 2.0 - 1.0;
		float face = targetFace();

		vec3 vec;
		if (face == 0.0) {
				vec = vec3(1, -st.y, -st.x);
		} else if (face == 1.0) {
				vec = vec3(-1, -st.y, st.x);
		} else if (face == 2.0) {
				vec = vec3(st.x, 1, st.y);
		} else if (face == 3.0) {
				vec = vec3(st.x, -1, -st.y);
		} else if (face == 4.0) {
				vec = vec3(st.x, -st.y, 1);
		} else {
				vec = vec3(-st.x, -st.y, -1);
		}

		return normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));
}

mat3 matrixFromVector(vec3 n) { // frisvad
		float a = 1.0 / (1.0 + n.z);
		float b = -n.x * n.y * a;
		vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
		vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
		return mat3(b1, b2, n);
}

mat3 matrixFromVectorSlow(vec3 n) {
		vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);
		vec3 x = normalize(cross(up, n));
		vec3 y = cross(n, x);
		return mat3(x, y, n);
}

vec4 reproject() {
		if (NUM_SAMPLES <= 1) {
				// single sample
				return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));
		} else {
				// multi sample
				vec3 t = TARGET_FUNC();
				vec3 tu = dFdx(t);
				vec3 tv = dFdy(t);

				vec3 result = vec3(0.0);
				for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {
						for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {
								result += DECODE_FUNC(SOURCE_FUNC(normalize(t +
																														tu * (u / NUM_SAMPLES_SQRT - 0.5) +
																														tv * (v / NUM_SAMPLES_SQRT - 0.5))));
						}
				}
				return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));
		}
}

vec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);

#ifdef USE_SAMPLES_TEX
		void unpackSample(int i, out vec3 L, out float mipLevel) {
				float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;
				float v = (floor(u) + 0.5) * samplesTexInverseSize.y;

				vec4 raw;
				raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);

				L.xyz = raw.xyz * 2.0 - 1.0;
				mipLevel = raw.w * 8.0;
		}

		// convolve an environment given pre-generated samples
		vec4 prefilterSamples() {
				// construct vector space given target direction
				mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());

				vec3 L;
				float mipLevel;

				vec3 result = vec3(0.0);
				float totalWeight = 0.0;
				for (int i = 0; i < NUM_SAMPLES; ++i) {
						unpackSample(i, L, mipLevel);
						result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;
						totalWeight += L.z;
				}

				return ENCODE_FUNC(result / totalWeight);
		}

		// unweighted version of prefilterSamples
		vec4 prefilterSamplesUnweighted() {
				// construct vector space given target direction
				mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());

				vec3 L;
				float mipLevel;

				vec3 result = vec3(0.0);
				float totalWeight = 0.0;
				for (int i = 0; i < NUM_SAMPLES; ++i) {
						unpackSample(i, L, mipLevel);
						result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));
				}

				return ENCODE_FUNC(result / float(NUM_SAMPLES));
		}
#endif

void main(void) {
		gl_FragColor = PROCESS_FUNC();
}
`,
              mi = `
uniform highp sampler2D uSceneDepthMap;

#ifndef SCREENSIZE
#define SCREENSIZE
uniform vec4 uScreenSize;
#endif

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

#ifndef LINEARIZE_DEPTH
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params; // x: 1 / camera_far,      y: camera_far,     z: camera_near,        w: is_ortho
#endif

#define LINEARIZE_DEPTH
#ifdef GL2
float linearizeDepth(float z) {
		if (camera_params.w == 0.0)
				return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));
		else
				return camera_params.z + z * (camera_params.y - camera_params.z);
}
#else // GL2
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif // LINEARIZE_DEPTH

// Retrieves rendered linear camera depth by UV
float getLinearScreenDepth(vec2 uv) {
		#ifdef GL2
				return linearizeDepth(texture2D(uSceneDepthMap, uv).r);
		#else
				return unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;
		#endif
}

#ifndef VERTEXSHADER
// Retrieves rendered linear camera depth under the current pixel
float getLinearScreenDepth() {
		vec2 uv = gl_FragCoord.xy * uScreenSize.zw;
		return getLinearScreenDepth(uv);
}
#endif

// Generates linear camera depth for the given world position
float getLinearDepth(vec3 pos) {
		return -(matrix_view * vec4(pos, 1.0)).z;
}
`,
              gi = `
const float maxCascades = 4.0;

// shadow matrix for selected cascade
mat4 cascadeShadowMat;

// function which selects a shadow projection matrix based on cascade distances 
void getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {

		// depth in 0 .. far plane range
		float depth = 1.0 / gl_FragCoord.w;

		// find cascade index based on the depth (loop as there is no per component vec compare operator in webgl)
		float cascadeIndex = 0.0;
		for (float i = 0.0; i < maxCascades; i++) {
				if (depth < shadowCascadeDistances[int(i)]) {
						cascadeIndex = i;
						break;
				}
		}

		// limit to actual number of used cascades
		cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);

		// pick shadow matrix
		#ifdef GL2
				cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];
		#else
				// webgl 1 does not allow non-cost index array lookup
				if (cascadeIndex == 0.0) {
						cascadeShadowMat = shadowMatrixPalette[0];
				}
				else if (cascadeIndex == 1.0) {
						cascadeShadowMat = shadowMatrixPalette[1];
				}
				else if (cascadeIndex == 2.0) {
						cascadeShadowMat = shadowMatrixPalette[2];
				}
				else {
						cascadeShadowMat = shadowMatrixPalette[3];
				}
		#endif
}

void fadeShadow(float shadowCascadeDistances[4]) {                  

		// if the pixel is past the shadow distance, remove shadow
		// this enforces straight line instead of corner of shadow which moves when camera rotates  
		float depth = 1.0 / gl_FragCoord.w;
		if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {
				dShadowCoord.z = -9999999.0;
		}
}
`,
              yi = `
float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		vec3 moments = texture2D(tex, texCoords).xyz;
		return calculateEVSM(moments, Z, vsmBias, exponent);
}

float getShadowVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(shadowMap, shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}

float getShadowSpotVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(shadowMap, shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`,
              Li = `
float VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		float pixelSize = 1.0 / resolution;
		texCoords -= vec2(pixelSize);
		vec3 s00 = texture2D(tex, texCoords).xyz;
		vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;
		vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;
		vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;
		vec2 fr = fract(texCoords * resolution);
		vec3 h0 = mix(s00, s10, fr.x);
		vec3 h1 = mix(s01, s11, fr.x);
		vec3 moments = mix(h0, h1, fr.y);
		return calculateEVSM(moments, Z, vsmBias, exponent);
}

float getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}

float getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`,
              Bi = `

/**
 * PCSS is a shadow sampling method that provides contact hardening soft shadows. 
 * Based on: 
 * - https://www.gamedev.net/tutorials/programming/graphics/effect-area-light-shadows-part-1-pcss-r4971/
 * - https://github.com/pboechat/PCSS 
 */


#define PCSS_SAMPLE_COUNT 16
uniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];
uniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];

vec2 vogelDisk(int sampleIndex, float count, float phi, float r) {
		const float GoldenAngle = 2.4;
		float theta = float(sampleIndex) * GoldenAngle + phi;

		float sine = sin(theta);
		float cosine = cos(theta);
		return vec2(r * cosine, r * sine);
}

vec3 vogelSphere(int sampleIndex, float count, float phi, float r) {
		const float GoldenAngle = 2.4;
		float theta = float(sampleIndex) * GoldenAngle + phi;

		float weight = float(sampleIndex) / count;
		return vec3(cos(theta) * r, weight, sin(theta) * r);
}

float noise(vec2 screenPos) {
		const float PHI = 1.61803398874989484820459;  // \u03A6 = Golden Ratio   
		return fract(tan(distance(screenPos * PHI, screenPos)) * screenPos.x);
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif

float viewSpaceDepth(float depth, mat4 invProjection) {
		float z = depth * 2.0 - 1.0;
		vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);
		vec4 viewSpace = invProjection * clipSpace;
		return viewSpace.z;
}

float PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {

		float blockers = 0.0;
		float averageBlocker = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				vec2 offset = sampleCoords[i] * searchSize;
				vec2 sampleUV = shadowCoords + offset;

		#ifdef GL2
				float blocker = textureLod(shadowMap, sampleUV, 0.0).r;
		#else // GL1
				float blocker = unpackFloat(texture2D(shadowMap, sampleUV));
		#endif        
				float isBlocking = step(blocker, z);
				blockers += isBlocking;
				averageBlocker += blocker * isBlocking;
		}

		if (blockers > 0.0)
				return averageBlocker /= blockers;
		return -1.0;
}

float PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {
		float receiverDepth = shadowCoords.z;
#ifndef GL2
		// If using packed depth on GL1, we need to normalize to get the correct receiver depth
		receiverDepth *= 1.0 / (cameraParams.y - cameraParams.z);
#endif

		vec2 samplePoints[PCSS_SAMPLE_COUNT];
		float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				float pcssPresample = pcssDiskSamples[i];
				samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);
		}

		float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);
		if (averageBlocker == -1.0) {
				return 1.0;
		} else {

				vec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;

				float shadow = 0.0;

				for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)
				{
						vec2 sampleUV = samplePoints[i] * filterRadius;
						sampleUV = shadowCoords.xy + sampleUV;

				#ifdef GL2
						float depth = textureLod(shadowMap, sampleUV, 0.0).r;
				#else // GL1
						float depth = unpackFloat(texture2D(shadowMap, sampleUV));
				#endif
						shadow += step(receiverDepth, depth);
				}
				return shadow / float(PCSS_SAMPLE_COUNT);
		} 
}

float PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {
		float blockers = 0.0;
		float averageBlocker = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;
				sampleDir = normalize(sampleDir);

		#ifdef GL2
				float blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
		#else // GL1
				float blocker = unpackFloat(textureCube(shadowMap, sampleDir));
		#endif
				float isBlocking = step(blocker, z);
				blockers += isBlocking;
				averageBlocker += blocker * isBlocking;
		}

		if (blockers > 0.0)
				return averageBlocker /= float(blockers);
		return -1.0;
}

float PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {
		
		vec3 samplePoints[PCSS_SAMPLE_COUNT];
		float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				float r = pcssSphereSamples[i];
				samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);
		}

		float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 lightDirNorm = normalize(lightDir);
		
		float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);
		if (averageBlocker == -1.0) {
				return 1.0;
		} else {

				float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;

				float shadow = 0.0;
				for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)
				{
						vec3 offset = samplePoints[i] * filterRadius;
						vec3 sampleDir = lightDirNorm + offset;
						sampleDir = normalize(sampleDir);

						#ifdef GL2
								float depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
						#else // GL1
								float depth = unpackFloat(textureCube(shadowMap, sampleDir));
						#endif
						shadow += step(receiverDepth, depth);
				}
				return shadow / float(PCSS_SAMPLE_COUNT);
		}
}

float getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
		return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);
}

float getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
		return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}

float getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
		return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}

`,
              Ai = `

vec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {

		vec3 surfacePosition = worldPosition;

#ifdef SHADOW_SAMPLE_POINT
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
				float distScale = length(lightDir);
				surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				lightDir = surfacePosition - lightPos;
				return lightDir;
		#endif
#else
		#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
				#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
						surfacePosition = worldPosition + normal * shadowParams.y;
				#endif
		#else
				#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
						#ifdef SHADOW_SAMPLE_ORTHO
								float distScale = 1.0;
						#else
								float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));
						#endif
						surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				#endif
		#endif

		vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);
		#ifdef SHADOW_SAMPLE_ORTHO
				positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;
		#else
				#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
						positionInShadowSpace.xyz /= positionInShadowSpace.w;
				#else
						positionInShadowSpace.xy /= positionInShadowSpace.w;
						positionInShadowSpace.z = length(lightDir) * shadowParams.w;
				#endif
		#endif

		#ifdef SHADOW_SAMPLE_Z_BIAS
				positionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);
		#endif
		surfacePosition = positionInShadowSpace.xyz;
#endif

		return surfacePosition;
}
`,
              Xi = `
vec3 lessThan2(vec3 a, vec3 b) {
		return clamp((b - a)*1000.0, 0.0, 1.0); // softer version
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
		float unpackFloat(vec4 rgbaDepth) {
				const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
				return dot(rgbaDepth, bitShift);
		}
#endif

// ----- Direct/Spot Sampling -----

#ifdef GL2

float _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
		float z = shadowCoord.z;
		vec2 uv = shadowCoord.xy * shadowParams.x; // 1 unit - 1 texel
		float shadowMapSizeInv = 1.0 / shadowParams.x;
		vec2 base_uv = floor(uv + 0.5);
		float s = (uv.x + 0.5 - base_uv.x);
		float t = (uv.y + 0.5 - base_uv.y);
		base_uv -= vec2(0.5);
		base_uv *= shadowMapSizeInv;

		float sum = 0.0;

		float uw0 = (3.0 - 2.0 * s);
		float uw1 = (1.0 + 2.0 * s);

		float u0 = (2.0 - s) / uw0 - 1.0;
		float u1 = s / uw1 + 1.0;

		float vw0 = (3.0 - 2.0 * t);
		float vw1 = (1.0 + 2.0 * t);

		float v0 = (2.0 - t) / vw0 - 1.0;
		float v1 = t / vw1 + 1.0;

		u0 = u0 * shadowMapSizeInv + base_uv.x;
		v0 = v0 * shadowMapSizeInv + base_uv.y;

		u1 = u1 * shadowMapSizeInv + base_uv.x;
		v1 = v1 * shadowMapSizeInv + base_uv.y;

		sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
		sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
		sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
		sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));

		sum *= 1.0f / 16.0;
		return sum;
}

float getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}

float getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}

float getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return textureShadow(shadowMap, shadowCoord);
}

float getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return textureShadow(shadowMap, shadowCoord);
}

#else // GL1

float _xgetShadowPCF3x3(mat3 depthKernel, vec3 shadowCoord, sampler2D shadowMap, vec3 shadowParams) {
		mat3 shadowKernel;
		vec3 shadowZ = vec3(shadowCoord.z);
		shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));
		shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));
		shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));

		vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );

		shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
		shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);

		vec4 shadowValues;
		shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
		shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
		shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
		shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);

		return dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}

float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec3 shadowParams) {
		float xoffset = 1.0 / shadowParams.x; // 1/shadow map width
		float dx0 = -xoffset;
		float dx1 = xoffset;

		mat3 depthKernel;
		depthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));
		depthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));
		depthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));
		depthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));
		depthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
		depthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));
		depthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));
		depthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));
		depthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));

		return _xgetShadowPCF3x3(depthKernel, shadowCoord, shadowMap, shadowParams);
}

float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}

float getShadowSpotPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}

float _getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord) {
		float shadowSample = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
		return shadowSample > shadowCoord.z ? 1.0 : 0.0;
}

float getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF1x1(shadowMap, shadowCoord);
}

float getShadowSpotPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF1x1(shadowMap, shadowCoord);
}
#endif


// ----- Omni Sampling -----

#ifndef WEBGPU

float _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {

		vec3 tc = normalize(dir);
		vec3 tcAbs = abs(tc);

		vec4 dirX = vec4(1,0,0, tc.x);
		vec4 dirY = vec4(0,1,0, tc.y);
		float majorAxisLength = tc.z;
		if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {
				dirX = vec4(0,0,1, tc.z);
				dirY = vec4(0,1,0, tc.y);
				majorAxisLength = tc.x;
		} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {
				dirX = vec4(1,0,0, tc.x);
				dirY = vec4(0,0,1, tc.z);
				majorAxisLength = tc.y;
		}

		float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);

		vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);
		vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);
		vec3 dx0 = -xoffset;
		vec3 dy0 = -yoffset;
		vec3 dx1 = xoffset;
		vec3 dy1 = yoffset;

		mat3 shadowKernel;
		mat3 depthKernel;

		depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));
		depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));
		depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));
		depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));
		depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));
		depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));
		depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));
		depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));
		depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));

		vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);

		shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));
		shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));
		shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));

		vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;

		vec2 fractionalCoord = fract( uv * shadowParams.x );

		shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
		shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);

		vec4 shadowValues;
		shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
		shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
		shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
		shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);

		return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}

float getShadowPointPCF3x3(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {
		return _getShadowPoint(shadowMap, shadowParams, lightDir);
}

#endif
`,
              Yi = `
float _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
		// http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/

		float z = shadowCoord.z;
		vec2 uv = shadowCoord.xy * shadowParams.x; // 1 unit - 1 texel
		float shadowMapSizeInv = 1.0 / shadowParams.x;
		vec2 base_uv = floor(uv + 0.5);
		float s = (uv.x + 0.5 - base_uv.x);
		float t = (uv.y + 0.5 - base_uv.y);
		base_uv -= vec2(0.5);
		base_uv *= shadowMapSizeInv;


		float uw0 = (4.0 - 3.0 * s);
		float uw1 = 7.0;
		float uw2 = (1.0 + 3.0 * s);

		float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;
		float u1 = (3.0 + s) / uw1;
		float u2 = s / uw2 + 2.0;

		float vw0 = (4.0 - 3.0 * t);
		float vw1 = 7.0;
		float vw2 = (1.0 + 3.0 * t);

		float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;
		float v1 = (3.0 + t) / vw1;
		float v2 = t / vw2 + 2.0;

		float sum = 0.0;

		u0 = u0 * shadowMapSizeInv + base_uv.x;
		v0 = v0 * shadowMapSizeInv + base_uv.y;

		u1 = u1 * shadowMapSizeInv + base_uv.x;
		v1 = v1 * shadowMapSizeInv + base_uv.y;

		u2 = u2 * shadowMapSizeInv + base_uv.x;
		v2 = v2 * shadowMapSizeInv + base_uv.y;

		sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
		sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
		sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));

		sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
		sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
		sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));

		sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));
		sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));
		sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));

		sum *= 1.0f / 144.0;

		sum = saturate(sum);

		return sum;
}

float getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}

float getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
`,
              Mn = `
float calculateVSM8(vec3 moments, float Z, float vsmBias) {
		float VSMBias = vsmBias;//0.01 * 0.25;
		float depthScale = VSMBias * Z;
		float minVariance1 = depthScale * depthScale;
		return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);
}

float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

float VSM8(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		vec4 c = texture2D(tex, texCoords);
		vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);
		return calculateVSM8(moments, Z, vsmBias);
}

float getShadowVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, 0.0);
}

float getShadowSpotVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);
}
`,
              Ci = `
float linstep(float a, float b, float v) {
		return saturate((v - a) / (b - a));
}

float reduceLightBleeding(float pMax, float amount) {
	 // Remove the [0, amount] tail and linearly rescale (amount, 1].
	 return linstep(amount, 1.0, pMax);
}

float chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {
		// Compute variance
		float variance = moments.y - (moments.x * moments.x);
		variance = max(variance, minVariance);

		// Compute probabilistic upper bound
		float d = mean - moments.x;
		float pMax = variance / (variance + (d * d));

		pMax = reduceLightBleeding(pMax, lightBleedingReduction);

		// One-tailed Chebyshev
		return (mean <= moments.x ? 1.0 : pMax);
}

float calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {
		Z = 2.0 * Z - 1.0;
		float warpedDepth = exp(exponent * Z);

		moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);

		float VSMBias = vsmBias;//0.01 * 0.25;
		float depthScale = VSMBias * exponent * warpedDepth;
		float minVariance1 = depthScale * depthScale;
		return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);
}
`,
              hn = `
attribute float vertex_boneIndices;

uniform vec4 matrix_pose[BONE_LIMIT * 3];

mat4 getBoneMatrix(const in float i) {
		// read 4x3 matrix
		vec4 v1 = matrix_pose[int(3.0 * i)];
		vec4 v2 = matrix_pose[int(3.0 * i + 1.0)];
		vec4 v3 = matrix_pose[int(3.0 * i + 2.0)];

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, 1
		);
}
`,
              Zi = `
attribute float vertex_boneIndices;

uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;

mat4 getBoneMatrix(const in float i) {
		float j = i * 3.0;
		float dx = texture_poseMapSize.z;
		float dy = texture_poseMapSize.w;

		float y = floor(j * dx);
		float x = j - (y * texture_poseMapSize.x);
		y = dy * (y + 0.5);

		// read elements of 4x3 matrix
		vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
		vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
		vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, 1
		);
}
`,
              cn = `
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;

uniform vec4 matrix_pose[BONE_LIMIT * 3];

void getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {
		// read 4x3 matrix
		v1 = matrix_pose[int(3.0 * i)];
		v2 = matrix_pose[int(3.0 * i + 1.0)];
		v3 = matrix_pose[int(3.0 * i + 2.0)];
}

mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
		// get 4 bone matrices
		vec4 a1, a2, a3;
		getBoneMatrix(indices.x, a1, a2, a3);

		vec4 b1, b2, b3;
		getBoneMatrix(indices.y, b1, b2, b3);

		vec4 c1, c2, c3;
		getBoneMatrix(indices.z, c1, c2, c3);

		vec4 d1, d2, d3;
		getBoneMatrix(indices.w, d1, d2, d3);

		// multiply them by weights and add up to get final 4x3 matrix
		vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
		vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
		vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;

		// add up weights
		float one = dot(weights, vec4(1.0));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, one
		);
}
`,
              Qi = `

attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;

uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;

void getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {

		float i = float(index);
		float j = i * 3.0;
		float dx = texture_poseMapSize.z;
		float dy = texture_poseMapSize.w;
		
		float y = floor(j * dx);
		float x = j - (y * texture_poseMapSize.x);
		y = dy * (y + 0.5);

		// read elements of 4x3 matrix
		v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
		v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
		v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
}

mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
		// get 4 bone matrices
		vec4 a1, a2, a3;
		getBoneMatrix(indices.x, a1, a2, a3);

		vec4 b1, b2, b3;
		getBoneMatrix(indices.y, b1, b2, b3);

		vec4 c1, c2, c3;
		getBoneMatrix(indices.z, c1, c2, c3);

		vec4 d1, d2, d3;
		getBoneMatrix(indices.w, d1, d2, d3);

		// multiply them by weights and add up to get final 4x3 matrix
		vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
		vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
		vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;

		// add up weights
		float one = dot(weights, vec4(1.0));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, one
		);
}
`,
              Ji = `
varying vec3 vViewDir;

uniform sampler2D texture_envAtlas;
uniform float mipLevel;

void main(void) {
		vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(normalize(dir));

		vec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));

		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`,
              dn = `
varying vec3 vViewDir;

uniform samplerCube texture_cubeMap;

void main(void) {
		vec3 dir=vViewDir;
		dir.x *= -1.0;

		vec3 linear = $DECODE(textureCube(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)));

		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`,
              un = `
attribute vec3 aPosition;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform mat4 matrix_projectionSkybox;
uniform mat3 cubeMapRotationMatrix;

varying vec3 vViewDir;

void main(void) {
		mat4 view = matrix_view;
		view[3][0] = view[3][1] = view[3][2] = 0.0;
		gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);

		// Force skybox to far Z, regardless of the clip planes on the camera
		// Subtract a tiny fudge factor to ensure floating point errors don't
		// still push pixels beyond far Z. See:
		// http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem

		gl_Position.z = gl_Position.w - 0.00001;
		vViewDir = aPosition * cubeMapRotationMatrix;
}
`,
              wn = `

#ifdef MAPCOLOR
uniform vec3 material_specular;
#endif

void getSpecularity() {
		vec3 specularColor = vec3(1,1,1);

		#ifdef MAPCOLOR
		specularColor *= material_specular;
		#endif

		#ifdef MAPTEXTURE
		specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		specularColor *= saturate(vVertexColor.$VC);
		#endif

		dSpecularity = specularColor;
}
`,
              In = `
// equirectangular helper functions
const float PI = 3.141592653589793;

vec2 toSpherical(vec3 dir) {
		return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}

vec2 toSphericalUv(vec3 dir) {
		vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;
		return vec2(uv.x, 1.0 - uv.y);
}
`,
              $i = `

#ifdef MAPFLOAT
uniform float material_specularityFactor;
#endif

void getSpecularityFactor() {
		float specularityFactor = 1.0;

		#ifdef MAPFLOAT
		specularityFactor *= material_specularityFactor;
		#endif

		#ifdef MAPTEXTURE
		specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		specularityFactor *= saturate(vVertexColor.$VC);
		#endif

		dSpecularityFactor = specularityFactor;
}
`,
              Dn = `
float getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {
		float cosAngle = dot(lightDirNorm, lightSpotDir);
		return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}
`,
              qi = `
void main(void) {
		dReflection = vec4(0);

		#ifdef LIT_CLEARCOAT
		ccSpecularLight = vec3(0);
		ccReflection = vec3(0);
		#endif
`,
              en = `
void main(void) {
		gl_Position = getPosition();
`,
              Fi = `
		nineSlicedUv = vUv0;
		nineSlicedUv.y = 1.0 - nineSlicedUv.y;

`,
              Ui = `
		vec2 tileMask = step(vMask, vec2(0.99999));
		vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);
		vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);
		vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
		clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
		nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);
		nineSlicedUv.y = 1.0 - nineSlicedUv.y;
		
`,
              Hs = `
float exponent = VSM_EXPONENT;

depth = 2.0 * depth - 1.0;
depth =  exp(exponent * depth);
gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
`,
              Pi = `
vec3 getTangent() {
		return normalize(dNormalMatrix * vertex_tangent.xyz);
}

vec3 getBinormal() {
		return cross(vNormalW, vTangentW) * vertex_tangent.w;
}
`,
              fn = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
		dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));
}
`,
              pn = `
uniform float tbnBasis;

// http://www.thetenthplanet.de/archives/1180
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
		vec2 uv = $UV;

		// get edge vectors of the pixel triangle
		vec3 dp1 = dFdx( vPositionW );
		vec3 dp2 = dFdy( vPositionW );
		vec2 duv1 = dFdx( uv );
		vec2 duv2 = dFdy( uv );

		// solve the linear system
		vec3 dp2perp = cross( dp2, normal );
		vec3 dp1perp = cross( normal, dp1 );
		vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
		vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

		// construct a scale-invariant frame
		float denom = max( dot(T,T), dot(B,B) );
		float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );
		dTBN = mat3(T * invmax, -B * invmax, normal );
}
`,
              tn = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
		dTBN = mat3(tangent, binormal, normal);
}
`,
              Rn = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {

		vec3 B = cross(normal, vObjectSpaceUpW);
		vec3 T = cross(normal, B);

		if (dot(B,B)==0.0) // deal with case when vObjectSpaceUpW normal are parallel
		{
				float major=max(max(normal.x, normal.y), normal.z);

				if (normal.x == major)
				{
						B=cross(normal, vec3(0,1,0));
						T=cross(normal, B);
				}
				else if (normal.y == major)
				{
						B=cross(normal, vec3(0,0,1));
						T=cross(normal, B);
				}
				else if (normal.z == major)
				{
						B=cross(normal, vec3(1,0,0));
						T=cross(normal, B);
				}
		}

		dTBN = mat3(normalize(T), normalize(B), normalize(normal));
}
`,
              ni = `
vec4 texture2DSRGB(sampler2D tex, vec2 uv) {
		return gammaCorrectInput(texture2D(tex, uv));
}

vec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {
		return gammaCorrectInput(texture2D(tex, uv, bias));
}

vec3 texture2DRGBM(sampler2D tex, vec2 uv) {
		return decodeRGBM(texture2D(tex, uv));
}

vec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {
		return decodeRGBM(texture2D(tex, uv, bias));
}

vec3 texture2DRGBE(sampler2D tex, vec2 uv) {
		return decodeRGBM(texture2D(tex, uv));
}

vec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {
		return decodeRGBM(texture2D(tex, uv, bias));
}
`,
              On = `
#ifdef MAPFLOAT
uniform float material_thickness;
#endif

void getThickness() {
		dThickness = 1.0;

		#ifdef MAPFLOAT
		dThickness *= material_thickness;
		#endif

		#ifdef MAPTEXTURE
		dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dThickness *= saturate(vVertexColor.$VC);
		#endif
}
`,
              _n = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		float tA = 2.51;
		float tB = 0.03;
		float tC = 2.43;
		float tD = 0.59;
		float tE = 0.14;
		vec3 x = color * exposure;
		return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);
}
`,
              Ln = `
uniform float exposure;

// ACES approximation by Stephen Hill

// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
const mat3 ACESInputMat = mat3(
		0.59719, 0.35458, 0.04823,
		0.07600, 0.90834, 0.01566,
		0.02840, 0.13383, 0.83777
);

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const mat3 ACESOutputMat = mat3(
		 1.60475, -0.53108, -0.07367,
		-0.10208,  1.10813, -0.00605,
		-0.00327, -0.07276,  1.07602
);

vec3 RRTAndODTFit(vec3 v) {
		vec3 a = v * (v + 0.0245786) - 0.000090537;
		vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
		return a / b;
}

vec3 toneMap(vec3 color) {
		color *= exposure / 0.6;
		color = color * ACESInputMat;

		// Apply RRT and ODT
		color = RRTAndODTFit(color);
		color = color * ACESOutputMat;

		// Clamp to [0, 1]
		color = clamp(color, 0.0, 1.0);

		return color;
}
`,
              Bn = `
const float A =  0.15;
const float B =  0.50;
const float C =  0.10;
const float D =  0.20;
const float E =  0.02;
const float F =  0.30;
const float W =  11.2;

uniform float exposure;

vec3 uncharted2Tonemap(vec3 x) {
	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 toneMap(vec3 color) {
		color = uncharted2Tonemap(color * exposure);
		vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));
		color = color * whiteScale;

		return color;
}
`,
              Fn = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		color *= exposure;
		const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;
		const float Scl = 1.25;

		vec3 h = max( vec3(0.0), color - vec3(0.004) );
		return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);
}
`,
              Un = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		return color * exposure;
}
`,
              Nn = `
vec3 toneMap(vec3 color) {
		return color;
}
`,
              zn = `
#ifdef PIXELSNAP
uniform vec4 uScreenSize;
#endif

#ifdef SCREENSPACE
uniform float projectionFlipY;
#endif

#ifdef MORPHING
uniform vec4 morph_weights_a;
uniform vec4 morph_weights_b;
#endif

#ifdef MORPHING_TEXTURE_BASED
		uniform vec4 morph_tex_params;

		#ifdef WEBGPU
				ivec2 getTextureMorphCoords() {

						// turn morph_vertex_id into int grid coordinates
						ivec2 textureSize = ivec2(morph_tex_params.xy);
						int morphGridV = int(morph_vertex_id / textureSize.x);
						int morphGridU = int(morph_vertex_id - (morphGridV * textureSize.x));
						morphGridV = textureSize.y - morphGridV - 1;
						return ivec2(morphGridU, morphGridV);
				}
		#else
				vec2 getTextureMorphCoords() {
						vec2 textureSize = morph_tex_params.xy;
						vec2 invTextureSize = morph_tex_params.zw;

						// turn morph_vertex_id into int grid coordinates
						float morphGridV = floor(morph_vertex_id * invTextureSize.x);
						float morphGridU = morph_vertex_id - (morphGridV * textureSize.x);

						// convert grid coordinates to uv coordinates with half pixel offset
						return vec2(morphGridU, morphGridV) * invTextureSize + (0.5 * invTextureSize);
				}
		#endif

#endif

#ifdef MORPHING_TEXTURE_BASED_POSITION
uniform highp sampler2D morphPositionTex;
#endif

mat4 getModelMatrix() {
		#ifdef DYNAMICBATCH
		return getBoneMatrix(vertex_boneIndices);
		#elif defined(SKIN)
		return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
		#elif defined(INSTANCING)
		return mat4(instance_line1, instance_line2, instance_line3, instance_line4);
		#else
		return matrix_model;
		#endif
}

vec4 getPosition() {
		dModelMatrix = getModelMatrix();
		vec3 localPos = vertex_position;

		#ifdef NINESLICED
		// outer and inner vertices are at the same position, scale both
		localPos.xz *= outerScale;

		// offset inner vertices inside
		// (original vertices must be in [-1;1] range)
		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
		localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;

		vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner

		localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5
		localPos = localPos.xzy;
		#endif

		#ifdef MORPHING
		#ifdef MORPHING_POS03
		localPos.xyz += morph_weights_a[0] * morph_pos0;
		localPos.xyz += morph_weights_a[1] * morph_pos1;
		localPos.xyz += morph_weights_a[2] * morph_pos2;
		localPos.xyz += morph_weights_a[3] * morph_pos3;
		#endif // MORPHING_POS03
		#ifdef MORPHING_POS47
		localPos.xyz += morph_weights_b[0] * morph_pos4;
		localPos.xyz += morph_weights_b[1] * morph_pos5;
		localPos.xyz += morph_weights_b[2] * morph_pos6;
		localPos.xyz += morph_weights_b[3] * morph_pos7;
		#endif // MORPHING_POS47
		#endif // MORPHING

		#ifdef MORPHING_TEXTURE_BASED_POSITION

				#ifdef WEBGPU
						ivec2 morphUV = getTextureMorphCoords();
						vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;
				#else
						vec2 morphUV = getTextureMorphCoords();
						vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;
				#endif

				localPos += morphPos;

		#endif

		vec4 posW = dModelMatrix * vec4(localPos, 1.0);
		#ifdef SCREENSPACE
		posW.zw = vec2(0.0, 1.0);
		#endif
		dPositionW = posW.xyz;

		vec4 screenPos;
		#ifdef UV1LAYOUT
		screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);
		#else
		#ifdef SCREENSPACE
		screenPos = posW;
		screenPos.y *= projectionFlipY;
		#else
		screenPos = matrix_viewProjection * posW;
		#endif

		#ifdef PIXELSNAP
		// snap vertex to a pixel boundary
		screenPos.xy = (screenPos.xy * 0.5) + 0.5;
		screenPos.xy *= uScreenSize.xy;
		screenPos.xy = floor(screenPos.xy);
		screenPos.xy *= uScreenSize.zw;
		screenPos.xy = (screenPos.xy * 2.0) - 1.0;
		#endif
		#endif

		return screenPos;
}

vec3 getWorldPosition() {
		return dPositionW;
}
`,
              bi = `
attribute vec3 vertex_position;

uniform mat4 matrix_model;
uniform mat4 matrix_viewProjection;

vec3 dPositionW;
mat4 dModelMatrix;
`,
              sn = `

#ifdef MAPFLOAT
uniform float material_refraction;
#endif

void getRefraction() {
		float refraction = 1.0;

		#ifdef MAPFLOAT
		refraction = material_refraction;
		#endif

		#ifdef MAPTEXTURE
		refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		refraction *= saturate(vVertexColor.$VC);
		#endif

		dTransmission = refraction;
}
`,
              kn = `
#ifdef NINESLICED
vec2 getUv0() {
		vec2 uv = vertex_position.xz;

		// offset inner vertices inside
		// (original vertices must be in [-1;1] range)
		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
		uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;

		uv = uv * -0.5 + 0.5;
		uv = uv * atlasRect.zw + atlasRect.xy;

		vMask = vertex_texCoord0.xy;

		return uv;
}
#else
vec2 getUv0() {
		return vertex_texCoord0;
}
#endif
`,
              Wn = `
vec2 getUv1() {
		return vertex_texCoord1;
}
`,
              Vn = `
void getViewDir() {
		dViewDirW = normalize(view_position - vPositionW);
}
`,
              mn = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

vec3 getViewNormal() {
		return mat3(matrix_view) * vNormalW;
}
`,
              Gn = a(6003),
              jn = a(7210);
            const gn = {
              alphaTestPS: A,
              ambientConstantPS: x,
              ambientEnvPS: y,
              ambientSHPS: c,
              aoPS: d,
              aoDetailMapPS: h,
              aoDiffuseOccPS: f,
              aoSpecOccPS: s,
              aoSpecOccConstPS: l,
              aoSpecOccConstSimplePS: n,
              aoSpecOccSimplePS: o,
              basePS: i,
              baseVS: e,
              baseNineSlicedPS: t,
              baseNineSlicedVS: r,
              baseNineSlicedTiledPS: u,
              biasConstPS: v,
              blurVSMPS: _,
              clearCoatPS: m,
              clearCoatGlossPS: g,
              clearCoatNormalPS: T,
              clusteredLightCookiesPS: M,
              clusteredLightShadowsPS: R,
              clusteredLightUtilsPS: E,
              clusteredLightPS: P,
              combinePS: F,
              cookiePS: b,
              cubeMapProjectBoxPS: D,
              cubeMapProjectNonePS: G,
              cubeMapRotatePS: X,
              debugOutputPS: ie,
              debugProcessFrontendPS: Q,
              detailModesPS: ae,
              diffusePS: Z,
              diffuseDetailMapPS: J,
              decodePS: te,
              emissivePS: ve,
              encodePS: _e,
              endPS: L,
              endVS: ge,
              envAtlasPS: k,
              envConstPS: j,
              envMultiplyPS: B,
              extensionPS: $,
              extensionVS: le,
              falloffInvSquaredPS: O,
              falloffLinearPS: Y,
              fixCubemapSeamsNonePS: ne,
              fixCubemapSeamsStretchPS: de,
              floatUnpackingPS: re,
              fogExpPS: I,
              fogExp2PS: w,
              fogLinearPS: N,
              fogNonePS: W,
              fresnelSchlickPS: he,
              fullscreenQuadPS: ue,
              fullscreenQuadVS: ye,
              gamma1_0PS: Oe,
              gamma2_2PS: Ae,
              gles2PS: ke.A,
              gles3PS: Ue.A,
              gles3VS: Ge.A,
              glossPS: ht,
              iridescenceDiffractionPS: me,
              iridescencePS: z,
              iridescenceThicknessPS: K,
              instancingVS: Te,
              iorPS: H,
              lightDiffuseLambertPS: q,
              lightDirPointPS: se,
              lightmapAddPS: Ce,
              lightmapDirAddPS: we,
              lightmapDirPS: Me,
              lightmapSinglePS: Ie,
              lightSpecularAnisoGGXPS: Le,
              lightSpecularBlinnPS: tt,
              lightSpecularPhongPS: vt,
              lightSheenPS: it,
              linearizeDepthPS: At,
              litShaderArgsPS: Rt,
              ltcPS: Ft,
              metalnessPS: ut,
              metalnessModulatePS: bt,
              msdfPS: Pt,
              msdfVS: Zt,
              normalVS: Xt,
              normalDetailMapPS: yt,
              normalInstancedVS: Pe,
              normalMapPS: $e,
              normalSkinnedVS: Je,
              normalXYPS: rt,
              normalXYZPS: ct,
              opacityPS: Ve,
              outputPS: wt,
              outputAlphaPS: at,
              outputAlphaOpaquePS: ce,
              outputAlphaPremulPS: pe,
              outputTex2DPS: De,
              packDepthPS: fe,
              sheenPS: Ze,
              sheenGlossPS: Ne,
              parallaxPS: Ye,
              particlePS: Ke,
              particleVS: nt,
              particleAnimFrameClampVS: ot,
              particleAnimFrameLoopVS: ze,
              particleAnimTexVS: et,
              particleInputFloatPS: _t,
              particleInputRgba8PS: Qe,
              particleOutputFloatPS: lt,
              particleOutputRgba8PS: xt,
              particleUpdaterAABBPS: Tt,
              particleUpdaterEndPS: ft,
              particleUpdaterInitPS: gt,
              particleUpdaterNoRespawnPS: Fe,
              particleUpdaterOnStopPS: Qt,
              particleUpdaterRespawnPS: zt,
              particleUpdaterSpherePS: Lt,
              particleUpdaterStartPS: $t,
              particle_billboardVS: Bt,
              particle_blendAddPS: Nt,
              particle_blendMultiplyPS: es,
              particle_blendNormalPS: kt,
              particle_cpuVS: ds,
              particle_cpu_endVS: os,
              particle_customFaceVS: ls,
              particle_endPS: Ps,
              particle_endVS: us,
              particle_halflambertPS: Xe,
              particle_initVS: vs,
              particle_lambertPS: fs,
              particle_lightingPS: bs,
              particle_localShiftVS: Ms,
              particle_meshVS: Ts,
              particle_normalVS: Js,
              particle_normalMapPS: Os,
              particle_pointAlongVS: li,
              particle_softPS: $s,
              particle_softVS: Cs,
              particle_stretchVS: Gs,
              particle_TBNVS: hi,
              particle_wrapVS: ci,
              reflDirPS: ii,
              reflDirAnisoPS: je,
              reflectionCCPS: mt,
              reflectionCubePS: Ot,
              reflectionEnvHQPS: ss,
              reflectionEnvPS: qt,
              reflectionSpherePS: is,
              reflectionSphereLowPS: Ls,
              reflectionSheenPS: js,
              refractionCubePS: fi,
              refractionDynamicPS: pi,
              reprojectPS: _i,
              screenDepthPS: mi,
              shadowCascadesPS: gi,
              shadowEVSMPS: yi,
              shadowEVSMnPS: Li,
              shadowPCSSPS: Bi,
              shadowSampleCoordPS: Ai,
              shadowStandardPS: Xi,
              shadowStandardGL2PS: Yi,
              shadowVSM8PS: Mn,
              shadowVSM_commonPS: Ci,
              skinBatchConstVS: hn,
              skinBatchTexVS: Zi,
              skinConstVS: cn,
              skinTexVS: Qi,
              skyboxEnvPS: Ji,
              skyboxHDRPS: dn,
              skyboxVS: un,
              specularPS: wn,
              sphericalPS: In,
              specularityFactorPS: $i,
              spotPS: Dn,
              startPS: qi,
              startVS: en,
              startNineSlicedPS: Fi,
              startNineSlicedTiledPS: Ui,
              storeEVSMPS: Hs,
              tangentBinormalVS: Pi,
              TBNPS: fn,
              TBNderivativePS: pn,
              TBNfastPS: tn,
              TBNObjectSpacePS: Rn,
              textureSamplePS: ni,
              thicknessPS: On,
              tonemappingAcesPS: _n,
              tonemappingAces2PS: Ln,
              tonemappingFilmicPS: Bn,
              tonemappingHejlPS: Fn,
              tonemappingLinearPS: Un,
              tonemappingNonePS: Nn,
              transformVS: zn,
              transformDeclVS: bi,
              transmissionPS: sn,
              uv0VS: kn,
              uv1VS: Wn,
              viewDirPS: Vn,
              viewNormalVS: mn,
              webgpuPS: Gn.A,
              webgpuVS: jn.A,
            };
          },
          783: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => y, o: () => c });
            var A = a(5950);
            const x = new A.N();
            function y(d) {
              return x.get(d);
            }
            function c(d, h) {
              x.get(d, () => h);
            }
          },
          6874: (xe, V, a) => {
            "use strict";
            a.d(V, { M: () => f });
            var A = a(8981),
              x = a(8506),
              y = a(8526),
              c = a(9391),
              d = a(4639),
              h = a(6261);
            class f {
              constructor(l, n) {
                (this.processedCache = new Map()),
                  (this.definitionsCache = new Map()),
                  (this._device = l),
                  (this._generators = {}),
                  (this._isClearingCache = !1),
                  (this._precached = !1),
                  (this._programsCollection = []),
                  (this._defaultStdMatOption = new h.l()),
                  (this._defaultStdMatOptionMin = new h.l()),
                  n.shaderOptBuilder.updateRef(
                    this._defaultStdMatOption,
                    {},
                    n,
                    null,
                    [],
                    c.OP,
                    null
                  ),
                  n.shaderOptBuilder.updateMinRef(
                    this._defaultStdMatOptionMin,
                    {},
                    n,
                    null,
                    c.vT,
                    null
                  ),
                  l.on("destroy:shader", (o) => {
                    this.removeFromCache(o);
                  });
              }
              destroy() {
                this.clearCache();
              }
              register(l, n) {
                this.isRegistered(l) || (this._generators[l] = n);
              }
              unregister(l) {
                this.isRegistered(l) && delete this._generators[l];
              }
              isRegistered(l) {
                return this._generators[l] !== void 0;
              }
              generateShaderDefinition(l, n, o, i) {
                let e = this.definitionsCache.get(o);
                if (!e) {
                  var t, r, u;
                  let v;
                  (t = i.litOptions) != null &&
                    t.lights &&
                    ((v = i.litOptions.lights),
                    (i.litOptions.lights = v.map(function (m) {
                      const g = m.clone ? m.clone() : m;
                      return (g.key = m.key), g;
                    }))),
                    this.storeNewProgram(n, i),
                    (r = i.litOptions) != null &&
                      r.lights &&
                      (i.litOptions.lights = v),
                    this._precached;
                  const _ = this._device;
                  (e = l.createShaderDefinition(_, i)),
                    (e.name =
                      (u = e.name) != null
                        ? u
                        : i.pass
                        ? `${n}-pass:${i.pass}`
                        : n),
                    this.definitionsCache.set(o, e);
                }
                return e;
              }
              getCachedShader(l) {
                return this.processedCache.get(l);
              }
              setCachedShader(l, n) {
                this.processedCache.set(l, n);
              }
              getProgram(l, n, o, i) {
                const e = this._generators[l];
                if (!e) return null;
                const t = e.generateKey(n),
                  r = (0, A.s)(t),
                  u = o.generateKey(this._device),
                  v = (0, A.s)(u),
                  _ = `${r}#${v}`;
                let m = this.getCachedShader(_);
                if (!m) {
                  const g = this.generateShaderDefinition(e, l, r, n);
                  let T = "",
                    E;
                  n.pass !== void 0 &&
                    ((E = d.p.get(this._device).getByIndex(n.pass)),
                    (T = `-${E.name}`)),
                    this._device.fire("shader:generate", {
                      userMaterialId: i,
                      shaderPassInfo: E,
                      definition: g,
                    });
                  const M = {
                    name: `${g.name}${T}-proc`,
                    attributes: g.attributes,
                    vshader: g.vshader,
                    fshader: g.fshader,
                    processingOptions: o,
                  };
                  (m = new y.M(this._device, M)), this.setCachedShader(_, m);
                }
                return m;
              }
              storeNewProgram(l, n) {
                let o = {};
                if (l === "standard") {
                  const i = this._getDefaultStdMatOptions(n.pass);
                  for (const e in n)
                    ((n.hasOwnProperty(e) && i[e] !== n[e]) || e === "pass") &&
                      (o[e] = n[e]);
                  for (const e in n.litOptions) o[e] = n.litOptions[e];
                } else o = n;
                this._programsCollection.push(
                  JSON.stringify({ name: l, options: o })
                );
              }
              dumpPrograms() {
                let l = `let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;
`;
                (l += "let shaders = ["),
                  this._programsCollection[0] &&
                    (l +=
                      `
	` + this._programsCollection[0]);
                for (let o = 1; o < this._programsCollection.length; ++o)
                  l +=
                    `,
	` + this._programsCollection[o];
                (l += `
];
`),
                  (l += `device.getProgramLibrary().precompile(shaders);
`),
                  (l +=
                    'if (pc.version != "' +
                    x.rE +
                    '" || pc.revision != "' +
                    x.QL +
                    `")
`),
                  (l +=
                    '	console.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");');
                const n = document.createElement("a");
                n.setAttribute(
                  "href",
                  "data:text/plain;charset=utf-8," + encodeURIComponent(l)
                ),
                  n.setAttribute("download", "precompile-shaders.js"),
                  (n.style.display = "none"),
                  document.body.appendChild(n),
                  n.click(),
                  document.body.removeChild(n);
              }
              clearCache() {
                (this._isClearingCache = !0),
                  this.processedCache.forEach((l) => {
                    l.destroy();
                  }),
                  this.processedCache.clear(),
                  (this._isClearingCache = !1);
              }
              removeFromCache(l) {
                this._isClearingCache ||
                  this.processedCache.forEach((n, o) => {
                    l === n && this.processedCache.delete(o);
                  });
              }
              _getDefaultStdMatOptions(l) {
                const n = d.p.get(this._device).getByIndex(l);
                return l === c.w8 || l === c.cz || n.isShadow
                  ? this._defaultStdMatOptionMin
                  : this._defaultStdMatOption;
              }
              precompile(l) {
                if (l) {
                  const n = new Array(l.length);
                  for (let o = 0; o < l.length; o++) {
                    if (l[o].name === "standard") {
                      const i = l[o].options,
                        e = this._getDefaultStdMatOptions(i.pass);
                      for (const t in e)
                        e.hasOwnProperty(t) && i[t] === void 0 && (i[t] = e[t]);
                    }
                    n[o] = this.getProgram(l[o].name, l[o].options);
                  }
                }
                this._precached = !0;
              }
            }
          },
          4559: (xe, V, a) => {
            "use strict";
            a.d(V, {
              K: () => c,
              P1: () => h,
              PY: () => y,
              _N: () => s,
              cu: () => d,
              qN: () => f,
            });
            var A = a(9391),
              x = a(2910);
            function y(l, n) {
              return (
                n || (n = x.G),
                l === A.Jd || l === A.t4
                  ? n.gamma2_2PS
                    ? n.gamma2_2PS
                    : x.G.gamma2_2PS
                  : l === A.Rz
                  ? `#define HDR
` + (n.gamma2_2PS ? n.gamma2_2PS : x.G.gamma2_2PS)
                  : n.gamma1_0PS
                  ? n.gamma1_0PS
                  : x.G.gamma1_0PS
              );
            }
            function c(l, n) {
              return (
                n || (n = x.G),
                l === A.c1
                  ? n.tonemappingFilmicPS
                    ? n.tonemappingFilmicPS
                    : x.G.tonemappingFilmicPS
                  : l === A.ll
                  ? n.tonemappingLinearPS
                    ? n.tonemappingLinearPS
                    : x.G.tonemappingLinearPS
                  : l === A.hF
                  ? n.tonemappingHejlPS
                    ? n.tonemappingHejlPS
                    : x.G.tonemappingHejlPS
                  : l === A.c2
                  ? n.tonemappingAcesPS
                    ? n.tonemappingAcesPS
                    : x.G.tonemappingAcesPS
                  : l === A.I1
                  ? n.tonemappingAces2PS
                    ? n.tonemappingAces2PS
                    : x.G.tonemappingAces2PS
                  : n.tonemapingNonePS
                  ? n.tonemapingNonePS
                  : x.G.tonemappingNonePS
              );
            }
            function d(l, n) {
              return (
                n || (n = x.G),
                l === "linear"
                  ? n.fogLinearPS
                    ? n.fogLinearPS
                    : x.G.fogLinearPS
                  : l === "exp"
                  ? n.fogExpPS
                    ? n.fogExpPS
                    : x.G.fogExpPS
                  : l === "exp2"
                  ? n.fogExp2PS
                    ? n.fogExp2PS
                    : x.G.fogExp2PS
                  : n.fogNonePS
                  ? n.fogNonePS
                  : x.G.fogNonePS
              );
            }
            function h(l, n) {
              return (
                n || (n = x.G),
                l.supportsBoneTextures
                  ? n.skinTexVS
                  : "#define BONE_LIMIT " +
                    l.getBoneLimit() +
                    `
` +
                    n.skinConstVS
              );
            }
            function f() {
              return `void main(void)
{
`;
            }
            function s() {
              return `}
`;
            }
          },
          8342: (xe, V, a) => {
            "use strict";
            a.d(V, { Z: () => x });
            var A = a(9391);
            const x = {
              generateKey(y) {
                return (
                  "lit" +
                  Object.keys(y)
                    .sort()
                    .map((c) =>
                      c === "chunks"
                        ? x.generateChunksKey(y)
                        : c === "lights"
                        ? x.generateLightsKey(y)
                        : c + y[c]
                    ).join(`
`)
                );
              },
              generateLightsKey(y) {
                return (
                  "lights:" +
                  y.lights
                    .map((c) =>
                      !y.clusteredLightingEnabled || c._type === A.kx
                        ? `${c.key},`
                        : ""
                    )
                    .join("")
                );
              },
              generateChunksKey(y) {
                var c;
                return (
                  `chunks:
` +
                  Object.keys((c = y.chunks) != null ? c : {})
                    .sort()
                    .map((d) => d + y.chunks[d])
                    .join("")
                );
              },
            };
          },
          8944: (xe, V, a) => {
            "use strict";
            a.d(V, { n: () => x });
            var A = a(9391);
            class x {
              constructor() {
                (this.hasTangents = !1),
                  (this.chunks = {}),
                  (this.pass = 0),
                  (this.alphaTest = !1),
                  (this.blendType = A.Rj),
                  (this.separateAmbient = !1),
                  (this.screenSpace = !1),
                  (this.skin = !1),
                  (this.useInstancing = !1),
                  (this.useMorphPosition = !1),
                  (this.useMorphNormal = !1),
                  (this.useMorphTextureBased = !1),
                  (this.nineSlicedMode = 0),
                  (this.clusteredLightingEnabled = !0),
                  (this.clusteredLightingCookiesEnabled = !1),
                  (this.clusteredLightingShadowsEnabled = !1),
                  (this.clusteredLightingShadowType = 0),
                  (this.clusteredLightingAreaLightsEnabled = !1),
                  (this.vertexColors = !1),
                  (this.lightMapEnabled = !1),
                  (this.dirLightMapEnabled = !1),
                  (this.useHeights = !1),
                  (this.useNormals = !1),
                  (this.useClearCoatNormals = !1),
                  (this.useAo = !1),
                  (this.diffuseMapEnabled = !1),
                  (this.useAmbientTint = !1),
                  (this.customFragmentShader = null),
                  (this.pixelSnap = !1),
                  (this.shadingModel = 0),
                  (this.ambientSH = !1),
                  (this.fastTbn = !1),
                  (this.twoSidedLighting = !1),
                  (this.occludeDirect = !1),
                  (this.occludeSpecular = 0),
                  (this.occludeSpecularFloat = !1),
                  (this.useMsdf = !1),
                  (this.msdfTextAttribute = !1),
                  (this.alphaToCoverage = !1),
                  (this.opacityFadesSpecular = !1),
                  (this.cubeMapProjection = 0),
                  (this.conserveEnergy = !1),
                  (this.useSpecular = !1),
                  (this.useSpecularityFactor = !1),
                  (this.enableGGXSpecular = !1),
                  (this.fresnelModel = 0),
                  (this.useRefraction = !1),
                  (this.useClearCoat = !1),
                  (this.useSheen = !1),
                  (this.useIridescence = !1),
                  (this.useMetalness = !1),
                  (this.useDynamicRefraction = !1),
                  (this.fog = A.qX),
                  (this.gamma = A.hc),
                  (this.toneMap = -1),
                  (this.fixSeams = !1),
                  (this.reflectionSource = null),
                  (this.reflectionEncoding = null),
                  (this.reflectionCubemapEncoding = null),
                  (this.ambientSource = "constant"),
                  (this.ambientEncoding = null),
                  (this.skyboxIntensity = 1),
                  (this.useCubeMapRotation = !1),
                  (this.lightMapWithoutAmbient = !1),
                  (this.lights = []),
                  (this.noShadow = !1),
                  (this.lightMaskDynamic = 0);
              }
            }
          },
          1151: (xe, V, a) => {
            "use strict";
            a.d(V, { J: () => i });
            var A = a(1630),
              x = a(2910),
              y = a(725),
              c = a(9391),
              d = a(9877),
              h = a(4639),
              f = a(4559),
              s = a(9855),
              l = a(7835);
            const n = {
                vertex_normal: A.XF6,
                vertex_tangent: A.h3u,
                vertex_texCoord0: A.slc,
                vertex_texCoord1: A.zEd,
                vertex_color: A.F8$,
                vertex_boneWeights: A.Hn_,
                vertex_boneIndices: A.aVd,
              },
              o = {
                vVertexColor: "vec4",
                vPositionW: "vec3",
                vNormalV: "vec3",
                vNormalW: "vec3",
                vTangentW: "vec3",
                vBinormalW: "vec3",
                vObjectSpaceUpW: "vec3",
                vUv0: "vec2",
                vUv1: "vec2",
              };
            class i {
              constructor(t, r) {
                if (
                  ((this.device = t),
                  (this.options = r),
                  (this.attributes = { vertex_position: A.JYe }),
                  r.chunks)
                ) {
                  const u = r.chunks;
                  this.chunks = Object.create(x.G);
                  for (const v in x.G)
                    if (u.hasOwnProperty(v)) {
                      const _ = u[v];
                      for (const m in n)
                        n.hasOwnProperty(m) &&
                          _.indexOf(m) >= 0 &&
                          (this.attributes[m] = n[m]);
                      this.chunks[v] = _;
                    }
                } else this.chunks = x.G;
                (this.shaderPassInfo = h.p.get(this.device).getByIndex(r.pass)),
                  (this.shadowPass = this.shaderPassInfo.isShadow),
                  (this.lighting =
                    r.lights.length > 0 ||
                    r.dirLightMapEnabled ||
                    r.clusteredLightingEnabled),
                  (this.reflections = !!r.reflectionSource),
                  (this.needsNormal =
                    this.lighting ||
                    this.reflections ||
                    r.useSpecular ||
                    r.ambientSH ||
                    r.useHeights ||
                    r.enableGGXSpecular ||
                    (r.clusteredLightingEnabled && !this.shadowPass) ||
                    r.useClearCoatNormals),
                  (this.needsNormal = this.needsNormal && !this.shadowPass),
                  (this.needsSceneColor = r.useDynamicRefraction),
                  (this.needsScreenSize = r.useDynamicRefraction),
                  (this.needsTransforms = r.useDynamicRefraction),
                  (this.varyings = ""),
                  (this.varyingDefines = ""),
                  (this.vshader = null),
                  (this.frontendDecl = null),
                  (this.frontendCode = null),
                  (this.frontendFunc = null),
                  (this.lightingUv = null),
                  (this.defines = []),
                  (this.fshader = null);
              }
              _vsAddBaseCode(t, r, u) {
                return (
                  (t += r.baseVS),
                  (u.nineSlicedMode === c.FC || u.nineSlicedMode === c.jZ) &&
                    (t += r.baseNineSlicedVS),
                  t
                );
              }
              _vsAddTransformCode(t, r, u, v) {
                return (t += this.chunks.transformVS), t;
              }
              _setMapTransform(t, r, u, v) {
                const _ = u + v * 100;
                if (!t[3][_]) {
                  const m = `texture_${r}MapTransform`;
                  (t[0] += `uniform vec3 ${m}0;
`),
                    (t[0] += `uniform vec3 ${m}1;
`),
                    (t[1] += `varying vec2 vUV${v}_${u};
`),
                    (t[2] += `   vUV${v}_${u} = vec2(dot(vec3(uv${v}, 1), ${m}0), dot(vec3(uv${v}, 1), ${m}1));
`),
                    (t[3][_] = !0);
                }
                return t;
              }
              _fsGetBaseCode() {
                const t = this.options,
                  r = this.chunks;
                let u = this.chunks.basePS;
                return (
                  t.nineSlicedMode === c.FC
                    ? (u += r.baseNineSlicedPS)
                    : t.nineSlicedMode === c.jZ &&
                      (u += r.baseNineSlicedTiledPS),
                  u
                );
              }
              _fsGetStartCode(t, r, u, v) {
                let _ = u.startPS;
                return (
                  v.nineSlicedMode === c.FC
                    ? (_ += u.startNineSlicedPS)
                    : v.nineSlicedMode === c.jZ &&
                      (_ += u.startNineSlicedTiledPS),
                  _
                );
              }
              _getLightSourceShapeString(t) {
                switch (t) {
                  case c.tt:
                    return "Rect";
                  case c.iU:
                    return "Disk";
                  case c.SY:
                    return "Sphere";
                  default:
                    return "";
                }
              }
              generateVertexShader(t, r, u) {
                const v = this.device,
                  _ = this.options,
                  m = this.chunks;
                let g = "",
                  T = "";
                (g = this._vsAddBaseCode(g, m, _)),
                  (T += `   vPositionW    = getWorldPosition();
`),
                  this.options.pass === c.w8 &&
                    ((g += `varying float vDepth;
`),
                    (g += `#ifndef VIEWMATRIX
`),
                    (g += `#define VIEWMATRIX
`),
                    (g += `uniform mat4 matrix_view;
`),
                    (g += `#endif
`),
                    (g += `#ifndef CAMERAPLANES
`),
                    (g += `#define CAMERAPLANES
`),
                    (g += `uniform vec4 camera_params;

`),
                    (g += `#endif
`),
                    (T += `    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;
`)),
                  this.options.useInstancing &&
                    ((this.attributes.instance_line1 = A.yZ0),
                    (this.attributes.instance_line2 = A.pov),
                    (this.attributes.instance_line3 = A.yof),
                    (this.attributes.instance_line4 = A.FHg),
                    (g += m.instancingVS)),
                  this.needsNormal &&
                    ((this.attributes.vertex_normal = A.XF6),
                    (T += `   vNormalW = getNormal();
`),
                    _.reflectionSource === "sphereMap" &&
                      v.fragmentUniformsCount <= 16 &&
                      ((g += m.viewNormalVS),
                      (T += `   vNormalV    = getViewNormal();
`)),
                    _.hasTangents &&
                    (_.useHeights || _.useNormals || _.enableGGXSpecular)
                      ? ((this.attributes.vertex_tangent = A.h3u),
                        (g += m.tangentBinormalVS),
                        (T += `   vTangentW   = getTangent();
`),
                        (T += `   vBinormalW  = getBinormal();
`))
                      : (_.enableGGXSpecular || !v.extStandardDerivatives) &&
                        (T += `   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));
`));
                const E = 2;
                for (let P = 0; P < E; P++)
                  t[P] &&
                    ((this.attributes["vertex_texCoord" + P] = "TEXCOORD" + P),
                    (g += m["uv" + P + "VS"]),
                    (T +=
                      "   vec2 uv" +
                      P +
                      " = getUv" +
                      P +
                      `();
`)),
                    r[P] &&
                      (T +=
                        "   vUv" +
                        P +
                        " = uv" +
                        P +
                        `;
`);
                const M = [g, this.varyings, T, []];
                if (
                  (u.forEach((P) => {
                    this._setMapTransform(M, P.name, P.id, P.uv);
                  }),
                  (g = M[0]),
                  (this.varyings = M[1]),
                  (T = M[2]),
                  _.vertexColors &&
                    ((this.attributes.vertex_color = A.F8$),
                    (T += `   vVertexColor = vertex_color;
`)),
                  _.useMsdf &&
                    _.msdfTextAttribute &&
                    ((this.attributes.vertex_outlineParameters = A.$_V),
                    (this.attributes.vertex_shadowParameters = A.URU),
                    (T += `    unpackMsdfParams();
`),
                    (g += m.msdfVS)),
                  _.useMorphPosition || _.useMorphNormal)
                )
                  if (_.useMorphTextureBased) {
                    (g += `#define MORPHING_TEXTURE_BASED
`),
                      _.useMorphPosition &&
                        (g += `#define MORPHING_TEXTURE_BASED_POSITION
`),
                      _.useMorphNormal &&
                        (g += `#define MORPHING_TEXTURE_BASED_NORMAL
`),
                      (this.attributes.morph_vertex_id = A.FHg);
                    const P = v.isWebGPU ? "uint" : "float";
                    g += `attribute ${P} morph_vertex_id;
`;
                  } else
                    (g += `#define MORPHING
`),
                      _.useMorphPosition
                        ? ((this.attributes.morph_pos0 = A.$_V),
                          (this.attributes.morph_pos1 = A.URU),
                          (this.attributes.morph_pos2 = A.yib),
                          (this.attributes.morph_pos3 = A.rGZ),
                          (g += `#define MORPHING_POS03
`),
                          (g += `attribute vec3 morph_pos0;
`),
                          (g += `attribute vec3 morph_pos1;
`),
                          (g += `attribute vec3 morph_pos2;
`),
                          (g += `attribute vec3 morph_pos3;
`))
                        : _.useMorphNormal &&
                          ((this.attributes.morph_nrm0 = A.$_V),
                          (this.attributes.morph_nrm1 = A.URU),
                          (this.attributes.morph_nrm2 = A.yib),
                          (this.attributes.morph_nrm3 = A.rGZ),
                          (g += `#define MORPHING_NRM03
`),
                          (g += `attribute vec3 morph_nrm0;
`),
                          (g += `attribute vec3 morph_nrm1;
`),
                          (g += `attribute vec3 morph_nrm2;
`),
                          (g += `attribute vec3 morph_nrm3;
`)),
                      _.useMorphNormal
                        ? ((this.attributes.morph_nrm4 = A.yZ0),
                          (this.attributes.morph_nrm5 = A.pov),
                          (this.attributes.morph_nrm6 = A.yof),
                          (this.attributes.morph_nrm7 = A.FHg),
                          (g += `#define MORPHING_NRM47
`),
                          (g += `attribute vec3 morph_nrm4;
`),
                          (g += `attribute vec3 morph_nrm5;
`),
                          (g += `attribute vec3 morph_nrm6;
`),
                          (g += `attribute vec3 morph_nrm7;
`))
                        : ((this.attributes.morph_pos4 = A.yZ0),
                          (this.attributes.morph_pos5 = A.pov),
                          (this.attributes.morph_pos6 = A.yof),
                          (this.attributes.morph_pos7 = A.FHg),
                          (g += `#define MORPHING_POS47
`),
                          (g += `attribute vec3 morph_pos4;
`),
                          (g += `attribute vec3 morph_pos5;
`),
                          (g += `attribute vec3 morph_pos6;
`),
                          (g += `attribute vec3 morph_pos7;
`));
                _.skin
                  ? ((this.attributes.vertex_boneWeights = A.Hn_),
                    (this.attributes.vertex_boneIndices = A.aVd),
                    (g += (0, f.P1)(v, m)),
                    (g += `#define SKIN
`))
                  : _.useInstancing &&
                    (g += `#define INSTANCING
`),
                  _.screenSpace &&
                    (g += `#define SCREENSPACE
`),
                  _.pixelSnap &&
                    (g += `#define PIXELSNAP
`),
                  (g = this._vsAddTransformCode(g, v, m, _)),
                  this.needsNormal && (g += m.normalVS),
                  (g += `
`),
                  (g += m.startVS),
                  (g += T),
                  (g += m.endVS),
                  (g += "}"),
                  Object.keys(o).forEach((P) => {
                    g.indexOf(P) >= 0 &&
                      ((this.varyings += `varying ${o[P]} ${P};
`),
                      (this.varyingDefines += `#define VARYING_${P.toUpperCase()}
`));
                  });
                const R = this.shaderPassInfo.shaderDefines;
                this.vshader = R + this.varyings + g;
              }
              _fsGetBeginCode() {
                let t = this.shaderPassInfo.shaderDefines;
                for (let r = 0; r < this.defines.length; r++)
                  t += `#define ${this.defines[r]}
`;
                return t;
              }
              _fsGetPickPassCode() {
                let t = this._fsGetBeginCode();
                return (
                  (t += `uniform vec4 uColor;
`),
                  (t += this.varyings),
                  (t += this.varyingDefines),
                  (t += this.frontendDecl),
                  (t += this.frontendCode),
                  (t += (0, f.qN)()),
                  (t += this.frontendFunc),
                  (t += `    gl_FragColor = uColor;
`),
                  (t += (0, f._N)()),
                  t
                );
              }
              _fsGetDepthPassCode() {
                const t = this.chunks;
                let r = this._fsGetBeginCode();
                return (
                  (r += `varying float vDepth;
`),
                  (r += this.varyings),
                  (r += this.varyingDefines),
                  (r += t.packDepthPS),
                  (r += this.frontendDecl),
                  (r += this.frontendCode),
                  (r += (0, f.qN)()),
                  (r += this.frontendFunc),
                  (r += `    gl_FragColor = packFloat(vDepth);
`),
                  (r += (0, f._N)()),
                  r
                );
              }
              _fsGetShadowPassCode() {
                const t = this.device,
                  r = this.options,
                  u = this.chunks,
                  v = this.varyings,
                  _ = this.shaderPassInfo.lightType;
                let m = this.shaderPassInfo.shadowType;
                _ !== c.kx &&
                  r.clusteredLightingEnabled &&
                  (m === c.oR || m === c.xv || m === c.DT || m === c.vJ) &&
                  (m = c.MF);
                let g = this._fsGetBeginCode();
                t.extStandardDerivatives &&
                  !t.webgl2 &&
                  !t.isWebGPU &&
                  (g += `uniform vec2 polygonOffset;
`),
                  m === c.DT
                    ? t.textureFloatHighPrecision
                      ? (g += `#define VSM_EXPONENT 15.0

`)
                      : (g += `#define VSM_EXPONENT 5.54

`)
                    : m === c.xv &&
                      (g += `#define VSM_EXPONENT 5.54

`),
                  _ !== c.kx &&
                    ((g += `uniform vec3 view_position;
`),
                    (g += `uniform float light_radius;
`)),
                  (g += v),
                  (g += this.varyingDefines),
                  (g += this.frontendDecl),
                  (g += this.frontendCode);
                const T = m === c.Mk || m === c.MF || m === c.Mq || m === c.vJ,
                  E = _ === c.dG && m !== c.vJ && !r.clusteredLightingEnabled,
                  M = (T && !t.supportsDepthShadow) || E;
                M
                  ? (g += u.packDepthPS)
                  : m === c.oR &&
                    ((g += `vec2 encodeFloatRG( float v ) {
`),
                    (g += `    vec2 enc = vec2(1.0, 255.0) * v;
`),
                    (g += `    enc = fract(enc);
`),
                    (g += `    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
`),
                    (g += `    return enc;
`),
                    (g += `}

`)),
                  m === c.vJ && (g += x.G.linearizeDepthPS),
                  (g += (0, f.qN)()),
                  (g += this.frontendFunc);
                const R = m === c.oR || m === c.xv || m === c.DT,
                  P = !t.webgl2 && t.extStandardDerivatives && !t.isWebGPU,
                  F = _ === c.kx || (!R && _ === c.Gy);
                let b = !1;
                return (
                  F
                    ? (g += `    float depth = gl_FragCoord.z;
`)
                    : ((g += `    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);
`),
                      (b = !0)),
                  P &&
                    ((g += `    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);
`),
                    (g += `    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;
`),
                    (b = !0)),
                  M
                    ? (g += `    gl_FragColor = packFloat(depth);
`)
                    : R
                    ? m === c.oR
                      ? (g += `    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));
`)
                      : (g += u.storeEVSMPS)
                    : m === c.vJ
                    ? (g += `    gl_FragColor.r = depth;
`)
                    : (b &&
                        (g += `    gl_FragDepth = depth;
`),
                      (g += `    gl_FragColor = vec4(1.0);
`)),
                  (g += (0, f._N)()),
                  g
                );
              }
              _fsGetLitPassCode() {
                const t = this.device,
                  r = this.options,
                  u = this.chunks,
                  v = new l.v(),
                  _ = new l.v(),
                  m = new l.v(),
                  g = new l.v();
                r.opacityFadesSpecular === !1 &&
                  v.append("uniform float material_alphaFade;"),
                  r.useSpecular &&
                    (this.defines.push("LIT_SPECULAR"),
                    this.reflections && this.defines.push("LIT_REFLECTIONS"),
                    r.useClearCoat && this.defines.push("LIT_CLEARCOAT"),
                    r.fresnelModel > 0 &&
                      this.defines.push("LIT_SPECULAR_FRESNEL"),
                    r.conserveEnergy &&
                      this.defines.push("LIT_CONSERVE_ENERGY"),
                    r.useSheen && this.defines.push("LIT_SHEEN"),
                    r.useIridescence && this.defines.push("LIT_IRIDESCENCE"));
                const T = [];
                let E = 0,
                  M = !1,
                  R = !1,
                  P = !1,
                  F = r.lights.some(function (B) {
                    return B._shape && B._shape !== c.j0;
                  });
                r.clusteredLightingEnabled &&
                  r.clusteredLightingAreaLightsEnabled &&
                  (F = !0);
                let b = "highp";
                t.areaLightLutFormat === A.Lxj &&
                  (v.append("#define AREA_R8_G8_B8_A8_LUTS"), (b = "lowp")),
                  (F || r.clusteredLightingEnabled) &&
                    (v.append("#define AREA_LIGHTS"),
                    v.append(`uniform ${b} sampler2D areaLightsLutTex1;`),
                    v.append(`uniform ${b} sampler2D areaLightsLutTex2;`));
                for (let B = 0; B < r.lights.length; B++) {
                  const $ = r.lights[B],
                    le = $._type;
                  if (r.clusteredLightingEnabled && le !== c.kx) continue;
                  const O = F && $._shape ? $._shape : c.j0;
                  v.append("uniform vec3 light" + B + "_color;"),
                    $._shadowType === c.vJ &&
                      $.castShadows &&
                      !r.noShadow &&
                      (v.append(`uniform float light${B}_shadowSearchArea;`),
                      v.append(`uniform vec4 light${B}_cameraParams;`)),
                    le === c.kx
                      ? v.append("uniform vec3 light" + B + "_direction;")
                      : (v.append("uniform vec3 light" + B + "_position;"),
                        v.append("uniform float light" + B + "_radius;"),
                        le === c.Gy &&
                          (v.append("uniform vec3 light" + B + "_direction;"),
                          v.append(
                            "uniform float light" + B + "_innerConeAngle;"
                          ),
                          v.append(
                            "uniform float light" + B + "_outerConeAngle;"
                          ))),
                    O !== c.j0 &&
                      (le === c.kx &&
                        v.append("uniform vec3 light" + B + "_position;"),
                      v.append("uniform vec3 light" + B + "_halfWidth;"),
                      v.append("uniform vec3 light" + B + "_halfHeight;")),
                    $.castShadows &&
                      !r.noShadow &&
                      (v.append("uniform mat4 light" + B + "_shadowMatrix;"),
                      v.append("uniform float light" + B + "_shadowIntensity;"),
                      le === c.kx &&
                        (v.append(
                          "uniform mat4 light" + B + "_shadowMatrixPalette[4];"
                        ),
                        v.append(
                          "uniform float light" +
                            B +
                            "_shadowCascadeDistances[4];"
                        ),
                        v.append(
                          "uniform float light" + B + "_shadowCascadeCount;"
                        )),
                      v.append("uniform vec4 light" + B + "_shadowParams;"),
                      le === c.kx && (M = !0),
                      le === c.dG
                        ? v.append(
                            "uniform samplerCube light" + B + "_shadowMap;"
                          )
                        : $._isPcf && t.supportsDepthShadow
                        ? v.append(
                            "uniform sampler2DShadow light" + B + "_shadowMap;"
                          )
                        : v.append(
                            "uniform sampler2D light" + B + "_shadowMap;"
                          ),
                      E++,
                      (T[$._shadowType] = !0),
                      $._isVsm && (R = !0),
                      $._shadowType === c.vJ && (P = !0)),
                    $._cookie &&
                      ($._cookie._cubemap
                        ? le === c.dG &&
                          (v.append(
                            "uniform samplerCube light" + B + "_cookie;"
                          ),
                          v.append(
                            "uniform float light" + B + "_cookieIntensity;"
                          ),
                          (!$.castShadows || r.noShadow) &&
                            v.append(
                              "uniform mat4 light" + B + "_shadowMatrix;"
                            ))
                        : le === c.Gy &&
                          (v.append("uniform sampler2D light" + B + "_cookie;"),
                          v.append(
                            "uniform float light" + B + "_cookieIntensity;"
                          ),
                          (!$.castShadows || r.noShadow) &&
                            v.append(
                              "uniform mat4 light" + B + "_shadowMatrix;"
                            ),
                          $._cookieTransform &&
                            (v.append(
                              "uniform vec4 light" + B + "_cookieMatrix;"
                            ),
                            v.append(
                              "uniform vec2 light" + B + "_cookieOffset;"
                            ))));
                }
                const D =
                  this.needsNormal &&
                  (r.useNormals ||
                    r.useClearCoatNormals ||
                    (r.enableGGXSpecular && !r.useHeights));
                if (
                  (D &&
                    (r.hasTangents
                      ? _.append(r.fastTbn ? u.TBNfastPS : u.TBNPS)
                      : t.extStandardDerivatives &&
                        (r.useNormals || r.useClearCoatNormals)
                      ? _.append(
                          u.TBNderivativePS.replace(/\$UV/g, this.lightingUv)
                        )
                      : _.append(u.TBNObjectSpacePS)),
                  _.append(u.sphericalPS),
                  _.append(u.decodePS),
                  _.append((0, f.PY)(r.gamma, u)),
                  _.append((0, f.K)(r.toneMap, u)),
                  _.append((0, f.cu)(r.fog, u)),
                  _.append(this.frontendCode),
                  r.useCubeMapRotation && v.append("#define CUBEMAP_ROTATION"),
                  this.needsNormal &&
                    (_.append(u.cubeMapRotatePS),
                    _.append(
                      r.cubeMapProjection > 0
                        ? u.cubeMapProjectBoxPS
                        : u.cubeMapProjectNonePS
                    ),
                    _.append(
                      r.skyboxIntensity ? u.envMultiplyPS : u.envConstPS
                    )),
                  ((this.lighting && r.useSpecular) || this.reflections) &&
                    (r.useMetalness && _.append(u.metalnessModulatePS),
                    r.fresnelModel === c.SU && _.append(u.fresnelSchlickPS),
                    r.useIridescence && _.append(u.iridescenceDiffractionPS)),
                  r.useAo)
                )
                  switch ((_.append(u.aoDiffuseOccPS), r.occludeSpecular)) {
                    case c.aP:
                      _.append(
                        r.occludeSpecularFloat
                          ? u.aoSpecOccSimplePS
                          : u.aoSpecOccConstSimplePS
                      );
                      break;
                    case c.Nt:
                      _.append(
                        r.occludeSpecularFloat
                          ? u.aoSpecOccPS
                          : u.aoSpecOccConstPS
                      );
                      break;
                  }
                if (r.reflectionSource === "envAtlasHQ")
                  _.append(
                    r.fixSeams
                      ? u.fixCubemapSeamsStretchPS
                      : u.fixCubemapSeamsNonePS
                  ),
                    _.append(u.envAtlasPS),
                    _.append(
                      u.reflectionEnvHQPS
                        .replace(
                          /\$DECODE_CUBEMAP/g,
                          y.N.decodeFunc(r.reflectionCubemapEncoding)
                        )
                        .replace(
                          /\$DECODE/g,
                          y.N.decodeFunc(r.reflectionEncoding)
                        )
                    );
                else if (r.reflectionSource === "envAtlas")
                  _.append(u.envAtlasPS),
                    _.append(
                      u.reflectionEnvPS.replace(
                        /\$DECODE/g,
                        y.N.decodeFunc(r.reflectionEncoding)
                      )
                    );
                else if (r.reflectionSource === "cubeMap")
                  _.append(
                    r.fixSeams
                      ? u.fixCubemapSeamsStretchPS
                      : u.fixCubemapSeamsNonePS
                  ),
                    _.append(
                      u.reflectionCubePS.replace(
                        /\$DECODE/g,
                        y.N.decodeFunc(r.reflectionEncoding)
                      )
                    );
                else if (r.reflectionSource === "sphereMap") {
                  const B =
                    t.fragmentUniformsCount > 16
                      ? u.reflectionSpherePS
                      : u.reflectionSphereLowPS;
                  _.append(
                    B.replace(/\$DECODE/g, y.N.decodeFunc(r.reflectionEncoding))
                  );
                }
                this.reflections &&
                  (r.useClearCoat && _.append(u.reflectionCCPS),
                  r.useSheen && _.append(u.reflectionSheenPS)),
                  r.useRefraction &&
                    (r.useDynamicRefraction
                      ? _.append(u.refractionDynamicPS)
                      : this.reflections && _.append(u.refractionCubePS)),
                  r.useSheen && _.append(u.lightSheenPS),
                  r.clusteredLightingEnabled &&
                    (_.append(u.clusteredLightUtilsPS),
                    r.clusteredLightingCookiesEnabled &&
                      _.append(u.clusteredLightCookiesPS),
                    r.clusteredLightingShadowsEnabled &&
                      !r.noShadow &&
                      ((T[c.MF] = !0), (T[c.Mq] = !0), (T[c.vJ] = !0))),
                  (E > 0 || r.clusteredLightingEnabled) &&
                    (M && _.append(u.shadowCascadesPS),
                    (T[c.Mk] || T[c.MF]) && _.append(u.shadowStandardPS),
                    T[c.Mq] &&
                      (t.webgl2 || t.isWebGPU) &&
                      _.append(u.shadowStandardGL2PS),
                    R &&
                      (_.append(u.shadowVSM_commonPS),
                      T[c.oR] && _.append(u.shadowVSM8PS),
                      T[c.xv] &&
                        _.append(
                          t.extTextureHalfFloatLinear
                            ? u.shadowEVSMPS.replace(/\$/g, "16")
                            : u.shadowEVSMnPS.replace(/\$/g, "16")
                        ),
                      T[c.DT] &&
                        _.append(
                          t.extTextureFloatLinear
                            ? u.shadowEVSMPS.replace(/\$/g, "32")
                            : u.shadowEVSMnPS.replace(/\$/g, "32")
                        )),
                    P &&
                      (_.append(u.linearizeDepthPS), _.append(u.shadowPCSSPS)),
                    t.webgl2 ||
                      t.extStandardDerivatives ||
                      t.isWebGPU ||
                      _.append(u.biasConstPS)),
                  r.enableGGXSpecular &&
                    _.append("uniform float material_anisotropy;"),
                  this.lighting &&
                    (_.append(u.lightDiffuseLambertPS),
                    (F || r.clusteredLightingAreaLightsEnabled) &&
                      _.append(u.ltcPS));
                let G = !1;
                r.useSpecular &&
                  (this.lighting &&
                    _.append(
                      r.shadingModel === c.Tp
                        ? u.lightSpecularPhongPS
                        : r.enableGGXSpecular
                        ? u.lightSpecularAnisoGGXPS
                        : u.lightSpecularBlinnPS
                    ),
                  !r.fresnelModel &&
                    !this.reflections &&
                    !r.diffuseMapEnabled &&
                    (v.append("uniform vec3 material_ambient;"),
                    v.append("#define LIT_OLD_AMBIENT"),
                    (G = !0))),
                  _.append(u.combinePS),
                  r.lightMapEnabled &&
                    _.append(
                      r.useSpecular && r.dirLightMapEnabled
                        ? u.lightmapDirAddPS
                        : u.lightmapAddPS
                    );
                const X = !r.lightMapEnabled || r.lightMapWithoutAmbient;
                X &&
                  (r.ambientSource === "ambientSH"
                    ? _.append(u.ambientSHPS)
                    : r.ambientSource === "envAtlas"
                    ? (r.reflectionSource !== "envAtlas" &&
                        r.reflectionSource !== "envAtlasHQ" &&
                        _.append(u.envAtlasPS),
                      _.append(
                        u.ambientEnvPS.replace(
                          /\$DECODE/g,
                          y.N.decodeFunc(r.ambientEncoding)
                        )
                      ))
                    : _.append(u.ambientConstantPS)),
                  r.useAmbientTint &&
                    !G &&
                    v.append("uniform vec3 material_ambient;"),
                  r.useMsdf &&
                    (r.msdfTextAttribute ||
                      v.append("#define UNIFORM_TEXT_PARAMETERS"),
                    _.append(u.msdfPS)),
                  this.needsNormal &&
                    (_.append(u.viewDirPS),
                    r.useSpecular &&
                      _.append(
                        r.enableGGXSpecular ? u.reflDirAnisoPS : u.reflDirPS
                      ));
                let ie = !1,
                  Q = !1,
                  te = !1,
                  ae = !1,
                  Z = !1,
                  J;
                if (
                  (r.clusteredLightingEnabled &&
                    this.lighting &&
                    ((ae = !0),
                    (ie = !0),
                    (Q = !0),
                    (Z = !0),
                    _.append(u.floatUnpackingPS),
                    r.lightMaskDynamic &&
                      v.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS"),
                    r.clusteredLightingCookiesEnabled &&
                      v.append("#define CLUSTER_COOKIES"),
                    r.clusteredLightingShadowsEnabled &&
                      !r.noShadow &&
                      (v.append("#define CLUSTER_SHADOWS"),
                      v.append(
                        "#define CLUSTER_SHADOW_TYPE_" +
                          c.BS[r.clusteredLightingShadowType]
                      )),
                    r.clusteredLightingAreaLightsEnabled &&
                      v.append("#define CLUSTER_AREALIGHTS"),
                    v.append(d.u.shaderDefines),
                    r.clusteredLightingShadowsEnabled &&
                      !r.noShadow &&
                      _.append(u.clusteredLightShadowsPS),
                    _.append(u.clusteredLightPS)),
                  r.twoSidedLighting &&
                    v.append("uniform float twoSidedLightingNegScaleFactor;"),
                  g.append(this._fsGetStartCode(g, t, u, r)),
                  this.needsNormal &&
                    (r.twoSidedLighting
                      ? g.append(
                          "    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);"
                        )
                      : g.append("    dVertexNormalW = normalize(vNormalW);"),
                    (r.useHeights || r.useNormals) &&
                      r.hasTangents &&
                      (r.twoSidedLighting
                        ? (g.append(
                            "    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;"
                          ),
                          g.append(
                            "    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;"
                          ))
                        : (g.append("    dTangentW = vTangentW;"),
                          g.append("    dBinormalW = vBinormalW;"))),
                    g.append("    getViewDir();"),
                    D &&
                      g.append(
                        "    getTBN(dTangentW, dBinormalW, dVertexNormalW);"
                      )),
                  g.append(this.frontendFunc),
                  this.needsNormal &&
                    (r.useSpecular &&
                      m.append(
                        "    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);"
                      ),
                    r.useClearCoat &&
                      m.append(
                        "    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));"
                      )),
                  ((this.lighting && r.useSpecular) || this.reflections) &&
                    (r.useMetalness &&
                      (m.append(
                        "    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;"
                      ),
                      m.append(
                        "    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);"
                      ),
                      m.append(
                        "    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);"
                      )),
                    r.useIridescence &&
                      m.append(
                        "    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);"
                      )),
                  X &&
                    (m.append("    addAmbient(litArgs_worldNormal);"),
                    r.conserveEnergy &&
                      r.useSpecular &&
                      m.append(
                        "   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);"
                      ),
                    r.separateAmbient &&
                      m.append(`
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`)),
                  r.useAmbientTint &&
                    !G &&
                    m.append("    dDiffuseLight *= material_ambient;"),
                  r.useAo &&
                    !r.occludeDirect &&
                    m.append("    occludeDiffuse(litArgs_ao);"),
                  r.lightMapEnabled &&
                    m.append(`    addLightMap(
								litArgs_lightmap, 
								litArgs_lightmapDir, 
								litArgs_worldNormal, 
								dViewDirW, 
								dReflDirW, 
								litArgs_gloss, 
								litArgs_specularity, 
								dVertexNormalW,
								dTBN
						#if defined(LIT_IRIDESCENCE)
								, iridescenceFresnel,
								litArgs_iridescence_intensity
						#endif
								);`),
                  this.lighting || this.reflections)
                ) {
                  this.reflections &&
                    (r.useClearCoat &&
                      (m.append(
                        "    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);"
                      ),
                      r.fresnelModel > 0
                        ? (m.append(
                            "    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));"
                          ),
                          m.append("    ccReflection.rgb *= ccFresnel;"))
                        : m.append("    ccFresnel = 0.0;")),
                    r.useSpecularityFactor &&
                      m.append(
                        "    ccReflection.rgb *= litArgs_specularityFactor;"
                      ),
                    r.useSheen &&
                      m.append(
                        "    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);"
                      ),
                    m.append("    addReflection(dReflDirW, litArgs_gloss);"),
                    r.fresnelModel > 0
                      ? m.append(`    dReflection.rgb *= 
												getFresnel(
														dot(dViewDirW, litArgs_worldNormal), 
														litArgs_gloss, 
														litArgs_specularity
												#if defined(LIT_IRIDESCENCE)
														, iridescenceFresnel,
														litArgs_iridescence_intensity
												#endif
														);`)
                      : m.append("    dReflection.rgb *= litArgs_specularity;"),
                    r.useSpecularityFactor &&
                      m.append(
                        "    dReflection.rgb *= litArgs_specularityFactor;"
                      )),
                    F &&
                      (m.append("    dSpecularLight *= litArgs_specularity;"),
                      r.useSpecular &&
                        m.append(
                          "    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);"
                        ));
                  for (let B = 0; B < r.lights.length; B++) {
                    const $ = r.lights[B],
                      le = $._type;
                    if (r.clusteredLightingEnabled && le !== c.kx) continue;
                    J = !1;
                    const O = F && $._shape ? $.shape : c.j0,
                      Y =
                        F && $._shape ? this._getLightSourceShapeString(O) : "";
                    if (
                      (O !== c.j0 &&
                        m.append(
                          "    calc" +
                            Y +
                            "LightValues(light" +
                            B +
                            "_position, light" +
                            B +
                            "_halfWidth, light" +
                            B +
                            "_halfHeight);"
                        ),
                      le === c.kx
                        ? (m.append(
                            "    dLightDirNormW = light" + B + "_direction;"
                          ),
                          m.append("    dAtten = 1.0;"))
                        : ($._cookie &&
                            ((le === c.Gy && !$._cookie._cubemap) ||
                              (le === c.dG && $._cookie._cubemap)) &&
                            ((Z = !0), (J = !0)),
                          m.append(
                            "    getLightDirPoint(light" + B + "_position);"
                          ),
                          (ie = !0),
                          J &&
                            (le === c.Gy
                              ? m.append(
                                  "    dAtten3 = getCookie2D" +
                                    ($._cookieFalloff ? "" : "Clip") +
                                    ($._cookieTransform ? "Xform" : "") +
                                    "(light" +
                                    B +
                                    "_cookie, light" +
                                    B +
                                    "_shadowMatrix, light" +
                                    B +
                                    "_cookieIntensity" +
                                    ($._cookieTransform
                                      ? ", light" +
                                        B +
                                        "_cookieMatrix, light" +
                                        B +
                                        "_cookieOffset"
                                      : "") +
                                    ")." +
                                    $._cookieChannel +
                                    ";"
                                )
                              : m.append(
                                  "    dAtten3 = getCookieCube(light" +
                                    B +
                                    "_cookie, light" +
                                    B +
                                    "_shadowMatrix, light" +
                                    B +
                                    "_cookieIntensity)." +
                                    $._cookieChannel +
                                    ";"
                                )),
                          O === c.j0
                            ? $._falloffMode === c.$7
                              ? (m.append(
                                  "    dAtten = getFalloffLinear(light" +
                                    B +
                                    "_radius, dLightDirW);"
                                ),
                                (Q = !0))
                              : (m.append(
                                  "    dAtten = getFalloffInvSquared(light" +
                                    B +
                                    "_radius, dLightDirW);"
                                ),
                                (te = !0))
                            : (m.append(
                                "    dAtten = getFalloffWindow(light" +
                                  B +
                                  "_radius, dLightDirW);"
                              ),
                              (te = !0)),
                          m.append("    if (dAtten > 0.00001) {"),
                          le === c.Gy &&
                            ((J && !$._cookieFalloff) ||
                              (m.append(
                                "    dAtten *= getSpotEffect(light" +
                                  B +
                                  "_direction, light" +
                                  B +
                                  "_innerConeAngle, light" +
                                  B +
                                  "_outerConeAngle, dLightDirNormW);"
                              ),
                              (ae = !0)))),
                      O !== c.j0
                        ? le === c.kx
                          ? m.append(
                              "    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);"
                            )
                          : m.append(
                              "    dAttenD = get" +
                                Y +
                                "LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;"
                            )
                        : m.append(
                            "    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);"
                          ),
                      $.castShadows && !r.noShadow)
                    ) {
                      const ne = $._shadowType === c.vJ,
                        de =
                          $._shadowType === c.oR ||
                          $._shadowType === c.xv ||
                          $._shadowType === c.DT,
                        re =
                          $._shadowType === c.Mk ||
                          $._shadowType === c.MF ||
                          $._shadowType === c.Mq;
                      let I = null,
                        w;
                      switch ($._shadowType) {
                        case c.oR:
                          (I = "VSM8"), (w = "0.0");
                          break;
                        case c.xv:
                          (I = "VSM16"), (w = "5.54");
                          break;
                        case c.DT:
                          (I = "VSM32"),
                            t.textureFloatHighPrecision
                              ? (w = "15.0")
                              : (w = "5.54");
                          break;
                        case c.Mk:
                          I = "PCF1x1";
                          break;
                        case c.Mq:
                          I = "PCF5x5";
                          break;
                        case c.vJ:
                          I = "PCSS";
                          break;
                        case c.MF:
                        default:
                          I = "PCF3x3";
                          break;
                      }
                      if (I !== null) {
                        $._normalOffsetBias &&
                          !$._isVsm &&
                          _.append("#define SHADOW_SAMPLE_NORMAL_OFFSET"),
                          le === c.kx &&
                            _.append("#define SHADOW_SAMPLE_ORTHO"),
                          (((re || ne) && t.webgl2) ||
                            t.extStandardDerivatives ||
                            t.isWebGPU) &&
                            _.append("#define SHADOW_SAMPLE_SOURCE_ZBUFFER"),
                          le === c.dG &&
                            _.append("#define SHADOW_SAMPLE_POINT");
                        const N = u.shadowSampleCoordPS;
                        _.append(N.replace("$LIGHT", B)),
                          _.append("#undef SHADOW_SAMPLE_NORMAL_OFFSET"),
                          _.append("#undef SHADOW_SAMPLE_ORTHO"),
                          _.append("#undef SHADOW_SAMPLE_SOURCE_ZBUFFER"),
                          _.append("#undef SHADOW_SAMPLE_POINT");
                        let W = `light${B}_shadowMatrix`;
                        le === c.kx &&
                          $.numCascades > 1 &&
                          (m.append(
                            `    getShadowCascadeMatrix(light${B}_shadowMatrixPalette, light${B}_shadowCascadeDistances, light${B}_shadowCascadeCount);`
                          ),
                          (W = "cascadeShadowMat")),
                          m.append(
                            `    dShadowCoord = getShadowSampleCoord${B}(${W}, light${B}_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);`
                          ),
                          le === c.kx &&
                            m.append(
                              `    fadeShadow(light${B}_shadowCascadeDistances);`
                            );
                        var ve = `SHADOWMAP_PASS(light${B}_shadowMap), dShadowCoord, light${B}_shadowParams`;
                        if (de) ve = `${ve}, ${w}, dLightDirW`;
                        else if (ne) {
                          let he = `vec2(light${B}_shadowSearchArea)`;
                          O !== c.j0 &&
                            (he = `vec2(length(light${B}_halfWidth), length(light${B}_halfHeight)) * light${B}_shadowSearchArea`),
                            (ve = `${ve}, light${B}_cameraParams, ${he}, dLightDirW`);
                        }
                        le === c.dG
                          ? ((I = `Point${I}`),
                            ne || (ve = `${ve}, dLightDirW`))
                          : le === c.Gy && (I = `Spot${I}`),
                          m.append(
                            `    float shadow${B} = getShadow${I}(${ve});`
                          ),
                          m.append(
                            `    dAtten *= mix(1.0, shadow${B}, light${B}_shadowIntensity);`
                          );
                      }
                    }
                    if (
                      (O !== c.j0
                        ? r.conserveEnergy && r.useSpecular
                          ? m.append(
                              "    dDiffuseLight += ((dAttenD * dAtten) * light" +
                                B +
                                "_color" +
                                (J ? " * dAtten3" : "") +
                                ") * (1.0 - dLTCSpecFres);"
                            )
                          : m.append(
                              "    dDiffuseLight += (dAttenD * dAtten) * light" +
                                B +
                                "_color" +
                                (J ? " * dAtten3" : "") +
                                ";"
                            )
                        : F && r.conserveEnergy && r.useSpecular
                        ? m.append(
                            "    dDiffuseLight += (dAtten * light" +
                              B +
                              "_color" +
                              (J ? " * dAtten3" : "") +
                              ") * (1.0 - litArgs_specularity);"
                          )
                        : m.append(
                            "    dDiffuseLight += dAtten * light" +
                              B +
                              "_color" +
                              (J ? " * dAtten3" : "") +
                              ";"
                          ),
                      r.useSpecular &&
                        m.append(
                          "    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);"
                        ),
                      $.affectSpecularity)
                    )
                      if (O !== c.j0)
                        r.useClearCoat &&
                          m.append(
                            `    ccSpecularLight += ccLTCSpecFres * get${Y}LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light${B}_color` +
                              (J ? " * dAtten3" : "") +
                              ";"
                          ),
                          r.useSpecular &&
                            m.append(
                              `    dSpecularLight += dLTCSpecFres * get${Y}LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light${B}_color` +
                                (J ? " * dAtten3" : "") +
                                ";"
                            );
                      else {
                        var _e = !1;
                        le === c.kx && r.fresnelModel > 0 && (_e = !0),
                          r.useClearCoat &&
                            m.append(
                              `    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light${B}_color` +
                                (J ? " * dAtten3" : "") +
                                (_e
                                  ? " * getFresnelCC(dot(dViewDirW, dHalfDirW));"
                                  : ";")
                            ),
                          r.useSheen &&
                            m.append(
                              `    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light${B}_color` +
                                (J ? " * dAtten3;" : ";")
                            ),
                          r.useSpecular &&
                            m.append(
                              `    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light${B}_color` +
                                (J ? " * dAtten3" : "") +
                                (_e
                                  ? ` 
																		* getFresnel(
																				dot(dViewDirW, dHalfDirW), 
																				litArgs_gloss, 
																				litArgs_specularity
																		#if defined(LIT_IRIDESCENCE)
																				, iridescenceFresnel, 
																				litArgs_iridescence_intensity
																		#endif
																		);`
                                  : "* litArgs_specularity;")
                            );
                      }
                    le !== c.kx && m.append("    }");
                  }
                  r.clusteredLightingEnabled &&
                    this.lighting &&
                    ((Q = !0),
                    (te = !0),
                    (ie = !0),
                    m.append(`    addClusteredLights(
																				litArgs_worldNormal, 
																				dViewDirW, 
																				dReflDirW,
																#if defined(LIT_CLEARCOAT)
																				ccReflDirW,
																#endif
																				litArgs_gloss, 
																				litArgs_specularity, 
																				dVertexNormalW, 
																				dTBN, 
																#if defined(LIT_IRIDESCENCE)
																				iridescenceFresnel,
																#endif
																				litArgs_clearcoat_worldNormal, 
																				litArgs_clearcoat_gloss,
																				litArgs_sheen_gloss,
																				litArgs_iridescence_intensity
																		);`)),
                    F &&
                      (r.useClearCoat &&
                        m.append("    litArgs_clearcoat_specularity = 1.0;"),
                      r.useSpecular &&
                        m.append("    litArgs_specularity = vec3(1);")),
                    r.useRefraction &&
                      m.append(`    addRefraction(
												litArgs_worldNormal, 
												dViewDirW, 
												litArgs_thickness, 
												litArgs_gloss, 
												litArgs_specularity, 
												litArgs_albedo, 
												litArgs_transmission,
												litArgs_ior
										#if defined(LIT_IRIDESCENCE)
												, iridescenceFresnel, 
												litArgs_iridescence_intensity
										#endif
										);`);
                }
                r.useAo &&
                  (r.occludeDirect &&
                    m.append("    occludeDiffuse(litArgs_ao);"),
                  (r.occludeSpecular === c.aP || r.occludeSpecular === c.Nt) &&
                    m.append(
                      "    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);"
                    )),
                  r.useSpecularityFactor &&
                    m.append(
                      "    dSpecularLight *= litArgs_specularityFactor;"
                    ),
                  r.opacityFadesSpecular === !1 &&
                    ((r.blendType === c.i9 || r.blendType === c.bY) &&
                      (m.append(
                        "float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));"
                      ),
                      m.append(`#ifdef LIT_CLEARCOAT
 specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));
#endif`),
                      m.append(
                        "litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);"
                      )),
                    m.append("litArgs_opacity *= material_alphaFade;")),
                  m.append(u.endPS),
                  r.blendType === c.i9 ||
                  r.blendType === c.HG ||
                  r.alphaToCoverage
                    ? m.append(u.outputAlphaPS)
                    : r.blendType === c.bY
                    ? m.append(u.outputAlphaPremulPS)
                    : m.append(u.outputAlphaOpaquePS),
                  r.useMsdf &&
                    m.append("    gl_FragColor = applyMsdf(gl_FragColor);"),
                  m.append(u.outputPS),
                  m.append(u.debugOutputPS),
                  ie && _.prepend(u.lightDirPointPS),
                  Q && _.prepend(u.falloffLinearPS),
                  te && _.prepend(u.falloffInvSquaredPS),
                  ae && _.prepend(u.spotPS),
                  Z && !r.clusteredLightingEnabled && _.prepend(u.cookiePS);
                let L = "";
                const ge = `void evaluateBackend() {
${m.code}
}`;
                _.append(ge),
                  g.append(u.debugProcessFrontendPS),
                  g.append("    evaluateBackend();"),
                  g.append((0, f._N)());
                const k = v.code + _.code + g.code;
                return (
                  k.includes("dTBN") &&
                    (L += `mat3 dTBN;
`),
                  k.includes("dVertexNormalW") &&
                    (L += `vec3 dVertexNormalW;
`),
                  k.includes("dTangentW") &&
                    (L += `vec3 dTangentW;
`),
                  k.includes("dBinormalW") &&
                    (L += `vec3 dBinormalW;
`),
                  k.includes("dViewDirW") &&
                    (L += `vec3 dViewDirW;
`),
                  k.includes("dReflDirW") &&
                    (L += `vec3 dReflDirW;
`),
                  k.includes("dHalfDirW") &&
                    (L += `vec3 dHalfDirW;
`),
                  k.includes("ccReflDirW") &&
                    (L += `vec3 ccReflDirW;
`),
                  k.includes("dLightDirNormW") &&
                    (L += `vec3 dLightDirNormW;
`),
                  k.includes("dLightDirW") &&
                    (L += `vec3 dLightDirW;
`),
                  k.includes("dLightPosW") &&
                    (L += `vec3 dLightPosW;
`),
                  k.includes("dShadowCoord") &&
                    (L += `vec3 dShadowCoord;
`),
                  k.includes("dReflection") &&
                    (L += `vec4 dReflection;
`),
                  k.includes("dDiffuseLight") &&
                    (L += `vec3 dDiffuseLight;
`),
                  k.includes("dSpecularLight") &&
                    (L += `vec3 dSpecularLight;
`),
                  k.includes("dAtten") &&
                    (L += `float dAtten;
`),
                  k.includes("dAttenD") &&
                    (L += `float dAttenD;
`),
                  k.includes("dAtten3") &&
                    (L += `vec3 dAtten3;
`),
                  k.includes("dMsdf") &&
                    (L += `vec4 dMsdf;
`),
                  k.includes("ccFresnel") &&
                    (L += `float ccFresnel;
`),
                  k.includes("ccReflection") &&
                    (L += `vec3 ccReflection;
`),
                  k.includes("ccSpecularLight") &&
                    (L += `vec3 ccSpecularLight;
`),
                  k.includes("ccSpecularityNoFres") &&
                    (L += `float ccSpecularityNoFres;
`),
                  k.includes("sSpecularLight") &&
                    (L += `vec3 sSpecularLight;
`),
                  k.includes("sReflection") &&
                    (L += `vec3 sReflection;
`),
                  this._fsGetBeginCode() +
                    this.varyings +
                    this.varyingDefines +
                    this._fsGetBaseCode() +
                    L +
                    this.frontendDecl +
                    k
                );
              }
              generateFragmentShader(t, r, u, v) {
                var _;
                const m = this.options;
                (this.frontendDecl = t),
                  (this.frontendCode = r),
                  (this.frontendFunc = u),
                  (this.lightingUv = v),
                  m.pass === c.cz
                    ? (this.fshader = this._fsGetPickPassCode())
                    : m.pass === c.w8
                    ? (this.fshader = this._fsGetDepthPassCode())
                    : this.shadowPass
                    ? (this.fshader = this._fsGetShadowPassCode())
                    : m.customFragmentShader
                    ? (this.fshader =
                        this._fsGetBeginCode() + m.customFragmentShader)
                    : (this.fshader = this._fsGetLitPassCode()),
                  (_ = this.handleCompatibility) == null || _.call(this);
              }
              getDefinition() {
                const t = s.l.createDefinition(this.device, {
                  name: "LitShader",
                  attributes: this.attributes,
                  vertexCode: this.vshader,
                  fragmentCode: this.fshader,
                });
                return this.shaderPassInfo.isForward && (t.tag = A.EB8), t;
              }
            }
          },
          333: (xe, V, a) => {
            "use strict";
            a.d(V, { $$: () => h, V$: () => f, gx: () => d });
            var A = a(8526),
              x = a(9855),
              y = a(2910),
              c = a(783);
            function d(s, l, n, o = !1) {
              return new A.M(
                s,
                x.l.createDefinition(s, {
                  name: `${l}_${n}`,
                  vertexCode: y.G[l],
                  fragmentCode: y.G[n],
                  useTransformFeedback: o,
                })
              );
            }
            function h(s, l, n, o, i, e = !1) {
              const t = (0, c.k)(s);
              let r = t.getCachedShader(o);
              return (
                r ||
                  ((r = new A.M(
                    s,
                    x.l.createDefinition(s, {
                      name: o,
                      vertexCode: l,
                      fragmentCode: n,
                      attributes: i,
                      useTransformFeedback: e,
                    })
                  )),
                  t.setCachedShader(o, r)),
                r
              );
            }
            function f(s, l) {
              var n;
              const o = s.definition,
                e = `${(n = o.name) != null ? n : "shader"}-id-${s.id}`,
                t = {
                  generateKey: function (_) {
                    return e;
                  },
                  createShaderDefinition: function (_, m) {
                    return o;
                  },
                },
                r = "shader",
                u = (0, c.k)(s.device);
              u.register(r, t);
              const v = u.getProgram(r, {}, l);
              return u.unregister(r), v;
            }
            (y.G.createShader = d), (y.G.createShaderFromCode = h);
          },
          4639: (xe, V, a) => {
            "use strict";
            a.d(V, { p: () => d });
            var A = a(9391),
              x = a(5950);
            const y = new x.N();
            class c {
              constructor(f, s, l = {}) {
                (this.index = void 0),
                  (this.name = void 0),
                  (this.shaderDefine = void 0),
                  (this.name = f),
                  (this.index = s),
                  Object.assign(this, l),
                  this.initShaderDefines();
              }
              initShaderDefines() {
                let f;
                this.isShadow
                  ? (f = "SHADOW")
                  : this.isForward
                  ? (f = "FORWARD")
                  : this.index === A.w8
                  ? (f = "DEPTH")
                  : this.index === A.cz && (f = "PICK");
                const s = f
                    ? `#define ${f}_PASS
`
                    : "",
                  l = `#define ${this.name.toUpperCase()}_PASS
`;
                this.shaderDefines = s + l;
              }
            }
            class d {
              constructor() {
                (this.passesNamed = new Map()),
                  (this.passesIndexed = []),
                  (this.nextIndex = 0);
                const f = (s, l, n) => {
                  this.allocate(s, n);
                };
                f("forward", A.OP, { isForward: !0 }),
                  f("forward_hdr", A.Su, { isForward: !0 }),
                  f("depth"),
                  f("pick"),
                  f("shadow");
              }
              static get(f) {
                return y.get(f, () => new d());
              }
              allocate(f, s) {
                let l = this.passesNamed.get(f);
                return (
                  l === void 0 &&
                    ((l = new c(f, this.nextIndex, s)),
                    this.passesNamed.set(l.name, l),
                    (this.passesIndexed[l.index] = l),
                    this.nextIndex++),
                  l
                );
              }
              getByIndex(f) {
                return this.passesIndexed[f];
              }
              getByName(f) {
                return this.passesNamed.get(f);
              }
            }
          },
          5506: (xe, V, a) => {
            "use strict";
            a.d(V, { b: () => c });
            var A = a(4460),
              x = a(8777);
            class y extends A.p {
              constructor(h, f) {
                super(), (this.skin = h), (this.skinInstance = f);
              }
            }
            class c {
              static createCachedSkinInstance(h, f, s) {
                let l = c.getCachedSkinInstance(h, f);
                return (
                  l ||
                    ((l = new x.h(h)),
                    l.resolve(f, s),
                    c.addCachedSkinInstance(h, f, l)),
                  l
                );
              }
              static getCachedSkinInstance(h, f) {
                let s = null;
                const l = c._skinInstanceCache.get(f);
                if (l) {
                  const n = l.find((o) => o.skin === h);
                  n && (n.incRefCount(), (s = n.skinInstance));
                }
                return s;
              }
              static addCachedSkinInstance(h, f, s) {
                let l = c._skinInstanceCache.get(f);
                l || ((l = []), c._skinInstanceCache.set(f, l));
                let n = l.find((o) => o.skin === h);
                n || ((n = new y(h, s)), l.push(n)), n.incRefCount();
              }
              static removeCachedSkinInstance(h) {
                if (h) {
                  const f = h.rootBone;
                  if (f) {
                    const s = c._skinInstanceCache.get(f);
                    if (s) {
                      const l = s.findIndex((n) => n.skinInstance === h);
                      if (l >= 0) {
                        const n = s[l];
                        n.decRefCount(),
                          n.refCount === 0 &&
                            (s.splice(l, 1),
                            s.length || c._skinInstanceCache.delete(f),
                            h && (h.destroy(), (n.skinInstance = null)));
                      }
                    }
                  }
                }
              }
            }
            c._skinInstanceCache = new Map();
          },
          8777: (xe, V, a) => {
            "use strict";
            a.d(V, { h: () => h });
            var A = a(8656),
              x = a(8484),
              y = a(1630),
              c = a(1208);
            const d = new x.$();
            class h {
              constructor(s) {
                (this.bones = void 0),
                  (this._dirty = !0),
                  (this._rootBone = null),
                  (this._skinUpdateIndex = -1),
                  (this._updateBeforeCull = !0),
                  s && this.initSkin(s);
              }
              set rootBone(s) {
                this._rootBone = s;
              }
              get rootBone() {
                return this._rootBone;
              }
              init(s, l) {
                if (s.supportsBoneTextures) {
                  const n = l * 3;
                  let o = Math.ceil(Math.sqrt(n));
                  o = A.D.roundUp(o, 3);
                  const i = Math.ceil(n / o);
                  (this.boneTexture = new c.g(s, {
                    width: o,
                    height: i,
                    format: y.s7h,
                    mipmaps: !1,
                    minFilter: y.uhC,
                    magFilter: y.uhC,
                    name: "skin",
                  })),
                    (this.matrixPalette = this.boneTexture.lock());
                } else this.matrixPalette = new Float32Array(l * 12);
              }
              destroy() {
                this.boneTexture &&
                  (this.boneTexture.destroy(), (this.boneTexture = null));
              }
              resolve(s, l) {
                this.rootBone = s;
                const n = this.skin,
                  o = [];
                for (let i = 0; i < n.boneNames.length; i++) {
                  const e = n.boneNames[i];
                  let t = s.findByName(e);
                  t || (t = l), o.push(t);
                }
                this.bones = o;
              }
              initSkin(s) {
                (this.skin = s), (this.bones = []);
                const l = s.inverseBindPose.length;
                this.init(s.device, l), (this.matrices = []);
                for (let n = 0; n < l; n++) this.matrices[n] = new x.$();
              }
              uploadBones(s) {
                s.supportsBoneTextures &&
                  (this.boneTexture.lock(), this.boneTexture.unlock());
              }
              _updateMatrices(s, l) {
                if (this._skinUpdateIndex !== l) {
                  (this._skinUpdateIndex = l),
                    d.copy(s.getWorldTransform()).invert();
                  for (let n = this.bones.length - 1; n >= 0; n--)
                    this.matrices[n].mulAffine2(
                      d,
                      this.bones[n].getWorldTransform()
                    ),
                      this.matrices[n].mulAffine2(
                        this.matrices[n],
                        this.skin.inverseBindPose[n]
                      );
                }
              }
              updateMatrices(s, l) {
                this._updateBeforeCull && this._updateMatrices(s, l);
              }
              updateMatrixPalette(s, l) {
                this._updateMatrices(s, l);
                const n = this.matrixPalette,
                  o = this.bones.length;
                for (let i = 0; i < o; i++) {
                  const e = this.matrices[i].data,
                    t = i * 12;
                  (n[t] = e[0]),
                    (n[t + 1] = e[4]),
                    (n[t + 2] = e[8]),
                    (n[t + 3] = e[12]),
                    (n[t + 4] = e[1]),
                    (n[t + 5] = e[5]),
                    (n[t + 6] = e[9]),
                    (n[t + 7] = e[13]),
                    (n[t + 8] = e[2]),
                    (n[t + 9] = e[6]),
                    (n[t + 10] = e[10]),
                    (n[t + 11] = e[14]);
                }
                this.uploadBones(this.skin.device);
              }
            }
          },
          2310: (xe, V, a) => {
            "use strict";
            a.d(V, { g: () => d });
            class A {
              constructor() {
                (this.index = 0), (this.boneIndices = [0, 0, 0, 0]);
              }
            }
            class x {
              constructor() {
                (this.partition = 0),
                  (this.vertexStart = 0),
                  (this.vertexCount = 0),
                  (this.indexStart = 0),
                  (this.indexCount = 0),
                  (this.boneIndices = []),
                  (this.vertices = []),
                  (this.indices = []),
                  (this.indexMap = {}),
                  (this.originalMesh = null);
              }
              addVertex(f, s, l) {
                let n = -1;
                if (this.indexMap[s] !== void 0)
                  (n = this.indexMap[s]), this.indices.push(n);
                else {
                  for (let o = 0; o < 4; o++) {
                    if (l.blendWeight.data[s * 4 + o] === 0) continue;
                    const i = l.blendIndices.data[f.index * 4 + o];
                    f.boneIndices[o] = this.getBoneRemap(i);
                  }
                  (n = this.vertices.length),
                    this.indices.push(n),
                    this.vertices.push(f),
                    (this.indexMap[s] = n);
                }
              }
              addPrimitive(f, s, l, n) {
                const o = [];
                let i = 0;
                const e = f.length;
                for (let t = 0; t < e; t++) {
                  const u = f[t].index;
                  for (let v = 0; v < 4; v++)
                    if (l.blendWeight.data[u * 4 + v] > 0) {
                      const _ = l.blendIndices.data[u * 4 + v];
                      let m = !0;
                      for (let g = 0; g < i; g++)
                        if (o[g] === _) {
                          m = !1;
                          break;
                        }
                      if (m) {
                        o[i] = _;
                        const g = this.getBoneRemap(_);
                        i += g === -1 ? 1 : 0;
                      }
                    }
                }
                if (this.boneIndices.length + i > n) return !1;
                for (let t = 0; t < i; t++) this.boneIndices.push(o[t]);
                for (let t = 0; t < e; t++) this.addVertex(f[t], s[t], l);
                return !0;
              }
              getBoneRemap(f) {
                for (let s = 0; s < this.boneIndices.length; s++)
                  if (this.boneIndices[s] === f) return s;
                return -1;
              }
            }
            function y(h) {
              const f = h.vertices,
                s = h.skins,
                l = h.meshes,
                n = h.meshInstances;
              for (let o = 0; o < l.length; o++)
                (l[o].vertices = f[l[o].vertices]),
                  l[o].skin !== void 0 && (l[o].skin = s[l[o].skin]);
              for (let o = 0; o < n.length; o++) n[o].mesh = l[n[o].mesh];
            }
            function c(h) {
              const f = h.vertices,
                s = h.skins,
                l = h.meshes,
                n = h.meshInstances;
              for (let o = 0; o < l.length; o++)
                (l[o].vertices = f.indexOf(l[o].vertices)),
                  l[o].skin !== void 0 && (l[o].skin = s.indexOf(l[o].skin));
              for (let o = 0; o < n.length; o++)
                n[o].mesh = l.indexOf(n[o].mesh);
            }
            function d(h, f, s) {
              let l, n, o, i;
              y(h);
              const e = h.vertices,
                t = h.skins;
              let r;
              const u = h.meshes,
                v = h.meshInstances,
                _ = function (g) {
                  const T = new A();
                  return (T.index = g), T;
                };
              for (l = t.length - 1; l >= 0; l--)
                if (t[l].boneNames.length > s) {
                  const m = t.splice(l, 1)[0],
                    g = [];
                  for (n = 0; n < u.length; n++)
                    u[n].skin === m && g.push(u[n]);
                  for (n = 0; n < g.length; n++)
                    (i = u.indexOf(g[n])), i !== -1 && u.splice(i, 1);
                  if (g.length === 0)
                    throw new Error(
                      "partitionSkin: There should be at least one mesh that references a skin"
                    );
                  const T = g[0].vertices;
                  for (n = 1; n < g.length; n++)
                    if (g[n].vertices !== T)
                      throw new Error(
                        "partitionSkin: All meshes that share a skin should also share the same vertex buffer"
                      );
                  let E;
                  const M = [],
                    R = [],
                    P = [];
                  let F = 0;
                  for (n = 0; n < g.length; n++) {
                    r = g[n];
                    const Z = r.indices;
                    for (let J = r.base; J < r.base + r.count; ) {
                      (i = Z[J++]),
                        (R[0] = _(i)),
                        (P[0] = i),
                        (i = Z[J++]),
                        (R[1] = _(i)),
                        (P[1] = i),
                        (i = Z[J++]),
                        (R[2] = _(i)),
                        (P[2] = i);
                      let ve = !1;
                      for (let _e = F; _e < M.length; _e++)
                        if (((E = M[_e]), E.addPrimitive(R, P, T, s))) {
                          ve = !0;
                          break;
                        }
                      ve ||
                        ((E = new x()),
                        (E.originalMesh = r),
                        E.addPrimitive(R, P, T, s),
                        M.push(E));
                    }
                    F = M.length;
                  }
                  const b = [],
                    D = [];
                  for (n = 0; n < M.length; n++)
                    if (((E = M[n]), E.vertices.length && E.indices.length)) {
                      const Z = b.length,
                        J = E.vertices.length,
                        ve = D.length,
                        _e = E.indices.length;
                      (E.partition = n),
                        (E.vertexStart = Z),
                        (E.vertexCount = J),
                        (E.indexStart = ve),
                        (E.indexCount = _e);
                      let L, ge;
                      for (L = 0, ge = Z; L < J; ) b[ge++] = E.vertices[L++];
                      for (L = 0, ge = ve; L < _e; )
                        D[ge++] = E.indices[L++] + Z;
                    }
                  const G = [];
                  for (n = 0; n < M.length; n++) {
                    E = M[n];
                    const Z = [],
                      J = [];
                    for (o = 0; o < E.boneIndices.length; o++)
                      Z.push(m.inverseBindMatrices[E.boneIndices[o]]),
                        J.push(m.boneNames[E.boneIndices[o]]);
                    const ve = { inverseBindMatrices: Z, boneNames: J };
                    G.push(ve), t.push(ve);
                  }
                  let X, ie, Q, te;
                  const ae = {};
                  for (ie in T)
                    ae[ie] = {
                      components: T[ie].components,
                      data: [],
                      type: T[ie].type,
                    };
                  for (ie in T)
                    if (ie === "blendIndices") {
                      const Z = ae[ie].data;
                      for (n = 0; n < b.length; n++) {
                        const J = b[n].boneIndices;
                        Z.push(J[0], J[1], J[2], J[3]);
                      }
                    } else
                      for (
                        X = T[ie], Q = X.data, te = X.components, n = 0;
                        n < b.length;
                        n++
                      )
                        for (i = b[n].index, o = 0; o < te; o++)
                          ae[ie].data.push(Q[i * te + o]);
                  for (e[e.indexOf(T)] = ae, n = 0; n < M.length; n++)
                    for (
                      E = M[n],
                        r = {
                          aabb: { min: [0, 0, 0], max: [0, 0, 0] },
                          vertices: ae,
                          skin: G[n],
                          indices: D.splice(0, E.indexCount),
                          type: "triangles",
                          base: 0,
                          count: E.indexCount,
                        },
                        u.push(r),
                        o = v.length - 1;
                      o >= 0;
                      o--
                    )
                      v[o].mesh === E.originalMesh &&
                        (v.push({ mesh: r, node: v[o].node }),
                        f &&
                          f.push({ material: f[o].material, path: f[o].path }));
                  for (n = 0; n < M.length; n++)
                    for (E = M[n], o = v.length - 1; o >= 0; o--)
                      v[o].mesh === E.originalMesh &&
                        (v.splice(o, 1), f && f.splice(o, 1));
                }
              c(h);
            }
          },
          8097: (xe, V, a) => {
            "use strict";
            a.d(V, { M: () => A });
            class A {
              constructor(y, c, d) {
                (this.device = y),
                  (this.inverseBindPose = c),
                  (this.boneNames = d);
              }
            }
          },
          8649: (xe, V, a) => {
            "use strict";
            a.d(V, { k: () => f });
            var A = a(8976),
              x = a(7994),
              y = a(9391),
              c = a(8531);
            const d = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
              h = [0, 1, 3, 2, 3, 1];
            class f extends A.J {
              constructor(l, n) {
                super(),
                  (this._device = l),
                  (this._pixelsPerUnit =
                    n && n.pixelsPerUnit !== void 0 ? n.pixelsPerUnit : 1),
                  (this._renderMode =
                    n && n.renderMode !== void 0 ? n.renderMode : y.hA),
                  (this._atlas = n && n.atlas !== void 0 ? n.atlas : null),
                  (this._frameKeys =
                    n && n.frameKeys !== void 0 ? n.frameKeys : null),
                  (this._meshes = []),
                  (this._updatingProperties = !1),
                  (this._meshesDirty = !1),
                  this._atlas && this._frameKeys && this._createMeshes();
              }
              set frameKeys(l) {
                (this._frameKeys = l),
                  this._atlas &&
                    this._frameKeys &&
                    (this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes()),
                  this.fire("set:frameKeys", l);
              }
              get frameKeys() {
                return this._frameKeys;
              }
              set atlas(l) {
                l !== this._atlas &&
                  (this._atlas &&
                    (this._atlas.off("set:frames", this._onSetFrames, this),
                    this._atlas.off("set:frame", this._onFrameChanged, this),
                    this._atlas.off(
                      "remove:frame",
                      this._onFrameRemoved,
                      this
                    )),
                  (this._atlas = l),
                  this._atlas &&
                    this._frameKeys &&
                    (this._atlas.on("set:frames", this._onSetFrames, this),
                    this._atlas.on("set:frame", this._onFrameChanged, this),
                    this._atlas.on("remove:frame", this._onFrameRemoved, this),
                    this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes()),
                  this.fire("set:atlas", l));
              }
              get atlas() {
                return this._atlas;
              }
              set pixelsPerUnit(l) {
                this._pixelsPerUnit !== l &&
                  ((this._pixelsPerUnit = l),
                  this.fire("set:pixelsPerUnit", l),
                  this._atlas &&
                    this._frameKeys &&
                    this.renderMode === y.hA &&
                    (this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes()));
              }
              get pixelsPerUnit() {
                return this._pixelsPerUnit;
              }
              set renderMode(l) {
                if (this._renderMode === l) return;
                const n = this._renderMode;
                (this._renderMode = l),
                  this.fire("set:renderMode", l),
                  (n === y.hA || l === y.hA) &&
                    this._atlas &&
                    this._frameKeys &&
                    (this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes());
              }
              get renderMode() {
                return this._renderMode;
              }
              get meshes() {
                return this._meshes;
              }
              _createMeshes() {
                const l = this._meshes.length;
                for (let i = 0; i < l; i++) {
                  const e = this._meshes[i];
                  e && e.destroy();
                }
                const n = this._frameKeys.length;
                this._meshes = new Array(n);
                const o =
                  this.renderMode === y.FC || this._renderMode === y.jZ
                    ? this._create9SliceMesh
                    : this._createSimpleMesh;
                for (let i = 0; i < n; i++) {
                  const e = this._atlas.frames[this._frameKeys[i]];
                  this._meshes[i] = e ? o.call(this, e) : null;
                }
                this.fire("set:meshes");
              }
              _createSimpleMesh(l) {
                const n = l.rect,
                  o = this._atlas.texture.width,
                  i = this._atlas.texture.height,
                  e = n.z / this._pixelsPerUnit,
                  t = n.w / this._pixelsPerUnit,
                  r = l.pivot.x,
                  u = l.pivot.y,
                  v = [
                    -r * e,
                    -u * t,
                    0,
                    (1 - r) * e,
                    -u * t,
                    0,
                    (1 - r) * e,
                    (1 - u) * t,
                    0,
                    -r * e,
                    (1 - u) * t,
                    0,
                  ],
                  _ = n.x / o,
                  m = 1 - n.y / i,
                  g = (n.x + n.z) / o,
                  T = 1 - (n.y + n.w) / i,
                  E = [_, m, g, m, g, T, _, T];
                return (0, c.qk)(this._device, v, {
                  uvs: E,
                  normals: d,
                  indices: h,
                });
              }
              _create9SliceMesh() {
                const l = x.Z.ONE,
                  n = 3,
                  o = 3,
                  i = [],
                  e = [],
                  t = [],
                  r = [];
                let u = 0;
                for (let _ = 0; _ <= n; _++) {
                  const m = _ === 0 || _ === n ? 0 : 1;
                  for (let g = 0; g <= o; g++) {
                    const T = -l.x + (2 * l.x * (_ <= 1 ? 0 : 3)) / n,
                      E = 0,
                      M = -(-l.y + (2 * l.y * (g <= 1 ? 0 : 3)) / o),
                      R = g === 0 || g === o ? 0 : 1;
                    i.push(-T, E, M),
                      e.push(0, 1, 0),
                      t.push(m, R),
                      _ < n &&
                        g < o &&
                        (r.push(u + o + 1, u + 1, u),
                        r.push(u + o + 1, u + o + 2, u + 1)),
                      u++;
                  }
                }
                const v = { normals: e, uvs: t, indices: r };
                return (0, c.qk)(this._device, i, v);
              }
              _onSetFrames(l) {
                this._updatingProperties
                  ? (this._meshesDirty = !0)
                  : this._createMeshes();
              }
              _onFrameChanged(l, n) {
                const o = this._frameKeys.indexOf(l);
                o < 0 ||
                  (n
                    ? this.renderMode === y.hA &&
                      (this._meshes[o] = this._createSimpleMesh(n))
                    : (this._meshes[o] = null),
                  this.fire("set:meshes"));
              }
              _onFrameRemoved(l) {
                const n = this._frameKeys.indexOf(l);
                n < 0 || ((this._meshes[n] = null), this.fire("set:meshes"));
              }
              startUpdate() {
                (this._updatingProperties = !0), (this._meshesDirty = !1);
              }
              endUpdate() {
                (this._updatingProperties = !1),
                  this._meshesDirty &&
                    this._atlas &&
                    this._frameKeys &&
                    this._createMeshes(),
                  (this._meshesDirty = !1);
              }
              destroy() {
                for (const l of this._meshes) l && l.destroy();
                this._meshes.length = 0;
              }
            }
          },
          2199: (xe, V, a) => {
            "use strict";
            a.d(V, { L: () => x });
            var A = a(8976);
            class x extends A.J {
              constructor() {
                super(), (this._texture = null), (this._frames = null);
              }
              set texture(c) {
                (this._texture = c), this.fire("set:texture", c);
              }
              get texture() {
                return this._texture;
              }
              set frames(c) {
                (this._frames = c), this.fire("set:frames", c);
              }
              get frames() {
                return this._frames;
              }
              setFrame(c, d) {
                let h = this._frames[c];
                h
                  ? (h.rect.copy(d.rect),
                    h.pivot.copy(d.pivot),
                    h.border.copy(d.border))
                  : ((h = {
                      rect: d.rect.clone(),
                      pivot: d.pivot.clone(),
                      border: d.border.clone(),
                    }),
                    (this._frames[c] = h)),
                  this.fire("set:frame", c.toString(), h);
              }
              removeFrame(c) {
                const d = this._frames[c];
                d &&
                  (delete this._frames[c],
                  this.fire("remove:frame", c.toString(), d));
              }
              destroy() {
                this._texture && this._texture.destroy();
              }
            }
          },
        },
        As = {};
      function Ut(xe) {
        var V = As[xe];
        if (V !== void 0) return V.exports;
        var a = (As[xe] = { exports: {} });
        return Qs[xe](a, a.exports, Ut), a.exports;
      }
      (Ut.n = (xe) => {
        var V = xe && xe.__esModule ? () => xe.default : () => xe;
        return Ut.d(V, { a: V }), V;
      }),
        (Ut.d = (xe, V) => {
          for (var a in V)
            Ut.o(V, a) &&
              !Ut.o(xe, a) &&
              Object.defineProperty(xe, a, { enumerable: !0, get: V[a] });
        }),
        (Ut.g = (function () {
          if (typeof globalThis == "object") return globalThis;
          try {
            return this || new Function("return this")();
          } catch (xe) {
            if (typeof window == "object") return window;
          }
        })()),
        (Ut.o = (xe, V) => Object.prototype.hasOwnProperty.call(xe, V)),
        (Ut.r = (xe) => {
          typeof Symbol != "undefined" &&
            Symbol.toStringTag &&
            Object.defineProperty(xe, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(xe, "__esModule", { value: !0 });
        });
      var ta = {};
      (() => {
        "use strict";
        Ut.d(ta, { Z: () => Ht });
        const xe = JSON.parse(
          '{"Wh":{"sfx_click":"assets/audios/sfx_click.mp3","sfx_coin":"assets/audios/sfx_coin.mp3","sfx_collide_checkPoint":"assets/audios/sfx_collide_checkPoint.mp3","sfx_collide_floor":"assets/audios/sfx_collide_floor.mp3","sfx_collide_pipe":"assets/audios/sfx_collide_pipe.mp3","sfx_hitBox":"assets/audios/sfx_hitBox.mp3","sfx_key":"assets/audios/sfx_key.mp3","sfx_respawn":"assets/audios/sfx_respawn.mp3","sfx_rolling_bridge":"assets/audios/sfx_rolling_bridge.mp3","sfx_rolling_floor":"assets/audios/sfx_rolling_floor.mp3","sfx_rolling_pipe":"assets/audios/sfx_rolling_pipe.mp3","sfx_wingame":"assets/audios/sfx_wingame.mp3"},"lG":{"font_rounded":"assets/fonts/font_rounded.json"},"Jn":{"model_ball_001":"assets/models/model_ball_001.glb","model_ball_003":"assets/models/model_ball_003.glb","model_ball_002":"assets/models/model_ball_002.glb","model_ball_004":"assets/models/model_ball_004.glb","model_ball_005":"assets/models/model_ball_005.glb","model_ball_006":"assets/models/model_ball_006.glb","model_box_obstacle_001":"assets/models/model_box_obstacle_001.glb","model_ball_obstacle_001":"assets/models/model_ball_obstacle_001.glb","model_barrier_001":"assets/models/model_barrier_001.glb","model_coin_001":"assets/models/model_coin_001.glb","model_key_001":"assets/models/model_key_001.glb","model_obstacle_hammerhead_001":"assets/models/model_obstacle_hammerhead_001.glb","model_finish_001":"assets/models/model_finish_001.glb","model_panel_direction_001":"assets/models/model_panel_direction_001.glb","model_pipe_001":"assets/models/model_pipe_001.glb","model_pipe_003":"assets/models/model_pipe_003.glb","model_pipe_002":"assets/models/model_pipe_002.glb","model_pipe_004":"assets/models/model_pipe_004.glb","model_pipe_007":"assets/models/model_pipe_007.glb","model_pipe_004_B":"assets/models/model_pipe_004_B.glb","model_pipe_010":"assets/models/model_pipe_010.glb","model_pipe_011_A":"assets/models/model_pipe_011_A.glb","model_pipe_012":"assets/models/model_pipe_012.glb","model_pipe_011_B":"assets/models/model_pipe_011_B.glb","model_pipe_013":"assets/models/model_pipe_013.glb","model_pipe_016":"assets/models/model_pipe_016.glb","model_pipe_014":"assets/models/model_pipe_014.glb","model_pipe_018":"assets/models/model_pipe_018.glb","model_pipe_019":"assets/models/model_pipe_019.glb","model_pipe_020":"assets/models/model_pipe_020.glb","model_pipe_021_A":"assets/models/model_pipe_021_A.glb","model_pipe_022_B":"assets/models/model_pipe_022_B.glb","model_pipe_023_A":"assets/models/model_pipe_023_A.glb","model_pipe_021_B":"assets/models/model_pipe_021_B.glb","model_pipe_024":"assets/models/model_pipe_024.glb","model_pipe_025":"assets/models/model_pipe_025.glb","model_pipe_030":"assets/models/model_pipe_030.glb","model_pipe_028":"assets/models/model_pipe_028.glb","model_pipe_039":"assets/models/model_pipe_039.glb","model_pipe_029":"assets/models/model_pipe_029.glb","model_pipe_039_B":"assets/models/model_pipe_039_B.glb","model_pipe_033":"assets/models/model_pipe_033.glb","model_pipe_042":"assets/models/model_pipe_042.glb","model_pipe_042_B":"assets/models/model_pipe_042_B.glb","model_pipe_043":"assets/models/model_pipe_043.glb","model_pipe_044":"assets/models/model_pipe_044.glb","model_pipe_044_B":"assets/models/model_pipe_044_B.glb","model_pipe_27":"assets/models/model_pipe_27.glb","model_pipe_head":"assets/models/model_pipe_head.glb","model_pipe_corner_002":"assets/models/model_pipe_corner_002.glb","model_platform_001":"assets/models/model_platform_001.glb","model_platform_jump_001":"assets/models/model_platform_jump_001.glb","model_ring_001":"assets/models/model_ring_001.glb","model_platform_life_bonus_001":"assets/models/model_platform_life_bonus_001.glb","model_road_001":"assets/models/model_road_001.glb","model_road_002":"assets/models/model_road_002.glb","model_road_004":"assets/models/model_road_004.glb","model_road_007":"assets/models/model_road_007.glb","model_road_006":"assets/models/model_road_006.glb","model_road_003":"assets/models/model_road_003.glb","model_road_008_A":"assets/models/model_road_008_A.glb","model_road_008_B":"assets/models/model_road_008_B.glb","model_road_010":"assets/models/model_road_010.glb","model_road_011":"assets/models/model_road_011.glb","model_road_012":"assets/models/model_road_012.glb","model_road_013":"assets/models/model_road_013.glb","model_road_015":"assets/models/model_road_015.glb","model_road_014":"assets/models/model_road_014.glb","model_road_016":"assets/models/model_road_016.glb","model_road_021":"assets/models/model_road_021.glb","model_road_018":"assets/models/model_road_018.glb","model_road_019":"assets/models/model_road_019.glb","model_road_022":"assets/models/model_road_022.glb","model_road_023":"assets/models/model_road_023.glb","model_road_024":"assets/models/model_road_024.glb","model_road_025":"assets/models/model_road_025.glb","model_road_026":"assets/models/model_road_026.glb","model_road_028":"assets/models/model_road_028.glb","model_road_029":"assets/models/model_road_029.glb","model_road_031":"assets/models/model_road_031.glb","model_road_030":"assets/models/model_road_030.glb","model_road_034":"assets/models/model_road_034.glb","model_road_032":"assets/models/model_road_032.glb","model_road_035":"assets/models/model_road_035.glb","model_road_036":"assets/models/model_road_036.glb","model_road_037":"assets/models/model_road_037.glb","model_road_039":"assets/models/model_road_039.glb","model_road_038":"assets/models/model_road_038.glb","model_road_041":"assets/models/model_road_041.glb","model_road_040":"assets/models/model_road_040.glb","model_road_042":"assets/models/model_road_042.glb","model_road_043":"assets/models/model_road_043.glb","model_road_043_B":"assets/models/model_road_043_B.glb","model_road_044":"assets/models/model_road_044.glb","model_road_boost_002":"assets/models/model_road_boost_002.glb","model_road_bridge_001":"assets/models/model_road_bridge_001.glb","model_static_obstacle_bump":"assets/models/model_static_obstacle_bump.glb"},"l2":{"4side":"assets/textures/4side.jpg","bottom":"assets/textures/bottom.jpg","spr_button_claim_x2":"assets/textures/spr_button_claim_x2.png","spr_button_continue":"assets/textures/spr_button_continue.png","spr_button_reward_ads":"assets/textures/spr_button_reward_ads.png","spr_button_reward_ads_ball":"assets/textures/spr_button_reward_ads_ball.png","spr_circle_white":"assets/textures/spr_circle_white.png","spr_coin":"assets/textures/spr_coin.png","spr_frame_continue":"assets/textures/spr_frame_continue.png","spr_frame_green":"assets/textures/spr_frame_green.png","spr_frame_level_complete":"assets/textures/spr_frame_level_complete.png","spr_frame_lv_false":"assets/textures/spr_frame_lv_false.png","spr_frame_reward":"assets/textures/spr_frame_reward.png","spr_frame_reward_inner":"assets/textures/spr_frame_reward_inner.png","spr_frame_setting":"assets/textures/spr_frame_setting.png","spr_frame_tutorial":"assets/textures/spr_frame_tutorial.png","spr_game_icon":"assets/textures/spr_game_icon.png","spr_glow_effect":"assets/textures/spr_glow_effect.png","spr_hand":"assets/textures/spr_hand.png","spr_icon_arrow":"assets/textures/spr_icon_arrow.png","spr_icon_back":"assets/textures/spr_icon_back.png","spr_icon_ball":"assets/textures/spr_icon_ball.png","spr_icon_ball_001":"assets/textures/spr_icon_ball_001.png","spr_icon_ball_002":"assets/textures/spr_icon_ball_002.png","spr_icon_ball_003":"assets/textures/spr_icon_ball_003.png","spr_icon_ball_004":"assets/textures/spr_icon_ball_004.png","spr_icon_ball_005":"assets/textures/spr_icon_ball_005.png","spr_icon_ball_006":"assets/textures/spr_icon_ball_006.png","spr_icon_ball_dead":"assets/textures/spr_icon_ball_dead.png","spr_icon_ball_select":"assets/textures/spr_icon_ball_select.png","spr_icon_check":"assets/textures/spr_icon_check.png","spr_icon_chest_close":"assets/textures/spr_icon_chest_close.png","spr_icon_chest_open":"assets/textures/spr_icon_chest_open.png","spr_icon_coin_reward":"assets/textures/spr_icon_coin_reward.png","spr_icon_key":"assets/textures/spr_icon_key.png","spr_icon_key_gray":"assets/textures/spr_icon_key_gray.png","spr_icon_level_current":"assets/textures/spr_icon_level_current.png","spr_icon_level_end_in_group":"assets/textures/spr_icon_level_end_in_group.png","spr_icon_level_locked":"assets/textures/spr_icon_level_locked.png","spr_icon_level_passed":"assets/textures/spr_icon_level_passed.png","spr_icon_pause":"assets/textures/spr_icon_pause.png","spr_icon_setting":"assets/textures/spr_icon_setting.png","spr_label_top":"assets/textures/spr_label_top.png","spr_slide_progress_bar":"assets/textures/spr_slide_progress_bar.png","spr_slide_progress_bar_fill":"assets/textures/spr_slide_progress_bar_fill.png","spr_slide_progress_bar_mask":"assets/textures/spr_slide_progress_bar_mask.png","spr_switch_active":"assets/textures/spr_switch_active.png","spr_switch_inactive":"assets/textures/spr_switch_inactive.png","spr_text_tutorial":"assets/textures/spr_text_tutorial.png","spr_tutorial_text":"assets/textures/spr_tutorial_text.png","tex_ball_001":"assets/textures/tex_ball_001.png","tex_ball_001_emissive":"assets/textures/tex_ball_001_emissive.png","tex_ball_002":"assets/textures/tex_ball_002.png","tex_ball_003":"assets/textures/tex_ball_003.jpg","tex_ball_004":"assets/textures/tex_ball_004.jpg","tex_ball_005":"assets/textures/tex_ball_005.jpg","tex_ball_006":"assets/textures/tex_ball_006.jpg","tex_ball_obstacle_001":"assets/textures/tex_ball_obstacle_001.jpg","tex_box_obstacle_001":"assets/textures/tex_box_obstacle_001.jpg","tex_confetti":"assets/textures/tex_confetti.jpg","tex_finish_001":"assets/textures/tex_finish_001.jpg","tex_finish_001_emissive":"assets/textures/tex_finish_001_emissive.jpg","tex_fx_circle":"assets/textures/tex_fx_circle.png","tex_items":"assets/textures/tex_items.jpg","tex_outerRay":"assets/textures/tex_outerRay.png","tex_panel_direction_001":"assets/textures/tex_panel_direction_001.png","tex_particle":"assets/textures/tex_particle.jpg","tex_platform_jump_001":"assets/textures/tex_platform_jump_001.jpg","tex_road_001":"assets/textures/tex_road_001.png","tex_road_001_emissive":"assets/textures/tex_road_001_emissive.png","tex_road_001_roughness":"assets/textures/tex_road_001_roughness.png","tex_road_002":"assets/textures/tex_road_002.png","tex_road_002_emissve":"assets/textures/tex_road_002_emissve.png","tex_road_bridge_001":"assets/textures/tex_road_bridge_001.jpg","top":"assets/textures/top.jpg"},"MN":{"adsConfig":"assets/jsons/adsConfig.json","ballSkin":"assets/jsons/ballSkin.json","externalLibraries":"assets/jsons/externalLibraries.json","levelData":"assets/jsons/levelData.json","map1":"assets/jsons/map1.json","map10":"assets/jsons/map10.json","map11":"assets/jsons/map11.json","map12":"assets/jsons/map12.json","map13":"assets/jsons/map13.json","map14":"assets/jsons/map14.json","map15":"assets/jsons/map15.json","map16":"assets/jsons/map16.json","map17":"assets/jsons/map17.json","map18":"assets/jsons/map18.json","map19":"assets/jsons/map19.json","map2":"assets/jsons/map2.json","map20":"assets/jsons/map20.json","map3":"assets/jsons/map3.json","map4":"assets/jsons/map4.json","map5":"assets/jsons/map5.json","map6":"assets/jsons/map6.json","map7":"assets/jsons/map7.json","map8":"assets/jsons/map8.json","map9":"assets/jsons/map9.json","mapTest":"assets/jsons/mapTest.json"},"Jh":{"cm_skybox":"assets/cubemaps/cm_skybox.json"},"DT":{"mat_ball.json":"assets/materials/mat_ball.json","mat_ball_003.json":"assets/materials/mat_ball_003.json","mat_ball_004.json":"assets/materials/mat_ball_004.json","mat_ball_005.json":"assets/materials/mat_ball_005.json","mat_ball_obstacle_001.json":"assets/materials/mat_ball_obstacle_001.json","mat_ball_006.json":"assets/materials/mat_ball_006.json","mat_box_obstacle_001.json":"assets/materials/mat_box_obstacle_001.json","mat_ball_002.json":"assets/materials/mat_ball_002.json","mat_gate_001.json":"assets/materials/mat_gate_001.json","mat_items_001.json":"assets/materials/mat_items_001.json","mat_gate_001_teleport.json":"assets/materials/mat_gate_001_teleport.json","mat_platform_jump_001.json":"assets/materials/mat_platform_jump_001.json","mat_panel_direction_001.json":"assets/materials/mat_panel_direction_001.json","mat_road_001.json":"assets/materials/mat_road_001.json","tex_road_bridge_001.json":"assets/materials/tex_road_bridge_001.json","mat_road_002.json":"assets/materials/mat_road_002.json","mat_road_003.json":"assets/materials/mat_road_003.json"}}'
        );
        var V = Ut(4196);
        const a = Object.freeze({
          GAME_WIDTH: 1920,
          GAME_HEIGHT: 1080,
          DEBUG_ON: !0,
          PLATFORM_ANDROID: "android",
          PLATFORM_IOS: "ios",
          SCENE_PLAY: "Play",
          SCENE_LOSE: "Lose",
          SCENE_ENDCARD: "EndCard",
          SCREEN_PLAY: "Play",
          SCREEN_WIN: "WIN",
          SCREEN_LOSE: "Lose",
          SCREEN_CHEST: "Chest",
          SCREEN_MAIN: "Main",
          SCREEN_SKIN_SELECTION: "BallSelection",
          SCREEN_SETTING: "Setting",
          SCREEN_PAUSE: "Pause",
          MINIUM_SPEED: 0.1,
          MAX_SPEED: 40,
          MAX_JUMPING_SPEED: 19,
          BALL_SCALE: 0.8,
          BALL_DIRECTION_ROTATE_SPEED: 5,
          BALL_ROTATION_SPEED: 150,
          BALL_Y_SMOOTH_SPEED: 10,
          CAMERA_FOLLOW_SPEED: 3,
          DEAD_HEIGHT: -40,
          TOTAL_LIFE: 5,
          MAX_FORCE: 20,
          CAN_CONTROL_IN_AIR: !0,
          MAX_VELOCITY_Y: 4,
          JUMP_FORCE_MULTIPLIER: 10,
          ROLLING_PIPE_FORCE: 2,
          JUMP_TIME: 1,
          BOOSTER_SPEED_MULTIPLIER: 2,
          TOTAL_KEY_TO_COLLECT: 3,
          ITEM_COIN_AMOUNT: 5,
          FIXED_TIME_STEP: 1 / 120,
          GRAVITY_X: 0,
          GRAVITY_Y: -9.8,
          GRAVITY_Z: 0,
          DEBUG_ORBIT_CAMERA: !0,
          DEBUG_PHYSICS: !1,
          DEBUG_PHYSICS_MODE: 1,
          STORAGE_CLEAR_ON_START: !1,
          STORAGE_KEY_COIN: "coin",
          STORAGE_KEY_KEY: "Key",
          STORAGE_KEY_LIFE: "life",
          STORAGE_KEY_SKIN: "skin",
          STORAGE_KEY_UNLOCKED_SKIN: "unlocked_skin",
          STORAGE_KEY_LEVEL: "level",
          STORAGE_KEY_SETTING: "setting",
          INIT_SKIN: "ball_001",
          PERCENTAGE_TO_OPEN_SKIN_CHEST: 0.1,
        });
        class A {
          static log(p, S, ...U) {
            this._logConsole("log", p, S, ...U);
          }
          static warn(p, S, ...U) {
            this._logConsole("warn", p, S, ...U);
          }
          static error(p, S, ...U) {
            this._logConsole("error", p, S, ...U);
          }
          static debug(p, S, ...U) {
            this._logConsole("debug", p, S, ...U);
          }
          static _logConsole(p, S, U, ...ee) {
            this.enabled && console[p] && console[p](`[${S}] ${U}`, ...ee);
          }
          static get enabled() {
            return a.DEBUG_ON;
          }
        }
        var x = Object.defineProperty,
          y = (C, p, S) =>
            p in C
              ? x(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          c = (C, p, S) => y(C, typeof p != "symbol" ? p + "" : p, S);
        const d = class Ki {
          static loadSetting() {
            let p = localStorage.getItem(a.STORAGE_KEY_SETTING);
            p ? (Ki._settings = JSON.parse(p)) : Ki.saveSetting(),
              f.muteAllMusic(!Ki._settings.music),
              f.muteAllSound(!Ki._settings.sound);
          }
          static saveSetting() {
            localStorage.setItem(
              a.STORAGE_KEY_SETTING,
              JSON.stringify(Ki._settings)
            );
          }
          static get(p) {
            return Ki._settings[p];
          }
          static set(p, S) {
            switch (((Ki._settings[p] = S), Ki.saveSetting(), p)) {
              case "music":
                f.muteAllMusic(!S);
                break;
              case "sound":
                f.muteAllSound(!S);
                break;
              case "vibration":
                break;
            }
          }
        };
        c(d, "_settings", { music: !0, sound: !0, vibration: !0 });
        let h = d;
        class f {
          static load(p, S) {
            (this._onLoaded = S), (this.audios = {}), (this.songs = {});
            var U = 0;
            for (var ee in p)
              this.audios[ee] = new V.Howl({
                src: p[ee],
                onloaderror: (Se, Re) =>
                  A.log("SoundManager", "Load error", Se, Re),
                onplayerror: (Se, Re) =>
                  A.log("SoundManager", "Play error", Se, Re),
                onload: () => {
                  U++,
                    U === Object.keys(p).length &&
                      ((this.loaded = !0), S && S());
                },
              });
          }
          static play(p, S = 1, U = !1) {
            if (V.Howler.ctx.state === "running") {
              var ee = this.audios[p],
                Se = ee.play();
              return (
                ee.volume(S),
                ee.loop(U),
                h.get("sound") === !1 && this.muteSound(p, !0),
                Se
              );
            }
          }
          static playMusic(p, S = 1, U = !0) {
            if (V.Howler.ctx.state !== "running") return;
            let ee = this.play(p, S, U);
            (this.songs[p] = ee),
              h.get("music") === !1 && this.muteMusic(p, !0);
          }
          static isPlaying(p) {
            return this.audios[p].playing();
          }
          static stop(p) {
            this.audios[p].stop();
          }
          static muteAll(p) {
            V.Howler.mute(p);
          }
          static muteAllSound(p) {
            for (var S in this.audios) this.muteSound(S, p);
          }
          static muteSound(p, S) {
            var U;
            (U = this.audios[p]) == null || U.mute(S);
          }
          static muteAllMusic(p) {
            for (var S in this.songs) this.muteMusic(S, p);
          }
          static muteMusic(p, S) {
            var U;
            (U = this.songs[p]) == null || U.mute(S);
          }
          static resumeAudioContext() {
            V.Howler.ctx.state !== "running" && V.Howler.ctx.resume();
          }
        }
        var s = Ut(3953),
          l = Ut(1208);
        class n {
          static init(p) {
            (this.loaded = !1),
              (this.app = p),
              (this.assets = p.assets),
              (this._loadedTextures = 0),
              (this._loadedModels = 0),
              (this._loadedFonts = 0),
              (this._loadedAudio = 0),
              (this._loadedJsons = 0),
              (this._loadedCubeMaps = 0),
              (this._loadedMaterials = 0);
          }
          static load(p) {
            this.onLoad = p;
            for (let S in xe.l2)
              this.loadFromURL(
                xe.l2[S],
                S,
                "texture",
                this._onTextureLoaded.bind(this)
              );
            for (let S in xe.DT)
              this.loadFromURL(
                xe.DT[S],
                S,
                "material",
                this._onMaterialLoaded.bind(this)
              );
            for (let S in xe.Jn)
              this.loadFromURL(
                xe.Jn[S],
                S,
                "model",
                this._onModelLoaded.bind(this)
              );
            for (let S in xe.MN)
              this.loadFromURL(
                xe.MN[S],
                S,
                "json",
                this._onJsonLoaded.bind(this)
              );
            for (let S in xe.lG) {
              let U = new s.V(S, "font", { url: xe.lG[S] });
              U.once("load", this._onFontLoaded.bind(this)),
                this.assets.add(U),
                this.assets.load(U);
            }
            this._loadCubeMap(), f.load(xe.Wh, this._checkLoad.bind(this));
          }
          static _loadCubeMap() {
            for (let p in xe.Jh)
              this.assets._loader.getHandler("json").load(xe.Jh[p], (S, U) => {
                let ee = U.textures.filter(
                    (Be, qe, Et) => Et.indexOf(Be) === qe
                  ),
                  Se = 0;
                var Re = () => {
                  if ((Se++, Se === ee.length)) {
                    var Be = new l.g(this.app.graphicsDevice, { cubemap: !0 });
                    (Be.name = p),
                      (Be.anisotropy = U.anisotropy),
                      (Be.minFilter = U.minFilter),
                      (Be.magFilter = U.magFilter),
                      Be.setSource(
                        U.textures.map((qe) => n.find(qe).resource.getSource())
                      ),
                      this.registerAsset(Be, p, "cubemap"),
                      this._loadedCubeMaps++,
                      this._checkLoad();
                  }
                };
                for (let Be of ee) this.loadFromURL(Be, Be, "texture", Re);
              });
          }
          static loadFromURL(p, S, U, ee) {
            this.assets.loadFromUrl(p, U, (Se, Re) => {
              (Re.name = S), ee();
            });
          }
          static _onMaterialLoaded() {
            this._loadedMaterials++, this._checkLoad();
          }
          static _onTextureLoaded() {
            this._loadedTextures++, this._checkLoad();
          }
          static _onModelLoaded() {
            this._loadedModels++, this._checkLoad();
          }
          static _onFontLoaded() {
            this._loadedFonts++, this._checkLoad();
          }
          static _onJsonLoaded() {
            this._loadedJsons++, this._checkLoad();
          }
          static _checkLoad() {
            this._loadedTextures >= Object.keys(xe.l2).length &&
              this._loadedModels >= Object.keys(xe.Jn).length &&
              this._loadedFonts >= Object.keys(xe.lG).length &&
              this._loadedJsons >= Object.keys(xe.MN).length &&
              this._loadedCubeMaps >= Object.keys(xe.Jh).length &&
              this._loadedMaterials >= Object.keys(xe.DT).length &&
              f.loaded &&
              ((this.loaded = !0), this.onLoad && this.onLoad());
          }
          static registerAsset(p, S, U) {
            let ee = new s.V(S, U, null);
            (ee.resource = p), (ee.loaded = !0), this.assets.add(ee);
          }
          static find(p) {
            return typeof p == "string" ? this.assets.find(p) : p;
          }
          static findAll(p) {
            return typeof p == "string" ? this.assets.findAll(p) : p;
          }
        }
        var o = Ut(371);
        (o.w.prototype.enable = function () {
          this.enabled = !0;
        }),
          (o.w.prototype.disable = function () {
            this.enabled = !1;
          });
        var i = Ut(7481);
        (i.e.prototype.min2 = function (C, p) {
          return (
            (this.x = Math.min(C.x, p.x)),
            (this.y = Math.min(C.y, p.y)),
            (this.z = Math.min(C.z, p.z)),
            this
          );
        }),
          (i.e.prototype.max2 = function (C, p) {
            return (
              (this.x = Math.max(C.x, p.x)),
              (this.y = Math.max(C.y, p.y)),
              (this.z = Math.max(C.z, p.z)),
              this
            );
          });
        var e = Ut(8484),
          t = Ut(9663),
          r = Ut(3637);
        const u = new e.$(),
          v = new t.R();
        r.F.prototype.rayCast = function (C) {
          u.copy(this.node.getWorldTransform()),
            u.invert(),
            v.set(C.origin, C.direction),
            v.transform(u),
            v.direction.normalize();
          const p = this._mesh.rayCast(v),
            S = p && p.dist,
            U = p && p.normal;
          return S
            ? (v.direction.mulScalar(S),
              v.origin.add(v.direction),
              this.node.getWorldTransform().transformPoint(v.origin, v.origin),
              { point: v.origin, normal: U })
            : null;
        };
        var _ = Ut(7915);
        Object.defineProperty(_.I.prototype, "halfArea", {
          get: function () {
            const { x: C, y: p, z: S } = this.halfExtents;
            return 4 * (C * (p + S) + p * S);
          },
        }),
          (t.R.prototype.transform = function (C) {
            C.transformPoint(this.origin, this.origin),
              C.transformVector(this.direction, this.direction);
          });
        var m = Ut(3035);
        const g = Object.getOwnPropertyDescriptor(m.t.prototype, "enabled");
        Object.defineProperty(m.t.prototype, "enabled", {
          get: function () {
            return g.get.call(this);
          },
          set: function (C) {
            var p, S;
            g.set.call(this, C),
              C
                ? (p = this.onEnable) == null || p.call(this)
                : (S = this.onDisable) == null || S.call(this);
          },
        }),
          Object.defineProperty(m.t.prototype, "_selfEnabled", {
            get: function () {
              return g.get.call(this);
            },
            set: function (C) {
              g.set.call(this, C);
            },
          });
        var T = Ut(0),
          E = Ut(1870),
          M = Object.defineProperty,
          R = Object.defineProperties,
          P = Object.getOwnPropertyDescriptors,
          F = Object.getOwnPropertySymbols,
          b = Object.prototype.hasOwnProperty,
          D = Object.prototype.propertyIsEnumerable,
          G = (C, p, S) =>
            p in C
              ? M(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          X = (C, p) => {
            for (var S in p || (p = {})) b.call(p, S) && G(C, S, p[S]);
            if (F) for (var S of F(p)) D.call(p, S) && G(C, S, p[S]);
            return C;
          },
          ie = (C, p) => R(C, P(p));
        function Q(C, p = !0, S = !0) {
          const U = {};
          return (
            (U[`${C}Map`] = "texture"),
            (U[`${C}MapTiling`] = "vec2"),
            (U[`${C}MapOffset`] = "vec2"),
            (U[`${C}MapRotation`] = "number"),
            (U[`${C}MapUv`] = "number"),
            p &&
              ((U[`${C}MapChannel`] = "string"),
              S &&
                ((U[`${C}VertexColor`] = "boolean"),
                (U[`${C}VertexColorChannel`] = "string"))),
            U
          );
        }
        const te = ie(
            X(
              X(
                ie(
                  X(
                    ie(
                      X(
                        ie(
                          X(
                            ie(
                              X(
                                ie(
                                  X(
                                    ie(
                                      X(
                                        ie(
                                          X(
                                            ie(
                                              X(
                                                ie(
                                                  X(
                                                    ie(
                                                      X(
                                                        ie(
                                                          X(
                                                            ie(
                                                              X(
                                                                ie(
                                                                  X(
                                                                    ie(
                                                                      X(
                                                                        ie(
                                                                          X(
                                                                            ie(
                                                                              X(
                                                                                ie(
                                                                                  X(
                                                                                    ie(
                                                                                      X(
                                                                                        X(
                                                                                          ie(
                                                                                            X(
                                                                                              X(
                                                                                                {
                                                                                                  name: "string",
                                                                                                  chunks:
                                                                                                    "chunks",
                                                                                                  mappingFormat:
                                                                                                    "string",
                                                                                                  _engine:
                                                                                                    "boolean",
                                                                                                  ambient:
                                                                                                    "rgb",
                                                                                                  ambientTint:
                                                                                                    "boolean",
                                                                                                },
                                                                                                Q(
                                                                                                  "ao"
                                                                                                )
                                                                                              ),
                                                                                              Q(
                                                                                                "aoDetail",
                                                                                                !0,
                                                                                                !1
                                                                                              )
                                                                                            ),
                                                                                            {
                                                                                              aoDetailMode:
                                                                                                "string",
                                                                                              diffuse:
                                                                                                "rgb",
                                                                                              diffuseTint:
                                                                                                "boolean",
                                                                                            }
                                                                                          ),
                                                                                          Q(
                                                                                            "diffuse"
                                                                                          )
                                                                                        ),
                                                                                        Q(
                                                                                          "diffuseDetail",
                                                                                          !0,
                                                                                          !1
                                                                                        )
                                                                                      ),
                                                                                      {
                                                                                        diffuseDetailMode:
                                                                                          "string",
                                                                                        specular:
                                                                                          "rgb",
                                                                                        specularTint:
                                                                                          "boolean",
                                                                                      }
                                                                                    ),
                                                                                    Q(
                                                                                      "specular"
                                                                                    )
                                                                                  ),
                                                                                  {
                                                                                    occludeSpecular:
                                                                                      "enum:occludeSpecular",
                                                                                    specularityFactor:
                                                                                      "number",
                                                                                    specularityFactorTint:
                                                                                      "boolean",
                                                                                  }
                                                                                ),
                                                                                Q(
                                                                                  "specularityFactor"
                                                                                )
                                                                              ),
                                                                              {
                                                                                useMetalness:
                                                                                  "boolean",
                                                                                metalness:
                                                                                  "number",
                                                                                enableGGXSpecular:
                                                                                  "boolean",
                                                                                anisotropy:
                                                                                  "number",
                                                                                metalnessTint:
                                                                                  "boolean",
                                                                              }
                                                                            ),
                                                                            Q(
                                                                              "metalness"
                                                                            )
                                                                          ),
                                                                          {
                                                                            useMetalnessSpecularColor:
                                                                              "boolean",
                                                                            conserveEnergy:
                                                                              "boolean",
                                                                            shininess:
                                                                              "number",
                                                                            gloss:
                                                                              "number",
                                                                            glossInvert:
                                                                              "boolean",
                                                                          }
                                                                        ),
                                                                        Q(
                                                                          "gloss"
                                                                        )
                                                                      ),
                                                                      {
                                                                        clearCoat:
                                                                          "number",
                                                                      }
                                                                    ),
                                                                    Q(
                                                                      "clearCoat"
                                                                    )
                                                                  ),
                                                                  {
                                                                    clearCoatGloss:
                                                                      "number",
                                                                    clearCoatGlossInvert:
                                                                      "boolean",
                                                                  }
                                                                ),
                                                                Q(
                                                                  "clearCoatGloss"
                                                                )
                                                              ),
                                                              {
                                                                clearCoatBumpiness:
                                                                  "number",
                                                              }
                                                            ),
                                                            Q(
                                                              "clearCoatNormal",
                                                              !1
                                                            )
                                                          ),
                                                          {
                                                            useSheen: "boolean",
                                                            sheen: "rgb",
                                                            sheenTint:
                                                              "boolean",
                                                          }
                                                        ),
                                                        Q("sheen")
                                                      ),
                                                      {
                                                        sheenGloss: "number",
                                                        sheenGlossTint:
                                                          "boolean",
                                                        sheenGlossInvert:
                                                          "boolean",
                                                      }
                                                    ),
                                                    Q("sheenGloss")
                                                  ),
                                                  {
                                                    fresnelModel: "number",
                                                    emissive: "rgb",
                                                    emissiveTint: "boolean",
                                                  }
                                                ),
                                                Q("emissive")
                                              ),
                                              { emissiveIntensity: "number" }
                                            ),
                                            Q("normal", !1)
                                          ),
                                          { bumpiness: "number" }
                                        ),
                                        Q("normalDetail", !1)
                                      ),
                                      { normalDetailMapBumpiness: "number" }
                                    ),
                                    Q("height", !0, !1)
                                  ),
                                  {
                                    heightMapFactor: "number",
                                    alphaToCoverage: "boolean",
                                    alphaTest: "number",
                                    alphaFade: "number",
                                    opacity: "number",
                                  }
                                ),
                                Q("opacity")
                              ),
                              {
                                opacityFadesSpecular: "boolean",
                                reflectivity: "number",
                                refraction: "number",
                                refractionTint: "boolean",
                              }
                            ),
                            Q("refraction")
                          ),
                          {
                            refractionIndex: "number",
                            thickness: "number",
                            thicknessTint: "boolean",
                          }
                        ),
                        Q("thickness")
                      ),
                      {
                        attenuation: "rgb",
                        attenuationDistance: "number",
                        useDynamicRefraction: "boolean",
                        sphereMap: "texture",
                        cubeMap: "cubemap",
                        cubeMapProjection: "number",
                        cubeMapProjectionBox: "boundingbox",
                        useIridescence: "boolean",
                        iridescence: "number",
                        iridescenceTint: "boolean",
                      }
                    ),
                    Q("iridescence")
                  ),
                  {
                    iridescenceThicknessTint: "boolean",
                    iridescenceThicknessMin: "number",
                    iridescenceThicknessMax: "number",
                    iridescenceRefractionIndex: "number",
                  }
                ),
                Q("iridescenceThickness")
              ),
              Q("light")
            ),
            {
              depthTest: "boolean",
              depthFunc: "enum:depthFunc",
              depthWrite: "boolean",
              depthBias: "number",
              slopeDepthBias: "number",
              cull: "enum:cull",
              blendType: "enum:blendType",
              shadingModel: "enum:shadingModel",
              useFog: "boolean",
              useLighting: "boolean",
              useSkybox: "boolean",
              useGammaTonemap: "boolean",
              envAtlas: "texture",
              twoSidedLighting: "boolean",
            }
          ),
          ae = [];
        for (const C in te) te[C] === "texture" && ae.push(C);
        const Z = [];
        for (const C in te) te[C] === "cubemap" && Z.push(C);
        const J = {
          aoMapVertexColor: "boolean",
          diffuseMapTint: "boolean",
          diffuseMapVertexColor: "boolean",
          emissiveMapTint: "boolean",
          emissiveMapVertexColor: "boolean",
          glossMapVertexColor: "boolean",
          metalnessMapVertexColor: "boolean",
          opacityMapVertexColor: "boolean",
          specularAntialias: "boolean",
          specularMapTint: "boolean",
          specularMapVertexColor: "boolean",
        };
        (T.k.prototype._loadModel = function (C, p) {
          const S = C.getFileUrl(),
            U = E.A.getExtension(S);
          if (U === ".json" || U === ".glb") {
            const ee = E.A.getDirectory(S),
              Se = E.A.getBasename(S),
              Re = E.A.join(ee, Se.replace(U, ".mapping.json"));
            this._loader.load(Re, "json", (Be, qe) => {
              Be
                ? ((C.data = { mapping: [] }), p(C))
                : this._loadMaterials(C, qe, (Et, Ct) => {
                    (C.data = qe),
                      C.once("load", () => {
                        for (
                          let St = 0;
                          St < C.resource.meshInstances.length;
                          St++
                        )
                          Ct[St] &&
                            (C.resource.meshInstances[St].material =
                              Ct[St].resource);
                      }),
                      p(C);
                  });
            });
          } else p(C);
        }),
          (T.k.prototype._loadMaterials = function (C, p, S) {
            const U = [];
            let ee = 0;
            const Se = (Re, Be) => {
              this._loadTextures(Be, (qe, Et) => {
                U.push(Be), U.length === ee && S(null, U);
              });
            };
            for (let Re = 0; Re < p.mapping.length; Re++) {
              const Be = p.mapping[Re].path;
              if (Be) {
                ee++;
                const qe = Be;
                this.loadFromUrl(qe, "material", Se);
              }
            }
            ee === 0 && S(null, U);
          }),
          (T.k.prototype._loadTextures = function (C, p) {
            const S = [];
            let U = 0;
            const ee = C.data;
            if (ee.mappingFormat !== "path") {
              p(null, S);
              return;
            }
            const Se = (Be, qe) => {
                Be && console.error(Be),
                  S.push(qe),
                  S.length === U && p(null, S);
              },
              Re = ae;
            for (let Be = 0; Be < Re.length; Be++) {
              const qe = ee[Re[Be]];
              if (qe && typeof qe == "string") {
                U++;
                const Et = qe;
                this.loadFromUrl(Et, "texture", (Ct, St) => {
                  Se(Ct, St), (C.resource[Re[Be]] = St.resource);
                });
              }
            }
            U === 0 && p(null, S);
          });
        var ve = Ut(7007),
          _e = Ut.n(ve);
        class L {
          static init(p) {
            (this.emitter = new (_e())()), (this.state = p);
          }
          static get state() {
            return this._state;
          }
          static set state(p) {
            this._state !== p &&
              ((this.prevState = this.state),
              (this._state = p),
              this.emitter &&
                this.emitter.emit("changed", this.state, this.prevState));
          }
          static isState(...p) {
            for (var S = 0; S < p.length; S++)
              if (p[S] === this.state) return !0;
            return !1;
          }
          static registerOnStateChangedCallback(p) {
            this.emitter.on("changed", p);
          }
          static removeOnStateChangedCallback(p) {
            this.emitter.off("changed", p);
          }
        }
        const ge = {
          MainMenu: "mainmenu",
          Playing: "playing",
          Paused: "paused",
          Lose: "lose",
          Win: "win",
          GameOver: "gameover",
          Tutorial: "tutorial",
          AutoPlay: "autoplay",
          AutoPlayOver: "autoplayover",
        };
        class k {
          static init(p) {
            (this.scenes = p), (this.addtiveScenes = []);
          }
          static loadScene(p) {
            let S = this.currentScene;
            (this.currentScene = p),
              this.addtiveScenes.forEach((U) => U.destroy()),
              Ht.app.root.addChild(this.currentScene),
              this.currentScene.create(),
              S && (Ht.app.root.removeChild(S), S.destroy());
          }
          static loadSceneAddtive(p) {
            this.addtiveScenes.push(p), Ht.app.root.addChild(p);
          }
          static update(p) {
            var S;
            (S = this.currentScene) == null || S.update(p),
              this.addtiveScenes.forEach((U) => U.update(p));
          }
          static resize() {
            var p;
            (p = this.currentScene) == null || p.resize(),
              this.addtiveScenes.forEach((S) => S.resize());
          }
          static pause() {
            var p;
            (p = this.currentScene) == null || p.pause(),
              this.addtiveScenes.forEach((S) => S.pause());
          }
          static resume() {
            var p;
            (p = this.currentScene) == null || p.resume(),
              this.addtiveScenes.forEach((S) => S.resume());
          }
          static getScene(p) {
            return this.scenes.find((S) => S.key === p);
          }
        }
        var j = Object.freeze({
            Linear: Object.freeze({
              None: function (C) {
                return C;
              },
              In: function (C) {
                return this.None(C);
              },
              Out: function (C) {
                return this.None(C);
              },
              InOut: function (C) {
                return this.None(C);
              },
            }),
            Quadratic: Object.freeze({
              In: function (C) {
                return C * C;
              },
              Out: function (C) {
                return C * (2 - C);
              },
              InOut: function (C) {
                return (C *= 2) < 1 ? 0.5 * C * C : -0.5 * (--C * (C - 2) - 1);
              },
            }),
            Cubic: Object.freeze({
              In: function (C) {
                return C * C * C;
              },
              Out: function (C) {
                return --C * C * C + 1;
              },
              InOut: function (C) {
                return (C *= 2) < 1
                  ? 0.5 * C * C * C
                  : 0.5 * ((C -= 2) * C * C + 2);
              },
            }),
            Quartic: Object.freeze({
              In: function (C) {
                return C * C * C * C;
              },
              Out: function (C) {
                return 1 - --C * C * C * C;
              },
              InOut: function (C) {
                return (C *= 2) < 1
                  ? 0.5 * C * C * C * C
                  : -0.5 * ((C -= 2) * C * C * C - 2);
              },
            }),
            Quintic: Object.freeze({
              In: function (C) {
                return C * C * C * C * C;
              },
              Out: function (C) {
                return --C * C * C * C * C + 1;
              },
              InOut: function (C) {
                return (C *= 2) < 1
                  ? 0.5 * C * C * C * C * C
                  : 0.5 * ((C -= 2) * C * C * C * C + 2);
              },
            }),
            Sinusoidal: Object.freeze({
              In: function (C) {
                return 1 - Math.sin(((1 - C) * Math.PI) / 2);
              },
              Out: function (C) {
                return Math.sin((C * Math.PI) / 2);
              },
              InOut: function (C) {
                return 0.5 * (1 - Math.sin(Math.PI * (0.5 - C)));
              },
            }),
            Exponential: Object.freeze({
              In: function (C) {
                return C === 0 ? 0 : Math.pow(1024, C - 1);
              },
              Out: function (C) {
                return C === 1 ? 1 : 1 - Math.pow(2, -10 * C);
              },
              InOut: function (C) {
                return C === 0
                  ? 0
                  : C === 1
                  ? 1
                  : (C *= 2) < 1
                  ? 0.5 * Math.pow(1024, C - 1)
                  : 0.5 * (-Math.pow(2, -10 * (C - 1)) + 2);
              },
            }),
            Circular: Object.freeze({
              In: function (C) {
                return 1 - Math.sqrt(1 - C * C);
              },
              Out: function (C) {
                return Math.sqrt(1 - --C * C);
              },
              InOut: function (C) {
                return (C *= 2) < 1
                  ? -0.5 * (Math.sqrt(1 - C * C) - 1)
                  : 0.5 * (Math.sqrt(1 - (C -= 2) * C) + 1);
              },
            }),
            Elastic: Object.freeze({
              In: function (C) {
                return C === 0
                  ? 0
                  : C === 1
                  ? 1
                  : -Math.pow(2, 10 * (C - 1)) *
                    Math.sin((C - 1.1) * 5 * Math.PI);
              },
              Out: function (C) {
                return C === 0
                  ? 0
                  : C === 1
                  ? 1
                  : Math.pow(2, -10 * C) * Math.sin((C - 0.1) * 5 * Math.PI) +
                    1;
              },
              InOut: function (C) {
                return C === 0
                  ? 0
                  : C === 1
                  ? 1
                  : ((C *= 2),
                    C < 1
                      ? -0.5 *
                        Math.pow(2, 10 * (C - 1)) *
                        Math.sin((C - 1.1) * 5 * Math.PI)
                      : 0.5 *
                          Math.pow(2, -10 * (C - 1)) *
                          Math.sin((C - 1.1) * 5 * Math.PI) +
                        1);
              },
            }),
            Back: Object.freeze({
              In: function (C) {
                var p = 1.70158;
                return C === 1 ? 1 : C * C * ((p + 1) * C - p);
              },
              Out: function (C) {
                var p = 1.70158;
                return C === 0 ? 0 : --C * C * ((p + 1) * C + p) + 1;
              },
              InOut: function (C) {
                var p = 2.5949095;
                return (C *= 2) < 1
                  ? 0.5 * (C * C * ((p + 1) * C - p))
                  : 0.5 * ((C -= 2) * C * ((p + 1) * C + p) + 2);
              },
            }),
            Bounce: Object.freeze({
              In: function (C) {
                return 1 - j.Bounce.Out(1 - C);
              },
              Out: function (C) {
                return C < 1 / 2.75
                  ? 7.5625 * C * C
                  : C < 2 / 2.75
                  ? 7.5625 * (C -= 1.5 / 2.75) * C + 0.75
                  : C < 2.5 / 2.75
                  ? 7.5625 * (C -= 2.25 / 2.75) * C + 0.9375
                  : 7.5625 * (C -= 2.625 / 2.75) * C + 0.984375;
              },
              InOut: function (C) {
                return C < 0.5
                  ? j.Bounce.In(C * 2) * 0.5
                  : j.Bounce.Out(C * 2 - 1) * 0.5 + 0.5;
              },
            }),
            generatePow: function (C) {
              return (
                C === void 0 && (C = 4),
                (C = C < Number.EPSILON ? Number.EPSILON : C),
                (C = C > 1e4 ? 1e4 : C),
                {
                  In: function (p) {
                    return Math.pow(p, C);
                  },
                  Out: function (p) {
                    return 1 - Math.pow(1 - p, C);
                  },
                  InOut: function (p) {
                    return p < 0.5
                      ? Math.pow(p * 2, C) / 2
                      : (1 - Math.pow(2 - p * 2, C)) / 2 + 0.5;
                  },
                }
              );
            },
          }),
          B = function () {
            return performance.now();
          },
          $ = (function () {
            function C() {
              (this._tweens = {}), (this._tweensAddedDuringUpdate = {});
            }
            return (
              (C.prototype.getAll = function () {
                var p = this;
                return Object.keys(this._tweens).map(function (S) {
                  return p._tweens[S];
                });
              }),
              (C.prototype.removeAll = function () {
                this._tweens = {};
              }),
              (C.prototype.add = function (p) {
                (this._tweens[p.getId()] = p),
                  (this._tweensAddedDuringUpdate[p.getId()] = p);
              }),
              (C.prototype.remove = function (p) {
                delete this._tweens[p.getId()],
                  delete this._tweensAddedDuringUpdate[p.getId()];
              }),
              (C.prototype.update = function (p, S) {
                p === void 0 && (p = B()), S === void 0 && (S = !1);
                var U = Object.keys(this._tweens);
                if (U.length === 0) return !1;
                for (; U.length > 0; ) {
                  this._tweensAddedDuringUpdate = {};
                  for (var ee = 0; ee < U.length; ee++) {
                    var Se = this._tweens[U[ee]],
                      Re = !S;
                    Se &&
                      Se.update(p, Re) === !1 &&
                      !S &&
                      delete this._tweens[U[ee]];
                  }
                  U = Object.keys(this._tweensAddedDuringUpdate);
                }
                return !0;
              }),
              C
            );
          })(),
          le = {
            Linear: function (C, p) {
              var S = C.length - 1,
                U = S * p,
                ee = Math.floor(U),
                Se = le.Utils.Linear;
              return p < 0
                ? Se(C[0], C[1], U)
                : p > 1
                ? Se(C[S], C[S - 1], S - U)
                : Se(C[ee], C[ee + 1 > S ? S : ee + 1], U - ee);
            },
            Bezier: function (C, p) {
              for (
                var S = 0,
                  U = C.length - 1,
                  ee = Math.pow,
                  Se = le.Utils.Bernstein,
                  Re = 0;
                Re <= U;
                Re++
              )
                S += ee(1 - p, U - Re) * ee(p, Re) * C[Re] * Se(U, Re);
              return S;
            },
            CatmullRom: function (C, p) {
              var S = C.length - 1,
                U = S * p,
                ee = Math.floor(U),
                Se = le.Utils.CatmullRom;
              return C[0] === C[S]
                ? (p < 0 && (ee = Math.floor((U = S * (1 + p)))),
                  Se(
                    C[(ee - 1 + S) % S],
                    C[ee],
                    C[(ee + 1) % S],
                    C[(ee + 2) % S],
                    U - ee
                  ))
                : p < 0
                ? C[0] - (Se(C[0], C[0], C[1], C[1], -U) - C[0])
                : p > 1
                ? C[S] - (Se(C[S], C[S], C[S - 1], C[S - 1], U - S) - C[S])
                : Se(
                    C[ee ? ee - 1 : 0],
                    C[ee],
                    C[S < ee + 1 ? S : ee + 1],
                    C[S < ee + 2 ? S : ee + 2],
                    U - ee
                  );
            },
            Utils: {
              Linear: function (C, p, S) {
                return (p - C) * S + C;
              },
              Bernstein: function (C, p) {
                var S = le.Utils.Factorial;
                return S(C) / S(p) / S(C - p);
              },
              Factorial: (function () {
                var C = [1];
                return function (p) {
                  var S = 1;
                  if (C[p]) return C[p];
                  for (var U = p; U > 1; U--) S *= U;
                  return (C[p] = S), S;
                };
              })(),
              CatmullRom: function (C, p, S, U, ee) {
                var Se = (S - C) * 0.5,
                  Re = (U - p) * 0.5,
                  Be = ee * ee,
                  qe = ee * Be;
                return (
                  (2 * p - 2 * S + Se + Re) * qe +
                  (-3 * p + 3 * S - 2 * Se - Re) * Be +
                  Se * ee +
                  p
                );
              },
            },
          },
          O = (function () {
            function C() {}
            return (
              (C.nextId = function () {
                return C._nextId++;
              }),
              (C._nextId = 0),
              C
            );
          })(),
          Y = new $(),
          ne = (function () {
            function C(p, S) {
              S === void 0 && (S = Y),
                (this._object = p),
                (this._group = S),
                (this._isPaused = !1),
                (this._pauseStart = 0),
                (this._valuesStart = {}),
                (this._valuesEnd = {}),
                (this._valuesStartRepeat = {}),
                (this._duration = 1e3),
                (this._isDynamic = !1),
                (this._initialRepeat = 0),
                (this._repeat = 0),
                (this._yoyo = !1),
                (this._isPlaying = !1),
                (this._reversed = !1),
                (this._delayTime = 0),
                (this._startTime = 0),
                (this._easingFunction = j.Linear.None),
                (this._interpolationFunction = le.Linear),
                (this._chainedTweens = []),
                (this._onStartCallbackFired = !1),
                (this._onEveryStartCallbackFired = !1),
                (this._id = O.nextId()),
                (this._isChainStopped = !1),
                (this._propertiesAreSetUp = !1),
                (this._goToEnd = !1);
            }
            return (
              (C.prototype.getId = function () {
                return this._id;
              }),
              (C.prototype.isPlaying = function () {
                return this._isPlaying;
              }),
              (C.prototype.isPaused = function () {
                return this._isPaused;
              }),
              (C.prototype.to = function (p, S) {
                if ((S === void 0 && (S = 1e3), this._isPlaying))
                  throw new Error(
                    "Can not call Tween.to() while Tween is already started or paused. Stop the Tween first."
                  );
                return (
                  (this._valuesEnd = p),
                  (this._propertiesAreSetUp = !1),
                  (this._duration = S),
                  this
                );
              }),
              (C.prototype.duration = function (p) {
                return p === void 0 && (p = 1e3), (this._duration = p), this;
              }),
              (C.prototype.dynamic = function (p) {
                return p === void 0 && (p = !1), (this._isDynamic = p), this;
              }),
              (C.prototype.start = function (p, S) {
                if (
                  (p === void 0 && (p = B()),
                  S === void 0 && (S = !1),
                  this._isPlaying)
                )
                  return this;
                if (
                  (this._group && this._group.add(this),
                  (this._repeat = this._initialRepeat),
                  this._reversed)
                ) {
                  this._reversed = !1;
                  for (var U in this._valuesStartRepeat)
                    this._swapEndStartRepeatValues(U),
                      (this._valuesStart[U] = this._valuesStartRepeat[U]);
                }
                if (
                  ((this._isPlaying = !0),
                  (this._isPaused = !1),
                  (this._onStartCallbackFired = !1),
                  (this._onEveryStartCallbackFired = !1),
                  (this._isChainStopped = !1),
                  (this._startTime = p),
                  (this._startTime += this._delayTime),
                  !this._propertiesAreSetUp || S)
                ) {
                  if (((this._propertiesAreSetUp = !0), !this._isDynamic)) {
                    var ee = {};
                    for (var Se in this._valuesEnd)
                      ee[Se] = this._valuesEnd[Se];
                    this._valuesEnd = ee;
                  }
                  this._setupProperties(
                    this._object,
                    this._valuesStart,
                    this._valuesEnd,
                    this._valuesStartRepeat,
                    S
                  );
                }
                return this;
              }),
              (C.prototype.startFromCurrentValues = function (p) {
                return this.start(p, !0);
              }),
              (C.prototype._setupProperties = function (p, S, U, ee, Se) {
                for (var Re in U) {
                  var Be = p[Re],
                    qe = Array.isArray(Be),
                    Et = qe ? "array" : typeof Be,
                    Ct = !qe && Array.isArray(U[Re]);
                  if (!(Et === "undefined" || Et === "function")) {
                    if (Ct) {
                      var St = U[Re];
                      if (St.length === 0) continue;
                      for (
                        var jt = [Be], ts = 0, ys = St.length;
                        ts < ys;
                        ts += 1
                      ) {
                        var Xs = this._handleRelativeValue(Be, St[ts]);
                        if (isNaN(Xs)) {
                          (Ct = !1),
                            console.warn(
                              "Found invalid interpolation list. Skipping."
                            );
                          break;
                        }
                        jt.push(Xs);
                      }
                      Ct && (U[Re] = jt);
                    }
                    if ((Et === "object" || qe) && Be && !Ct) {
                      S[Re] = qe ? [] : {};
                      var Is = Be;
                      for (var ui in Is) S[Re][ui] = Is[ui];
                      ee[Re] = qe ? [] : {};
                      var St = U[Re];
                      if (!this._isDynamic) {
                        var ji = {};
                        for (var ui in St) ji[ui] = St[ui];
                        U[Re] = St = ji;
                      }
                      this._setupProperties(Is, S[Re], St, ee[Re], Se);
                    } else
                      (typeof S[Re] == "undefined" || Se) && (S[Re] = Be),
                        qe || (S[Re] *= 1),
                        Ct
                          ? (ee[Re] = U[Re].slice().reverse())
                          : (ee[Re] = S[Re] || 0);
                  }
                }
              }),
              (C.prototype.stop = function () {
                return (
                  this._isChainStopped ||
                    ((this._isChainStopped = !0), this.stopChainedTweens()),
                  this._isPlaying
                    ? (this._group && this._group.remove(this),
                      (this._isPlaying = !1),
                      (this._isPaused = !1),
                      this._onStopCallback &&
                        this._onStopCallback(this._object),
                      this)
                    : this
                );
              }),
              (C.prototype.end = function () {
                return (this._goToEnd = !0), this.update(1 / 0), this;
              }),
              (C.prototype.pause = function (p) {
                return (
                  p === void 0 && (p = B()),
                  this._isPaused || !this._isPlaying
                    ? this
                    : ((this._isPaused = !0),
                      (this._pauseStart = p),
                      this._group && this._group.remove(this),
                      this)
                );
              }),
              (C.prototype.resume = function (p) {
                return (
                  p === void 0 && (p = B()),
                  !this._isPaused || !this._isPlaying
                    ? this
                    : ((this._isPaused = !1),
                      (this._startTime += p - this._pauseStart),
                      (this._pauseStart = 0),
                      this._group && this._group.add(this),
                      this)
                );
              }),
              (C.prototype.stopChainedTweens = function () {
                for (var p = 0, S = this._chainedTweens.length; p < S; p++)
                  this._chainedTweens[p].stop();
                return this;
              }),
              (C.prototype.group = function (p) {
                return p === void 0 && (p = Y), (this._group = p), this;
              }),
              (C.prototype.delay = function (p) {
                return p === void 0 && (p = 0), (this._delayTime = p), this;
              }),
              (C.prototype.repeat = function (p) {
                return (
                  p === void 0 && (p = 0),
                  (this._initialRepeat = p),
                  (this._repeat = p),
                  this
                );
              }),
              (C.prototype.repeatDelay = function (p) {
                return (this._repeatDelayTime = p), this;
              }),
              (C.prototype.yoyo = function (p) {
                return p === void 0 && (p = !1), (this._yoyo = p), this;
              }),
              (C.prototype.easing = function (p) {
                return (
                  p === void 0 && (p = j.Linear.None),
                  (this._easingFunction = p),
                  this
                );
              }),
              (C.prototype.interpolation = function (p) {
                return (
                  p === void 0 && (p = le.Linear),
                  (this._interpolationFunction = p),
                  this
                );
              }),
              (C.prototype.chain = function () {
                for (var p = [], S = 0; S < arguments.length; S++)
                  p[S] = arguments[S];
                return (this._chainedTweens = p), this;
              }),
              (C.prototype.onStart = function (p) {
                return (this._onStartCallback = p), this;
              }),
              (C.prototype.onEveryStart = function (p) {
                return (this._onEveryStartCallback = p), this;
              }),
              (C.prototype.onUpdate = function (p) {
                return (this._onUpdateCallback = p), this;
              }),
              (C.prototype.onRepeat = function (p) {
                return (this._onRepeatCallback = p), this;
              }),
              (C.prototype.onComplete = function (p) {
                return (this._onCompleteCallback = p), this;
              }),
              (C.prototype.onStop = function (p) {
                return (this._onStopCallback = p), this;
              }),
              (C.prototype.update = function (p, S) {
                if (
                  (p === void 0 && (p = B()),
                  S === void 0 && (S = !0),
                  this._isPaused)
                )
                  return !0;
                var U,
                  ee,
                  Se = this._startTime + this._duration;
                if (!this._goToEnd && !this._isPlaying) {
                  if (p > Se) return !1;
                  S && this.start(p, !0);
                }
                if (((this._goToEnd = !1), p < this._startTime)) return !0;
                this._onStartCallbackFired === !1 &&
                  (this._onStartCallback && this._onStartCallback(this._object),
                  (this._onStartCallbackFired = !0)),
                  this._onEveryStartCallbackFired === !1 &&
                    (this._onEveryStartCallback &&
                      this._onEveryStartCallback(this._object),
                    (this._onEveryStartCallbackFired = !0)),
                  (ee = (p - this._startTime) / this._duration),
                  (ee = this._duration === 0 || ee > 1 ? 1 : ee);
                var Re = this._easingFunction(ee);
                if (
                  (this._updateProperties(
                    this._object,
                    this._valuesStart,
                    this._valuesEnd,
                    Re
                  ),
                  this._onUpdateCallback &&
                    this._onUpdateCallback(this._object, ee),
                  ee === 1)
                )
                  if (this._repeat > 0) {
                    isFinite(this._repeat) && this._repeat--;
                    for (U in this._valuesStartRepeat)
                      !this._yoyo &&
                        typeof this._valuesEnd[U] == "string" &&
                        (this._valuesStartRepeat[U] =
                          this._valuesStartRepeat[U] +
                          parseFloat(this._valuesEnd[U])),
                        this._yoyo && this._swapEndStartRepeatValues(U),
                        (this._valuesStart[U] = this._valuesStartRepeat[U]);
                    return (
                      this._yoyo && (this._reversed = !this._reversed),
                      this._repeatDelayTime !== void 0
                        ? (this._startTime = p + this._repeatDelayTime)
                        : (this._startTime = p + this._delayTime),
                      this._onRepeatCallback &&
                        this._onRepeatCallback(this._object),
                      (this._onEveryStartCallbackFired = !1),
                      !0
                    );
                  } else {
                    this._onCompleteCallback &&
                      this._onCompleteCallback(this._object);
                    for (
                      var Be = 0, qe = this._chainedTweens.length;
                      Be < qe;
                      Be++
                    )
                      this._chainedTweens[Be].start(
                        this._startTime + this._duration,
                        !1
                      );
                    return (this._isPlaying = !1), !1;
                  }
                return !0;
              }),
              (C.prototype._updateProperties = function (p, S, U, ee) {
                for (var Se in U)
                  if (S[Se] !== void 0) {
                    var Re = S[Se] || 0,
                      Be = U[Se],
                      qe = Array.isArray(p[Se]),
                      Et = Array.isArray(Be),
                      Ct = !qe && Et;
                    Ct
                      ? (p[Se] = this._interpolationFunction(Be, ee))
                      : typeof Be == "object" && Be
                      ? this._updateProperties(p[Se], Re, Be, ee)
                      : ((Be = this._handleRelativeValue(Re, Be)),
                        typeof Be == "number" && (p[Se] = Re + (Be - Re) * ee));
                  }
              }),
              (C.prototype._handleRelativeValue = function (p, S) {
                return typeof S != "string"
                  ? S
                  : S.charAt(0) === "+" || S.charAt(0) === "-"
                  ? p + parseFloat(S)
                  : parseFloat(S);
              }),
              (C.prototype._swapEndStartRepeatValues = function (p) {
                var S = this._valuesStartRepeat[p],
                  U = this._valuesEnd[p];
                typeof U == "string"
                  ? (this._valuesStartRepeat[p] =
                      this._valuesStartRepeat[p] + parseFloat(U))
                  : (this._valuesStartRepeat[p] = this._valuesEnd[p]),
                  (this._valuesEnd[p] = S);
              }),
              C
            );
          })(),
          de = "21.1.1",
          re = O.nextId,
          I = Y,
          w = I.getAll.bind(I),
          N = I.removeAll.bind(I),
          W = I.add.bind(I),
          he = I.remove.bind(I),
          ue = I.update.bind(I),
          ye = {
            Easing: j,
            Group: $,
            Interpolation: le,
            now: B,
            Sequence: O,
            nextId: re,
            Tween: ne,
            VERSION: de,
            getAll: w,
            removeAll: N,
            add: W,
            remove: he,
            update: ue,
          };
        class Oe extends ye.Tween {
          constructor(p, S) {
            super(p, S);
          }
          start() {
            return super.start();
          }
        }
        var Ae = Ut(5227),
          ke = Ut(3021),
          Ue = Math.pow;
        class Ge {
          static linear(p, S, U) {
            return p + (S - p) * U;
          }
          static easeIn(p, S, U) {
            return p + (S - p) * Ue(U, 2);
          }
          static easeOut(p, S, U) {
            return p + (S - p) * (1 - Ue(1 - U, 2));
          }
          static easeInOut(p, S, U) {
            return p + (S - p) * (-Math.cos(U * Math.PI) / 2 + 0.5);
          }
          static copyObject(p, S = {}) {
            return (
              Object.keys(p).forEach((U) => {
                S[U] = p[U];
              }),
              S
            );
          }
          static sign(p) {
            return p < 0 ? -1 : 1;
          }
          static random(p, S) {
            return Math.random() * (S - p) + p;
          }
          static randomInt(p, S) {
            return Math.floor(Math.random() * (S - p + 1) + p);
          }
          static randomFromList(p) {
            if (p && p.length > 0) {
              let S = this.randomInt(0, p.length - 1);
              return p[S];
            } else return -1;
          }
          static randomVector(p, S, U = new i.e()) {
            return (
              (U.x = Ge.random(p.x, S.x)),
              (U.y = Ge.random(p.y, S.y)),
              (U.z = Ge.random(p.z, S.z)),
              U
            );
          }
          static distanceBetween(p, S) {
            return Math.abs(Math.abs(p) - Math.abs(S));
          }
          static getAlpha(p, S) {
            return S === 0
              ? 90
              : this.toDegree(Math.atan(Math.abs(p) / Math.abs(S)));
          }
          static toDegree(p) {
            return (p * 180) / Math.PI;
          }
          static toRadian(p) {
            return (p * Math.PI) / 180;
          }
          static getRandomIntExclude(p, S, U) {
            let ee = Math.floor(Math.random() * (S - p)) + p;
            return ee === U && (ee = S), ee;
          }
          static getSpriteFrame(p, S = 1) {
            let U = p.atlas.frames[p.frameKeys[0]].rect;
            return { x: U.x, y: U.y, width: U.z * S, height: U.w * S };
          }
          static getSpriteAtlasFrame(p) {
            return p.atlas.frames[p.frameKeys[0]];
          }
          static getSpriteWorldSize(p) {
            let S = this.getSpriteAtlasFrame(p);
            return {
              width: S.rect.z / p.pixelsPerUnit,
              height: S.rect.w / p.pixelsPerUnit,
            };
          }
          static createColor(p = 255, S = 255, U = 255, ee = 1) {
            return new Ae.Q(p / 255, S / 255, U / 255, ee);
          }
          static setSpriteDepthTest(p, S = !0) {
            let U = p._meshInstance.material.clone();
            (U.depthTest = S), U.update(), (p._meshInstance.material = U);
          }
          static setUpEffectModel(p) {
            (p.model.castShadows = !1),
              (p.model.castShadowsLightmap = !1),
              (p.model.receiveShadows = !1);
          }
          static setModelOpacity(p, S) {
            p.model.meshInstances.forEach((U) => {
              (U.material.opacity = S), U.material.update();
            });
          }
          static setModelMaterial(p, S, U = 0) {
            p.model.meshInstances[U].material = S;
          }
          static registerOnTouch(p, S, U) {
            (p.useInput = !0),
              p.on("mousedown", S, U),
              p.on("touchstart", S, U);
          }
          static registerOnceTouch(p, S, U) {
            (p.useInput = !0),
              p.once("mousedown", S, U),
              p.once("touchstart", S, U);
          }
          static updateCircleTransform(p, S, U, ee) {
            let Se = p.getLocalPosition(),
              Re = Se.x,
              Be = Ue(S, 2),
              qe = Ue(Re, 2),
              Et = Math.sqrt(Be + qe) + U;
            (Se.y = Et), p.setLocalPosition(Se);
            let Ct = p.getLocalEulerAngles(),
              St = Ge.sign(Se.x),
              jt = Math.abs(Et - U),
              ts = (Math.atan(jt / Math.abs(Re)) * 180) / Math.PI;
            (Ct.z = -St * (ts - 90) * ee), p.setLocalEulerAngles(Ct);
          }
          static getCashFormat(p) {
            return p >= 1e9
              ? `${(p / 1e9).toFixed(1).replace(/\.0$/, "")}B`
              : p >= 1e6
              ? `${(p / 1e6).toFixed(1).replace(/\.0$/, "")}M`
              : p >= 1e3
              ? `${(p / 1e3).toFixed(1).replace(/\.0$/, "")}K`
              : p;
          }
          static shuffleArray(p) {
            for (let S = p.length - 1; S > 0; S--) {
              const U = Math.floor(Math.random() * (S + 1));
              [p[S], p[U]] = [p[U], p[S]];
            }
          }
        }
        function ht(C, p) {
          return typeof C != "function" || typeof p != "function"
            ? !1
            : C.prototype instanceof p;
        }
        function me(C) {
          let p,
            S,
            U = [],
            ee = new _.I(),
            Se = C.findComponents("render");
          for (p = 0; p < Se.length; p++) {
            let Be = Se[p];
            for (S = 0; S < Be.meshInstances.length; S++)
              U.push(Be.meshInstances[S]);
          }
          let Re = C.findComponents("model");
          for (p = 0; p < Re.length; p++) {
            let Be = Re[p];
            for (S = 0; S < Be.meshInstances.length; S++)
              U.push(Be.meshInstances[S]);
          }
          for (p = 0; p < U.length; p++)
            p === 0 ? ee.copy(U[p].aabb) : ee.add(U[p].aabb);
          return ee;
        }
        var z = new i.e(),
          K = new i.e(),
          Te = new ke.k();
        function H(C, p, S = void 0) {
          C = C.normalize();
          var U = C.normalize();
          (z = z.cross(p, U).normalize()), (K = K.cross(U, z));
          var ee = z.x,
            Se = z.y,
            Re = z.z,
            Be = K.x,
            qe = K.y,
            Et = K.z,
            Ct = U.x,
            St = U.y,
            jt = U.z,
            ts = ee + qe + jt;
          if ((Te.copy(ke.k.IDENTITY), ts > 0)) {
            var ys = Math.sqrt(ts + 1);
            return (
              (Te.w = ys * 0.5),
              (ys = 0.5 / ys),
              (Te.x = (Et - St) * ys),
              (Te.y = (Ct - Re) * ys),
              (Te.z = (Se - Be) * ys),
              Te
            );
          }
          if (ee >= qe && ee >= jt) {
            var Xs = Math.sqrt(1 + ee - qe - jt),
              Is = 0.5 / Xs;
            return (
              (Te.x = 0.5 * Xs),
              (Te.y = (Se + Be) * Is),
              (Te.z = (Re + Ct) * Is),
              (Te.w = (Et - St) * Is),
              Te
            );
          }
          if (qe > jt) {
            var ui = Math.sqrt(1 + qe - ee - jt),
              ji = 0.5 / ui;
            return (
              (Te.x = (Be + Se) * ji),
              (Te.y = 0.5 * ui),
              (Te.z = (St + Et) * ji),
              (Te.w = (Ct - Re) * ji),
              Te
            );
          }
          var qr = Math.sqrt(1 + jt - ee - qe),
            Er = 0.5 / qr;
          return (
            (Te.x = (Ct + Re) * Er),
            (Te.y = (St + Et) * Er),
            (Te.z = 0.5 * qr),
            (Te.w = (Se - Be) * Er),
            S ? (S.copy(Te), S) : Te.clone()
          );
        }
        var q = Object.defineProperty,
          se = (C, p, S) =>
            p in C
              ? q(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          Ce = (C, p, S) => se(C, typeof p != "symbol" ? p + "" : p, S);
        const we = class Oi {
          static init(p) {
            p.on("start", () => {
              p.on("update", this.update, this);
            });
          }
          static update() {
            ye.update();
          }
          static createShakeTween(p, S = new i.e(), U = 0.1) {
            let ee = Ge.randomVector(S.clone().scale(-1), S);
            return Oi.createLocalTranslateTween(p, ee, {
              duration: U,
              repeat: 3,
              yoyo: !0,
            });
          }
          static createLocalTranslateTween(p, S = {}, U = Oi.defaultConfig) {
            let ee = p.getLocalPosition().clone(),
              Se = new i.e(),
              Re = Object.keys(S),
              Be = this.createTween(ee, S, U),
              qe = Be._onUpdateCallback;
            return (
              Be.onUpdate(() => {
                Se.copy(p.getLocalPosition()),
                  Re.forEach((Et) => (Se[Et] = ee[Et])),
                  p.setLocalPosition(Se),
                  qe();
              }),
              Be
            );
          }
          static createGlobalTranslateTween(p, S = {}, U = Oi.defaultConfig) {
            let ee = p.getPosition().clone(),
              Se = new i.e(),
              Re = Object.keys(S),
              Be = this.createTween(ee, S, U),
              qe = Be._onUpdateCallback;
            return (
              Be.onUpdate(() => {
                Se.copy(p.getPosition()),
                  Re.forEach((Et) => (Se[Et] = ee[Et])),
                  p.setPosition(Se),
                  qe();
              }),
              Be
            );
          }
          static createRotateTween(p, S = {}, U = Oi.defaultConfig) {
            let ee = p.getLocalEulerAngles().clone(),
              Se = new i.e(),
              Re = Object.keys(S),
              Be = this.createTween(ee, S, U),
              qe = Be._onUpdateCallback;
            return (
              Be.onUpdate(() => {
                Se.copy(p.getLocalEulerAngles()),
                  Re.forEach((Et) => (Se[Et] = ee[Et])),
                  p.setLocalEulerAngles(Se),
                  qe();
              }),
              Be
            );
          }
          static createScaleTween(p, S = {}, U = Oi.defaultConfig) {
            let ee = p.getLocalScale().clone(),
              Se = new i.e(),
              Re = Object.keys(S),
              Be = this.createTween(ee, S, U),
              qe = Be._onUpdateCallback;
            return (
              Be.onUpdate(() => {
                Se.copy(p.getLocalScale()),
                  Re.forEach((Et) => (Se[Et] = ee[Et])),
                  p.setLocalScale(Se),
                  qe();
              }),
              Be
            );
          }
          static createMaterialTween(p, S = {}, U = Oi.defaultConfig) {
            let ee = this.createTween(p, S, U),
              Se = ee._onUpdateCallback;
            return (
              ee.onUpdate(() => {
                p.update(), Se();
              }),
              ee
            );
          }
          static createCountTween(p = Oi.defaultConfig) {
            let S = { percent: 0 };
            return this.createTween(S, { percent: 1 }, p);
          }
          static createTween(p, S = {}, U = Oi.defaultConfig) {
            let ee = this._setupConfig(U),
              Se = new Oe(p);
            return Se.to(S, ee.duration * 1e3), this._setupTween(Se, ee), Se;
          }
          static _setupConfig(p) {
            return Ge.copyObject(p, Ge.copyObject(Oi.defaultConfig));
          }
          static _setupTween(p, S) {
            p.easing(S.easing),
              p.delay(S.delay * 1e3),
              p.repeatDelay(S.repeatDelay * 1e3),
              S.loop ? p.repeat(1 / 0) : p.repeat(S.repeat),
              p.yoyo(S.yoyo),
              p.onStart(S.onStart),
              p.onRepeat(S.onRepeat),
              p.onStop(S.onStop),
              p.onUpdate(S.onUpdate),
              p.onComplete(S.onComplete);
          }
          static get Easing() {
            return ye.Easing;
          }
        };
        Ce(
          we,
          "defaultConfig",
          Object.freeze({
            duration: 1,
            easing: ye.Easing.Linear.None,
            loop: !1,
            yoyo: !1,
            delay: 0,
            repeatDelay: 0,
            repeat: 0,
            onStart: () => {},
            onRepeat: () => {},
            onStop: () => {},
            onUpdate: () => {},
            onComplete: () => {},
          })
        );
        let Me = we;
        var Ie = Ut(5616),
          Le = Ut(7896),
          tt = Ut(9273),
          vt = Ut(8520),
          it = Ut(8789),
          At = Ut(8947),
          Rt = Ut(9222);
        class Ft {
          static init(p) {
            (this._current = 0),
              (this._dt = 0),
              (this.scale = 1),
              p.on("update", this.update, this);
          }
          static update(p) {
            (this._dt = p * this.scale), (this._current += this._dt);
          }
          static get dt() {
            return this._dt;
          }
          static get current() {
            return this._current;
          }
          static get currentMS() {
            return this._current * 1e3;
          }
        }
        var ut = Ut(9939);
        const Pt = Object.freeze({
          PointerDown: "inputmanager:pointerdown",
          PointerMove: "inputmanager:pointermove",
          PointerUp: "inputmanager:pointerup",
        });
        class bt {
          static init(p) {
            (this.app = p),
              (this.emitter = new o.w()),
              this._initMouse(),
              this._initTouch();
          }
          static _initMouse() {
            let p = this.app.mouse;
            p.on(ut.B$, (S) =>
              this._handleInputEvent(S, this._onPointerDown.bind(this))
            ),
              p.on(ut.SV, (S) =>
                this._handleInputEvent(S, this._onPointerMove.bind(this))
              ),
              p.on(ut.Ol, (S) =>
                this._handleInputEvent(S, this._onPointerUp.bind(this))
              ),
              this.app.graphicsDevice.canvas.addEventListener("mouseout", (S) =>
                this._onPointerUp(S)
              );
          }
          static _initTouch() {
            let p = this.app.touch;
            p.on(ut.n3, (S) =>
              this._handleInputEvent(S, this._onPointerDown.bind(this))
            ),
              p.on(ut.OJ, (S) =>
                this._handleInputEvent(S, this._onPointerMove.bind(this))
              ),
              p.on(ut.OM, (S) =>
                this._handleInputEvent(S, this._onPointerUp.bind(this))
              ),
              p.on(ut.pU, (S) =>
                this._handleInputEvent(S, this._onPointerUp.bind(this))
              );
          }
          static _handleInputEvent(p, S) {
            p.event.preventDefault(), S(p);
          }
          static _onPointerDown(p) {
            this.emitter.fire(Pt.PointerDown, p);
          }
          static _onPointerMove(p) {
            this.emitter.fire(Pt.PointerMove, p);
          }
          static _onPointerUp(p) {
            this.emitter.fire(Pt.PointerUp, p);
          }
        }
        for (
          var Zt =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            Xt = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256),
            yt = 0;
          yt < Zt.length;
          yt++
        )
          Xt[Zt.charCodeAt(yt)] = yt;
        var Pe = function (C) {
            var p = new Uint8Array(C),
              S,
              U = p.length,
              ee = "";
            for (S = 0; S < U; S += 3)
              (ee += Zt[p[S] >> 2]),
                (ee += Zt[((p[S] & 3) << 4) | (p[S + 1] >> 4)]),
                (ee += Zt[((p[S + 1] & 15) << 2) | (p[S + 2] >> 6)]),
                (ee += Zt[p[S + 2] & 63]);
            return (
              U % 3 === 2
                ? (ee = ee.substring(0, ee.length - 1) + "=")
                : U % 3 === 1 && (ee = ee.substring(0, ee.length - 2) + "=="),
              ee
            );
          },
          $e = function (C) {
            var p = C.length * 0.75,
              S = C.length,
              U,
              ee = 0,
              Se,
              Re,
              Be,
              qe;
            C[C.length - 1] === "=" && (p--, C[C.length - 2] === "=" && p--);
            var Et = new ArrayBuffer(p),
              Ct = new Uint8Array(Et);
            for (U = 0; U < S; U += 4)
              (Se = Xt[C.charCodeAt(U)]),
                (Re = Xt[C.charCodeAt(U + 1)]),
                (Be = Xt[C.charCodeAt(U + 2)]),
                (qe = Xt[C.charCodeAt(U + 3)]),
                (Ct[ee++] = (Se << 2) | (Re >> 4)),
                (Ct[ee++] = ((Re & 15) << 4) | (Be >> 2)),
                (Ct[ee++] = ((Be & 3) << 6) | (qe & 63));
            return Et;
          },
          Je = Ut(8287),
          rt = Ut(9206);
        class ct {
          static load(p, S = void 0) {
            let U = S || n.find("externalLibraries.json");
            if (!U.loaded) {
              U.on("load", () => {
                ct.load(p, U);
              });
              return;
            }
            let ee = U.resources,
              Se = ee.length,
              Re = 0,
              Be = performance.now();
            if (Se === 0) {
              p();
              return;
            }
            let qe = (Et, Ct) => {
              Re++,
                Et && console.error(Et),
                Re === Se &&
                  ((Be = performance.now() - Be),
                  console.log(`Loaded ${Se} libraries in ${Be}ms`),
                  p());
            };
            ee.forEach((Et) => {
              ct._loadScript(Et, qe);
            });
          }
          static _loadScript(p, S) {
            let U;
            if (p.type === "base64") {
              let Re = $e(p.source);
              if (p.compressed) {
                let Be = Je.hp.from(Re),
                  qe = (0, rt.i_)(Be);
                U = new TextDecoder("utf-8").decode(qe);
              } else U = new TextDecoder("utf-8").decode(Re);
            } else if (p.type === "url" || p.type === "script") U = p.source;
            else throw new Error(`Unknown type ${p.type}`);
            const ee = document.createElement("script");
            let Se = (Re) => {
              if (Re) {
                S(Re);
                return;
              }
              let Be = window[p.name];
              (window[p.name] = void 0),
                Be({
                  onAbort: () => {
                    S(`Aborted loading ${p.name}`);
                  },
                }).then((qe) => {
                  S(null, qe);
                });
            };
            p.type === "url"
              ? (ee.setAttribute("src", U),
                (ee.onload = Se),
                (ee.onerror = () => Se(`Error loading ${U}`, p.name)),
                document.body.appendChild(ee))
              : ((ee.innerHTML = U), document.body.appendChild(ee), Se(null));
          }
        }
        var Ve = Ut(9391),
          wt = Ut(1630),
          at = Ut(5596),
          ce = Ut(1369);
        const pe = JSON.parse(
          '[{"name":"ball_001","model":"model_ball_001","price":0,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_001","emissiveMap":"tex_ball_001_emissive"}]},{"name":"ball_002","model":"model_ball_002","price":200,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_002","emissiveMap":"tex_ball_002"}]},{"name":"ball_003","model":"model_ball_003","price":500,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_003","emissiveMap":"tex_ball_003"}]},{"name":"ball_004","model":"model_ball_004","price":1000,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_004","emissiveMap":"tex_ball_004"}]},{"name":"ball_006","model":"model_ball_006","price":2000,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_006","emissiveMap":"tex_ball_006"}]},{"name":"ball_005","model":"model_ball_005","price":4000,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_005","emissiveMap":"tex_ball_005"}]}]'
        );
        class De {
          static config() {
            this._configRoad(), this._configBallSkins();
          }
          static _configRoad() {
            var p = n.find("mat_road_001.json").resource;
            p.cubeMap = n.find("cm_skybox").resource;
            var S = 10;
            p.diffuseMap && (p.diffuseMap.anisotropy = S),
              p.emissiveMap && (p.emissiveMap.anisotropy = S),
              p.glossMap && (p.glossMap.anisotropy = S);
          }
          static _configBallSkins() {
            pe.forEach((p) => {
              let S = n.find(p.model),
                U = new o.w(p.name);
              U.addComponent("model", { type: "asset", asset: S }),
                n.registerAsset(U, p.name, "entity");
            });
          }
          static setTextureFiltering(p, S = wt.uhC, U = wt.x3I) {
            (p.minFilter = S),
              (p.magFilter = S),
              (p.addressU = U),
              (p.addressV = U);
          }
          static setSpriteSlice(p, S = new at.Z(), U = 1) {
            let ee = n.find(p);
            (ee.resource.renderMode = Ve.FC),
              this.setSpriteBorder(ee, S.x, S.y, S.z, S.w),
              this.setSpritePixelsPerUnit(p, U);
          }
          static setSpriteBorder(p, S = 0, U = 0, ee = 0, Se = 0) {
            let Re = n.find(p).resource;
            Re.atlas.frames[Re.frameKeys[0]].border.set(S, U, ee, Se);
          }
          static setSpritePixelsPerUnit(p, S = 100) {
            let U = n.find(p).resource;
            U.pixelsPerUnit = S;
          }
          static setModelTexture(p, S, U = 0) {
            let ee = this.getMaterial(p, U),
              Se = n.find(S);
            ee.diffuseMap = Se.resource;
          }
          static setModelDiffuse(p, S, U = 0) {
            let ee = this.getMaterial(p, U);
            ee.diffuse.copy(S), (ee.diffuseTint = !0);
          }
          static setModelMaterial(p, S, U = 0) {
            let ee = n.find(p).resource;
            ee.meshInstances[U].material = S;
          }
          static setModelMaterialInRange(p, S, U, ee) {
            for (var Se = U; Se <= ee; Se++) this.setModelMaterial(p, S, Se);
          }
          static setModelMaterialWithIndexes(p, S, U = []) {
            U.forEach((ee) => {
              this.setModelMaterial(p, S, ee);
            });
          }
          static createColorMaterial(p = 255, S = 255, U = 255, ee = 1) {
            let Se = new ce.F();
            return (
              typeof p == "object"
                ? (Se.diffuse = p)
                : (Se.diffuse = Ge.createColor(p, S, U, ee)),
              Se
            );
          }
          static getMaterial(p, S = 0) {
            let U = n.find(p),
              ee = U.resource.meshInstances[S].material;
            return (
              ee.id === 1 &&
                ((ee = new ce.F()),
                (U.resource.meshInstances[S].material = ee)),
              ee
            );
          }
        }
        class fe {
          static config() {
            (this.scene = Ht.app.scene),
              De.config(),
              this._configScene(),
              this._configSkybox();
          }
          static _configSkybox() {
            let p = n.find("cm_skybox").resource;
            this.scene.skybox = p;
          }
          static _configScene() {
            (this.scene.ambientLight = Ge.createColor(160, 160, 160)),
              (this.scene.gammaCorrection = Ve.Jd);
          }
        }
        var Ze = Ut(2417),
          Ne = Ut(7994);
        class Ye extends o.w {
          constructor(p) {
            super(),
              (this.key = p),
              this.addComponent("screen", {
                screenSpace: !0,
                scaleMode: Ze.G,
                resolution: new Ne.Z(a.GAME_WIDTH, a.GAME_HEIGHT),
                referenceResolution: new Ne.Z(a.GAME_WIDTH, a.GAME_HEIGHT),
              }),
              (this.enabled = !1);
          }
          create() {
            this.created = !0;
          }
          pause() {}
          resume() {}
          destroyChildren() {
            for (; this.children.length > 0; ) this.children[0].destroy();
          }
          update() {}
          resize() {}
          getScreenSpacePosition(p, S = new i.e()) {
            return (
              (S.x = p.x * Ht.app.graphicsDevice.maxPixelRatio),
              (S.y =
                Ht.app.graphicsDevice.height -
                p.y * Ht.app.graphicsDevice.maxPixelRatio),
              (S.z = 0),
              S.scale(1 / this.screen.scale),
              S
            );
          }
        }
        class Ke extends o.w {
          constructor() {
            super("ui_manager"), (this.screens = []);
          }
          update(p) {
            this.screens.forEach((S) => S.enabled && S.update(p));
          }
          pause() {
            this.screens.forEach((p) => p.enabled && p.pause());
          }
          resume() {
            this.screens.forEach((p) => p.enabled && p.resume());
          }
          addScreens(...p) {
            p.forEach((S) => {
              this.addChild(S), this.screens.push(S), S.create();
            });
          }
          removeScreen(...p) {
            p.forEach((S) => {
              let U = this.getScreen(S);
              U && this.screens.splice(U, 1);
            });
          }
          setScreenActive(p, S = !0) {
            let U = this.getScreen(p);
            U
              ? (U.enabled = S)
              : a.DEBUG_ON && console.warn(`Scene ${p} not found!`);
          }
          disableAllScreens() {
            this.screens.forEach((p) => (p.enabled = !1));
          }
          getScreen(p) {
            return this.screens.find((S) => S.key === p);
          }
          resize() {
            this.screens.forEach((p) => p.resize());
          }
          getActiveScreens() {
            return this.screens.filter((p) => p.enabled);
          }
          getLastActiveScreen() {
            return this.getActiveScreens().pop();
          }
        }
        class nt extends o.w {
          constructor(p) {
            super(p),
              (this.key = p),
              (this.ui = new Ke()),
              this.addChild(this.ui);
          }
          create() {
            A.log(`${this.key}Scene`, "Create");
          }
          update() {
            this.ui.update();
          }
          resize() {
            this.ui.resize();
          }
          pause() {
            this.ui.pause();
          }
          resume() {
            this.ui.resume();
          }
          destroy() {
            super.destroy();
          }
        }
        var ot = Ut(9189);
        class ze {
          static createCamera(p, S) {
            let U = new o.w(p);
            return U.addComponent("camera", S), U;
          }
          static createColorBackground(p = new Ae.Q(), S = 1) {
            let U = new o.w("spr_bg");
            return (
              U.addComponent("element", {
                type: "image",
                anchor: new at.Z(0, 0, 1, 1),
                color: p,
                opacity: S,
              }),
              U
            );
          }
          static createModel(p, ...S) {
            let U = n.find(p),
              ee = new o.w(U.name);
            return (
              ee.addComponent("model", { asset: U }),
              S.forEach((Se, Re) => {
                var Be = n.find(Se).resource;
                ee.model.meshInstances[Re].material = Be;
              }),
              ee
            );
          }
          static createBox(p) {
            let S = new o.w();
            if ((S.addComponent("model", { type: "box" }), p)) {
              let U = n.find(p).resource;
              S.model.meshInstances[0].material = U;
            }
            return S;
          }
          static createSphere(p) {
            let S = new o.w();
            if ((S.addComponent("model", { type: "sphere" }), p)) {
              let U = n.find(p).resource;
              S.model.meshInstances[0].material = U;
            }
            return S;
          }
          static createCone(p) {
            let S = new o.w();
            return (
              S.addComponent("model", { type: "cone" }),
              p && (S.model.meshInstances[0].material = p),
              S
            );
          }
          static createPlane(p) {
            let S = new o.w();
            if ((S.addComponent("model", { type: "plane" }), p)) {
              let U = n.find(p);
              S.model.meshInstances[0].material = U.resource;
            }
            return S;
          }
          static createSprite(p) {
            let S = n.find(p),
              U = new o.w(S.name);
            return U.addComponent("sprite", { spriteAsset: S }), U;
          }
          static createImageElement(p, S = {}) {
            let U = n.find(p),
              ee = S.x || 0,
              Se = S.y || 0,
              Re = S.z || 0,
              Be = S.scale || 1,
              qe = S.opacity || 1,
              Et = S.anchor || new at.Z(0.5, 0.5, 0.5, 0.5),
              Ct = S.pivot || new Ne.Z(0.5, 0.5),
              St = S.width || U.resource.width * Be,
              jt = S.height || U.resource.height * Be,
              ts = S.useInput || !1,
              ys = new o.w("element");
            return (
              ys.addComponent("element", {
                type: ot.b5,
                textureAsset: U,
                anchor: Et,
                pivot: Ct,
                opacity: qe,
                width: St,
                height: jt,
                useInput: ts,
              }),
              ys.setLocalPosition(ee, Se, Re),
              ys
            );
          }
          static createEmptyImageElement(p = {}) {
            let S = p.x || 0,
              U = p.y || 0,
              ee = p.z || 0,
              Se = p.opacity || 1,
              Re = p.anchor || new at.Z(0.5, 0.5, 0.5, 0.5),
              Be = p.pivot || new Ne.Z(0.5, 0.5),
              qe = p.width || 100,
              Et = p.height || 100,
              Ct = p.useInput || !1,
              St = new o.w("element"),
              jt = p.color || new Ae.Q(1, 1, 1);
            return (
              St.addComponent("element", {
                type: ot.b5,
                anchor: Re,
                pivot: Be,
                opacity: Se,
                color: jt,
                width: qe,
                height: Et,
                useInput: Ct,
              }),
              St.setLocalPosition(S, U, ee),
              St
            );
          }
          static createButtonElement(p, S = {}) {
            S.useInput === void 0 && (S.useInput = !0);
            let U = this.createImageElement(p, S),
              ee = S.hoverTint || new Ae.Q(0.9, 0.9, 0.9),
              Se = S.pressedTint || new Ae.Q(0.5, 0.5, 0.5);
            return (
              U.addComponent("button", {
                active: !0,
                hoverTint: ee,
                pressedTint: Se,
                imageEntity: U,
              }),
              U
            );
          }
          static createGroupElement(p = {}) {
            let S = p.x || 0,
              U = p.y || 0,
              ee = p.z || 0,
              Se = p.anchor || new at.Z(0.5, 0.5, 0.5, 0.5),
              Re = p.pivot || new Ne.Z(0.5, 0.5),
              Be = new o.w("element");
            return (
              Be.addComponent("element", {
                type: ot.Dk,
                anchor: Se,
                pivot: Re,
                width: p.width,
                height: p.height,
              }),
              Be.setLocalPosition(S, U, ee),
              Be
            );
          }
          static createTextElement(p, S) {
            var U = n.find(p);
            let ee = S.text || "",
              Se = S.fontSize || 16,
              Re = S.anchor || new at.Z(0.5, 0.5, 0.5, 0.5),
              Be = S.pivot || new Ne.Z(0.5, 0.5),
              qe = S.alignment || new Ne.Z(0.5, 0.5),
              Et = S.color || new Ae.Q(0, 0, 0),
              Ct = S.x || 0,
              St = S.y || 0,
              jt = S.opacity || 1,
              ts = new o.w("txt_tutorial");
            return (
              ts.addComponent("element", {
                type: ot.l$,
                fontAsset: U,
                text: ee,
                anchor: Re,
                pivot: Be,
                fontSize: Se,
                color: Et,
                opacity: jt,
                margin: new at.Z(0, 0, 0, 0),
              }),
              ts.setLocalPosition(Ct, St, 0),
              ts
            );
          }
        }
        var et = Ut(8976),
          _t = Object.defineProperty,
          Qe = (C, p, S) =>
            p in C
              ? _t(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          lt = (C, p, S) => Qe(C, typeof p != "symbol" ? p + "" : p, S);
        const xt = Object.freeze({ ValueChanged: "GameStorage:ValueChanged" }),
          Tt = class extends et.J {
            constructor() {
              super(), a.STORAGE_CLEAR_ON_START && this.clear();
            }
            clear() {
              localStorage.clear();
            }
            setValue(p, S) {
              localStorage.setItem(p, S), this.fire(xt.ValueChanged, p);
            }
            addInt(p, S) {
              var U = this.getInt(p);
              return this.setValue(p, U + S), U + S;
            }
            addFloat(p, S) {
              var U = this.getFloat(p);
              this.setValue(p, U + S);
            }
            getInt(p, S = 0) {
              var U = parseInt(localStorage.getItem(p));
              return U || (U = S), U;
            }
            getBoolean(p, S = !1) {
              var U = localStorage.getItem(p);
              return U || (U = S), U === "true";
            }
            getFloat(p) {
              var S = parseFloat(localStorage.getItem(p));
              return S || (S = 0), S;
            }
            getObject(p) {
              var S = localStorage.getItem(p);
              return S || (S = {}), JSON.parse(S);
            }
            getString(p, S = "") {
              var U = localStorage.getItem(p);
              return U || (U = S), U;
            }
          };
        lt(Tt, "instance", new Tt());
        let ft = Tt;
        const gt = Object.freeze({
          LeftToRight: "UiTweenDirection:LeftToRight",
          RightToLeft: "UiTweenDirection:RightToLeft",
          TopToBottom: "UiTweenDirection:TopToBottom",
          BottomToTop: "UiTweenDirection:BottomToTop",
        });
        class Fe {
          static createTransitionAppearTween(p, S, U = Me.defaultConfig) {
            let ee = p.element.anchor.clone(),
              Se = ee.clone();
            S === gt.LeftToRight
              ? ((Se.x -= 1), (Se.z -= 1))
              : S === gt.RightToLeft
              ? ((Se.x += 1), (Se.z += 1))
              : S === gt.TopToBottom
              ? ((Se.y += 1), (Se.w += 1))
              : S === gt.BottomToTop && ((Se.y -= 1), (Se.w -= 1));
            let Re = Me.createTween(Se, ee, U),
              Be = Re._onUpdateCallback,
              qe = Re._onStartCallback;
            return (
              Re.onStart(() => {
                (p.element.anchor = Se), (p.element.enabled = !0), qe();
              }),
              Re.onUpdate(() => {
                (p.element.anchor = Se), Be();
              }),
              Re
            );
          }
          static createTransitionDisappearTween(p, S, U = Me.defaultConfig) {
            let ee = p.element.anchor.clone(),
              Se = ee.clone();
            S === gt.LeftToRight
              ? ((Se.x += 1), (Se.z += 1))
              : S === gt.RightToLeft
              ? ((Se.x -= 1), (Se.z -= 1))
              : S === gt.TopToBottom
              ? ((Se.y -= 1), (Se.w -= 1))
              : S === gt.BottomToTop && ((Se.y += 1), (Se.w += 1));
            let Re = Me.createTween(ee, Se, U),
              Be = Re._onUpdateCallback;
            return (
              Re.onUpdate(() => {
                (p.element.anchor = ee), Be();
              }),
              Re
            );
          }
        }
        const Qt = Object.freeze({
          OpenPauseScreen: "PlayScreen:OpenPauseScreen",
        });
        class zt extends Ye {
          constructor() {
            super(a.SCREEN_PLAY);
          }
          create() {
            super.create(),
              this._createLife(),
              this._initProgress(),
              this._initLevelText(),
              this._initButtonPause(),
              this._initAnimation();
          }
          _createLife() {
            (this.currentSkin = ft.instance.getString(
              a.STORAGE_KEY_SKIN,
              a.INIT_SKIN
            )),
              (this.lifeBackground = ze.createEmptyImageElement({
                anchor: new at.Z(1, 1, 1, 1),
                pivot: new Ne.Z(1, 1),
                width: 70,
                height: 60 * a.TOTAL_LIFE + 10,
                x: -21,
                y: -10,
                color: new Ae.Q(0.5, 0.5, 0.5),
                opacity: 0.6,
              })),
              this.addChild(this.lifeBackground),
              (this.lifeGroup = ze.createGroupElement({
                anchor: new at.Z(1, 1, 1, 1),
                pivot: new Ne.Z(1, 1),
                x: -28,
                y: -10,
              })),
              this.lifeGroup.addComponent("layoutgroup", {
                orientation: Ve.Yn,
                spacing: new Ne.Z(0, 10),
              }),
              this.lifeBackground.addChild(this.lifeGroup),
              (this.ballIcons = []);
            for (let p = 0; p < a.TOTAL_LIFE; p++) {
              let S = ze.createImageElement(`spr_icon_${this.currentSkin}`, {
                width: 50,
                height: 50,
              });
              this.lifeGroup.addChild(S), this.ballIcons.push(S);
            }
          }
          updateLife(p) {
            if (!this.ballIcons) return;
            this.currentSkin = ft.instance.getString(
              a.STORAGE_KEY_SKIN,
              a.INIT_SKIN
            );
            let S = n.find(`spr_icon_${this.currentSkin}`),
              U = n.find("spr_icon_ball_dead");
            for (let ee = 0; ee < a.TOTAL_LIFE; ee++) {
              let Se = this.ballIcons[ee];
              ee < p
                ? (Se.element.textureAsset = S)
                : (Se.element.textureAsset = U);
            }
          }
          _initProgress() {
            (this.progressBar = ze.createImageElement(
              "spr_slide_progress_bar",
              {
                anchor: new at.Z(0.5, 0.8, 0.5, 0.8),
                pivot: new Ne.Z(0.5, 0.5),
                scale: 1.5,
                y: 170,
                opacity: 0.9,
              }
            )),
              this.addChild(this.progressBar),
              (this.progressBarMask = ze.createImageElement(
                "spr_slide_progress_bar_mask",
                {
                  anchor: new at.Z(0, 0.5, 0, 0.5),
                  pivot: new Ne.Z(0, 0.5),
                  scale: 1.51,
                  x: 5,
                  y: 3,
                }
              )),
              this.progressBar.addChild(this.progressBarMask),
              (this.progressBarWidth = this.progressBarMask.element.width),
              (this.progressBarMask.element.width = 0),
              (this.progressBarMask.element.mask = !0),
              (this.progressBarFill = ze.createImageElement(
                "spr_slide_progress_bar_fill",
                {
                  anchor: new at.Z(0, 0.5, 0, 0.5),
                  pivot: new Ne.Z(0, 0.5),
                  scale: 1.48,
                }
              )),
              this.progressBarMask.addChild(this.progressBarFill);
          }
          setProgress(p) {
            this.progressBarMask.element.width = this.progressBarWidth * p;
          }
          _initLevelText() {
            (this.levelText = ze.createTextElement("font_rounded", {
              anchor: new at.Z(0.5, 0.8, 0.5, 0.8),
              pivot: new Ne.Z(0.5, 0.5),
              text: "Level 1",
              y: 100,
              fontSize: 52,
              color: Ae.Q.WHITE,
            })),
              (this.levelText.element.outlineColor = Ae.Q.BLACK),
              (this.levelText.element.outlineThickness = 0.6),
              this.addChild(this.levelText);
          }
          setLevelText(p) {
            this.levelText.element.text = `Level ${p}`;
          }
          _initButtonPause() {
            (this.buttonPause = ze.createButtonElement("spr_icon_pause", {
              anchor: new at.Z(0, 1, 0, 1),
              pivot: new Ne.Z(0, 1),
              x: 48,
              y: -48,
            })),
              this.addChild(this.buttonPause),
              this.buttonPause.button.on(
                "click",
                this._onButtonPauseClick,
                this
              );
          }
          _onButtonPauseClick() {
            this.fire(Qt.OpenPauseScreen);
          }
          _initAnimation() {
            (this._appearTweens = []), (this._disappearTweens = []);
            let p = { duration: 0.5, easing: Me.Easing.Back.Out };
            this._appearTweens.push(
              Fe.createTransitionAppearTween(
                this.lifeBackground,
                gt.RightToLeft,
                p
              )
            ),
              this._appearTweens.push(
                Fe.createTransitionAppearTween(
                  this.progressBar,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearTweens.push(
                Fe.createTransitionAppearTween(
                  this.levelText,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearTweens.push(
                Fe.createTransitionAppearTween(
                  this.buttonPause,
                  gt.TopToBottom,
                  p
                )
              );
          }
          onEnable() {
            this._appearTweens.forEach((p) => p.start());
          }
        }
        var Lt = Ut(8656),
          $t = Ut(2633),
          Bt = Ut(714),
          Nt = Ut(6087);
        class es {
          constructor() {
            (this.name = ""),
              (this.attributes = {}),
              (this.initialize = null),
              (this.postInitialize = null),
              (this.update = null),
              (this.fixedUpdate = null),
              (this.postUpdate = null),
              (this.onEnable = null),
              (this.onDisable = null),
              (this.onDestroy = null),
              (this._initialized = !1);
          }
        }
        class kt {
          static createScript(p = new es()) {
            return Ge.copyObject(p);
          }
          static _initScript(p) {
            let S = (0, $t.so)(p.name);
            Object.keys(p).forEach((U) => {
              U === "attributes"
                ? Object.keys(p.attributes).forEach((ee) => {
                    S.attributes.add(ee, p.attributes[ee]);
                  })
                : (S.prototype[U] = p[U]);
            }),
              (p._initialized = !0);
          }
        }
        (o.w.prototype.addScript = function (C, p = {}) {
          this.script || this.addComponent("script");
          let S;
          if (ht(C, Bt.e)) {
            let Se = C.name;
            if (
              (Se || (Se = C.prototype.constructor.name),
              !Ht.app.scripts.has(Se))
            ) {
              if (!(C.attributes instanceof Nt.x))
                (C._customAttributes = C.attributes),
                  (C.attributes = new Nt.x(C));
              else {
                var U = new C({ app: Ht.app, entity: this }),
                  ee = Object.keys(U).filter(
                    (Be) =>
                      Be !== "app" && Be !== "entity" && !Be.startsWith("_")
                  );
                (C._customAttributes = {}),
                  ee.forEach((Be) => {
                    C._customAttributes[Be] = {
                      type: typeof U[Be],
                      default: U[Be],
                    };
                  }),
                  Object.keys(p.attributes).forEach((Be) => {
                    ee.includes(Be) ||
                      (C._customAttributes[Be] = {
                        type: typeof p.attributes[Be],
                        default: p.attributes[Be],
                      });
                  }),
                  (U = void 0);
              }
              (0, $t.tX)(C),
                Object.keys(C._customAttributes).forEach((Be) => {
                  C.attributes.add(Be, C._customAttributes[Be]);
                }),
                delete C._customAttributes;
            }
            S = this.script.create(Se, p);
          } else
            C &&
              (C._initialized || kt._initScript(C),
              (S = this.script.create(C.name, { attributes: p })));
          return (
            S.onEnable && S.on("enable", S.onEnable, S),
            S.onDisable && S.on("disable", S.onDisable, S),
            S.onDestroy && S.on("destroy", S.onDestroy, S),
            S.enable || (S.enable = () => (S.enabled = !0)),
            S.disable || (S.disable = () => (S.enabled = !1)),
            S
          );
        }),
          (o.w.prototype.getScript = function (C) {
            return this.script ? this.script[C.name] : null;
          });
        const ds = kt.createScript({
            name: "inputHandler",
            initialize() {
              bt.emitter.on(Pt.PointerDown, this._onPointerDown, this),
                bt.emitter.on(Pt.PointerMove, this._onPointerMove, this),
                bt.emitter.on(Pt.PointerUp, this._onPointerUp, this);
            },
            _onPointerDown(C) {
              this.enabled && this.fire(os.PointerDown, C);
            },
            _onPointerMove(C) {
              this.enabled && this.fire(os.PointerMove, C);
            },
            _onPointerUp(C) {
              this.enabled && this.fire(os.PointerUp, C);
            },
          }),
          os = Object.freeze({
            PointerDown: "inputHandler:pointerdown",
            PointerMove: "inputHandler:pointermove",
            PointerUp: "inputHandler:pointerup",
          }),
          ls = Object.freeze({
            Start: "start",
            Pause: "pause",
            Resume: "resume",
            Lose: "lose",
            Replay: "resplay",
            Win: "win",
          }),
          Ps = kt.createScript({
            name: "gameManager",
            start() {
              A.log("GameManager", "Start"), this.fire(ls.Start);
            },
            pause() {
              A.log("GameManager", "Pause"), this.fire(ls.Pause);
            },
            resume() {
              A.log("GameManager", "Resume"), this.fire(ls.Resume);
            },
            lose() {
              A.log("GameManager", "Lose"), this.fire(ls.Lose);
            },
            replay() {
              A.log("GameManager", "Replay"), this.fire(ls.Replay);
            },
            win() {
              A.log("GameManager", "Win"), this.fire(ls.Win);
            },
          }),
          us = Object.freeze({
            Current: "spr_icon_level_current",
            Locked: "spr_icon_level_locked",
            Passed: "spr_icon_level_passed",
            EndInGroup: "spr_icon_level_end_in_group",
          });
        class Xe extends o.w {
          constructor(p = us.Current, S = 0, U = "") {
            super("levelElement"),
              (this.frameName = p),
              (this.iconName = U),
              this.addComponent("element", {
                type: "image",
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
                pivot: new Ne.Z(0.5, 0.5),
                textureAsset: n.find(p),
              }),
              this.setLocalScale(1.8, 1.8, 1.8),
              (this.text = ze.createTextElement("font_rounded", {
                fontSize: 20,
                color: Ae.Q.WHITE,
                text: S.toString(),
                y: -3,
              })),
              (this.text.element.autoFitHeight = !0),
              (this.text.element.autoWidth = !0),
              (this.text.element.width = this.element.width - 20),
              (this.text.element.height = this.element.height - 20),
              (this.text.element.outlineColor = Ae.Q.BLACK),
              (this.text.element.outlineThickness = 0.6),
              this.addChild(this.text);
          }
          setIcon(p, S, U) {
            (this.text.enabled = !1),
              this.icon
                ? ((this.icon.element.textureAsset = n.find(p)),
                  (this.icon.enabled = !0))
                : (S === void 0 && (S = this.element.width - 10),
                  U === void 0 && (U = this.element.height - 10),
                  (this.icon = ze.createImageElement(p, {
                    width: S,
                    height: U,
                  })),
                  this.addChild(this.icon));
          }
          setText(p) {
            (this.text.enabled = !0),
              this.icon && (this.icon.enabled = !1),
              (this.text.element.text = p);
          }
          setFrame(p) {
            (this.frameName = p), (this.element.textureAsset = n.find(p));
          }
        }
        var vs = Object.defineProperty,
          fs = (C, p, S) =>
            p in C
              ? vs(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          bs = (C, p, S) => fs(C, typeof p != "symbol" ? p + "" : p, S);
        const Ms = class ul {
          static init(p) {
            if (
              ((this.adsConfig = window.LAGGED_SDK_CONFIG),
              !this.adsConfig.SHOW_ADS)
            ) {
              (this.isReady = !0), p == null || p();
              return;
            }
            this._createBackground(),
              LaggedAPI.init(
                this.adsConfig.DEV_ID,
                this.adsConfig.PUBLISHER_ID
              ),
              setTimeout(() => {
                (ul.isReady = !0), this.emitter.fire("ready"), p == null || p();
              }, 550);
          }
          static _createBackground() {
            (this._background = document.createElement("div")),
              (this._background.style.top = "0px"),
              (this._background.style.left = "0px"),
              (this._background.style.margin = "0px"),
              (this._background.style.padding = "0px"),
              (this._background.id = "ads-background"),
              (this._background.style.position = "absolute"),
              (this._background.style.width = "100%"),
              (this._background.style.height = "100%"),
              (this._background.style.backgroundColor = "black"),
              (this._background.style.opacity = "0.8"),
              (this._background.style.zIndex = "10"),
              document.body.appendChild(this._background),
              (this._background.style.display = "none");
            const p = (S) => {
              S.stopPropagation();
            };
            this._background.addEventListener("mousedown", p),
              this._background.addEventListener("mousemove", p),
              this._background.addEventListener("mouseup", p),
              this._background.addEventListener("touchstart", p),
              this._background.addEventListener("touchmove", p),
              this._background.addEventListener("touchend", p),
              this._background.addEventListener("keydown", p),
              this._background.addEventListener("keyup", p),
              this._background.addEventListener("keypress", p),
              this._background.addEventListener("contextmenu", p),
              (this.alphaInTween = Me.createTween(
                { opacity: 0 },
                { opacity: 0.8 },
                {
                  duration: 0.2,
                  onStart: () => {
                    this._background.style.display = "block";
                  },
                  onUpdate: (S) => {
                    this._background.style.opacity = S.opacity;
                  },
                }
              )),
              (this.alphaOutTween = Me.createTween(
                { opacity: 0.8 },
                { opacity: 0 },
                {
                  duration: 0.2,
                  onUpdate: (S) => {
                    this._background.style.opacity = S.opacity;
                  },
                  onComplete: () => {
                    this._background.style.display = "none";
                  },
                }
              ));
          }
          static _showBackground() {
            this.alphaInTween.stop(),
              this.alphaOutTween.stop(),
              this.alphaInTween.start();
          }
          static _hideBackground() {
            this.alphaInTween.stop(),
              this.alphaOutTween.stop(),
              this.alphaOutTween.start();
          }
          static _showBackgroundNoOpacity() {
            (this._background.style.display = "block"),
              (this._background.style.opacity = "0.0");
          }
          static _hideBackgroundNoOpacity() {
            (this._background.style.display = "none"),
              (this._background.style.opacity = "0.0");
          }
          static showInterstitialAds(p) {
            if (!this.adsConfig.SHOW_ADS) {
              p == null || p();
              return;
            }
            if (!this.isReady) {
              this.emitter.once("ready", () => {
                this.showInterstitialAds(p);
              });
              return;
            }
            this._showBackgroundNoOpacity(),
              LaggedAPI.APIAds.show(() => {
                this._hideBackgroundNoOpacity(), p == null || p();
              });
          }
          static saveAchievement(p, S) {
            LaggedAPI.Achievements.save([p], (U) => {
              U.success
                ? (console.log("achievement saved"), S == null || S())
                : (console.warn(U.errormsg), S == null || S(U.errormsg));
            });
          }
          static checkIsRewardAdsReady(p) {
            if (!this.adsConfig.SHOW_ADS) {
              p == null || p(!1);
              return;
            }
            if (!this.isReady) {
              this.emitter.once("ready", () => {
                this.checkIsRewardAdsReady(p);
              });
              return;
            }
            if (
              performance.now() - this._lastCallRewardAds <
              this._rewardAdsThreshold
            ) {
              p == null || p(!1, "Too fast");
              return;
            }
            this._lastCallRewardAds = performance.now();
            let S = !1,
              U = (Re, Be) => {
                S || ((S = !0), p == null || p(Re, Be));
              };
            if (this._showRewardAdsFn) {
              U(!0);
              return;
            }
            let ee = (Re, Be) => {
                Re
                  ? ((this._showRewardAdsFn = Be), U(!0))
                  : U(!1, "Reward ads not ready");
              },
              Se = (Re) => {
                var Be, qe;
                this._rewardAdsSuccessCallback &&
                  (Re
                    ? (Be = this._rewardAdsSuccessCallback) == null ||
                      Be.call(this)
                    : (qe = this._rewardAdsSuccessCallback) == null ||
                      qe.call(this, "Reward ads failed"));
              };
            LaggedAPI.GEvents.reward(ee, Se);
          }
          static showRewardAds(p) {
            if (!this.adsConfig.SHOW_ADS) {
              p == null || p();
              return;
            }
            if (!this._showRewardAdsFn) {
              p == null || p("Reward ads not ready");
              return;
            }
            if (!this.isReady) {
              this.emitter.once("ready", () => {
                this.showRewardAds(p);
              });
              return;
            }
            this._showBackground(),
              (this._rewardAdsSuccessCallback = (S) => {
                this._hideBackground(),
                  p == null || p(S),
                  (this._rewardAdsSuccessCallback = null);
              }),
              this._showRewardAdsFn(),
              (this._showRewardAdsFn = null);
          }
        };
        bs(Ms, "isReady", !1),
          bs(Ms, "emitter", new et.J()),
          bs(Ms, "_lastCallRewardAds", 0),
          bs(Ms, "_rewardAdsThreshold", 1e3),
          bs(Ms, "_showRewardAdsFn", null),
          bs(Ms, "_rewardAdsSuccessCallback", null);
        let Ts = Ms;
        var Js = Object.defineProperty,
          Os = (C, p, S) =>
            p in C
              ? Js(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          li = (C, p, S) => Os(C, typeof p != "symbol" ? p + "" : p, S);
        const $s = class {
          constructor() {
            (this.lifeCount = 0), (this.coinCount = 0), (this.keyCount = 0);
          }
          reset() {
            (this.coinCount = 0), (this.keyCount = 0);
          }
        };
        li($s, "instance", new $s());
        let Cs = $s;
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Gs = {
          NODE_CLIENT: !1,
          NODE_ADMIN: !1,
          SDK_VERSION: "${JSCORE_VERSION}",
        };
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const hi = function (C, p) {
            if (!C) throw ci(p);
          },
          ci = function (C) {
            return new Error(
              "Firebase Database (" +
                Gs.SDK_VERSION +
                ") INTERNAL ASSERT FAILED: " +
                C
            );
          };
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const ii = function (C) {
            const p = [];
            let S = 0;
            for (let U = 0; U < C.length; U++) {
              let ee = C.charCodeAt(U);
              ee < 128
                ? (p[S++] = ee)
                : ee < 2048
                ? ((p[S++] = (ee >> 6) | 192), (p[S++] = (ee & 63) | 128))
                : (ee & 64512) === 55296 &&
                  U + 1 < C.length &&
                  (C.charCodeAt(U + 1) & 64512) === 56320
                ? ((ee =
                    65536 + ((ee & 1023) << 10) + (C.charCodeAt(++U) & 1023)),
                  (p[S++] = (ee >> 18) | 240),
                  (p[S++] = ((ee >> 12) & 63) | 128),
                  (p[S++] = ((ee >> 6) & 63) | 128),
                  (p[S++] = (ee & 63) | 128))
                : ((p[S++] = (ee >> 12) | 224),
                  (p[S++] = ((ee >> 6) & 63) | 128),
                  (p[S++] = (ee & 63) | 128));
            }
            return p;
          },
          je = function (C) {
            const p = [];
            let S = 0,
              U = 0;
            for (; S < C.length; ) {
              const ee = C[S++];
              if (ee < 128) p[U++] = String.fromCharCode(ee);
              else if (ee > 191 && ee < 224) {
                const Se = C[S++];
                p[U++] = String.fromCharCode(((ee & 31) << 6) | (Se & 63));
              } else if (ee > 239 && ee < 365) {
                const Se = C[S++],
                  Re = C[S++],
                  Be = C[S++],
                  qe =
                    (((ee & 7) << 18) |
                      ((Se & 63) << 12) |
                      ((Re & 63) << 6) |
                      (Be & 63)) -
                    65536;
                (p[U++] = String.fromCharCode(55296 + (qe >> 10))),
                  (p[U++] = String.fromCharCode(56320 + (qe & 1023)));
              } else {
                const Se = C[S++],
                  Re = C[S++];
                p[U++] = String.fromCharCode(
                  ((ee & 15) << 12) | ((Se & 63) << 6) | (Re & 63)
                );
              }
            }
            return p.join("");
          },
          mt = {
            byteToCharMap_: null,
            charToByteMap_: null,
            byteToCharMapWebSafe_: null,
            charToByteMapWebSafe_: null,
            ENCODED_VALS_BASE:
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
            get ENCODED_VALS() {
              return this.ENCODED_VALS_BASE + "+/=";
            },
            get ENCODED_VALS_WEBSAFE() {
              return this.ENCODED_VALS_BASE + "-_.";
            },
            HAS_NATIVE_SUPPORT: typeof atob == "function",
            encodeByteArray(C, p) {
              if (!Array.isArray(C))
                throw Error("encodeByteArray takes an array as a parameter");
              this.init_();
              const S = p ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
                U = [];
              for (let ee = 0; ee < C.length; ee += 3) {
                const Se = C[ee],
                  Re = ee + 1 < C.length,
                  Be = Re ? C[ee + 1] : 0,
                  qe = ee + 2 < C.length,
                  Et = qe ? C[ee + 2] : 0,
                  Ct = Se >> 2,
                  St = ((Se & 3) << 4) | (Be >> 4);
                let jt = ((Be & 15) << 2) | (Et >> 6),
                  ts = Et & 63;
                qe || ((ts = 64), Re || (jt = 64)),
                  U.push(S[Ct], S[St], S[jt], S[ts]);
              }
              return U.join("");
            },
            encodeString(C, p) {
              return this.HAS_NATIVE_SUPPORT && !p
                ? btoa(C)
                : this.encodeByteArray(ii(C), p);
            },
            decodeString(C, p) {
              return this.HAS_NATIVE_SUPPORT && !p
                ? atob(C)
                : je(this.decodeStringToByteArray(C, p));
            },
            decodeStringToByteArray(C, p) {
              this.init_();
              const S = p ? this.charToByteMapWebSafe_ : this.charToByteMap_,
                U = [];
              for (let ee = 0; ee < C.length; ) {
                const Se = S[C.charAt(ee++)],
                  Be = ee < C.length ? S[C.charAt(ee)] : 0;
                ++ee;
                const Et = ee < C.length ? S[C.charAt(ee)] : 64;
                ++ee;
                const St = ee < C.length ? S[C.charAt(ee)] : 64;
                if (
                  (++ee, Se == null || Be == null || Et == null || St == null)
                )
                  throw new Ot();
                const jt = (Se << 2) | (Be >> 4);
                if ((U.push(jt), Et !== 64)) {
                  const ts = ((Be << 4) & 240) | (Et >> 2);
                  if ((U.push(ts), St !== 64)) {
                    const ys = ((Et << 6) & 192) | St;
                    U.push(ys);
                  }
                }
              }
              return U;
            },
            init_() {
              if (!this.byteToCharMap_) {
                (this.byteToCharMap_ = {}),
                  (this.charToByteMap_ = {}),
                  (this.byteToCharMapWebSafe_ = {}),
                  (this.charToByteMapWebSafe_ = {});
                for (let C = 0; C < this.ENCODED_VALS.length; C++)
                  (this.byteToCharMap_[C] = this.ENCODED_VALS.charAt(C)),
                    (this.charToByteMap_[this.byteToCharMap_[C]] = C),
                    (this.byteToCharMapWebSafe_[C] =
                      this.ENCODED_VALS_WEBSAFE.charAt(C)),
                    (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[C]] =
                      C),
                    C >= this.ENCODED_VALS_BASE.length &&
                      ((this.charToByteMap_[
                        this.ENCODED_VALS_WEBSAFE.charAt(C)
                      ] = C),
                      (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(C)] =
                        C));
              }
            },
          };
        class Ot extends Error {
          constructor() {
            super(...arguments), (this.name = "DecodeBase64StringError");
          }
        }
        const ss = function (C) {
            const p = ii(C);
            return mt.encodeByteArray(p, !0);
          },
          qt = function (C) {
            return ss(C).replace(/\./g, "");
          },
          is = function (C) {
            try {
              return mt.decodeString(C, !0);
            } catch (p) {
              console.error("base64Decode failed: ", p);
            }
            return null;
          };
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Ls(C) {
          return js(void 0, C);
        }
        function js(C, p) {
          if (!(p instanceof Object)) return p;
          switch (p.constructor) {
            case Date:
              const S = p;
              return new Date(S.getTime());
            case Object:
              C === void 0 && (C = {});
              break;
            case Array:
              C = [];
              break;
            default:
              return p;
          }
          for (const S in p)
            !p.hasOwnProperty(S) || !fi(S) || (C[S] = js(C[S], p[S]));
          return C;
        }
        function fi(C) {
          return C !== "__proto__";
        }
        /**
         * @license
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function pi() {
          if (typeof self != "undefined") return self;
          if (typeof window != "undefined") return window;
          if (typeof Ut.g != "undefined") return Ut.g;
          throw new Error("Unable to locate global object.");
        }
        /**
         * @license
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const _i = () => pi().__FIREBASE_DEFAULTS__,
          mi = () => {
            if (
              typeof process == "undefined" ||
              typeof process.env == "undefined"
            )
              return;
            const C = process.env.__FIREBASE_DEFAULTS__;
            if (C) return JSON.parse(C);
          },
          gi = () => {
            if (typeof document == "undefined") return;
            let C;
            try {
              C = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
            } catch (S) {
              return;
            }
            const p = C && is(C[1]);
            return p && JSON.parse(p);
          },
          yi = () => {
            try {
              return _i() || mi() || gi();
            } catch (C) {
              console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${C}`);
              return;
            }
          },
          Li = (C) => {
            var p, S;
            return (S =
              (p = yi()) === null || p === void 0
                ? void 0
                : p.emulatorHosts) === null || S === void 0
              ? void 0
              : S[C];
          },
          Bi = (C) => {
            const p = Li(C);
            if (!p) return;
            const S = p.lastIndexOf(":");
            if (S <= 0 || S + 1 === p.length)
              throw new Error(
                `Invalid host ${p} with no separate hostname and port!`
              );
            const U = parseInt(p.substring(S + 1), 10);
            return p[0] === "["
              ? [p.substring(1, S - 1), U]
              : [p.substring(0, S), U];
          },
          Ai = () => {
            var C;
            return (C = yi()) === null || C === void 0 ? void 0 : C.config;
          },
          Xi = (C) => {
            var p;
            return (p = yi()) === null || p === void 0 ? void 0 : p[`_${C}`];
          };
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class Yi {
          constructor() {
            (this.reject = () => {}),
              (this.resolve = () => {}),
              (this.promise = new Promise((p, S) => {
                (this.resolve = p), (this.reject = S);
              }));
          }
          wrapCallback(p) {
            return (S, U) => {
              S ? this.reject(S) : this.resolve(U),
                typeof p == "function" &&
                  (this.promise.catch(() => {}),
                  p.length === 1 ? p(S) : p(S, U));
            };
          }
        }
        /**
         * @license
         * Copyright 2021 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Mn(C, p) {
          if (C.uid)
            throw new Error(
              'The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'
            );
          const S = { alg: "none", type: "JWT" },
            U = p || "demo-project",
            ee = C.iat || 0,
            Se = C.sub || C.user_id;
          if (!Se)
            throw new Error(
              "mockUserToken must contain 'sub' or 'user_id' field!"
            );
          const Re = Object.assign(
            {
              iss: `https://securetoken.google.com/${U}`,
              aud: U,
              iat: ee,
              exp: ee + 3600,
              auth_time: ee,
              sub: Se,
              user_id: Se,
              firebase: { sign_in_provider: "custom", identities: {} },
            },
            C
          );
          return [qt(JSON.stringify(S)), qt(JSON.stringify(Re)), ""].join(".");
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Ci() {
          return typeof navigator != "undefined" &&
            typeof navigator.userAgent == "string"
            ? navigator.userAgent
            : "";
        }
        function hn() {
          return (
            typeof window != "undefined" &&
            !!(window.cordova || window.phonegap || window.PhoneGap) &&
            /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(Ci())
          );
        }
        function Zi() {
          var C;
          const p =
            (C = yi()) === null || C === void 0 ? void 0 : C.forceEnvironment;
          if (p === "node") return !0;
          if (p === "browser") return !1;
          try {
            return (
              Object.prototype.toString.call(Ut.g.process) ===
              "[object process]"
            );
          } catch (S) {
            return !1;
          }
        }
        function cn() {
          return typeof window != "undefined" || Qi();
        }
        function Qi() {
          return (
            typeof WorkerGlobalScope != "undefined" &&
            typeof self != "undefined" &&
            self instanceof WorkerGlobalScope
          );
        }
        function Ji() {
          const C =
            typeof chrome == "object"
              ? chrome.runtime
              : typeof browser == "object"
              ? browser.runtime
              : void 0;
          return typeof C == "object" && C.id !== void 0;
        }
        function dn() {
          return (
            typeof navigator == "object" && navigator.product === "ReactNative"
          );
        }
        function un() {
          return Ci().indexOf("Electron/") >= 0;
        }
        function wn() {
          const C = Ci();
          return C.indexOf("MSIE ") >= 0 || C.indexOf("Trident/") >= 0;
        }
        function In() {
          return Ci().indexOf("MSAppHost/") >= 0;
        }
        function $i() {
          return Gs.NODE_CLIENT === !0 || Gs.NODE_ADMIN === !0;
        }
        function Dn() {
          return (
            !Zi() &&
            !!navigator.userAgent &&
            navigator.userAgent.includes("Safari") &&
            !navigator.userAgent.includes("Chrome")
          );
        }
        function qi() {
          try {
            return typeof indexedDB == "object";
          } catch (C) {
            return !1;
          }
        }
        function en() {
          return new Promise((C, p) => {
            try {
              let S = !0;
              const U =
                  "validate-browser-context-for-indexeddb-analytics-module",
                ee = self.indexedDB.open(U);
              (ee.onsuccess = () => {
                ee.result.close(), S || self.indexedDB.deleteDatabase(U), C(!0);
              }),
                (ee.onupgradeneeded = () => {
                  S = !1;
                }),
                (ee.onerror = () => {
                  var Se;
                  p(
                    ((Se = ee.error) === null || Se === void 0
                      ? void 0
                      : Se.message) || ""
                  );
                });
            } catch (S) {
              p(S);
            }
          });
        }
        function Fi() {
          return !(typeof navigator == "undefined" || !navigator.cookieEnabled);
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Ui = "FirebaseError";
        class Hs extends Error {
          constructor(p, S, U) {
            super(S),
              (this.code = p),
              (this.customData = U),
              (this.name = Ui),
              Object.setPrototypeOf(this, Hs.prototype),
              Error.captureStackTrace &&
                Error.captureStackTrace(this, Pi.prototype.create);
          }
        }
        class Pi {
          constructor(p, S, U) {
            (this.service = p), (this.serviceName = S), (this.errors = U);
          }
          create(p, ...S) {
            const U = S[0] || {},
              ee = `${this.service}/${p}`,
              Se = this.errors[p],
              Re = Se ? fn(Se, U) : "Error",
              Be = `${this.serviceName}: ${Re} (${ee}).`;
            return new Hs(ee, Be, U);
          }
        }
        function fn(C, p) {
          return C.replace(pn, (S, U) => {
            const ee = p[U];
            return ee != null ? String(ee) : `<${U}?>`;
          });
        }
        const pn = /\{\$([^}]+)}/g;
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function tn(C) {
          return JSON.parse(C);
        }
        function Rn(C) {
          return JSON.stringify(C);
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const ni = function (C) {
            let p = {},
              S = {},
              U = {},
              ee = "";
            try {
              const Se = C.split(".");
              (p = tn(is(Se[0]) || "")),
                (S = tn(is(Se[1]) || "")),
                (ee = Se[2]),
                (U = S.d || {}),
                delete S.d;
            } catch (Se) {}
            return { header: p, claims: S, data: U, signature: ee };
          },
          On = function (C) {
            const p = ni(C).claims,
              S = Math.floor(new Date().getTime() / 1e3);
            let U = 0,
              ee = 0;
            return (
              typeof p == "object" &&
                (p.hasOwnProperty("nbf")
                  ? (U = p.nbf)
                  : p.hasOwnProperty("iat") && (U = p.iat),
                p.hasOwnProperty("exp") ? (ee = p.exp) : (ee = U + 86400)),
              !!S && !!U && !!ee && S >= U && S <= ee
            );
          },
          _n = function (C) {
            const p = ni(C).claims;
            return typeof p == "object" && p.hasOwnProperty("iat")
              ? p.iat
              : null;
          },
          Ln = function (C) {
            const p = ni(C),
              S = p.claims;
            return !!S && typeof S == "object" && S.hasOwnProperty("iat");
          },
          Bn = function (C) {
            const p = ni(C).claims;
            return typeof p == "object" && p.admin === !0;
          };
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Fn(C, p) {
          return Object.prototype.hasOwnProperty.call(C, p);
        }
        function Un(C, p) {
          if (Object.prototype.hasOwnProperty.call(C, p)) return C[p];
        }
        function Nn(C) {
          for (const p in C)
            if (Object.prototype.hasOwnProperty.call(C, p)) return !1;
          return !0;
        }
        function zn(C, p, S) {
          const U = {};
          for (const ee in C)
            Object.prototype.hasOwnProperty.call(C, ee) &&
              (U[ee] = p.call(S, C[ee], ee, C));
          return U;
        }
        function bi(C, p) {
          if (C === p) return !0;
          const S = Object.keys(C),
            U = Object.keys(p);
          for (const ee of S) {
            if (!U.includes(ee)) return !1;
            const Se = C[ee],
              Re = p[ee];
            if (sn(Se) && sn(Re)) {
              if (!bi(Se, Re)) return !1;
            } else if (Se !== Re) return !1;
          }
          for (const ee of U) if (!S.includes(ee)) return !1;
          return !0;
        }
        function sn(C) {
          return C !== null && typeof C == "object";
        }
        /**
         * @license
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function kn(C, p = 2e3) {
          const S = new Yi();
          return (
            setTimeout(() => S.reject("timeout!"), p),
            C.then(S.resolve, S.reject),
            S.promise
          );
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Wn(C) {
          const p = [];
          for (const [S, U] of Object.entries(C))
            Array.isArray(U)
              ? U.forEach((ee) => {
                  p.push(encodeURIComponent(S) + "=" + encodeURIComponent(ee));
                })
              : p.push(encodeURIComponent(S) + "=" + encodeURIComponent(U));
          return p.length ? "&" + p.join("&") : "";
        }
        function Vn(C) {
          const p = {};
          return (
            C.replace(/^\?/, "")
              .split("&")
              .forEach((U) => {
                if (U) {
                  const [ee, Se] = U.split("=");
                  p[decodeURIComponent(ee)] = decodeURIComponent(Se);
                }
              }),
            p
          );
        }
        function mn(C) {
          const p = C.indexOf("?");
          if (!p) return "";
          const S = C.indexOf("#", p);
          return C.substring(p, S > 0 ? S : void 0);
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class Gn {
          constructor() {
            (this.chain_ = []),
              (this.buf_ = []),
              (this.W_ = []),
              (this.pad_ = []),
              (this.inbuf_ = 0),
              (this.total_ = 0),
              (this.blockSize = 512 / 8),
              (this.pad_[0] = 128);
            for (let p = 1; p < this.blockSize; ++p) this.pad_[p] = 0;
            this.reset();
          }
          reset() {
            (this.chain_[0] = 1732584193),
              (this.chain_[1] = 4023233417),
              (this.chain_[2] = 2562383102),
              (this.chain_[3] = 271733878),
              (this.chain_[4] = 3285377520),
              (this.inbuf_ = 0),
              (this.total_ = 0);
          }
          compress_(p, S) {
            S || (S = 0);
            const U = this.W_;
            if (typeof p == "string")
              for (let St = 0; St < 16; St++)
                (U[St] =
                  (p.charCodeAt(S) << 24) |
                  (p.charCodeAt(S + 1) << 16) |
                  (p.charCodeAt(S + 2) << 8) |
                  p.charCodeAt(S + 3)),
                  (S += 4);
            else
              for (let St = 0; St < 16; St++)
                (U[St] =
                  (p[S] << 24) | (p[S + 1] << 16) | (p[S + 2] << 8) | p[S + 3]),
                  (S += 4);
            for (let St = 16; St < 80; St++) {
              const jt = U[St - 3] ^ U[St - 8] ^ U[St - 14] ^ U[St - 16];
              U[St] = ((jt << 1) | (jt >>> 31)) & 4294967295;
            }
            let ee = this.chain_[0],
              Se = this.chain_[1],
              Re = this.chain_[2],
              Be = this.chain_[3],
              qe = this.chain_[4],
              Et,
              Ct;
            for (let St = 0; St < 80; St++) {
              St < 40
                ? St < 20
                  ? ((Et = Be ^ (Se & (Re ^ Be))), (Ct = 1518500249))
                  : ((Et = Se ^ Re ^ Be), (Ct = 1859775393))
                : St < 60
                ? ((Et = (Se & Re) | (Be & (Se | Re))), (Ct = 2400959708))
                : ((Et = Se ^ Re ^ Be), (Ct = 3395469782));
              const jt =
                (((ee << 5) | (ee >>> 27)) + Et + qe + Ct + U[St]) & 4294967295;
              (qe = Be),
                (Be = Re),
                (Re = ((Se << 30) | (Se >>> 2)) & 4294967295),
                (Se = ee),
                (ee = jt);
            }
            (this.chain_[0] = (this.chain_[0] + ee) & 4294967295),
              (this.chain_[1] = (this.chain_[1] + Se) & 4294967295),
              (this.chain_[2] = (this.chain_[2] + Re) & 4294967295),
              (this.chain_[3] = (this.chain_[3] + Be) & 4294967295),
              (this.chain_[4] = (this.chain_[4] + qe) & 4294967295);
          }
          update(p, S) {
            if (p == null) return;
            S === void 0 && (S = p.length);
            const U = S - this.blockSize;
            let ee = 0;
            const Se = this.buf_;
            let Re = this.inbuf_;
            for (; ee < S; ) {
              if (Re === 0)
                for (; ee <= U; ) this.compress_(p, ee), (ee += this.blockSize);
              if (typeof p == "string") {
                for (; ee < S; )
                  if (
                    ((Se[Re] = p.charCodeAt(ee)),
                    ++Re,
                    ++ee,
                    Re === this.blockSize)
                  ) {
                    this.compress_(Se), (Re = 0);
                    break;
                  }
              } else
                for (; ee < S; )
                  if (((Se[Re] = p[ee]), ++Re, ++ee, Re === this.blockSize)) {
                    this.compress_(Se), (Re = 0);
                    break;
                  }
            }
            (this.inbuf_ = Re), (this.total_ += S);
          }
          digest() {
            const p = [];
            let S = this.total_ * 8;
            this.inbuf_ < 56
              ? this.update(this.pad_, 56 - this.inbuf_)
              : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
            for (let ee = this.blockSize - 1; ee >= 56; ee--)
              (this.buf_[ee] = S & 255), (S /= 256);
            this.compress_(this.buf_);
            let U = 0;
            for (let ee = 0; ee < 5; ee++)
              for (let Se = 24; Se >= 0; Se -= 8)
                (p[U] = (this.chain_[ee] >> Se) & 255), ++U;
            return p;
          }
        }
        function jn(C, p) {
          const S = new gn(C, p);
          return S.subscribe.bind(S);
        }
        class gn {
          constructor(p, S) {
            (this.observers = []),
              (this.unsubscribes = []),
              (this.observerCount = 0),
              (this.task = Promise.resolve()),
              (this.finalized = !1),
              (this.onNoObservers = S),
              this.task
                .then(() => {
                  p(this);
                })
                .catch((U) => {
                  this.error(U);
                });
          }
          next(p) {
            this.forEachObserver((S) => {
              S.next(p);
            });
          }
          error(p) {
            this.forEachObserver((S) => {
              S.error(p);
            }),
              this.close(p);
          }
          complete() {
            this.forEachObserver((p) => {
              p.complete();
            }),
              this.close();
          }
          subscribe(p, S, U) {
            let ee;
            if (p === void 0 && S === void 0 && U === void 0)
              throw new Error("Missing Observer.");
            $n(p, ["next", "error", "complete"])
              ? (ee = p)
              : (ee = { next: p, error: S, complete: U }),
              ee.next === void 0 && (ee.next = yn),
              ee.error === void 0 && (ee.error = yn),
              ee.complete === void 0 && (ee.complete = yn);
            const Se = this.unsubscribeOne.bind(this, this.observers.length);
            return (
              this.finalized &&
                this.task.then(() => {
                  try {
                    this.finalError ? ee.error(this.finalError) : ee.complete();
                  } catch (Re) {}
                }),
              this.observers.push(ee),
              Se
            );
          }
          unsubscribeOne(p) {
            this.observers === void 0 ||
              this.observers[p] === void 0 ||
              (delete this.observers[p],
              (this.observerCount -= 1),
              this.observerCount === 0 &&
                this.onNoObservers !== void 0 &&
                this.onNoObservers(this));
          }
          forEachObserver(p) {
            if (!this.finalized)
              for (let S = 0; S < this.observers.length; S++)
                this.sendOne(S, p);
          }
          sendOne(p, S) {
            this.task.then(() => {
              if (this.observers !== void 0 && this.observers[p] !== void 0)
                try {
                  S(this.observers[p]);
                } catch (U) {
                  typeof console != "undefined" &&
                    console.error &&
                    console.error(U);
                }
            });
          }
          close(p) {
            this.finalized ||
              ((this.finalized = !0),
              p !== void 0 && (this.finalError = p),
              this.task.then(() => {
                (this.observers = void 0), (this.onNoObservers = void 0);
              }));
          }
        }
        function Tr(C, p) {
          return (...S) => {
            Promise.resolve(!0)
              .then(() => {
                C(...S);
              })
              .catch((U) => {
                p && p(U);
              });
          };
        }
        function $n(C, p) {
          if (typeof C != "object" || C === null) return !1;
          for (const S of p) if (S in C && typeof C[S] == "function") return !0;
          return !1;
        }
        function yn() {}
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const xr = function (C, p, S, U) {
          let ee;
          if (
            (U < p
              ? (ee = "at least " + p)
              : U > S && (ee = S === 0 ? "none" : "no more than " + S),
            ee)
          ) {
            const Se =
              C +
              " failed: Was called with " +
              U +
              (U === 1 ? " argument." : " arguments.") +
              " Expects " +
              ee +
              ".";
            throw new Error(Se);
          }
        };
        function vn(C, p) {
          return `${C} failed: ${p} argument `;
        }
        function Ar(C, p, S) {
          if (!(S && !p) && typeof p != "string")
            throw new Error(
              vn(C, "namespace") + "must be a valid firebase namespace."
            );
        }
        function Ni(C, p, S, U) {
          if (!(U && !S) && typeof S != "function")
            throw new Error(vn(C, p) + "must be a valid function.");
        }
        function Cr(C, p, S, U) {
          if (!(U && !S) && (typeof S != "object" || S === null))
            throw new Error(vn(C, p) + "must be a valid context object.");
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Pr = function (C) {
            const p = [];
            let S = 0;
            for (let U = 0; U < C.length; U++) {
              let ee = C.charCodeAt(U);
              if (ee >= 55296 && ee <= 56319) {
                const Se = ee - 55296;
                U++,
                  hi(U < C.length, "Surrogate pair missing trail surrogate.");
                const Re = C.charCodeAt(U) - 56320;
                ee = 65536 + (Se << 10) + Re;
              }
              ee < 128
                ? (p[S++] = ee)
                : ee < 2048
                ? ((p[S++] = (ee >> 6) | 192), (p[S++] = (ee & 63) | 128))
                : ee < 65536
                ? ((p[S++] = (ee >> 12) | 224),
                  (p[S++] = ((ee >> 6) & 63) | 128),
                  (p[S++] = (ee & 63) | 128))
                : ((p[S++] = (ee >> 18) | 240),
                  (p[S++] = ((ee >> 12) & 63) | 128),
                  (p[S++] = ((ee >> 6) & 63) | 128),
                  (p[S++] = (ee & 63) | 128));
            }
            return p;
          },
          br = function (C) {
            let p = 0;
            for (let S = 0; S < C.length; S++) {
              const U = C.charCodeAt(S);
              U < 128
                ? p++
                : U < 2048
                ? (p += 2)
                : U >= 55296 && U <= 56319
                ? ((p += 4), S++)
                : (p += 3);
            }
            return p;
          };
        /**
         * @license
         * Copyright 2022 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const ns = function () {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
            /[xy]/g,
            (C) => {
              const p = (Math.random() * 16) | 0;
              return (C === "x" ? p : (p & 3) | 8).toString(16);
            }
          );
        };
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const qn = 1e3,
          er = 2,
          En = 4 * 60 * 60 * 1e3,
          tr = 0.5;
        function Hn(C, p = qn, S = er) {
          const U = p * Math.pow(S, C),
            ee = Math.round(tr * U * (Math.random() - 0.5) * 2);
          return Math.min(En, U + ee);
        }
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Mr(C) {
          return Number.isFinite(C) ? C + sr(C) : `${C}`;
        }
        function sr(C) {
          C = Math.abs(C);
          const p = C % 100;
          if (p >= 10 && p <= 20) return "th";
          const S = C % 10;
          return S === 1 ? "st" : S === 2 ? "nd" : S === 3 ? "rd" : "th";
        }
        /**
         * @license
         * Copyright 2021 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Kn(C) {
          return C && C._delegate ? C._delegate : C;
        }
        class zs {
          constructor(p, S, U) {
            (this.name = p),
              (this.instanceFactory = S),
              (this.type = U),
              (this.multipleInstances = !1),
              (this.serviceProps = {}),
              (this.instantiationMode = "LAZY"),
              (this.onInstanceCreated = null);
          }
          setInstantiationMode(p) {
            return (this.instantiationMode = p), this;
          }
          setMultipleInstances(p) {
            return (this.multipleInstances = p), this;
          }
          setServiceProps(p) {
            return (this.serviceProps = p), this;
          }
          setInstanceCreatedCallback(p) {
            return (this.onInstanceCreated = p), this;
          }
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const zi = "[DEFAULT]";
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class sa {
          constructor(p, S) {
            (this.name = p),
              (this.container = S),
              (this.component = null),
              (this.instances = new Map()),
              (this.instancesDeferred = new Map()),
              (this.instancesOptions = new Map()),
              (this.onInitCallbacks = new Map());
          }
          get(p) {
            const S = this.normalizeInstanceIdentifier(p);
            if (!this.instancesDeferred.has(S)) {
              const U = new Yi();
              if (
                (this.instancesDeferred.set(S, U),
                this.isInitialized(S) || this.shouldAutoInitialize())
              )
                try {
                  const ee = this.getOrInitializeService({
                    instanceIdentifier: S,
                  });
                  ee && U.resolve(ee);
                } catch (ee) {}
            }
            return this.instancesDeferred.get(S).promise;
          }
          getImmediate(p) {
            var S;
            const U = this.normalizeInstanceIdentifier(
                p == null ? void 0 : p.identifier
              ),
              ee =
                (S = p == null ? void 0 : p.optional) !== null && S !== void 0
                  ? S
                  : !1;
            if (this.isInitialized(U) || this.shouldAutoInitialize())
              try {
                return this.getOrInitializeService({ instanceIdentifier: U });
              } catch (Se) {
                if (ee) return null;
                throw Se;
              }
            else {
              if (ee) return null;
              throw Error(`Service ${this.name} is not available`);
            }
          }
          getComponent() {
            return this.component;
          }
          setComponent(p) {
            if (p.name !== this.name)
              throw Error(
                `Mismatching Component ${p.name} for Provider ${this.name}.`
              );
            if (this.component)
              throw Error(
                `Component for ${this.name} has already been provided`
              );
            if (((this.component = p), !!this.shouldAutoInitialize())) {
              if (na(p))
                try {
                  this.getOrInitializeService({ instanceIdentifier: zi });
                } catch (S) {}
              for (const [S, U] of this.instancesDeferred.entries()) {
                const ee = this.normalizeInstanceIdentifier(S);
                try {
                  const Se = this.getOrInitializeService({
                    instanceIdentifier: ee,
                  });
                  U.resolve(Se);
                } catch (Se) {}
              }
            }
          }
          clearInstance(p = zi) {
            this.instancesDeferred.delete(p),
              this.instancesOptions.delete(p),
              this.instances.delete(p);
          }
          delete() {
            return Kt(this, null, function* () {
              const p = Array.from(this.instances.values());
              yield Promise.all([
                ...p
                  .filter((S) => "INTERNAL" in S)
                  .map((S) => S.INTERNAL.delete()),
                ...p.filter((S) => "_delete" in S).map((S) => S._delete()),
              ]);
            });
          }
          isComponentSet() {
            return this.component != null;
          }
          isInitialized(p = zi) {
            return this.instances.has(p);
          }
          getOptions(p = zi) {
            return this.instancesOptions.get(p) || {};
          }
          initialize(p = {}) {
            const { options: S = {} } = p,
              U = this.normalizeInstanceIdentifier(p.instanceIdentifier);
            if (this.isInitialized(U))
              throw Error(`${this.name}(${U}) has already been initialized`);
            if (!this.isComponentSet())
              throw Error(`Component ${this.name} has not been registered yet`);
            const ee = this.getOrInitializeService({
              instanceIdentifier: U,
              options: S,
            });
            for (const [Se, Re] of this.instancesDeferred.entries()) {
              const Be = this.normalizeInstanceIdentifier(Se);
              U === Be && Re.resolve(ee);
            }
            return ee;
          }
          onInit(p, S) {
            var U;
            const ee = this.normalizeInstanceIdentifier(S),
              Se =
                (U = this.onInitCallbacks.get(ee)) !== null && U !== void 0
                  ? U
                  : new Set();
            Se.add(p), this.onInitCallbacks.set(ee, Se);
            const Re = this.instances.get(ee);
            return (
              Re && p(Re, ee),
              () => {
                Se.delete(p);
              }
            );
          }
          invokeOnInitCallbacks(p, S) {
            const U = this.onInitCallbacks.get(S);
            if (U)
              for (const ee of U)
                try {
                  ee(p, S);
                } catch (Se) {}
          }
          getOrInitializeService({ instanceIdentifier: p, options: S = {} }) {
            let U = this.instances.get(p);
            if (
              !U &&
              this.component &&
              ((U = this.component.instanceFactory(this.container, {
                instanceIdentifier: ia(p),
                options: S,
              })),
              this.instances.set(p, U),
              this.instancesOptions.set(p, S),
              this.invokeOnInitCallbacks(U, p),
              this.component.onInstanceCreated)
            )
              try {
                this.component.onInstanceCreated(this.container, p, U);
              } catch (ee) {}
            return U || null;
          }
          normalizeInstanceIdentifier(p = zi) {
            return this.component
              ? this.component.multipleInstances
                ? p
                : zi
              : p;
          }
          shouldAutoInitialize() {
            return (
              !!this.component &&
              this.component.instantiationMode !== "EXPLICIT"
            );
          }
        }
        function ia(C) {
          return C === zi ? void 0 : C;
        }
        function na(C) {
          return C.instantiationMode === "EAGER";
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class ra {
          constructor(p) {
            (this.name = p), (this.providers = new Map());
          }
          addComponent(p) {
            const S = this.getProvider(p.name);
            if (S.isComponentSet())
              throw new Error(
                `Component ${p.name} has already been registered with ${this.name}`
              );
            S.setComponent(p);
          }
          addOrOverwriteComponent(p) {
            this.getProvider(p.name).isComponentSet() &&
              this.providers.delete(p.name),
              this.addComponent(p);
          }
          getProvider(p) {
            if (this.providers.has(p)) return this.providers.get(p);
            const S = new sa(p, this);
            return this.providers.set(p, S), S;
          }
          getProviders() {
            return Array.from(this.providers.values());
          }
        }
        /**
         * @license
         * Copyright 2017 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const ir = [];
        var ps;
        (function (C) {
          (C[(C.DEBUG = 0)] = "DEBUG"),
            (C[(C.VERBOSE = 1)] = "VERBOSE"),
            (C[(C.INFO = 2)] = "INFO"),
            (C[(C.WARN = 3)] = "WARN"),
            (C[(C.ERROR = 4)] = "ERROR"),
            (C[(C.SILENT = 5)] = "SILENT");
        })(ps || (ps = {}));
        const wr = {
            debug: ps.DEBUG,
            verbose: ps.VERBOSE,
            info: ps.INFO,
            warn: ps.WARN,
            error: ps.ERROR,
            silent: ps.SILENT,
          },
          aa = ps.INFO,
          oa = {
            [ps.DEBUG]: "log",
            [ps.VERBOSE]: "log",
            [ps.INFO]: "info",
            [ps.WARN]: "warn",
            [ps.ERROR]: "error",
          },
          la = (C, p, ...S) => {
            if (p < C.logLevel) return;
            const U = new Date().toISOString(),
              ee = oa[p];
            if (ee) console[ee](`[${U}]  ${C.name}:`, ...S);
            else
              throw new Error(
                `Attempted to log a message with an invalid logType (value: ${p})`
              );
          };
        class Ir {
          constructor(p) {
            (this.name = p),
              (this._logLevel = aa),
              (this._logHandler = la),
              (this._userLogHandler = null),
              ir.push(this);
          }
          get logLevel() {
            return this._logLevel;
          }
          set logLevel(p) {
            if (!(p in ps))
              throw new TypeError(
                `Invalid value "${p}" assigned to \`logLevel\``
              );
            this._logLevel = p;
          }
          setLogLevel(p) {
            this._logLevel = typeof p == "string" ? wr[p] : p;
          }
          get logHandler() {
            return this._logHandler;
          }
          set logHandler(p) {
            if (typeof p != "function")
              throw new TypeError(
                "Value assigned to `logHandler` must be a function"
              );
            this._logHandler = p;
          }
          get userLogHandler() {
            return this._userLogHandler;
          }
          set userLogHandler(p) {
            this._userLogHandler = p;
          }
          debug(...p) {
            this._userLogHandler && this._userLogHandler(this, ps.DEBUG, ...p),
              this._logHandler(this, ps.DEBUG, ...p);
          }
          log(...p) {
            this._userLogHandler &&
              this._userLogHandler(this, ps.VERBOSE, ...p),
              this._logHandler(this, ps.VERBOSE, ...p);
          }
          info(...p) {
            this._userLogHandler && this._userLogHandler(this, ps.INFO, ...p),
              this._logHandler(this, ps.INFO, ...p);
          }
          warn(...p) {
            this._userLogHandler && this._userLogHandler(this, ps.WARN, ...p),
              this._logHandler(this, ps.WARN, ...p);
          }
          error(...p) {
            this._userLogHandler && this._userLogHandler(this, ps.ERROR, ...p),
              this._logHandler(this, ps.ERROR, ...p);
          }
        }
        function rs(C) {
          ir.forEach((p) => {
            p.setLogLevel(C);
          });
        }
        function _o(C, p) {
          for (const S of ir) {
            let U = null;
            p && p.level && (U = wr[p.level]),
              C === null
                ? (S.userLogHandler = null)
                : (S.userLogHandler = (ee, Se, ...Re) => {
                    const Be = Re.map((qe) => {
                      if (qe == null) return null;
                      if (typeof qe == "string") return qe;
                      if (typeof qe == "number" || typeof qe == "boolean")
                        return qe.toString();
                      if (qe instanceof Error) return qe.message;
                      try {
                        return JSON.stringify(qe);
                      } catch (Et) {
                        return null;
                      }
                    })
                      .filter((qe) => qe)
                      .join(" ");
                    Se >= (U != null ? U : ee.logLevel) &&
                      C({
                        level: ps[Se].toLowerCase(),
                        message: Be,
                        args: Re,
                        type: ee.name,
                      });
                  });
          }
        }
        const Sn = (C, p) => p.some((S) => C instanceof S);
        let Dr, Rr;
        function Or() {
          return (
            Dr ||
            (Dr = [
              IDBDatabase,
              IDBObjectStore,
              IDBIndex,
              IDBCursor,
              IDBTransaction,
            ])
          );
        }
        function ha() {
          return (
            Rr ||
            (Rr = [
              IDBCursor.prototype.advance,
              IDBCursor.prototype.continue,
              IDBCursor.prototype.continuePrimaryKey,
            ])
          );
        }
        const Lr = new WeakMap(),
          nr = new WeakMap(),
          Br = new WeakMap(),
          rr = new WeakMap(),
          ar = new WeakMap();
        function ca(C) {
          const p = new Promise((S, U) => {
            const ee = () => {
                C.removeEventListener("success", Se),
                  C.removeEventListener("error", Re);
              },
              Se = () => {
                S(Mi(C.result)), ee();
              },
              Re = () => {
                U(C.error), ee();
              };
            C.addEventListener("success", Se), C.addEventListener("error", Re);
          });
          return (
            p
              .then((S) => {
                S instanceof IDBCursor && Lr.set(S, C);
              })
              .catch(() => {}),
            ar.set(p, C),
            p
          );
        }
        function da(C) {
          if (nr.has(C)) return;
          const p = new Promise((S, U) => {
            const ee = () => {
                C.removeEventListener("complete", Se),
                  C.removeEventListener("error", Re),
                  C.removeEventListener("abort", Re);
              },
              Se = () => {
                S(), ee();
              },
              Re = () => {
                U(C.error || new DOMException("AbortError", "AbortError")),
                  ee();
              };
            C.addEventListener("complete", Se),
              C.addEventListener("error", Re),
              C.addEventListener("abort", Re);
          });
          nr.set(C, p);
        }
        let ki = {
          get(C, p, S) {
            if (C instanceof IDBTransaction) {
              if (p === "done") return nr.get(C);
              if (p === "objectStoreNames")
                return C.objectStoreNames || Br.get(C);
              if (p === "store")
                return S.objectStoreNames[1]
                  ? void 0
                  : S.objectStore(S.objectStoreNames[0]);
            }
            return Mi(C[p]);
          },
          set(C, p, S) {
            return (C[p] = S), !0;
          },
          has(C, p) {
            return C instanceof IDBTransaction &&
              (p === "done" || p === "store")
              ? !0
              : p in C;
          },
        };
        function ua(C) {
          ki = C(ki);
        }
        function fa(C) {
          return C === IDBDatabase.prototype.transaction &&
            !("objectStoreNames" in IDBTransaction.prototype)
            ? function (p, ...S) {
                const U = C.call(or(this), p, ...S);
                return Br.set(U, p.sort ? p.sort() : [p]), Mi(U);
              }
            : ha().includes(C)
            ? function (...p) {
                return C.apply(or(this), p), Mi(Lr.get(this));
              }
            : function (...p) {
                return Mi(C.apply(or(this), p));
              };
        }
        function pa(C) {
          return typeof C == "function"
            ? fa(C)
            : (C instanceof IDBTransaction && da(C),
              Sn(C, Or()) ? new Proxy(C, ki) : C);
        }
        function Mi(C) {
          if (C instanceof IDBRequest) return ca(C);
          if (rr.has(C)) return rr.get(C);
          const p = pa(C);
          return p !== C && (rr.set(C, p), ar.set(p, C)), p;
        }
        const or = (C) => ar.get(C);
        function lr(
          C,
          p,
          { blocked: S, upgrade: U, blocking: ee, terminated: Se } = {}
        ) {
          const Re = indexedDB.open(C, p),
            Be = Mi(Re);
          return (
            U &&
              Re.addEventListener("upgradeneeded", (qe) => {
                U(
                  Mi(Re.result),
                  qe.oldVersion,
                  qe.newVersion,
                  Mi(Re.transaction),
                  qe
                );
              }),
            S &&
              Re.addEventListener("blocked", (qe) =>
                S(qe.oldVersion, qe.newVersion, qe)
              ),
            Be.then((qe) => {
              Se && qe.addEventListener("close", () => Se()),
                ee &&
                  qe.addEventListener("versionchange", (Et) =>
                    ee(Et.oldVersion, Et.newVersion, Et)
                  );
            }).catch(() => {}),
            Be
          );
        }
        function mo(C, { blocked: p } = {}) {
          const S = indexedDB.deleteDatabase(C);
          return (
            p && S.addEventListener("blocked", (U) => p(U.oldVersion, U)),
            wrap(S).then(() => {})
          );
        }
        const _a = ["get", "getKey", "getAll", "getAllKeys", "count"],
          ma = ["put", "add", "delete", "clear"],
          hr = new Map();
        function Fr(C, p) {
          if (!(C instanceof IDBDatabase && !(p in C) && typeof p == "string"))
            return;
          if (hr.get(p)) return hr.get(p);
          const S = p.replace(/FromIndex$/, ""),
            U = p !== S,
            ee = ma.includes(S);
          if (
            !(S in (U ? IDBIndex : IDBObjectStore).prototype) ||
            !(ee || _a.includes(S))
          )
            return;
          const Se = function (Re, ...Be) {
            return Kt(this, null, function* () {
              const qe = this.transaction(Re, ee ? "readwrite" : "readonly");
              let Et = qe.store;
              return (
                U && (Et = Et.index(Be.shift())),
                (yield Promise.all([Et[S](...Be), ee && qe.done]))[0]
              );
            });
          };
          return hr.set(p, Se), Se;
        }
        ua((C) =>
          dl(cl({}, C), {
            get: (p, S, U) => Fr(p, S) || C.get(p, S, U),
            has: (p, S) => !!Fr(p, S) || C.has(p, S),
          })
        );
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class ga {
          constructor(p) {
            this.container = p;
          }
          getPlatformInfoString() {
            return this.container
              .getProviders()
              .map((S) => {
                if (ya(S)) {
                  const U = S.getImmediate();
                  return `${U.library}/${U.version}`;
                } else return null;
              })
              .filter((S) => S)
              .join(" ");
          }
        }
        function ya(C) {
          const p = C.getComponent();
          return (p == null ? void 0 : p.type) === "VERSION";
        }
        const nn = "@firebase/app",
          cr = "0.10.9";
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Si = new Ir("@firebase/app"),
          va = "@firebase/app-compat",
          Ea = "@firebase/analytics-compat",
          Sa = "@firebase/analytics",
          Ta = "@firebase/app-check-compat",
          xa = "@firebase/app-check",
          Aa = "@firebase/auth",
          Ca = "@firebase/auth-compat",
          Pa = "@firebase/database",
          _s = "@firebase/database-compat",
          ba = "@firebase/functions",
          Ma = "@firebase/functions-compat",
          Bs = "@firebase/installations",
          Ur = "@firebase/installations-compat",
          wa = "@firebase/messaging",
          Ia = "@firebase/messaging-compat",
          Da = "@firebase/performance",
          Ra = "@firebase/performance-compat",
          Nr = "@firebase/remote-config",
          Oa = "@firebase/remote-config-compat",
          Xn = "@firebase/storage",
          zr = "@firebase/storage-compat",
          La = "@firebase/firestore",
          Ba = "@firebase/vertexai-preview",
          Fa = "@firebase/firestore-compat",
          Ua = "firebase",
          go = "10.13.0";
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Yn = "[DEFAULT]",
          Na = {
            [nn]: "fire-core",
            [va]: "fire-core-compat",
            [Sa]: "fire-analytics",
            [Ea]: "fire-analytics-compat",
            [xa]: "fire-app-check",
            [Ta]: "fire-app-check-compat",
            [Aa]: "fire-auth",
            [Ca]: "fire-auth-compat",
            [Pa]: "fire-rtdb",
            [_s]: "fire-rtdb-compat",
            [ba]: "fire-fn",
            [Ma]: "fire-fn-compat",
            [Bs]: "fire-iid",
            [Ur]: "fire-iid-compat",
            [wa]: "fire-fcm",
            [Ia]: "fire-fcm-compat",
            [Da]: "fire-perf",
            [Ra]: "fire-perf-compat",
            [Nr]: "fire-rc",
            [Oa]: "fire-rc-compat",
            [Xn]: "fire-gcs",
            [zr]: "fire-gcs-compat",
            [La]: "fire-fst",
            [Fa]: "fire-fst-compat",
            [Ba]: "fire-vertex",
            "fire-js": "fire-js",
            [Ua]: "fire-js-all",
          };
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Wi = new Map(),
          Tn = new Map(),
          xn = new Map();
        function kr(C, p) {
          try {
            C.container.addComponent(p);
          } catch (S) {
            Si.debug(
              `Component ${p.name} failed to register with FirebaseApp ${C.name}`,
              S
            );
          }
        }
        function yo(C, p) {
          C.container.addOrOverwriteComponent(p);
        }
        function wi(C) {
          const p = C.name;
          if (xn.has(p))
            return (
              Si.debug(
                `There were multiple attempts to register component ${p}.`
              ),
              !1
            );
          xn.set(p, C);
          for (const S of Wi.values()) kr(S, C);
          for (const S of Tn.values()) kr(S, C);
          return !0;
        }
        function An(C, p) {
          const S = C.container
            .getProvider("heartbeat")
            .getImmediate({ optional: !0 });
          return S && S.triggerHeartbeat(), C.container.getProvider(p);
        }
        function vo(C, p, S = Yn) {
          An(C, p).clearInstance(S);
        }
        function za(C) {
          return C.options !== void 0;
        }
        function Eo(C) {
          return C.settings !== void 0;
        }
        function So() {
          xn.clear();
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const ka = {
            "no-app":
              "No Firebase App '{$appName}' has been created - call initializeApp() first",
            "bad-app-name": "Illegal App name: '{$appName}'",
            "duplicate-app":
              "Firebase App named '{$appName}' already exists with different options or config",
            "app-deleted": "Firebase App named '{$appName}' already deleted",
            "server-app-deleted": "Firebase Server App has been deleted",
            "no-options":
              "Need to provide options, when not being deployed to hosting via source.",
            "invalid-app-argument":
              "firebase.{$appName}() takes either no argument or a Firebase App instance.",
            "invalid-log-argument":
              "First argument to `onLog` must be null or a function.",
            "idb-open":
              "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
            "idb-get":
              "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
            "idb-set":
              "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
            "idb-delete":
              "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
            "finalization-registry-not-supported":
              "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
            "invalid-server-app-environment":
              "FirebaseServerApp is not for use in browser environments.",
          },
          ri = new Pi("app", "Firebase", ka);
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class Wr {
          constructor(p, S, U) {
            (this._isDeleted = !1),
              (this._options = Object.assign({}, p)),
              (this._config = Object.assign({}, S)),
              (this._name = S.name),
              (this._automaticDataCollectionEnabled =
                S.automaticDataCollectionEnabled),
              (this._container = U),
              this.container.addComponent(new zs("app", () => this, "PUBLIC"));
          }
          get automaticDataCollectionEnabled() {
            return this.checkDestroyed(), this._automaticDataCollectionEnabled;
          }
          set automaticDataCollectionEnabled(p) {
            this.checkDestroyed(), (this._automaticDataCollectionEnabled = p);
          }
          get name() {
            return this.checkDestroyed(), this._name;
          }
          get options() {
            return this.checkDestroyed(), this._options;
          }
          get config() {
            return this.checkDestroyed(), this._config;
          }
          get container() {
            return this._container;
          }
          get isDeleted() {
            return this._isDeleted;
          }
          set isDeleted(p) {
            this._isDeleted = p;
          }
          checkDestroyed() {
            if (this.isDeleted)
              throw ri.create("app-deleted", { appName: this._name });
          }
        }
        /**
         * @license
         * Copyright 2023 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class Wa extends Wr {
          constructor(p, S, U, ee) {
            const Se =
                S.automaticDataCollectionEnabled !== void 0
                  ? S.automaticDataCollectionEnabled
                  : !1,
              Re = { name: U, automaticDataCollectionEnabled: Se };
            if (p.apiKey !== void 0) super(p, Re, ee);
            else {
              const Be = p;
              super(Be.options, Re, ee);
            }
            (this._serverConfig = Object.assign(
              { automaticDataCollectionEnabled: Se },
              S
            )),
              (this._finalizationRegistry = null),
              typeof FinalizationRegistry != "undefined" &&
                (this._finalizationRegistry = new FinalizationRegistry(() => {
                  this.automaticCleanup();
                })),
              (this._refCount = 0),
              this.incRefCount(this._serverConfig.releaseOnDeref),
              (this._serverConfig.releaseOnDeref = void 0),
              (S.releaseOnDeref = void 0),
              Ti(nn, cr, "serverapp");
          }
          toJSON() {}
          get refCount() {
            return this._refCount;
          }
          incRefCount(p) {
            this.isDeleted ||
              (this._refCount++,
              p !== void 0 &&
                this._finalizationRegistry !== null &&
                this._finalizationRegistry.register(p, this));
          }
          decRefCount() {
            return this.isDeleted ? 0 : --this._refCount;
          }
          automaticCleanup() {
            Ga(this);
          }
          get settings() {
            return this.checkDestroyed(), this._serverConfig;
          }
          checkDestroyed() {
            if (this.isDeleted) throw ri.create("server-app-deleted");
          }
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const To = null;
        function Vr(C, p = {}) {
          let S = C;
          typeof p != "object" && (p = { name: p });
          const U = Object.assign(
              { name: Yn, automaticDataCollectionEnabled: !1 },
              p
            ),
            ee = U.name;
          if (typeof ee != "string" || !ee)
            throw ri.create("bad-app-name", { appName: String(ee) });
          if ((S || (S = Ai()), !S)) throw ri.create("no-options");
          const Se = Wi.get(ee);
          if (Se) {
            if (bi(S, Se.options) && bi(U, Se.config)) return Se;
            throw ri.create("duplicate-app", { appName: ee });
          }
          const Re = new ra(ee);
          for (const qe of xn.values()) Re.addComponent(qe);
          const Be = new Wr(S, U, Re);
          return Wi.set(ee, Be), Be;
        }
        function xo(C, p) {
          if (isBrowser() && !isWebWorker())
            throw ri.create("invalid-server-app-environment");
          p.automaticDataCollectionEnabled === void 0 &&
            (p.automaticDataCollectionEnabled = !1);
          let S;
          za(C) ? (S = C.options) : (S = C);
          const U = Object.assign(Object.assign({}, p), S);
          U.releaseOnDeref !== void 0 && delete U.releaseOnDeref;
          const ee = (Et) =>
            [...Et].reduce(
              (Ct, St) => (Math.imul(31, Ct) + St.charCodeAt(0)) | 0,
              0
            );
          if (
            p.releaseOnDeref !== void 0 &&
            typeof FinalizationRegistry == "undefined"
          )
            throw ri.create("finalization-registry-not-supported", {});
          const Se = "" + ee(JSON.stringify(U)),
            Re = Tn.get(Se);
          if (Re) return Re.incRefCount(p.releaseOnDeref), Re;
          const Be = new ComponentContainer(Se);
          for (const Et of xn.values()) Be.addComponent(Et);
          const qe = new Wa(S, p, Se, Be);
          return Tn.set(Se, qe), qe;
        }
        function Va(C = Yn) {
          const p = Wi.get(C);
          if (!p && C === Yn && Ai()) return Vr();
          if (!p) throw ri.create("no-app", { appName: C });
          return p;
        }
        function Ao() {
          return Array.from(Wi.values());
        }
        function Ga(C) {
          return Kt(this, null, function* () {
            let p = !1;
            const S = C.name;
            Wi.has(S)
              ? ((p = !0), Wi.delete(S))
              : Tn.has(S) && C.decRefCount() <= 0 && (Tn.delete(S), (p = !0)),
              p &&
                (yield Promise.all(
                  C.container.getProviders().map((U) => U.delete())
                ),
                (C.isDeleted = !0));
          });
        }
        function Ti(C, p, S) {
          var U;
          let ee = (U = Na[C]) !== null && U !== void 0 ? U : C;
          S && (ee += `-${S}`);
          const Se = ee.match(/\s|\//),
            Re = p.match(/\s|\//);
          if (Se || Re) {
            const Be = [
              `Unable to register library "${ee}" with version "${p}":`,
            ];
            Se &&
              Be.push(
                `library name "${ee}" contains illegal characters (whitespace or "/")`
              ),
              Se && Re && Be.push("and"),
              Re &&
                Be.push(
                  `version name "${p}" contains illegal characters (whitespace or "/")`
                ),
              Si.warn(Be.join(" "));
            return;
          }
          wi(
            new zs(
              `${ee}-version`,
              () => ({ library: ee, version: p }),
              "VERSION"
            )
          );
        }
        function Co(C, p) {
          if (C !== null && typeof C != "function")
            throw ri.create("invalid-log-argument");
          setUserLogHandler(C, p);
        }
        function Po(C) {
          setLogLevel$1(C);
        }
        /**
         * @license
         * Copyright 2021 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const ja = "firebase-heartbeat-database",
          Ha = 1,
          rn = "firebase-heartbeat-store";
        let dr = null;
        function an() {
          return (
            dr ||
              (dr = lr(ja, Ha, {
                upgrade: (C, p) => {
                  switch (p) {
                    case 0:
                      try {
                        C.createObjectStore(rn);
                      } catch (S) {
                        console.warn(S);
                      }
                  }
                },
              }).catch((C) => {
                throw ri.create("idb-open", {
                  originalErrorMessage: C.message,
                });
              })),
            dr
          );
        }
        function Ka(C) {
          return Kt(this, null, function* () {
            try {
              const S = (yield an()).transaction(rn),
                U = yield S.objectStore(rn).get(Gr(C));
              return yield S.done, U;
            } catch (p) {
              if (p instanceof Hs) Si.warn(p.message);
              else {
                const S = ri.create("idb-get", {
                  originalErrorMessage: p == null ? void 0 : p.message,
                });
                Si.warn(S.message);
              }
            }
          });
        }
        function Zn(C, p) {
          return Kt(this, null, function* () {
            try {
              const U = (yield an()).transaction(rn, "readwrite");
              yield U.objectStore(rn).put(p, Gr(C)), yield U.done;
            } catch (S) {
              if (S instanceof Hs) Si.warn(S.message);
              else {
                const U = ri.create("idb-set", {
                  originalErrorMessage: S == null ? void 0 : S.message,
                });
                Si.warn(U.message);
              }
            }
          });
        }
        function Gr(C) {
          return `${C.name}!${C.options.appId}`;
        }
        /**
         * @license
         * Copyright 2021 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Xa = 1024,
          Ya = 30 * 24 * 60 * 60 * 1e3;
        class Za {
          constructor(p) {
            (this.container = p), (this._heartbeatsCache = null);
            const S = this.container.getProvider("app").getImmediate();
            (this._storage = new Ja(S)),
              (this._heartbeatsCachePromise = this._storage
                .read()
                .then((U) => ((this._heartbeatsCache = U), U)));
          }
          triggerHeartbeat() {
            return Kt(this, null, function* () {
              var p, S, U;
              try {
                const Se = this.container
                    .getProvider("platform-logger")
                    .getImmediate()
                    .getPlatformInfoString(),
                  Re = Ss();
                return (
                  console.log(
                    "heartbeats",
                    (p = this._heartbeatsCache) === null || p === void 0
                      ? void 0
                      : p.heartbeats
                  ),
                  (((S = this._heartbeatsCache) === null || S === void 0
                    ? void 0
                    : S.heartbeats) == null &&
                    ((this._heartbeatsCache = yield this
                      ._heartbeatsCachePromise),
                    ((U = this._heartbeatsCache) === null || U === void 0
                      ? void 0
                      : U.heartbeats) == null)) ||
                  this._heartbeatsCache.lastSentHeartbeatDate === Re ||
                  this._heartbeatsCache.heartbeats.some((Be) => Be.date === Re)
                    ? void 0
                    : (this._heartbeatsCache.heartbeats.push({
                        date: Re,
                        agent: Se,
                      }),
                      (this._heartbeatsCache.heartbeats =
                        this._heartbeatsCache.heartbeats.filter((Be) => {
                          const qe = new Date(Be.date).valueOf();
                          return Date.now() - qe <= Ya;
                        })),
                      this._storage.overwrite(this._heartbeatsCache))
                );
              } catch (ee) {
                Si.warn(ee);
              }
            });
          }
          getHeartbeatsHeader() {
            return Kt(this, null, function* () {
              var p;
              try {
                if (
                  (this._heartbeatsCache === null &&
                    (yield this._heartbeatsCachePromise),
                  ((p = this._heartbeatsCache) === null || p === void 0
                    ? void 0
                    : p.heartbeats) == null ||
                    this._heartbeatsCache.heartbeats.length === 0)
                )
                  return "";
                const S = Ss(),
                  { heartbeatsToSend: U, unsentEntries: ee } = Qa(
                    this._heartbeatsCache.heartbeats
                  ),
                  Se = qt(JSON.stringify({ version: 2, heartbeats: U }));
                return (
                  (this._heartbeatsCache.lastSentHeartbeatDate = S),
                  ee.length > 0
                    ? ((this._heartbeatsCache.heartbeats = ee),
                      yield this._storage.overwrite(this._heartbeatsCache))
                    : ((this._heartbeatsCache.heartbeats = []),
                      this._storage.overwrite(this._heartbeatsCache)),
                  Se
                );
              } catch (S) {
                return Si.warn(S), "";
              }
            });
          }
        }
        function Ss() {
          return new Date().toISOString().substring(0, 10);
        }
        function Qa(C, p = Xa) {
          const S = [];
          let U = C.slice();
          for (const ee of C) {
            const Se = S.find((Re) => Re.agent === ee.agent);
            if (Se) {
              if ((Se.dates.push(ee.date), jr(S) > p)) {
                Se.dates.pop();
                break;
              }
            } else if (
              (S.push({ agent: ee.agent, dates: [ee.date] }), jr(S) > p)
            ) {
              S.pop();
              break;
            }
            U = U.slice(1);
          }
          return { heartbeatsToSend: S, unsentEntries: U };
        }
        class Ja {
          constructor(p) {
            (this.app = p),
              (this._canUseIndexedDBPromise =
                this.runIndexedDBEnvironmentCheck());
          }
          runIndexedDBEnvironmentCheck() {
            return Kt(this, null, function* () {
              return qi()
                ? en()
                    .then(() => !0)
                    .catch(() => !1)
                : !1;
            });
          }
          read() {
            return Kt(this, null, function* () {
              if (yield this._canUseIndexedDBPromise) {
                const S = yield Ka(this.app);
                return S != null && S.heartbeats ? S : { heartbeats: [] };
              } else return { heartbeats: [] };
            });
          }
          overwrite(p) {
            return Kt(this, null, function* () {
              var S;
              if (yield this._canUseIndexedDBPromise) {
                const ee = yield this.read();
                return Zn(this.app, {
                  lastSentHeartbeatDate:
                    (S = p.lastSentHeartbeatDate) !== null && S !== void 0
                      ? S
                      : ee.lastSentHeartbeatDate,
                  heartbeats: p.heartbeats,
                });
              } else return;
            });
          }
          add(p) {
            return Kt(this, null, function* () {
              var S;
              if (yield this._canUseIndexedDBPromise) {
                const ee = yield this.read();
                return Zn(this.app, {
                  lastSentHeartbeatDate:
                    (S = p.lastSentHeartbeatDate) !== null && S !== void 0
                      ? S
                      : ee.lastSentHeartbeatDate,
                  heartbeats: [...ee.heartbeats, ...p.heartbeats],
                });
              } else return;
            });
          }
        }
        function jr(C) {
          return qt(JSON.stringify({ version: 2, heartbeats: C })).length;
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function $a(C) {
          wi(new zs("platform-logger", (p) => new ga(p), "PRIVATE")),
            wi(new zs("heartbeat", (p) => new Za(p), "PRIVATE")),
            Ti(nn, cr, C),
            Ti(nn, cr, "esm2017"),
            Ti("fire-js", "");
        }
        $a("");
        var qa = "firebase",
          eo = "10.13.0";
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ Ti(qa, eo, "app");
        const Hr = "@firebase/installations",
          ur = "0.6.8";
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Kr = 1e4,
          Xr = `w:${ur}`,
          Yr = "FIS_v2",
          to = "https://firebaseinstallations.googleapis.com/v1",
          Yt = 60 * 60 * 1e3,
          Wt = "installations",
          oe = "Installations";
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Ee = {
            "missing-app-config-values":
              'Missing App configuration value: "{$valueName}"',
            "not-registered": "Firebase Installation is not registered.",
            "installation-not-found": "Firebase Installation not found.",
            "request-failed":
              '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
            "app-offline": "Could not process request. Application offline.",
            "delete-pending-registration":
              "Can't delete installation while there is a pending registration request.",
          },
          be = new Pi(Wt, oe, Ee);
        function We(C) {
          return C instanceof Hs && C.code.includes("request-failed");
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function He({ projectId: C }) {
          return `${to}/projects/${C}/installations`;
        }
        function st(C) {
          return {
            token: C.token,
            requestStatus: 2,
            expiresIn: Dt(C.expiresIn),
            creationTime: Date.now(),
          };
        }
        function dt(C, p) {
          return Kt(this, null, function* () {
            const U = (yield p.json()).error;
            return be.create("request-failed", {
              requestName: C,
              serverCode: U.code,
              serverMessage: U.message,
              serverStatus: U.status,
            });
          });
        }
        function pt({ apiKey: C }) {
          return new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-goog-api-key": C,
          });
        }
        function Mt(C, { refreshToken: p }) {
          const S = pt(C);
          return S.append("Authorization", Gt(p)), S;
        }
        function It(C) {
          return Kt(this, null, function* () {
            const p = yield C();
            return p.status >= 500 && p.status < 600 ? C() : p;
          });
        }
        function Dt(C) {
          return Number(C.replace("s", "000"));
        }
        function Gt(C) {
          return `${Yr} ${C}`;
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Vt(U, ee) {
          return Kt(
            this,
            arguments,
            function* (
              { appConfig: C, heartbeatServiceProvider: p },
              { fid: S }
            ) {
              const Se = He(C),
                Re = pt(C),
                Be = p.getImmediate({ optional: !0 });
              if (Be) {
                const St = yield Be.getHeartbeatsHeader();
                St && Re.append("x-firebase-client", St);
              }
              const qe = {
                  fid: S,
                  authVersion: Yr,
                  appId: C.appId,
                  sdkVersion: Xr,
                },
                Et = { method: "POST", headers: Re, body: JSON.stringify(qe) },
                Ct = yield It(() => fetch(Se, Et));
              if (Ct.ok) {
                const St = yield Ct.json();
                return {
                  fid: St.fid || S,
                  registrationStatus: 2,
                  refreshToken: St.refreshToken,
                  authToken: st(St.authToken),
                };
              } else throw yield dt("Create Installation", Ct);
            }
          );
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Jt(C) {
          return new Promise((p) => {
            setTimeout(p, C);
          });
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function ms(C) {
          return btoa(String.fromCharCode(...C))
            .replace(/\+/g, "-")
            .replace(/\//g, "_");
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const ks = /^[cdef][\w-]{21}$/,
          Ds = "";
        function qs() {
          try {
            const C = new Uint8Array(17);
            (self.crypto || self.msCrypto).getRandomValues(C),
              (C[0] = 112 + (C[0] % 16));
            const S = vi(C);
            return ks.test(S) ? S : Ds;
          } catch (C) {
            return Ds;
          }
        }
        function vi(C) {
          return ms(C).substr(0, 22);
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function di(C) {
          return `${C.appName}!${C.appId}`;
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const cs = new Map();
        function hs(C, p) {
          const S = di(C);
          ai(S, p), ws(S, p);
        }
        function as(C, p) {
          ei();
          const S = di(C);
          let U = cs.get(S);
          U || ((U = new Set()), cs.set(S, U)), U.add(p);
        }
        function Es(C, p) {
          const S = di(C),
            U = cs.get(S);
          U && (U.delete(p), U.size === 0 && cs.delete(S), Ws());
        }
        function ai(C, p) {
          const S = cs.get(C);
          if (S) for (const U of S) U(p);
        }
        function ws(C, p) {
          const S = ei();
          S && S.postMessage({ key: C, fid: p }), Ws();
        }
        let xs = null;
        function ei() {
          return (
            !xs &&
              "BroadcastChannel" in self &&
              ((xs = new BroadcastChannel("[Firebase] FID Change")),
              (xs.onmessage = (C) => {
                ai(C.data.key, C.data.fid);
              })),
            xs
          );
        }
        function Ws() {
          cs.size === 0 && xs && (xs.close(), (xs = null));
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const on = "firebase-installations-database",
          Ii = 1,
          gs = "firebase-installations-store";
        let Vs = null;
        function ti() {
          return (
            Vs ||
              (Vs = lr(on, Ii, {
                upgrade: (C, p) => {
                  switch (p) {
                    case 0:
                      C.createObjectStore(gs);
                  }
                },
              })),
            Vs
          );
        }
        function Ks(C, p) {
          return Kt(this, null, function* () {
            const S = di(C),
              ee = (yield ti()).transaction(gs, "readwrite"),
              Se = ee.objectStore(gs),
              Re = yield Se.get(S);
            return (
              yield Se.put(p, S),
              yield ee.done,
              (!Re || Re.fid !== p.fid) && hs(C, p.fid),
              p
            );
          });
        }
        function fr(C) {
          return Kt(this, null, function* () {
            const p = di(C),
              U = (yield ti()).transaction(gs, "readwrite");
            yield U.objectStore(gs).delete(p), yield U.done;
          });
        }
        function Fs(C, p) {
          return Kt(this, null, function* () {
            const S = di(C),
              ee = (yield ti()).transaction(gs, "readwrite"),
              Se = ee.objectStore(gs),
              Re = yield Se.get(S),
              Be = p(Re);
            return (
              Be === void 0 ? yield Se.delete(S) : yield Se.put(Be, S),
              yield ee.done,
              Be && (!Re || Re.fid !== Be.fid) && hs(C, Be.fid),
              Be
            );
          });
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Us(C) {
          return Kt(this, null, function* () {
            let p;
            const S = yield Fs(C.appConfig, (U) => {
              const ee = pl(U),
                Se = _l(C, ee);
              return (p = Se.registrationPromise), Se.installationEntry;
            });
            return S.fid === Ds
              ? { installationEntry: yield p }
              : { installationEntry: S, registrationPromise: p };
          });
        }
        function pl(C) {
          const p = C || { fid: qs(), registrationStatus: 0 };
          return Mo(p);
        }
        function _l(C, p) {
          if (p.registrationStatus === 0) {
            if (!navigator.onLine) {
              const ee = Promise.reject(be.create("app-offline"));
              return { installationEntry: p, registrationPromise: ee };
            }
            const S = {
                fid: p.fid,
                registrationStatus: 1,
                registrationTime: Date.now(),
              },
              U = ml(C, S);
            return { installationEntry: S, registrationPromise: U };
          } else
            return p.registrationStatus === 1
              ? { installationEntry: p, registrationPromise: gl(C) }
              : { installationEntry: p };
        }
        function ml(C, p) {
          return Kt(this, null, function* () {
            try {
              const S = yield Vt(C, p);
              return Ks(C.appConfig, S);
            } catch (S) {
              throw (
                (We(S) && S.customData.serverCode === 409
                  ? yield fr(C.appConfig)
                  : yield Ks(C.appConfig, {
                      fid: p.fid,
                      registrationStatus: 0,
                    }),
                S)
              );
            }
          });
        }
        function gl(C) {
          return Kt(this, null, function* () {
            let p = yield bo(C.appConfig);
            for (; p.registrationStatus === 1; )
              yield Jt(100), (p = yield bo(C.appConfig));
            if (p.registrationStatus === 0) {
              const { installationEntry: S, registrationPromise: U } = yield Us(
                C
              );
              return U || S;
            }
            return p;
          });
        }
        function bo(C) {
          return Fs(C, (p) => {
            if (!p) throw be.create("installation-not-found");
            return Mo(p);
          });
        }
        function Mo(C) {
          return yl(C) ? { fid: C.fid, registrationStatus: 0 } : C;
        }
        function yl(C) {
          return (
            C.registrationStatus === 1 && C.registrationTime + Kr < Date.now()
          );
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function vl(U, ee) {
          return Kt(
            this,
            arguments,
            function* ({ appConfig: C, heartbeatServiceProvider: p }, S) {
              const Se = El(C, S),
                Re = Mt(C, S),
                Be = p.getImmediate({ optional: !0 });
              if (Be) {
                const St = yield Be.getHeartbeatsHeader();
                St && Re.append("x-firebase-client", St);
              }
              const qe = { installation: { sdkVersion: Xr, appId: C.appId } },
                Et = { method: "POST", headers: Re, body: JSON.stringify(qe) },
                Ct = yield It(() => fetch(Se, Et));
              if (Ct.ok) {
                const St = yield Ct.json();
                return st(St);
              } else throw yield dt("Generate Auth Token", Ct);
            }
          );
        }
        function El(C, { fid: p }) {
          return `${He(C)}/${p}/authTokens:generate`;
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function so(C, p = !1) {
          return Kt(this, null, function* () {
            let S;
            const U = yield Fs(C.appConfig, (Se) => {
              if (!Io(Se)) throw be.create("not-registered");
              const Re = Se.authToken;
              if (!p && xl(Re)) return Se;
              if (Re.requestStatus === 1) return (S = Sl(C, p)), Se;
              {
                if (!navigator.onLine) throw be.create("app-offline");
                const Be = Cl(Se);
                return (S = Tl(C, Be)), Be;
              }
            });
            return S ? yield S : U.authToken;
          });
        }
        function Sl(C, p) {
          return Kt(this, null, function* () {
            let S = yield wo(C.appConfig);
            for (; S.authToken.requestStatus === 1; )
              yield Jt(100), (S = yield wo(C.appConfig));
            const U = S.authToken;
            return U.requestStatus === 0 ? so(C, p) : U;
          });
        }
        function wo(C) {
          return Fs(C, (p) => {
            if (!Io(p)) throw be.create("not-registered");
            const S = p.authToken;
            return Pl(S)
              ? Object.assign(Object.assign({}, p), {
                  authToken: { requestStatus: 0 },
                })
              : p;
          });
        }
        function Tl(C, p) {
          return Kt(this, null, function* () {
            try {
              const S = yield vl(C, p),
                U = Object.assign(Object.assign({}, p), { authToken: S });
              return yield Ks(C.appConfig, U), S;
            } catch (S) {
              if (
                We(S) &&
                (S.customData.serverCode === 401 ||
                  S.customData.serverCode === 404)
              )
                yield fr(C.appConfig);
              else {
                const U = Object.assign(Object.assign({}, p), {
                  authToken: { requestStatus: 0 },
                });
                yield Ks(C.appConfig, U);
              }
              throw S;
            }
          });
        }
        function Io(C) {
          return C !== void 0 && C.registrationStatus === 2;
        }
        function xl(C) {
          return C.requestStatus === 2 && !Al(C);
        }
        function Al(C) {
          const p = Date.now();
          return p < C.creationTime || C.creationTime + C.expiresIn < p + Yt;
        }
        function Cl(C) {
          const p = { requestStatus: 1, requestTime: Date.now() };
          return Object.assign(Object.assign({}, C), { authToken: p });
        }
        function Pl(C) {
          return C.requestStatus === 1 && C.requestTime + Kr < Date.now();
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function bl(C) {
          return Kt(this, null, function* () {
            const p = C,
              { installationEntry: S, registrationPromise: U } = yield Us(p);
            return (
              U ? U.catch(console.error) : so(p).catch(console.error), S.fid
            );
          });
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Ml(C, p = !1) {
          return Kt(this, null, function* () {
            const S = C;
            return yield wl(S), (yield so(S, p)).token;
          });
        }
        function wl(C) {
          return Kt(this, null, function* () {
            const { registrationPromise: p } = yield Us(C);
            p && (yield p);
          });
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Il(C, p) {
          return Kt(this, null, function* () {
            const S = Dl(C, p),
              ee = { method: "DELETE", headers: Mt(C, p) },
              Se = yield It(() => fetch(S, ee));
            if (!Se.ok) throw yield dt("Delete Installation", Se);
          });
        }
        function Dl(C, { fid: p }) {
          return `${He(C)}/${p}`;
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Cc(C) {
          return Kt(this, null, function* () {
            const { appConfig: p } = C,
              S = yield Fs(p, (U) => {
                if (!(U && U.registrationStatus === 0)) return U;
              });
            if (S) {
              if (S.registrationStatus === 1)
                throw be.create("delete-pending-registration");
              if (S.registrationStatus === 2)
                if (navigator.onLine) yield Il(p, S), yield fr(p);
                else throw be.create("app-offline");
            }
          });
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Pc(C, p) {
          const { appConfig: S } = C;
          return (
            as(S, p),
            () => {
              Es(S, p);
            }
          );
        }
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function bc(C = getApp()) {
          return _getProvider(C, "installations").getImmediate();
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Rl(C) {
          if (!C || !C.options) throw io("App Configuration");
          if (!C.name) throw io("App Name");
          const p = ["projectId", "apiKey", "appId"];
          for (const S of p) if (!C.options[S]) throw io(S);
          return {
            appName: C.name,
            projectId: C.options.projectId,
            apiKey: C.options.apiKey,
            appId: C.options.appId,
          };
        }
        function io(C) {
          return be.create("missing-app-config-values", { valueName: C });
        }
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Do = "installations",
          Ol = "installations-internal",
          Ll = (C) => {
            const p = C.getProvider("app").getImmediate(),
              S = Rl(p),
              U = An(p, "heartbeat");
            return {
              app: p,
              appConfig: S,
              heartbeatServiceProvider: U,
              _delete: () => Promise.resolve(),
            };
          },
          Bl = (C) => {
            const p = C.getProvider("app").getImmediate(),
              S = An(p, Do).getImmediate();
            return { getId: () => bl(S), getToken: (ee) => Ml(S, ee) };
          };
        function Fl() {
          wi(new zs(Do, Ll, "PUBLIC")), wi(new zs(Ol, Bl, "PRIVATE"));
        }
        Fl(), Ti(Hr, ur), Ti(Hr, ur, "esm2017");
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Zr = "analytics",
          Ul = "firebase_id",
          Nl = "origin",
          zl = 60 * 1e3,
          kl =
            "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig",
          no = "https://www.googletagmanager.com/gtag/js";
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Ns = new Ir("@firebase/analytics");
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Wl = {
            "already-exists":
              "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
            "already-initialized":
              "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-initialized instance.",
            "already-initialized-settings":
              "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
            "interop-component-reg-failed":
              "Firebase Analytics Interop Component failed to instantiate: {$reason}",
            "invalid-analytics-context":
              "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
            "indexeddb-unavailable":
              "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
            "fetch-throttle":
              "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
            "config-fetch-failed":
              "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
            "no-api-key":
              'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
            "no-app-id":
              'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.',
            "no-client-id": 'The "client_id" field is empty.',
            "invalid-gtag-resource":
              "Trusted Types detected an invalid gtag resource: {$gtagURL}.",
          },
          si = new Pi("analytics", "Analytics", Wl);
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function Vl(C) {
          if (!C.startsWith(no)) {
            const p = si.create("invalid-gtag-resource", { gtagURL: C });
            return Ns.warn(p.message), "";
          }
          return C;
        }
        function Ro(C) {
          return Promise.all(C.map((p) => p.catch((S) => S)));
        }
        function Gl(C, p) {
          let S;
          return (
            window.trustedTypes && (S = window.trustedTypes.createPolicy(C, p)),
            S
          );
        }
        function jl(C, p) {
          const S = Gl("firebase-js-sdk-policy", { createScriptURL: Vl }),
            U = document.createElement("script"),
            ee = `${no}?l=${C}&id=${p}`;
          (U.src = S ? (S == null ? void 0 : S.createScriptURL(ee)) : ee),
            (U.async = !0),
            document.head.appendChild(U);
        }
        function Hl(C) {
          let p = [];
          return (
            Array.isArray(window[C]) ? (p = window[C]) : (window[C] = p), p
          );
        }
        function Kl(C, p, S, U, ee, Se) {
          return Kt(this, null, function* () {
            const Re = U[ee];
            try {
              if (Re) yield p[Re];
              else {
                const qe = (yield Ro(S)).find((Et) => Et.measurementId === ee);
                qe && (yield p[qe.appId]);
              }
            } catch (Be) {
              Ns.error(Be);
            }
            C("config", ee, Se);
          });
        }
        function Xl(C, p, S, U, ee) {
          return Kt(this, null, function* () {
            try {
              let Se = [];
              if (ee && ee.send_to) {
                let Re = ee.send_to;
                Array.isArray(Re) || (Re = [Re]);
                const Be = yield Ro(S);
                for (const qe of Re) {
                  const Et = Be.find((St) => St.measurementId === qe),
                    Ct = Et && p[Et.appId];
                  if (Ct) Se.push(Ct);
                  else {
                    Se = [];
                    break;
                  }
                }
              }
              Se.length === 0 && (Se = Object.values(p)),
                yield Promise.all(Se),
                C("event", U, ee || {});
            } catch (Se) {
              Ns.error(Se);
            }
          });
        }
        function Yl(C, p, S, U) {
          function ee(Se, ...Re) {
            return Kt(this, null, function* () {
              try {
                if (Se === "event") {
                  const [Be, qe] = Re;
                  yield Xl(C, p, S, Be, qe);
                } else if (Se === "config") {
                  const [Be, qe] = Re;
                  yield Kl(C, p, S, U, Be, qe);
                } else if (Se === "consent") {
                  const [Be, qe] = Re;
                  C("consent", Be, qe);
                } else if (Se === "get") {
                  const [Be, qe, Et] = Re;
                  C("get", Be, qe, Et);
                } else if (Se === "set") {
                  const [Be] = Re;
                  C("set", Be);
                } else C(Se, ...Re);
              } catch (Be) {
                Ns.error(Be);
              }
            });
          }
          return ee;
        }
        function Zl(C, p, S, U, ee) {
          let Se = function (...Re) {
            window[U].push(arguments);
          };
          return (
            window[ee] && typeof window[ee] == "function" && (Se = window[ee]),
            (window[ee] = Yl(Se, C, p, S)),
            { gtagCore: Se, wrappedGtag: window[ee] }
          );
        }
        function Ql(C) {
          const p = window.document.getElementsByTagName("script");
          for (const S of Object.values(p))
            if (S.src && S.src.includes(no) && S.src.includes(C)) return S;
          return null;
        }
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ const Jl = 30,
          $l = 1e3;
        class ql {
          constructor(p = {}, S = $l) {
            (this.throttleMetadata = p), (this.intervalMillis = S);
          }
          getThrottleMetadata(p) {
            return this.throttleMetadata[p];
          }
          setThrottleMetadata(p, S) {
            this.throttleMetadata[p] = S;
          }
          deleteThrottleMetadata(p) {
            delete this.throttleMetadata[p];
          }
        }
        const Oo = new ql();
        function eh(C) {
          return new Headers({
            Accept: "application/json",
            "x-goog-api-key": C,
          });
        }
        function th(C) {
          return Kt(this, null, function* () {
            var p;
            const { appId: S, apiKey: U } = C,
              ee = { method: "GET", headers: eh(U) },
              Se = kl.replace("{app-id}", S),
              Re = yield fetch(Se, ee);
            if (Re.status !== 200 && Re.status !== 304) {
              let Be = "";
              try {
                const qe = yield Re.json();
                !((p = qe.error) === null || p === void 0) &&
                  p.message &&
                  (Be = qe.error.message);
              } catch (qe) {}
              throw si.create("config-fetch-failed", {
                httpStatus: Re.status,
                responseMessage: Be,
              });
            }
            return Re.json();
          });
        }
        function sh(U) {
          return Kt(this, arguments, function* (C, p = Oo, S) {
            const { appId: ee, apiKey: Se, measurementId: Re } = C.options;
            if (!ee) throw si.create("no-app-id");
            if (!Se) {
              if (Re) return { measurementId: Re, appId: ee };
              throw si.create("no-api-key");
            }
            const Be = p.getThrottleMetadata(ee) || {
                backoffCount: 0,
                throttleEndTimeMillis: Date.now(),
              },
              qe = new rh();
            return (
              setTimeout(
                () =>
                  Kt(this, null, function* () {
                    qe.abort();
                  }),
                S !== void 0 ? S : zl
              ),
              Lo({ appId: ee, apiKey: Se, measurementId: Re }, Be, qe, p)
            );
          });
        }
        function Lo(Se, Re, Be) {
          return Kt(
            this,
            arguments,
            function* (
              C,
              { throttleEndTimeMillis: p, backoffCount: S },
              U,
              ee = Oo
            ) {
              var qe;
              const { appId: Et, measurementId: Ct } = C;
              try {
                yield ih(U, p);
              } catch (St) {
                if (Ct)
                  return (
                    Ns.warn(
                      `Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${Ct} provided in the "measurementId" field in the local Firebase config. [${
                        St == null ? void 0 : St.message
                      }]`
                    ),
                    { appId: Et, measurementId: Ct }
                  );
                throw St;
              }
              try {
                const St = yield th(C);
                return ee.deleteThrottleMetadata(Et), St;
              } catch (St) {
                const jt = St;
                if (!nh(jt)) {
                  if ((ee.deleteThrottleMetadata(Et), Ct))
                    return (
                      Ns.warn(
                        `Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${Ct} provided in the "measurementId" field in the local Firebase config. [${
                          jt == null ? void 0 : jt.message
                        }]`
                      ),
                      { appId: Et, measurementId: Ct }
                    );
                  throw St;
                }
                const ts =
                    Number(
                      (qe = jt == null ? void 0 : jt.customData) === null ||
                        qe === void 0
                        ? void 0
                        : qe.httpStatus
                    ) === 503
                      ? Hn(S, ee.intervalMillis, Jl)
                      : Hn(S, ee.intervalMillis),
                  ys = {
                    throttleEndTimeMillis: Date.now() + ts,
                    backoffCount: S + 1,
                  };
                return (
                  ee.setThrottleMetadata(Et, ys),
                  Ns.debug(`Calling attemptFetch again in ${ts} millis`),
                  Lo(C, ys, U, ee)
                );
              }
            }
          );
        }
        function ih(C, p) {
          return new Promise((S, U) => {
            const ee = Math.max(p - Date.now(), 0),
              Se = setTimeout(S, ee);
            C.addEventListener(() => {
              clearTimeout(Se),
                U(si.create("fetch-throttle", { throttleEndTimeMillis: p }));
            });
          });
        }
        function nh(C) {
          if (!(C instanceof Hs) || !C.customData) return !1;
          const p = Number(C.customData.httpStatus);
          return p === 429 || p === 500 || p === 503 || p === 504;
        }
        class rh {
          constructor() {
            this.listeners = [];
          }
          addEventListener(p) {
            this.listeners.push(p);
          }
          abort() {
            this.listeners.forEach((p) => p());
          }
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ let ro;
        function ah(C, p, S, U, ee) {
          return Kt(this, null, function* () {
            if (ee && ee.global) {
              C("event", S, U);
              return;
            } else {
              const Se = yield p,
                Re = Object.assign(Object.assign({}, U), { send_to: Se });
              C("event", S, Re);
            }
          });
        }
        function oh(C, p, S, U) {
          return Kt(this, null, function* () {
            if (U && U.global)
              return C("set", { screen_name: S }), Promise.resolve();
            {
              const ee = yield p;
              C("config", ee, { update: !0, screen_name: S });
            }
          });
        }
        function lh(C, p, S, U) {
          return Kt(this, null, function* () {
            if (U && U.global)
              return C("set", { user_id: S }), Promise.resolve();
            {
              const ee = yield p;
              C("config", ee, { update: !0, user_id: S });
            }
          });
        }
        function hh(C, p, S, U) {
          return Kt(this, null, function* () {
            if (U && U.global) {
              const ee = {};
              for (const Se of Object.keys(S))
                ee[`user_properties.${Se}`] = S[Se];
              return C("set", ee), Promise.resolve();
            } else {
              const ee = yield p;
              C("config", ee, { update: !0, user_properties: S });
            }
          });
        }
        function ch(C, p) {
          return Kt(this, null, function* () {
            const S = yield p;
            return new Promise((U, ee) => {
              C("get", S, "client_id", (Se) => {
                Se || ee(si.create("no-client-id")), U(Se);
              });
            });
          });
        }
        function dh(C, p) {
          return Kt(this, null, function* () {
            const S = yield C;
            window[`ga-disable-${S}`] = !p;
          });
        }
        let ao;
        function Bo(C) {
          ao = C;
        }
        function Fo(C) {
          ro = C;
        }
        /**
         * @license
         * Copyright 2020 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ function uh() {
          return Kt(this, null, function* () {
            if (qi())
              try {
                yield en();
              } catch (C) {
                return (
                  Ns.warn(
                    si.create("indexeddb-unavailable", {
                      errorInfo: C == null ? void 0 : C.toString(),
                    }).message
                  ),
                  !1
                );
              }
            else
              return (
                Ns.warn(
                  si.create("indexeddb-unavailable", {
                    errorInfo:
                      "IndexedDB is not available in this environment.",
                  }).message
                ),
                !1
              );
            return !0;
          });
        }
        function fh(C, p, S, U, ee, Se, Re) {
          return Kt(this, null, function* () {
            var Be;
            const qe = sh(C);
            qe
              .then((ts) => {
                (S[ts.measurementId] = ts.appId),
                  C.options.measurementId &&
                    ts.measurementId !== C.options.measurementId &&
                    Ns.warn(
                      `The measurement ID in the local Firebase config (${C.options.measurementId}) does not match the measurement ID fetched from the server (${ts.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`
                    );
              })
              .catch((ts) => Ns.error(ts)),
              p.push(qe);
            const Et = uh().then((ts) => {
                if (ts) return U.getId();
              }),
              [Ct, St] = yield Promise.all([qe, Et]);
            Ql(Se) || jl(Se, Ct.measurementId),
              ao && (ee("consent", "default", ao), Bo(void 0)),
              ee("js", new Date());
            const jt =
              (Be = Re == null ? void 0 : Re.config) !== null && Be !== void 0
                ? Be
                : {};
            return (
              (jt[Nl] = "firebase"),
              (jt.update = !0),
              St != null && (jt[Ul] = St),
              ee("config", Ct.measurementId, jt),
              ro && (ee("set", ro), Fo(void 0)),
              Ct.measurementId
            );
          });
        }
        /**
         * @license
         * Copyright 2019 Google LLC
         *
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         *   http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */ class ph {
          constructor(p) {
            this.app = p;
          }
          _delete() {
            return delete Di[this.app.options.appId], Promise.resolve();
          }
        }
        let Di = {},
          Uo = [];
        const No = {};
        let Qr = "dataLayer",
          zo = "gtag",
          ko,
          Ri,
          oo = !1;
        function Mc(C) {
          if (oo) throw si.create("already-initialized");
          C.dataLayerName && (Qr = C.dataLayerName),
            C.gtagName && (zo = C.gtagName);
        }
        function _h() {
          const C = [];
          if (
            (Ji() && C.push("This is a browser extension environment."),
            Fi() || C.push("Cookies are not available."),
            C.length > 0)
          ) {
            const p = C.map((U, ee) => `(${ee + 1}) ${U}`).join(" "),
              S = si.create("invalid-analytics-context", { errorInfo: p });
            Ns.warn(S.message);
          }
        }
        function mh(C, p, S) {
          _h();
          const U = C.options.appId;
          if (!U) throw si.create("no-app-id");
          if (!C.options.apiKey)
            if (C.options.measurementId)
              Ns.warn(
                `The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${C.options.measurementId} provided in the "measurementId" field in the local Firebase config.`
              );
            else throw si.create("no-api-key");
          if (Di[U] != null) throw si.create("already-exists", { id: U });
          if (!oo) {
            Hl(Qr);
            const { wrappedGtag: Se, gtagCore: Re } = Zl(Di, Uo, No, Qr, zo);
            (Ri = Se), (ko = Re), (oo = !0);
          }
          return (Di[U] = fh(C, Uo, No, p, ko, Qr, S)), new ph(C);
        }
        function gh(C = Va()) {
          C = Kn(C);
          const p = An(C, Zr);
          return p.isInitialized() ? p.getImmediate() : yh(C);
        }
        function yh(C, p = {}) {
          const S = An(C, Zr);
          if (S.isInitialized()) {
            const ee = S.getImmediate();
            if (bi(p, S.getOptions())) return ee;
            throw si.create("already-initialized");
          }
          return S.initialize({ options: p });
        }
        function wc() {
          return Kt(this, null, function* () {
            if (
              isBrowserExtension() ||
              !areCookiesEnabled() ||
              !isIndexedDBAvailable()
            )
              return !1;
            try {
              return yield validateIndexedDBOpenable();
            } catch (C) {
              return !1;
            }
          });
        }
        function Ic(C, p, S) {
          (C = getModularInstance(C)),
            oh(Ri, Di[C.app.options.appId], p, S).catch((U) => Ns.error(U));
        }
        function Dc(C) {
          return Kt(this, null, function* () {
            return (C = getModularInstance(C)), ch(Ri, Di[C.app.options.appId]);
          });
        }
        function Rc(C, p, S) {
          (C = getModularInstance(C)),
            lh(Ri, Di[C.app.options.appId], p, S).catch((U) => Ns.error(U));
        }
        function Oc(C, p, S) {
          (C = getModularInstance(C)),
            hh(Ri, Di[C.app.options.appId], p, S).catch((U) => Ns.error(U));
        }
        function Lc(C, p) {
          (C = getModularInstance(C)),
            dh(Di[C.app.options.appId], p).catch((S) => Ns.error(S));
        }
        function Bc(C) {
          Ri ? Ri("set", C) : Fo(C);
        }
        function Wo(C, p, S, U) {
          (C = Kn(C)),
            ah(Ri, Di[C.app.options.appId], p, S, U).catch((ee) =>
              Ns.error(ee)
            );
        }
        function Fc(C) {
          Ri ? Ri("consent", "update", C) : Bo(C);
        }
        const Vo = "@firebase/analytics",
          Go = "0.10.7";
        function vh() {
          wi(
            new zs(
              Zr,
              (p, { options: S }) => {
                const U = p.getProvider("app").getImmediate(),
                  ee = p.getProvider("installations-internal").getImmediate();
                return mh(U, ee, S);
              },
              "PUBLIC"
            )
          ),
            wi(new zs("analytics-internal", C, "PRIVATE")),
            Ti(Vo, Go),
            Ti(Vo, Go, "esm2017");
          function C(p) {
            try {
              const S = p.getProvider(Zr).getImmediate();
              return { logEvent: (U, ee, Se) => Wo(S, U, ee, Se) };
            } catch (S) {
              throw si.create("interop-component-reg-failed", { reason: S });
            }
          }
        }
        vh();
        var Eh = Object.defineProperty,
          Sh = (C, p, S) =>
            p in C
              ? Eh(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          Th = (C, p, S) => Sh(C, typeof p != "symbol" ? p + "" : p, S);
        class oi {
          static init() {
            Vr({
              apiKey: "AIzaSyAOCqrr-8GmjGnB0HLGyeO4v6wpdosEhZY",
              authDomain: "rolling-ball-h5.firebaseapp.com",
              projectId: "rolling-ball-h5",
              storageBucket: "rolling-ball-h5.appspot.com",
              messagingSenderId: "559360685161",
              appId: "1:559360685161:web:3787d880569529f56cdef8",
              measurementId: "G-985X2GJWDB",
            }),
              (this.analytics = gh());
          }
          static log(p, S) {
            Wo(this.analytics, p, S), console.log(`Event logged: ${p}`, S);
          }
        }
        Th(oi, "analytics");
        const pr = Object.freeze({ LevelGroupCount: 4 }),
          jo = Object.freeze({
            NextLevelButtonClicked: "WinScreen:NextLevelButtonClicked",
          });
        class xh extends Ye {
          constructor() {
            super(a.SCREEN_WIN);
          }
          create() {
            this._initBackground(),
              this._createLevelInfo(),
              this._initCollectedCoin(),
              this._initButtonClaimX2(),
              this._initButtonSkipRewardAds(),
              this._initButtonContinue(),
              this._createCoins(),
              this._createKeys(),
              this._createAnimations();
          }
          _createLevelInfo() {
            (this.line = ze.createEmptyImageElement({
              anchor: new at.Z(0.5, 0.8, 0.5, 0.8),
              pivot: new Ne.Z(0.5, 0.5),
              height: 20,
              width: 300,
              color: new Ae.Q(0.4, 0.4, 0.4),
              y: -150,
            })),
              this.addChild(this.line),
              (this.levelGroup = ze.createGroupElement({
                anchor: new at.Z(0.5, 0.8, 0.5, 0.8),
                y: -150,
              })),
              this.levelGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(80, 0),
              }),
              this.addChild(this.levelGroup),
              (this.levelElements = []);
            for (let p = 0; p < pr.LevelGroupCount; p++) {
              let S = new Xe();
              S.setLocalScale(2, 2, 2),
                this.levelElements.push(S),
                this.levelGroup.addChild(S);
            }
            (this.levelCompleteBg = new o.w("levelCompleteBg")),
              this.levelCompleteBg.addComponent("element", {
                type: "image",
                anchor: new at.Z(-0.1, 0.8, 1.1, 0.8),
                pivot: new Ne.Z(0.5, 0.5),
                height: 120,
                textureAsset: n.find("spr_frame_level_complete"),
              }),
              this.addChild(this.levelCompleteBg),
              (this.textLevelComplete = ze.createTextElement("font_rounded", {
                text: "LEVEL COMPLETED!",
                fontSize: 62,
                color: Ae.Q.WHITE,
              })),
              (this.textLevelComplete.element.outlineColor = new Ae.Q(
                13 / 255,
                160 / 255,
                0
              )),
              (this.textLevelComplete.element.outlineThickness = 0.6),
              this.levelCompleteBg.addChild(this.textLevelComplete),
              (this.levelText = ze.createTextElement("font_rounded", {
                anchor: new at.Z(0.5, 0.8, 0.5, 0.8),
                pivot: new Ne.Z(0.5, 0.5),
                text: "Level 1",
                y: 100,
                fontSize: 62,
                color: Ae.Q.WHITE,
              })),
              (this.levelText.element.outlineColor = Ae.Q.BLACK),
              (this.levelText.element.outlineThickness = 0.6),
              this.addChild(this.levelText);
          }
          updateLevelInfo(p) {
            let S =
                Math.floor((p - 1) / pr.LevelGroupCount) * pr.LevelGroupCount,
              U = S + pr.LevelGroupCount;
            for (let ee = S; ee < U; ee++) {
              let Se = this.levelElements[ee % pr.LevelGroupCount];
              Se.setText(ee + 1),
                ee < p - 1
                  ? Se.setFrame(us.Passed)
                  : ee === p - 1
                  ? (Se.setFrame(us.Current), Se.setIcon("spr_icon_check"))
                  : Se.setFrame(us.Locked),
                ee === U - 1 && Se.setFrame(us.EndInGroup);
            }
            this.levelText.element.text = `Level ${p}`;
          }
          _initBackground() {
            let p = Ge.createColor(0, 0, 0);
            (this.bg = ze.createColorBackground(p)),
              (this.bg.element.opacity = 0.5),
              this.addChild(this.bg);
          }
          _initCollectedCoin() {
            (this.txtCollected = ze.createTextElement("font_rounded", {
              text: "COLLECTED",
              fontSize: 60,
              color: Ge.createColor(255, 255, 255),
              anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
              y: -50,
            })),
              (this.txtCollected.element.outlineColor = Ae.Q.BLACK),
              (this.txtCollected.element.outlineThickness = 0.6),
              this.addChild(this.txtCollected),
              (this.collectedGroup = ze.createGroupElement({ y: -100 })),
              this.collectedGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 1),
                spacing: new Ne.Z(10, 0),
              }),
              this.addChild(this.collectedGroup),
              (this.txtCollectedCoin = ze.createTextElement("font_rounded", {
                text: "0",
                fontSize: 100,
                pivot: new Ne.Z(1, 0.5),
                color: Ae.Q.WHITE,
              })),
              (this.txtCollectedCoin.element.outlineColor = Ae.Q.BLACK),
              (this.txtCollectedCoin.element.outlineThickness = 0.6),
              this.collectedGroup.addChild(this.txtCollectedCoin),
              (this.imgCoin = ze.createImageElement("spr_coin", {
                scale: 0.75,
              })),
              this.collectedGroup.addChild(this.imgCoin),
              this.imgCoin.setLocalPosition(0, 10, 0);
          }
          updateRewardCoin(p) {
            this.txtCollectedCoin.element.text = p;
          }
          _createCoins() {
            (this.coinBackground = new o.w("coinBackground")),
              this.coinBackground.addComponent("element", {
                type: "image",
                anchor: new at.Z(1, 1, 1, 1),
                pivot: new Ne.Z(1, 1),
                width: 130,
                height: 50,
                color: new Ae.Q(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.coinBackground.setLocalPosition(-10, -20, 0),
              this.addChild(this.coinBackground),
              (this.coinIcon = ze.createImageElement("spr_icon_coin_reward", {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                pivot: new Ne.Z(1, 0.5),
                x: -10,
                scale: 0.8,
              })),
              this.coinBackground.addChild(this.coinIcon),
              (this.coinText = ze.createTextElement("font_rounded", {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                pivot: new Ne.Z(1, 0.5),
                text: "0",
                fontSize: 46,
                color: Ae.Q.WHITE,
                x: -80,
                y: -5,
              })),
              (this.coinText.element.autoWidth = !0),
              this.coinBackground.addChild(this.coinText);
          }
          updateCoins(p) {
            (this.coinText.element.text = p),
              setTimeout(() => {
                this.coinBackground.element.width =
                  this.coinText.element.width + 90;
              }, 1);
          }
          _createKeys() {
            (this.keyBackground = new o.w("keyBackground")),
              this.keyBackground.addComponent("element", {
                type: "image",
                anchor: new at.Z(0, 1, 0, 1),
                pivot: new Ne.Z(0, 1),
                width: 150,
                height: 50,
                color: new Ae.Q(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.keyBackground.setLocalPosition(10, -20, 0),
              this.addChild(this.keyBackground),
              (this.keyGroup = ze.createGroupElement()),
              this.keyGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(10, 0),
              }),
              this.keyBackground.addChild(this.keyGroup),
              (this.keys = []);
            for (let p = 0; p < a.TOTAL_KEY_TO_COLLECT; p++) {
              let S = ze.createImageElement("spr_icon_key", { scale: 0.8 });
              this.keys.push(S), this.keyGroup.addChild(S);
            }
          }
          updateKeys(p) {
            p > a.TOTAL_KEY_TO_COLLECT && (p = a.TOTAL_KEY_TO_COLLECT);
            for (let S = 0; S < this.keys.length; S++) {
              let U = this.keys[S];
              S < p
                ? (U.element.textureAsset = n.find("spr_icon_key"))
                : (U.element.textureAsset = n.find("spr_icon_key_gray"));
            }
          }
          _initButtonSkipRewardAds() {
            (this.btnSkipReward = ze.createTextElement("font_rounded", {
              anchor: new at.Z(0.5, 0.3, 0.5, 0.3),
              y: -200,
              text: "No Thanks",
              fontSize: 52,
              color: new Ae.Q(0.5, 0.5, 0.5),
            })),
              (this.enabled = !1),
              this.addChild(this.btnSkipReward),
              Ge.registerOnTouch(
                this.btnSkipReward.element,
                this._onNextLevelButtonClicked,
                this
              ),
              (this.tweenShowButtonSkip = Me.createCountTween({
                delay: 2,
                duration: 0.5,
                onStart: () => {
                  (this.btnSkipReward.enabled = !0),
                    (this.btnSkipReward.element.opacity = 0);
                },
                onUpdate: (p) => {
                  this.btnSkipReward.element.opacity = p.percent;
                },
              }));
          }
          _initButtonClaimX2() {
            (this.btnClaimX2 = ze.createButtonElement("spr_button_claim_x2", {
              anchor: new at.Z(0.5, 0.3, 0.5, 0.3),
              y: -80,
              scale: 0.8,
            })),
              this.addChild(this.btnClaimX2),
              Ge.registerOnTouch(
                this.btnClaimX2.element,
                this._onClaimX2ButtonClicked,
                this
              ),
              (this.buttonClaimTween = Me.createScaleTween(
                this.btnClaimX2,
                { x: 1.2, y: 1.2, z: 1.2 },
                {
                  duration: 0.4,
                  easing: Me.Easing.Quadratic.InOut,
                  yoyo: !0,
                  loop: !0,
                }
              ).start());
          }
          _initButtonContinue() {
            (this.btnContinue = ze.createButtonElement("spr_button_continue", {
              anchor: new at.Z(0.5, 0.3, 0.5, 0.3),
              y: -80,
              scale: 0.8,
            })),
              this.addChild(this.btnContinue),
              Ge.registerOnTouch(
                this.btnContinue.element,
                this._onNextLevelButtonClicked,
                this
              );
          }
          _onClaimX2ButtonClicked() {
            f.play("sfx_click"),
              (this.btnClaimX2.enabled = !1),
              this.buttonClaimTween.stop(),
              this.tweenShowButtonSkip.stop(),
              Ht.pause(),
              (Ht.resumeable = !1),
              Ts.showRewardAds((p) => {
                Ht.resume(),
                  (Ht.resumeable = !0),
                  (this.btnSkipReward.enabled = !1),
                  p
                    ? alert(p)
                    : (oi.log("reward_show", { case: "increase_coin_on_win" }),
                      (Cs.instance.coinCount *= 2),
                      this.updateRewardCoin(Cs.instance.coinCount)),
                  setTimeout(() => {
                    this._onNextLevelButtonClicked();
                  }, 500);
              });
          }
          _onNextLevelButtonClicked() {
            this.buttonClaimTween.stop(),
              (this.btnSkipReward.enabled = !1),
              f.play("sfx_click");
            let p = Math.floor(this.txtCollectedCoin.element.text),
              S = Math.floor(this.coinText.element.text);
            Me.createTween(
              { reward: p, coin: S },
              { reward: 0, coin: S + p },
              {
                duration: 0.5,
                onUpdate: (U) => {
                  this.updateRewardCoin(Math.floor(U.reward)),
                    this.updateCoins(Math.floor(U.coin));
                },
                onComplete: () => {
                  this.fire(jo.NextLevelButtonClicked);
                },
              }
            ).start();
          }
          _createAnimations() {
            (this._appearAnimations = []), (this._disappearAnimations = []);
            let p = { duration: 0.4, easing: Me.Easing.Back.Out };
            this._appearAnimations.push(
              Fe.createTransitionAppearTween(this.line, gt.LeftToRight, p)
            ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.levelGroup,
                  gt.LeftToRight,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.levelText,
                  gt.LeftToRight,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.coinBackground,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.keyBackground,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.levelCompleteBg,
                  gt.LeftToRight,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.btnClaimX2,
                  gt.BottomToTop,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.btnSkipReward,
                  gt.BottomToTop,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.txtCollected,
                  gt.BottomToTop,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.collectedGroup,
                  gt.BottomToTop,
                  p
                )
              );
          }
          checkRewardAdsReady() {
            this.checkRewardAdsIntervalID = setInterval(() => {
              Ts.checkIsRewardAdsReady((p) => {
                p
                  ? ((this.btnClaimX2.enabled = !0),
                    (this.btnContinue.enabled = !1),
                    (this.isRewardAdsReady = !0),
                    clearInterval(this.checkRewardAdsIntervalID))
                  : ((this.btnClaimX2.enabled = !1),
                    (this.btnContinue.enabled = !0),
                    (this.isRewardAdsReady = !1));
              });
            }, 1e3);
          }
          onEnable() {
            var p;
            (p = this._disappearAnimations) == null ||
              p.forEach((S) => S.stop()),
              this._appearAnimations.forEach((S) => S.start()),
              this.tweenShowButtonSkip.stop(),
              (this.btnSkipReward.enabled = !1),
              (this.btnClaimX2.enabled = !1),
              Ht.pause(),
              (Ht.resumeable = !1),
              Ts.showInterstitialAds(() => {
                oi.log("inter_show", { case: "win" }),
                  Ht.resume(),
                  (Ht.resumeable = !0),
                  this.isRewardAdsReady &&
                    (this.buttonClaimTween.start(),
                    (this.btnClaimX2.enabled = !0),
                    this.tweenShowButtonSkip.start());
              });
          }
        }
        class Ah extends Bt.e {
          constructor(p) {
            var S, U, ee;
            super(p),
              (this.maxSpeed =
                ((S = p.attributes) == null ? void 0 : S.maxSpeed) || 0),
              (this.maxJumpingSpeed =
                ((U = p.attributes) == null ? void 0 : U.maxJumpingSpeed) || 0),
              (this.jumpTime =
                ((ee = p.attributes) == null ? void 0 : ee.jumpTime) || 0),
              (this._rotation = null),
              (this._currentRotation = null),
              (this._screenVector = null);
          }
          initialize() {
            (this.force = new i.e()),
              (this._rotation = new ke.k()),
              (this._currentRotation = new ke.k()),
              (this.speed = 0),
              (this._screenScaleRatio = Ht.height / a.GAME_HEIGHT),
              (this.soundNameRollingFloor = "sfx_rolling_floor"),
              (this.soundNameRollingPipe = "sfx_rolling_pipe"),
              (this.soundNameRollingBridge = "sfx_rolling_bridge"),
              (this.speedSoundFloorThreshold = 4),
              (this.speedSoundPipeThreshold = 1),
              (this.isResetting = !1),
              (this._lastJumpTime = 0),
              (this.pauseSoundTime = 5),
              this.entity;
          }
          postUpdate(p) {
            var S, U;
            if (p === 0) return;
            if (this.isResetting) {
              (this.entity.ballBody.rigidbody.enabled = !0),
                (this.isResetting = !1);
              return;
            }
            this.entity.preVelocity =
              this.entity.ballBody.rigidbody.linearVelocity;
            let ee = this.entity.ballBody.rigidbody.linearVelocity;
            if (
              (this.entity.requestJump &&
                ((ee.y = a.JUMP_FORCE_MULTIPLIER),
                (this.entity.requestJump = !1),
                (this.entity.jumping = !0),
                (this._lastJumpTime = Ft.current)),
              this.entity.requestBoostSpeed)
            ) {
              let Et =
                (U =
                  (S = this.entity._currentCollides.find((Ct) =>
                    Ct.name.includes("road_speed_booster")
                  )) == null
                    ? void 0
                    : S.forward) == null
                  ? void 0
                  : U.clone();
              Et
                ? (ee.add(Et.mulScalar(a.BOOSTER_SPEED_MULTIPLIER * -1)),
                  (this.entity.requestBoostSpeed = !1),
                  (this.entity.boosting = !0),
                  (this._lastJumpTime = Ft.current))
                : (this.entity.requestBoostSpeed = !1);
            }
            this.entity.jumping || this.entity.boosting
              ? Ft.current - this._lastJumpTime > this.jumpTime &&
                ((this.entity.jumping = !1), (this.entity.boosting = !1))
              : (ee.y = Math.min(ee.y, a.MAX_VELOCITY_Y));
            let Se = ee.x,
              Re = ee.z,
              Be = Math.sqrt(Se * Se + Re * Re);
            if (
              (Be > this.maxSpeed && ee.normalize().mulScalar(this.maxSpeed),
              (this.entity.ballBody.rigidbody.linearVelocity = ee),
              (this.speed = Be),
              Be > a.MINIUM_SPEED)
            ) {
              let Et = Math.atan2(ee.x, ee.z) * Lt.D.RAD_TO_DEG,
                Ct = this.entity.getEulerAngles();
              this._rotation.setFromEulerAngles(0, Et, 0),
                this._currentRotation.slerp(
                  this._currentRotation,
                  this._rotation,
                  p * a.BALL_DIRECTION_ROTATE_SPEED
                ),
                this.entity.setRotation(this._currentRotation);
              let St = Ct.x;
              (Ct = this.entity.getEulerAngles()),
                (Ct.x = St),
                this.entity.setEulerAngles(Ct),
                this.entity.setPosition(this.entity.ballBody.getPosition());
            }
            let qe = Be * a.BALL_ROTATION_SPEED * p;
            this.entity.rotateLocal(qe, 0, 0),
              this.entity.getPosition().y < a.DEAD_HEIGHT &&
                this.entity.fire(Pn.Dead),
              this._onRolling(Be);
          }
          _onRolling(p) {
            (p > this.speedSoundFloorThreshold && this.entity.isGrounded()) ||
            (p > this.speedSoundPipeThreshold &&
              this.entity.isRollingOnTheBridged())
              ? (this._playSound(this.soundNameRollingFloor, 1), (this.dt = 0))
              : ((this.dt += 0.1),
                this.dt >= this.pauseSoundTime &&
                  this._stopSound(this.soundNameRollingFloor)),
              p > this.speedSoundPipeThreshold &&
              this.entity.isRollingOnTheRoadPipe()
                ? this._playSound(this.soundNameRollingPipe, 0.4)
                : this._stopSound(this.soundNameRollingPipe);
          }
          _playSound(p, S = 1) {
            f.isPlaying(p) || f.play(p, S, !1);
          }
          _stopSound(p) {
            f.stop(p);
          }
          applyForce(p, S) {
            if (isNaN(this._screenScaleRatio)) {
              this._screenScaleRatio = Ht.height / a.GAME_HEIGHT;
              return;
            }
            let U = a.MAX_FORCE * this._screenScaleRatio * S;
            if (this.entity.isGrounded()) this.force.copy(p).mulScalar(U);
            else if (a.CAN_CONTROL_IN_AIR)
              (U *= 0.2), this.force.copy(p).mulScalar(U);
            else return;
            this.entity.isRollingOnTheRoadPipe() &&
              ((U *= a.ROLLING_PIPE_FORCE), this.force.copy(p).mulScalar(U)),
              this.entity.ballBody.rigidbody.applyForce(this.force);
          }
          getRotation() {
            return this._rotation;
          }
          speedRatio() {
            return this.speed / a.MAX_SPEED;
          }
          reset(p) {
            this._currentRotation.copy(p),
              this._rotation.copy(p),
              (this.entity.ballBody.rigidbody.velocity = new i.e(0, 0, 0)),
              (this.entity.ballBody.rigidbody.linearVelocity = new i.e(
                0,
                0,
                0
              )),
              (this.entity.ballBody.rigidbody.angularVelocity = new i.e(
                0,
                0,
                0
              )),
              (this.entity.ballBody.rigidbody.enabled = !1),
              (this.isResetting = !0);
          }
        }
        class Ch extends Bt.e {
          constructor(p = {}) {
            var S, U, ee, Se;
            super(p),
              (this.target =
                ((S = p.attributes) == null ? void 0 : S.target) || void 0),
              (this.offset =
                ((U = p.attributes) == null ? void 0 : U.offset) ||
                new i.e(0, 0, 0)),
              (this.speed =
                ((ee = p.attributes) == null ? void 0 : ee.speed) || 0.1),
              (this.unbouncingSpeed =
                ((Se = p.attributes) == null ? void 0 : Se.unbouncingSpeed) ||
                10);
          }
          initialize() {
            (this._targetPosition = this.target
              .getPosition()
              .clone()
              .add(this.offset)),
              (this._currentPosition = this._targetPosition.clone()),
              this.entity.setPosition(this._currentPosition),
              (this.isTeleporting = !1);
          }
          update(p) {
            if (this.isTeleporting) {
              this.isTeleporting = !1;
              return;
            }
            let S = this._currentPosition.y;
            this._targetPosition
              .copy(this.target.getPosition())
              .add(this.offset),
              this._currentPosition.lerp(
                this._currentPosition,
                this._targetPosition,
                p * this.speed
              ),
              (this._currentPosition.y = Lt.D.lerp(
                S,
                this._targetPosition.y,
                p * this.unbouncingSpeed
              )),
              this.entity.setPosition(this._currentPosition);
          }
          teleport(p) {
            this._targetPosition.copy(p).add(this.offset),
              this._currentPosition.copy(this._targetPosition),
              this.entity.setPosition(this._currentPosition),
              (this.isTeleporting = !0);
          }
        }
        var Ei = Ut(2358),
          Vi = Ut(5567);
        const _r = Object.freeze({ Spawn: "spawn", Despawn: "despawn" }),
          lo = kt.createScript({
            name: "spawner",
            attributes: {
              class: {},
              args: { default: [] },
              poolSize: { default: 0 },
            },
            initialize() {
              this.pool = [];
            },
            postInitialize() {
              this._createPool();
            },
            spawn(C = null, p = -1) {
              let S = this.pool.pop();
              return (
                S || (S = this.createEntity()),
                (S.enabled = !0),
                S.once(_r.Despawn, () => this.despawn(S)),
                C && (p >= 0 ? C.insertChild(S, p) : C.addChild(S)),
                S.fire(_r.Spawn),
                S
              );
            },
            despawn(C) {
              (C.enabled = !1), C.parent.removeChild(C), this.pool.push(C);
            },
            spawnAt(C, p = null, S = -1) {
              let U = C.getPosition(),
                ee = this.spawn(p || C, S);
              return ee.setPosition(U), ee;
            },
            spawnTo(C, p = null, S = -1) {
              let U = this.spawn(p || this.entity, S);
              return U.setPosition(C), U;
            },
            _createPool: function () {
              for (var C = 0; C < this.poolSize; C++)
                this.pool.push(this.createEntity());
            },
            createEntity() {
              return new this.class(...this.args);
            },
          });
        class Cn extends o.w {
          static playAt(p) {
            this._spawner || this._createPool();
            let S = this._spawner.spawn();
            return S.setPosition(p), S.play(), S;
          }
          static _createPool() {
            let p = new o.w("spawner_hitPipeEffect");
            (this._spawner = p.addScript(lo, { class: Cn, poolSize: 10 })),
              Ht.app.root.addChild(p);
          }
          constructor() {
            super("fx_hit_pipe"),
              this._configParticle(),
              this._initParticle(),
              Ht.app.root.addChild(this);
          }
          _initParticle() {
            this.addComponent("particlesystem", {
              autoPlay: !1,
              loop: !1,
              lifetime: 0.15,
              numParticles: 30,
              rate: 0.001,
              rate2: 0.005,
              blend: Ve.i9,
              colorMap: n.find("tex_outerRay").resource,
              animNumAnimations: 4,
              animNumFrames: 1,
              randomizeAnimIndex: !0,
              animLoop: !0,
              animSpeed: 1,
              startAngle: 0,
              startAngle2: 0,
              scaleGraph: this.scaleGraph1,
              scaleGraph2: this.scaleGraph2,
              localVelocityGraph: this.velocityParticle1Graph1,
              localVelocityGraph2: this.velocityParticle1Graph2,
              emitterExtents: this.emitterExtents,
            });
          }
          _configParticle() {
            (this.velocityParticle1Graph1 = new Ei.K([
              [0, 5],
              [0, 5],
              [0, 5],
            ])),
              (this.velocityParticle1Graph2 = new Ei.K([
                [0, -5],
                [0, -5],
                [0, -5],
              ])),
              (this.scaleGraph1 = new Vi.I([0, 0.1, 0.5, 0.2, 1, 0.1])),
              (this.scaleGraph2 = new Vi.I([0, 0.1, 0.5, 0.2, 1, 0.1])),
              (this.emitterExtents = [0.5, 0, 0.5]);
          }
          play() {
            this.particlesystem.reset(),
              this.particlesystem.play(),
              Me.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this.fire(_r.Despawn);
                },
              });
          }
        }
        class Ph extends Bt.e {
          constructor(p = {}) {
            var S, U, ee, Se;
            super(p),
              (this.target =
                ((S = p.attributes) == null ? void 0 : S.target) || void 0),
              (this.speed =
                ((U = p.attributes) == null ? void 0 : U.speed) || 10),
              (this.minSpeed =
                ((ee = p.attributes) == null ? void 0 : ee.minSpeed) || 0.1),
              (this.ballController =
                ((Se = p.attributes) == null ? void 0 : Se.ballController) ||
                null);
          }
          initialize() {
            (this._currentRotation = this.entity.getRotation().clone()),
              (this._targetRotation = new ke.k()),
              this._targetRotation.copy(this._currentRotation),
              (this.forceUpdate = !1),
              (this.isResetting = !1);
          }
          update(p) {
            if (this.isResetting) {
              this.isResetting = !1;
              return;
            }
            if (this.target.linearVelocity.length() < this.minSpeed) return;
            let S = this.speed * p;
            this.forceUpdate || (S *= this.ballController.speedRatio()),
              (this._targetRotation = H(
                this.target.linearVelocity,
                i.e.UP,
                this._targetRotation
              )),
              this._currentRotation.slerp(
                this._currentRotation,
                this._targetRotation,
                S
              ),
              this.entity.setRotation(this._currentRotation);
          }
          reset(p) {
            this._currentRotation.copy(p),
              this._targetRotation.copy(p),
              this.entity.setRotation(p),
              (this.isResetting = !0);
          }
        }
        class bh {
          static vibrate(p = 0.1) {
            navigator.vibrate &&
              h.get("vibration") &&
              navigator.vibrate(p * 1e3);
          }
        }
        const Pn = Object.freeze({
          Shake: "Ball:Shake",
          Dead: "Ball:Dead",
          Finish: "Ball:Finish",
          UpdateLife: "Ball:UpdateLife",
        });
        class Mh extends o.w {
          constructor() {
            super("ball"),
              this._create(),
              this.setLocalScale(a.BALL_SCALE, a.BALL_SCALE, a.BALL_SCALE),
              (this._currentCollides = []),
              (this.life = ft.instance.getInt(a.STORAGE_KEY_LIFE, 1)),
              (this.isDeadAtLastFrame = !1),
              (this.preVelocity = new i.e()),
              this._createController(),
              (this.isCheck = !0);
          }
          _createController() {
            (this.controller = this.addScript(Ah, {
              attributes: {
                maxSpeed: a.MAX_SPEED,
                maxJumpingSpeed: a.MAX_JUMPING_SPEED,
                jumpTime: a.JUMP_TIME,
              },
            })),
              (this.checkPoint = {
                position: new i.e(0, 0.4, 0),
                rotation: ke.k.IDENTITY.clone(),
              }),
              (this.rotateFollowVelocity = this.stableMovingBall.addScript(Ph, {
                attributes: {
                  target: this.ballBody.rigidbody,
                  speed: 10,
                  ballController: this.controller,
                },
              }));
          }
          _create() {
            this.loadSkin(),
              (this.ballBody = new o.w("ballBody")),
              this.ballBody.addComponent("rigidbody", {
                type: "dynamic",
                mass: 10,
                friction: 1,
                rollingFriction: 0.1,
                linearDamping: 0.1,
                angularDamping: 0.1,
                restitution: 0,
              }),
              this.ballBody.addComponent("collision", {
                type: "sphere",
                radius: 0.4,
              }),
              this.ballBody.rigidbody.on(
                "triggerenter",
                this._onTriggerEnter,
                this
              ),
              this.ballBody.rigidbody.on(
                "collisionstart",
                this._onCollisionStart,
                this
              ),
              this.ballBody.rigidbody.on(
                "collisionend",
                this._onCollisionEnd,
                this
              ),
              (this.stableMovingBall = new o.w("stableMovingBall")),
              this.stableMovingBall.setLocalScale(0.5, 0.5, 1.5),
              (this.unbouncingFollow = this.stableMovingBall.addScript(Ch, {
                attributes: {
                  target: this.ballBody,
                  offset: new i.e(0, 0.5, 0),
                  speed: 10,
                  unbouncingSpeed: 10,
                },
              }));
          }
          loadSkin() {
            this.skin && this.removeChild(this.skin),
              (this.skinName = ft.instance.getString(
                a.STORAGE_KEY_SKIN,
                a.INIT_SKIN
              )),
              (this.skin = n.find(this.skinName).resource.clone()),
              (this.skin.enabled = !0),
              this.addChild(this.skin);
          }
          _onTriggerEnter(p) {
            let S = p.name;
            S.includes("collectable_ball")
              ? this._onCollideCollectableBall(p)
              : S.includes("platform_jump") &&
                this._onCollideWithPlatformJump(p);
          }
          _onCollisionStart(p) {
            this._currentCollides.indexOf(p.other) < 0 &&
              this._currentCollides.push(p.other);
            let S = p.other.name;
            S.includes("normal_road")
              ? this._onCollideWithRoad()
              : S.includes("normal_pipe")
              ? this._onCollideWithPipe(p)
              : S.includes("road_speed_booster") &&
                this._onCollideWithRoadSpeedBooster(p);
          }
          _onCollideWithPipe(p) {
            let U = this.ballBody.rigidbody.linearVelocity.length();
            U > 1 && this.fire(Pn.Shake, U * 0.02),
              this.ballBody.rigidbody.linearVelocity.mulScalar(-1),
              (this.preVelocity.z > 1.5 || this.preVelocity.z < -1.5) &&
                p.other._onCollide(this),
              bh.vibrate(0.1);
          }
          _onCollideWithRoad() {
            this.preVelocity.y < -0.3 &&
              this.isCheck &&
              (f.play("sfx_collide_floor"),
              Cn.playAt(this.getPosition()),
              (this.isCheck = !1),
              Me.createCountTween({
                duration: 1,
                onComplete: () => {
                  this.isCheck = !0;
                },
              }).start());
          }
          _onCollideCollectableBall(p) {
            let S = p.getPosition();
            this.checkPoint.position.set(S.x, S.y + 0.4, S.z),
              this.checkPoint.rotation.copy(p.getRotation()),
              this.life < a.TOTAL_LIFE &&
                (this.life++, this.fire(Pn.UpdateLife, this.life));
          }
          _onCollisionEnd(p) {
            this._currentCollides.indexOf(p) >= 0 &&
              this._currentCollides.splice(this._currentCollides.indexOf(p), 1);
          }
          _onCollideWithPlatformJump() {
            this.requestJump = !0;
          }
          _onCollideWithRoadSpeedBooster() {
            this.requestBoostSpeed = !0;
          }
          isGrounded() {
            return !!(
              this._currentCollides.length > 0 &&
              this._currentCollides[0].name.includes("normal_road")
            );
          }
          isRollingOnTheRoadPipe() {
            return !!(
              this._currentCollides.length > 0 &&
              this._currentCollides[0].name.includes("road_pipe")
            );
          }
          isRollingOnTheBridged() {
            return !!(
              (this._currentCollides.length > 0 &&
                this._currentCollides[0].name.includes("bridgeModel")) ||
              (this._currentCollides.length > 0 &&
                this._currentCollides[0].name.includes("model_road_bridge"))
            );
          }
          reset() {
            this.ballBody.rigidbody.teleport(0, 0.5, 0),
              (this.ballBody.rigidbody.velocity = new i.e(0, 0, 0)),
              (this.ballBody.rigidbody.linearVelocity = new i.e(0, 0, 0)),
              (this.ballBody.rigidbody.angularVelocity = new i.e(0, 0, 0));
          }
          teleport(p) {
            this.ballBody.rigidbody.teleport(p),
              this.setPosition(p),
              this.stableMovingBall.setEulerAngles(0, 0, 0),
              this.unbouncingFollow.teleport(p),
              this.rotateFollowVelocity.reset();
          }
          respawn() {
            let p = this.checkPoint.position,
              S = this.checkPoint.rotation;
            this.setPosition(p),
              this.setRotation(S),
              this.ballBody.setRotation(S),
              this.ballBody.rigidbody.teleport(p),
              this.unbouncingFollow.teleport(p),
              this.controller.reset(S),
              this.rotateFollowVelocity.reset(S);
          }
        }
        const Ho = Object.freeze({ Start: "start", Move: "move", End: "end" }),
          wh = kt.createScript({
            name: "swipeMovement",
            attributes: {
              screenEntity: {},
              multiplier: { default: 0 },
              speed: { default: 10 },
              range: { default: 20 },
            },
            touchedDown: !1,
            startPos: new i.e(),
            currPos: new i.e(),
            _deltaPos: new i.e(),
            _tmpTouchPosition: new i.e(),
            distance: 0,
            direction: new i.e(),
            initialize() {
              this._vector = new i.e();
            },
            onEnable() {
              this.startPos = this.currPos;
            },
            update() {
              if (!this.touchedDown) return;
              let C = Math.min(1, this.speed * Ft.dt);
              (this.startPos = this.startPos.lerp(
                this.startPos,
                this.currPos,
                C
              )),
                this.startPos.distance(this.currPos) > this.range &&
                  (this._vector
                    .copy(this.currPos)
                    .sub(this.startPos)
                    .normalize()
                    .mulScalar(this.range),
                  this.startPos.copy(this.currPos).sub(this._vector));
            },
            onPointerDown(C) {
              (this.touchedDown = !0),
                C.touches && C.touches[0]
                  ? this.setStart(C.touches[0])
                  : this.setStart(C);
            },
            onPointerMove(C) {
              this.touchedDown &&
                (C.touches && C.touches[0]
                  ? this.setMove(C.touches[0])
                  : this.setMove(C));
            },
            onPointerUp() {
              (this.touchedDown = !1),
                this.startPos.set(0, 0, 0),
                this.currPos.set(0, 0, 0);
            },
            setStart(C) {
              this.getScreenSpacePosition(C, this._tmpTouchPosition),
                this.startPos.copy(this._tmpTouchPosition),
                this.currPos.copy(this._tmpTouchPosition),
                this._deltaPos.set(0, 0, 0),
                (this.distance = 0),
                this.direction.set(0, 0, 0);
            },
            setMove(C) {
              this.getScreenSpacePosition(C, this._tmpTouchPosition),
                this.currPos.copy(this._tmpTouchPosition),
                this._deltaPos.copy(this.currPos).sub(this.startPos),
                (this.distance = this._deltaPos.length()),
                this.direction.copy(this._deltaPos).normalize(),
                this.entity.fire(Ho.Move, this.direction, this.distance);
            },
            getScreenSpacePosition(C, p = new i.e()) {
              (p.x = -C.x * this.app.graphicsDevice.maxPixelRatio),
                (p.z =
                  this.app.graphicsDevice.height -
                  C.y * this.app.graphicsDevice.maxPixelRatio),
                (p.y = 0),
                p.mulScalar(1 / this.screenEntity.screen.scale);
            },
          });
        var mr = Ut(9886);
        class Ih {
          constructor(p = {}) {
            if (!window.Ammo) {
              console.warn(
                "Warning! Trying to initialize Ammo Debug Drawer without Ammo lib in the project. Aborting."
              );
              return;
            }
            const S = p.app || mr.Application.getApplication(),
              ee = S.scene.layers,
              Se = this,
              Re =
                p.layer ||
                ee.getLayerByName("Debug Draw") ||
                ee.getLayerById(mr.LAYERID_UI),
              { entity: Be, distance: qe, ignorePartials: Et } = p.limit || {},
              Ct = new Dh(),
              St = new mr.Vec3(),
              jt = new mr.Vec3(),
              ts = new mr.Vec3();
            let ys = 1,
              Xs = !1;
            const Is = new Ammo.DebugDrawer();
            (Is.drawLine = uc.bind(this)),
              (Is.drawContactPoint = Er.bind(this)),
              (Is.reportErrorWarning = ji.bind(this)),
              (Is.draw3dText = qr.bind(this)),
              (Is.setDebugMode = fc.bind(this)),
              (Is.getDebugMode = pc.bind(this)),
              (Is.enable = _c.bind(this)),
              (Is.disable = il.bind(this)),
              (Is.update = uo.bind(this));
            const ui = S.systems.rigidbody.dynamicsWorld;
            ui.setDebugDrawer(Is), (Se.clear = co), (Se.toggle = mc);
            function ji(Ys) {}
            function qr(Ys, ea) {}
            function Er(Ys, ea, rl, bn, ln) {
              const Zs = Ammo.wrapPointer(Ys, Ammo.btVector3),
                Jn = Ammo.wrapPointer(ea, Ammo.btVector3),
                Hi = Ammo.wrapPointer(ln, Ammo.btVector3),
                Sr = Zs.x(),
                al = Zs.y(),
                ol = Zs.z();
              Ct.pushPos(
                Sr,
                al,
                ol,
                Sr + Jn.x() * 0.5,
                al + Jn.y() * 0.5,
                ol + Jn.z() * 0.5
              ),
                Ct.pushColor(
                  Hi.x(),
                  Hi.y(),
                  Hi.z(),
                  1,
                  Hi.x(),
                  Hi.y(),
                  Hi.z(),
                  1
                );
            }
            function uc(Ys, ea, rl) {
              const bn = Ammo.wrapPointer(Ys, Ammo.btVector3),
                ln = Ammo.wrapPointer(ea, Ammo.btVector3),
                Zs = Ammo.wrapPointer(rl, Ammo.btVector3);
              if (Be) {
                St.set(bn.x(), bn.y(), bn.z()), jt.set(ln.x(), ln.y(), ln.z());
                const Jn = Be.getPosition(),
                  Hi = Jn.distance(St),
                  Sr = Jn.distance(jt);
                ((Hi < qe && Sr < qe) || (Be && !Et && (Hi < qe || Sr < qe))) &&
                  (Ct.pushPos(St.x, St.y, St.z, jt.x, jt.y, jt.z),
                  Ct.pushColor(
                    Zs.x(),
                    Zs.y(),
                    Zs.z(),
                    1,
                    Zs.x(),
                    Zs.y(),
                    Zs.z(),
                    1
                  ));
              } else
                Ct.pushPos(bn.x(), bn.y(), bn.z(), ln.x(), ln.y(), ln.z()),
                  Ct.pushColor(
                    Zs.x(),
                    Zs.y(),
                    Zs.z(),
                    1,
                    Zs.x(),
                    Zs.y(),
                    Zs.z(),
                    1
                  );
            }
            function co() {
              Ct.clear();
            }
            function fc(Ys) {
              ys = Ys;
            }
            function pc() {
              return ys;
            }
            function _c() {
              Se.enabled = !0;
            }
            function il() {
              Se.enabled = !1;
            }
            function mc() {
              Se.enabled = !Xs;
            }
            function gc() {
              try {
                Ct.entries.forEach((Ys) => {
                  S.drawLineArrays(Ys.positions, Ys.colors, !1, Re);
                });
              } catch (Ys) {
                console.warn("Error drawing debug lines", Ys), il();
              }
            }
            function uo() {
              Xs && ui.debugDrawWorld();
            }
            function nl() {
              Xs && (gc(), co());
            }
            Object.defineProperties(Se, {
              enabled: {
                get: () => Xs,
                set: (Ys) => {
                  (Xs = Ys),
                    Xs
                      ? (S.systems.on("update", uo, Se),
                        S.systems.on("postUpdate", nl, Se))
                      : (S.systems.off("update", uo, Se),
                        S.systems.off("postUpdate", nl, Se),
                        co());
                },
              },
              mode: {
                get: () => ys,
                set: (Ys) => {
                  ys = Ys;
                },
              },
            });
          }
        }
        class Dh {
          constructor() {
            const p = this,
              S = new Map(),
              U = 64e3;
            let ee = 0;
            S.set(ee, { positions: [], colors: [] }),
              (p.entries = S),
              (p.clear = Se),
              (p.pushColor = Re),
              (p.pushPos = Be),
              qe(ee);
            function Se() {
              S.clear(), (ee = 0), qe(ee);
            }
            function Re(Ct, St, jt, ts, ys, Xs, Is, ui) {
              Et("colors", 8).colors.push(Ct, St, jt, ts, ys, Xs, Is, ui);
            }
            function Be(Ct, St, jt, ts, ys, Xs) {
              Et("positions", 6).positions.push(Ct, St, jt, ts, ys, Xs);
            }
            function qe(Ct) {
              const St = { positions: [], colors: [] };
              return S.set(Ct, St), St;
            }
            function Et(Ct, St) {
              let jt = S.get(ee);
              return jt[Ct].length + St > U && (jt = qe(++ee)), jt;
            }
          }
        }
        const Rh = kt.createScript({
          name: "rotateScript ",
          attributes: { speed: { default: new i.e(0, 0, 0) } },
          update(C) {
            this.entity.rotateLocal(
              this.speed.x * C,
              this.speed.y * C,
              this.speed.z * C
            );
          },
        });
        class Gi extends o.w {
          constructor(p) {
            super(p.name),
              (this.data = p),
              this._initModel(),
              this._applyTransformData();
          }
          _applyTransformData() {
            this.setPosition(...this.data.position),
              this.setEulerAngles(...this.data.eulerAngles),
              this.setLocalScale(...this.data.scale);
          }
          _initModel() {
            if (!this.data.model) return;
            let p = n.find(this.data.model);
            if (!p) {
              console.error(`Model asset ${this.data.model} not found`);
              return;
            }
            this.addComponent("model", { asset: p, castShadows: !1 }),
              this.data.materials &&
                this.data.materials.forEach((S, U) => {
                  let ee = n.find(S);
                  if (!ee) {
                    console.error(`Material asset ${S} not found`);
                    return;
                  }
                  this.model.meshInstances[U].material = ee.resource;
                });
          }
        }
        class ho extends Gi {
          constructor(p) {
            super(p);
          }
          _applyTransformData() {
            this._initCollider(), super._applyTransformData();
          }
          _initCollider(p = null) {
            let U = me(p || this).halfExtents;
            this.addComponent("collision", { type: "box", halfExtents: U }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
          _onTriggerEnter(p) {
            p.name === "ballBody" && this._playTween(p);
          }
          _playTween(p) {
            Me.createLocalTranslateTween(
              this,
              {
                x: this.getLocalPosition().x,
                y: this.getLocalPosition().y + 2,
              },
              {
                duration: 0.3,
                onUpdate: () => {
                  this.rotateLocal(0, -6, 0);
                },
                onComplete: () => {
                  Me.createLocalTranslateTween(
                    this,
                    { y: p.getLocalPosition().y + 1 },
                    {
                      duration: 0.3,
                      delay: 0,
                      onUpdate: () => {
                        this.rotateLocal(0, -6, 0);
                      },
                      onComplete: () => {
                        this.destroy();
                      },
                    }
                  ).start(),
                    Me.createScaleTween(
                      this,
                      { x: 0.7, y: 0.7, z: 0.7 },
                      {
                        duration: 0.3,
                        delay: 0.1,
                        onComplete: () => {
                          this.destroy();
                        },
                      }
                    ).start();
                },
              }
            ).start(),
              Me.createLocalTranslateTween(
                this,
                {},
                {
                  duration: 0.8,
                  delay: 0,
                  onUpdate: () => {
                    let ee = this.getLocalPosition(),
                      Se = p.getLocalPosition(),
                      Re = Se.x,
                      Be = ee.y,
                      qe = Se.z;
                    this.setPosition(Re, Be, qe);
                  },
                }
              ).start();
          }
        }
        class gr extends o.w {
          static playAt(p, S) {
            this._spawner || this._createPool();
            let U = this._spawner.spawn();
            return (
              U.setPosition(p.x, p.y + 0.5, p.z),
              U.setEulerAngles(S),
              U.play(),
              U
            );
          }
          static _createPool() {
            let p = new o.w("spawner_hitCoinEffect");
            (this._spawner = p.addScript(lo, { class: gr, poolSize: 10 })),
              Ht.app.root.addChild(p);
          }
          constructor() {
            super("fx_hit_coin"),
              this._initPlane(),
              this._initTween(),
              Ht.app.root.addChild(this);
          }
          _initPlane() {
            (this.texture = n.find("tex_outerRay").resource),
              (this.plane = new o.w()),
              this.plane.addComponent("model", { type: "plane" }),
              (this.plane.model.castShadows = !1),
              this.plane.setEulerAngles(-90, 0, 0);
            let p = new ce.F();
            (p.diffuse = new Ae.Q(226 / 255, 1, 80 / 255)),
              (p.blendType = Ve.HG),
              (p.opacityMap = this.texture),
              (p.opacityMapChannel = "a"),
              (p.cull = wt.pLF),
              (this.plane.model.meshInstances[0].material = p),
              this.addChild(this.plane);
          }
          _initTween() {
            this.plane.setLocalScale(0.2, 0.2, 0.2),
              (this.scaleTween1 = Me.createScaleTween(
                this.plane,
                { x: 4, y: 4, z: 4 },
                {
                  duration: 0.2,
                  onComplete: () => {
                    (this.scaleBackTween1 = Me.createScaleTween(
                      this.plane,
                      { x: 0, y: 0, z: 0 },
                      { duration: 0.1 }
                    )),
                      this.scaleBackTween1.start();
                  },
                }
              ));
          }
          play() {
            this.scaleTween1.stop(),
              this.scaleTween1.start(),
              Me.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this.fire(_r.Despawn);
                },
              });
          }
        }
        class Oh extends ho {
          constructor(p) {
            super(p);
          }
          _initModel() {
            (this.bodyModel = new o.w("bodyModel")),
              this.addChild(this.bodyModel),
              this.bodyModel.addScript(Rh, { speed: new i.e(0, 200, 0) }),
              this.bodyModel.addComponent("model", {
                asset: n.find(this.data.model),
                castShadows: !1,
              }),
              (this.bodyModel.model.castShadows = !1);
          }
          _initCollider(p = null) {
            let U = me(p || this).halfExtents;
            U.set(U.x * 1.5, U.y * 1.5, U.z * 1.5),
              this.addComponent("collision", { type: "box", halfExtents: U }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
          _onTriggerEnter(p) {
            p.name === "ballBody" &&
              (this.collision.onDisable(),
              super._onTriggerEnter(p),
              f.play("sfx_coin", 0.5),
              (Cs.instance.coinCount += a.ITEM_COIN_AMOUNT),
              this._onCollide(p));
          }
          _onCollide(p) {
            gr.playAt(this.getPosition(), p.parent.mainCamera.getEulerAngles());
          }
        }
        var Ko = Ut(54);
        class Lh extends Gi {
          constructor(p) {
            super(p);
          }
          _applyTransformData() {
            let p = new i.e();
            this.model.meshInstances.forEach((S) => {
              p.add(S.aabb.halfExtents);
            }),
              p.mul(new i.e(...this.data.scale)),
              this.addComponent("collision", { type: "box", halfExtents: p }),
              super._applyTransformData(),
              setTimeout(() => {
                this.addComponent("rigidbody", { type: "dynamic", mass: 0.5 }),
                  setTimeout(() => {
                    this.rigidbody.body.setActivationState(Ko.Qe);
                  }, 1);
              }, 1),
              this.collision.on("collisionstart", this._onCollide, this);
          }
          _onCollide(p) {
            p.other.name === "ballBody" &&
              (f.isPlaying("sfx_hitBox") ||
                (f.play("sfx_hitBox", 1, !1), Cn.playAt(this.getPosition())));
          }
        }
        class Xo extends ho {
          constructor(p) {
            super(p), this._initParticle();
          }
          _initModel() {
            super._initModel(), this._initBall();
          }
          _initBall() {
            let p = ft.instance.getString(a.STORAGE_KEY_SKIN, a.INIT_SKIN),
              S = n.find(p).resource.clone();
            (S.enabled = !0),
              this.addChild(S),
              S.setLocalPosition(0, 2, 0),
              S.setEulerAngles(0, 0, 0),
              (this.tween = Me.createLocalTranslateTween(
                S,
                { y: 1 },
                {
                  duration: 2,
                  yoyo: !0,
                  loop: !0,
                  easing: Me.Easing.Quadratic.InOut,
                }
              )),
              this.tween.start();
          }
          _initCollider() {
            let p = me(this),
              S = p.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: p.halfExtents,
              linearOffset: S,
            }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
          _onTriggerEnter(p) {
            p.name === "ballBody" &&
              (this.tween.stop(),
              this.children.forEach((S) => {
                S instanceof o.w && (this.removeChild(S), S.destroy());
              }),
              this.particles.particlesystem.stop(),
              f.play("sfx_collide_checkPoint"),
              this.removeComponent("collision"));
          }
          _initParticle() {
            this._createParticle(), this._createCircleParticle();
          }
          _createParticle() {
            let p = new Ei.K([
                [0, 0],
                [0, 2],
                [0, 0],
              ]),
              S = new Vi.I([0, 0.2]),
              U = new Vi.I([0, 0.4]),
              ee = n.find("tex_outerRay").resource;
            this.particles = new o.w();
            let Se = new Vi.I([0, 1, 0.5, 0.6, 1, 0]),
              Re = new Ei.K([
                [0, 120 / 255],
                [0, 226 / 255],
                [0, 1],
              ]);
            this.addChild(this.particles),
              this.particles.addComponent("particlesystem", {
                autoPlay: !0,
                loop: !0,
                lifetime: 1,
                numParticles: 40,
                colorMap: ee,
                rate: 0.02,
                rate2: 0.1,
                randomizeAnimIndex: !0,
                animLoop: !0,
                blendType: Ve.dc,
                scaleGraph: S,
                scaleGraph2: U,
                localVelocityGraph: p,
                alphaGraph: Se,
                colorGraph: Re,
                emitterShape: Ve.M2,
                emitterRadius: 1,
              });
          }
          _createCircleParticle() {
            let p = n.find("tex_fx_circle").resource;
            this.circleParticle = new o.w();
            let S = new Ei.K([
                [0, 0],
                [0, 1.5],
                [0, 0],
              ]),
              U = new Vi.I([0, 1, 0.7, 1, 1, 0]),
              ee = new Ei.K([
                [0, 120 / 255],
                [0, 226 / 255],
                [0, 1],
              ]);
            this.addChild(this.circleParticle),
              this.circleParticle.addComponent("particlesystem", {
                autoPlay: !0,
                loop: !0,
                orientation: Ve.KQ,
                lifetime: 1.5,
                numParticles: 2,
                colorMap: p,
                rate: 0.7,
                rate2: 0.7,
                randomizeAnimIndex: !0,
                animLoop: !0,
                blendType: Ve.dc,
                localVelocityGraph: S,
                alphaGraph: U,
                colorGraph: ee,
              });
          }
        }
        class Bh extends ho {
          constructor(p) {
            super(p), this._initAnimation();
          }
          _initCollider() {
            (this.ring = ze.createModel("model_ring_001")),
              this.addChild(this.ring),
              super._initCollider(this.ring);
          }
          _onTriggerEnter(p) {
            p.name === "ballBody" && this._onCollide(p);
          }
          _initAnimation() {
            Me.createCountTween({
              duration: 0.5,
              loop: !0,
              onUpdate: () => {
                this.ring.rotateLocal(0, -1.5, 0);
              },
            }).start();
          }
          _onCollide(p) {
            Cs.instance.keyCount++,
              f.play("sfx_key"),
              gr.playAt(
                this.getPosition(),
                p.parent.mainCamera.getEulerAngles()
              ),
              Me.createLocalTranslateTween(
                this,
                { y: this.getPosition().y + 7 },
                {
                  duration: 0.4,
                  easing: Me.Easing.Back.InOut,
                  onComplete: () => {
                    this.destroy();
                  },
                }
              ).start();
          }
        }
        class Yo extends Gi {
          constructor(p) {
            super(p), this._initCollider();
          }
          _initCollider() {
            let p = me(this),
              S = p.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: p.halfExtents,
              linearOffset: S,
            }),
              this.addComponent("rigidbody", { type: "static" });
          }
        }
        class Fh extends Yo {
          constructor(p) {
            super(p), this._initMovement();
          }
          _initCollider() {
            let p = this.getLocalScale();
            this.addComponent("collision", {
              type: "cylinder",
              radius: 0.57 * p.z,
              height: 2 * p.x,
              axis: 0,
              linearOffset: new i.e(0, -3.92 * p.y, 0),
            }),
              this.addComponent("rigidbody", { type: "kinematic" });
          }
          _initMovement() {
            if (this.data.hammerType && this.data.hammerType === "double") {
              this.setLocalEulerAngles(0, 0, 20);
              let p = Me.createTween(
                  { x: 0, y: 0, z: 20 },
                  { x: 0, y: 0, z: -50 },
                  {
                    duration: 0.7,
                    easing: Me.Easing.Cubic.In,
                    onUpdate: (U) => {
                      this.setLocalEulerAngles(U.x, U.y, U.z);
                    },
                  }
                ),
                S = Me.createTween(
                  { x: 0, y: 0, z: -50 },
                  { x: 0, y: 0, z: 20 },
                  {
                    duration: 2,
                    delay: 0.2,
                    easing: Me.Easing.Sinusoidal.InOut,
                    onUpdate: (U) => {
                      this.setLocalEulerAngles(U.x, U.y, U.z);
                    },
                  }
                );
              p.chain(S), S.chain(p), p.start();
            } else
              this.setLocalEulerAngles(0, 0, 50),
                Me.createRotateTween(
                  this,
                  { x: 0, y: 0, z: -50 },
                  {
                    duration: 1.3,
                    loop: !0,
                    yoyo: !0,
                    easing: Me.Easing.Cubic.InOut,
                  }
                ).start();
          }
        }
        class Uh extends o.w {
          constructor(p) {
            super(p.name),
              (this.data = p),
              this.setPosition(...this.data.position),
              this.setEulerAngles(...this.data.eulerAngles),
              this.setLocalScale(...this.data.scale),
              this._initModel(p),
              this._initColliders();
          }
          _initModel(p) {
            (this.bridgeModel = new o.w("bridgeModel")),
              this.bridgeModel.addComponent("model", {
                asset: n.find(p.model),
                castShadows: !1,
              }),
              this.addChild(this.bridgeModel),
              p.materials &&
                p.materials.forEach((S, U) => {
                  let ee = n.find(S);
                  this.bridgeModel.model.meshInstances[U].material =
                    ee.resource;
                });
          }
          _initColliders() {
            let p = me(this.bridgeModel),
              S = p.halfExtents,
              U = p.center.sub(this.getPosition());
            this.bridgeModel.addComponent("collision", {
              type: "box",
              halfExtents: S,
              linearOffset: U,
            }),
              this.bridgeModel.addComponent("rigidbody", {
                type: "kinematic",
                friction: 0,
                rollingFriction: 0,
              }),
              this.bridgeModel.setLocalEulerAngles(-90, 0, 0),
              this.bridgeModel.rigidbody.on(
                "collisionstart",
                this._onCollisionStart,
                this
              );
          }
          _onCollisionStart(p) {
            p.other.name === "ballBody" &&
              (Me.createRotateTween(
                this.bridgeModel,
                { x: 0, y: 0, z: 0 },
                { duration: 0.5 }
              ).start(),
              this.bridgeModel.collision.off(
                "triggerenter",
                this._onTriggerEnter,
                this
              ));
          }
        }
        class Nh extends Gi {
          constructor(p) {
            super(p), this._initCollider();
          }
          _initCollider() {
            var p = me(this);
            let S = p.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: p.halfExtents,
              linearOffset: S,
              trigger: !0,
            }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
        }
        class zh extends Nh {
          constructor(p) {
            super(p);
          }
          _onTriggerEnter(p) {
            p.name === "ballBody" && p.fire(Pn.Finish, this);
          }
        }
        class Jr extends Gi {
          constructor(p) {
            super(p), this._createCollider();
          }
          _createCollider() {
            var p;
            let S = {};
            (S.type = (p = this.model) == null ? void 0 : p.type),
              S.type === "asset" &&
                ((S.type = "mesh"), (S.asset = n.find(this.data.model))),
              this.addComponent("collision", S),
              this.addComponent("rigidbody", {
                type: "static",
                friction: 1,
                rollingFriction: 0.5,
                linearDamping: 0,
                angularDamping: 0,
                restitution: 0,
              }),
              this.data.contactProcessingThreshold !== void 0 &&
                setTimeout(() => {
                  var U = this.rigidbody.body;
                  U.setContactProcessingThreshold(
                    this.data.contactProcessingThreshold
                  );
                }, 10),
              this._recreateCollider();
          }
          _recreateCollider() {
            setTimeout(() => {
              (this.enabled = !1),
                Ammo.destroy(this.collision.shape),
                (this.collision.shape = null);
              for (const p of this.collision.model.meshInstances)
                delete Ht.app.systems.collision._triMeshCache[p.mesh.id];
              this.enabled = !0;
            }, 1);
          }
        }
        class kh extends Jr {
          constructor(p) {
            super(p);
          }
          _createCollider() {
            var p;
            let S = {};
            (S.type = (p = this.model) == null ? void 0 : p.type),
              S.type === "asset" &&
                ((S.type = "mesh"), (S.asset = n.find(this.data.model))),
              this.addComponent("collision", S),
              this.addComponent("rigidbody", {
                type: "static",
                friction: 0,
                rollingFriction: 0,
                linearDamping: 0,
                angularDamping: 0,
                restitution: 0,
              }),
              this._recreateCollider();
          }
          _onCollide(p) {
            let S = p.getPosition(),
              U = S,
              ee = S.clone().add(new i.e(0.5, 0, 0)),
              Se = S.clone().add(new i.e(-0.5, 0, 0)),
              Re = Ht.app.systems.rigidbody.raycastFirst(U, ee),
              Be = Ht.app.systems.rigidbody.raycastFirst(U, Se);
            Re && Cn.playAt(Re.point),
              Be && Cn.playAt(Be.point),
              f.play("sfx_collide_pipe");
          }
        }
        var Wh = Object.defineProperty,
          Vh = (C, p, S) =>
            p in C
              ? Wh(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          Gh = (C, p, S) => Vh(C, typeof p != "symbol" ? p + "" : p, S);
        const Zo = class fo extends Gi {
          constructor(p) {
            if ((super(p), !fo._animationRegistered)) {
              fo._animationRegistered = !0;
              let S = this.model.meshInstances[0].material,
                U = 0,
                ee = -0.005;
              Me.createCountTween({
                duration: 1,
                loop: !0,
                onUpdate: () => {
                  (S.diffuseMapOffset.x = U),
                    (S.emissiveMapOffset.x = U),
                    S.update(),
                    (U += ee);
                },
              }).start();
            }
          }
        };
        Gh(Zo, "_animationRegistered", !1);
        let jh = Zo;
        class Hh extends Gi {
          constructor(p) {
            super(p);
          }
          _applyTransformData() {
            super._applyTransformData(),
              this.addComponent("collision", {
                type: "sphere",
                radius: this.data.scale[0] / 2,
              }),
              this.addComponent("rigidbody", { type: "dynamic", mass: 10 }),
              setTimeout(() => {
                setTimeout(() => {
                  this.rigidbody.body.setActivationState(Ko.Qe);
                }, 1);
              }, 1);
          }
        }
        class Kh extends Jr {
          constructor(p) {
            super(p);
          }
          _createCollider() {
            var p;
            let S = {};
            (S.type = (p = this.model) == null ? void 0 : p.type),
              S.type === "asset" &&
                ((S.type = "mesh"), (S.asset = n.find(this.data.model))),
              this.addComponent("collision", S),
              this.addComponent("rigidbody", {
                type: "static",
                friction: 0,
                rollingFriction: 0.5,
                linearDamping: 0,
                angularDamping: 0,
                restitution: 0,
              });
          }
        }
        class Xh extends Gi {
          constructor(p) {
            super(p), this._createCollider();
          }
          _createCollider() {
            let p = me(this),
              S = p.halfExtents,
              U = p.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: S,
              center: U,
            });
          }
        }
        var Yh = Object.defineProperty,
          Zh = (C, p, S) =>
            p in C
              ? Yh(C, p, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: S,
                })
              : (C[p] = S),
          Qh = (C, p, S) => Zh(C, typeof p != "symbol" ? p + "" : p, S);
        const Qo = class po extends Jr {
          constructor(p) {
            if ((super(p), !po._animationRegistered)) {
              po._animationRegistered = !0;
              let S = this.model.meshInstances[1].material,
                U = 0,
                ee = -0.005;
              Me.createCountTween({
                duration: 1,
                loop: !0,
                onUpdate: () => {
                  (S.diffuseMapOffset.x = U),
                    (S.emissiveMapOffset.x = U),
                    S.update(),
                    (U += ee);
                },
              }).start();
            }
          }
        };
        Qh(Qo, "_animationRegistered", !1);
        const Jh = {
          coin: Oh,
          key: Bh,
          boxObstacle: Lh,
          ballObstacle: Hh,
          bridge: Uh,
          staticObstacle: Yo,
          collectableBall: Xo,
          pipeObject: kh,
          finishObject: zh,
          directionSign: jh,
          hammerObstacle: Fh,
          roadPipeObject: Kh,
          platformJump: Xh,
          roadSpeedBooster: Qo,
          collisionObject: Jr,
          mapObject: Gi,
        };
        class $h extends o.w {
          constructor(p) {
            super("map"), (this.finish = null), this._addEntityNode(p, this);
          }
          _addEntityNode(p, S) {
            var U = this._createEntityNode(p, S),
              ee = U.getWorldTransform().clone(),
              Se = S.getWorldTransform().clone().invert();
            ee.mul2(Se, ee);
            var Re = ee.getTranslation(),
              Be = new ke.k().setFromMat4(ee),
              qe = ee.getScale();
            U.reparent(S),
              U.setLocalPosition(Re),
              U.setLocalRotation(Be),
              U.setLocalScale(qe);
          }
          _createEntityNode(p) {
            var S;
            return (
              (S = new Jh[p.type](p)),
              p.type === "finishObject" && (this.finish = S),
              p.children &&
                p.children.length > 0 &&
                p.children.forEach((U) => {
                  this._addEntityNode(U, S);
                }),
              S
            );
          }
        }
        class qh extends o.w {
          constructor(p, S) {
            super(S), (this.mapData = p), (this.numLevel = 0);
          }
          create() {
            (this.map = new $h(this.mapData)), this.addChild(this.map);
          }
        }
        const ec = JSON.parse(
            '[{"mapData":"map1"},{"mapData":"map2"},{"mapData":"map3"},{"mapData":"map4"},{"mapData":"map5"},{"mapData":"map6"},{"mapData":"map7"},{"mapData":"map8"},{"mapData":"map9"},{"mapData":"map10"},{"mapData":"map11"},{"mapData":"map12"},{"mapData":"map13"},{"mapData":"map14"},{"mapData":"map15"},{"mapData":"map16"},{"mapData":"map17"},{"mapData":"map18"},{"mapData":"map19"},{"mapData":"map20"}]'
          ),
          Jo = Object.freeze({ LevelLoaded: "LevelManager:LevelLoaded" });
        class tc extends o.w {
          constructor() {
            super(),
              (this.levels = []),
              (this.currentLevelIndex = 0),
              (this.currentLevel = null),
              this._initLevels();
          }
          _initLevels() {
            ec.forEach((p, S) => {
              let U = n.find(p.mapData).resource,
                ee = new qh(U, `Level_${S}`);
              this.addChild(ee), this.levels.push(ee);
            });
          }
          loadNextLevel() {
            this.loadLevel(this.currentLevelIndex + 1);
          }
          loadLevel(p) {
            this.currentLevelIndex = p;
            var S = this.levels[this.currentLevelIndex % this.levels.length];
            if (!S) {
              console.warn(`Level "${this.currentLevelIndex}" is not found!`);
              return;
            }
            this.currentLevel && this.currentLevel.destroy(),
              (S.numLevel = this.currentLevelIndex + 1),
              S.create(),
              (this.currentLevel = S),
              this.fire(Jo.LevelLoaded, S);
          }
        }
        const $o = Object.freeze({ Opened: "ChestItem:Opened" }),
          qo = Object.freeze({ Complete: "ChestScreen:Complete" });
        class sc extends Ye {
          constructor() {
            super(a.SCREEN_CHEST);
          }
          create() {
            this._createBackground(),
              this._createBase(),
              this._createReward(),
              this._createKeys(),
              this._createBestReward(),
              this._createAnimations();
          }
          _createBackground() {
            (this.bg = ze.createColorBackground(Ae.Q.BLACK, 0.5)),
              this.addChild(this.bg);
          }
          _createBase() {
            (this.base = ze.createImageElement("spr_frame_reward")),
              (this.glow = ze.createImageElement("spr_glow_effect", {
                y: 250,
              })),
              this.base.addChild(this.glow),
              (this.label = ze.createImageElement("spr_label_top", {
                anchor: new at.Z(0.5, 1, 0.5, 1),
                pivot: new Ne.Z(0.5, 0.8),
                y: 10,
              })),
              this.base.addChild(this.label),
              (this.txtBestPrize = ze.createTextElement("font_rounded", {
                text: "Best prize",
                fontSize: 40,
                color: Ae.Q.WHITE,
                y: 5,
              })),
              this.label.addChild(this.txtBestPrize),
              (this.txtChoose = ze.createTextElement("font_rounded", {
                text: "Choose a chest",
                fontSize: 40,
                anchor: new at.Z(0.5, 0, 0.5, 0),
                pivot: new Ne.Z(0.5, 0.5),
                color: Ae.Q.WHITE,
                y: 130,
              })),
              this.base.addChild(this.txtChoose),
              this.addChild(this.base);
          }
          _createReward() {
            (this.chests = []),
              (this.rewardGroupBackground = ze.createImageElement(
                "spr_frame_reward_inner",
                {
                  anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
                  pivot: new Ne.Z(0.5, 0.5),
                  y: -50,
                }
              )),
              this.base.addChild(this.rewardGroupBackground),
              (this.rewardGroup = ze.createGroupElement({
                width: 300,
                height: 300,
              })),
              this.rewardGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(100, 100),
                wrap: !0,
              });
            for (let p = 0; p < 9; p++) {
              let S = new ic();
              S.on($o.Opened, this._onChestOpened, this),
                this.rewardGroup.addChild(S),
                this.chests.push(S);
            }
            this.rewardGroupBackground.addChild(this.rewardGroup);
          }
          _createKeys() {
            (this.keys = []),
              (this.keyGroup = ze.createGroupElement({
                anchor: new at.Z(0.5, 0, 0.5, 0),
                pivot: new Ne.Z(0.5, 0.5),
                width: 300,
                height: 50,
                y: 70,
              })),
              this.keyGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(30, 0),
              });
            for (let p = 0; p < a.TOTAL_KEY_TO_COLLECT; p++) {
              let S = ze.createImageElement("spr_icon_key");
              this.keys.push(S), this.keyGroup.addChild(S);
            }
            this.base.addChild(this.keyGroup);
          }
          _onChestOpened(p) {
            let S, U;
            Math.random() < a.PERCENTAGE_TO_OPEN_SKIN_CHEST &&
            this.rewards.skin === "" &&
            this.skin
              ? ((S = "skin"), (U = this.skin), (this.rewards.skin = U))
              : ((S = "coin"),
                (U = Ge.randomInt(this.minCoin, this.maxCoin)),
                (this.rewards.coin += U)),
              p.setReward(S, U),
              p.open(),
              this.openedChests++,
              this._updateKeys(),
              this.openedChests === this.keys.length &&
                (this.chests.forEach((ee) => {
                  ee.canOpen = !1;
                }),
                this.fire(qo.Complete, this.rewards)),
              f.play("sfx_click");
          }
          _updateKeys() {
            for (let p = 0; p < this.keys.length; p++) {
              let S = this.keys[p];
              p < this.keys.length - this.openedChests
                ? (S.element.textureAsset = n.find("spr_icon_key"))
                : (S.element.textureAsset = n.find("spr_icon_key_gray"));
            }
          }
          updateReward(p, S, U) {
            (this.rewards = { coin: 0, skin: "" }),
              (this.openedChests = 0),
              this._updateKeys(),
              (this.maxCoin = S),
              (this.minCoin = p),
              (this.skin = U),
              this.chests.forEach((ee) => {
                ee.reset();
              }),
              this._updateBestReward();
          }
          _createBestReward() {
            (this.bestCoinReward = ze.createGroupElement({
              width: 300,
              height: 300,
              y: 250,
            })),
              this.bestCoinReward.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(10, 0),
                wrap: !0,
              }),
              (this.bestRewardText = ze.createTextElement("font_rounded", {
                text: "123",
                fontSize: 52,
                color: Ae.Q.WHITE,
              })),
              (this.bestRewardText.element.outlineThickness = 0.1),
              this.bestCoinReward.addChild(this.bestRewardText),
              (this.bestRewardIcon = ze.createImageElement(
                "spr_icon_coin_reward"
              )),
              this.bestCoinReward.addChild(this.bestRewardIcon),
              this.base.addChild(this.bestCoinReward),
              (this.bestCoinReward.enabled = !1),
              (this.bestBallReward = ze.createImageElement(
                "spr_icon_ball_001",
                { width: 150, height: 150, y: 260 }
              )),
              this.base.addChild(this.bestBallReward),
              (this.bestBallReward.enabled = !1);
          }
          _updateBestReward() {
            this.skin
              ? ((this.bestBallReward.enabled = !0),
                (this.bestCoinReward.enabled = !1),
                (this.bestBallReward.element.textureAsset = n.find(
                  `spr_icon_${this.skin}`
                )))
              : ((this.bestBallReward.enabled = !1),
                (this.bestCoinReward.enabled = !0),
                (this.bestRewardText.element.text = this.maxCoin));
          }
          _createAnimations() {
            this._appearAnimation = Me.createTween(
              { x: 0, y: 0, z: 0 },
              { x: 1, y: 1, z: 1 },
              {
                duration: 0.5,
                easing: Me.Easing.Back.Out,
                onUpdate: (p) => {
                  this.base.setLocalScale(p.x, p.y, p.z);
                },
              }
            );
          }
          onEnable() {
            this._appearAnimation.start();
          }
        }
        class ic extends o.w {
          constructor() {
            super("chest_item"),
              this.addComponent("element", {
                type: ot.Dk,
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
                pivot: new Ne.Z(0.5, 0.5),
              }),
              this._initCloseChest(),
              this._initOpenChest(),
              this._initReward();
          }
          _initCloseChest() {
            (this.closeChest = ze.createImageElement("spr_icon_chest_close", {
              anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
              pivot: new Ne.Z(0.5, 0.5),
            })),
              this.addChild(this.closeChest),
              Ge.registerOnTouch(this.closeChest.element, this._onClick, this);
          }
          _initOpenChest() {
            (this.openChest = ze.createImageElement("spr_icon_chest_open", {
              anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
              pivot: new Ne.Z(0.5, 0.5),
            })),
              this.addChild(this.openChest),
              (this.openChest.enabled = !1);
          }
          setReward(p, S) {
            (this.rewardType = p),
              (this.rewardValue = S),
              p === "coin"
                ? ((this.textReward.enabled = !0),
                  (this.textReward.element.text = S),
                  (this.textReward.element.opacity = 0),
                  (this.iconReward.element.textureAsset = n.find(
                    "spr_icon_coin_reward"
                  )),
                  this.iconReward.setLocalScale(0.7, 0.7, 0.7))
                : p === "skin" &&
                  ((this.textReward.enabled = !1),
                  (this.iconReward.element.textureAsset = n.find(
                    `spr_icon_${S}`
                  )),
                  this.iconReward.setLocalScale(1, 1, 1));
          }
          reset() {
            (this.closeChest.enabled = !0),
              (this.openChest.enabled = !1),
              (this.canOpen = !0),
              (this.iconReward.element.opacity = 0),
              (this.textReward.enabled = !1);
          }
          _initReward() {
            (this.reward = ze.createGroupElement({ width: 100, height: 100 })),
              this.reward.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(5, 0),
              }),
              (this.iconReward = ze.createImageElement("spr_icon_coin_reward", {
                width: 50,
                height: 50,
              })),
              this.reward.addChild(this.iconReward),
              (this.iconReward.element.opacity = 0),
              (this.textReward = ze.createTextElement("font_rounded", {
                text: this.rewardValue,
                fontSize: 30,
                color: Ae.Q.WHITE,
              })),
              this.reward.addChild(this.textReward),
              (this.textReward.element.opacity = 0),
              this.addChild(this.reward);
          }
          _onClick() {
            (this.closeChest.enabled = !1),
              (this.openChest.enabled = !0),
              this.fire($o.Opened, this);
          }
          open() {
            this.openChest.setLocalScale(0.5, 0.5, 0.5),
              Me.createScaleTween(
                this.openChest,
                { x: 1, y: 1 },
                { duration: 0.5, easing: Me.Easing.Back.Out }
              ).start(),
              this.rewardType &&
                (Me.createTween(
                  this.iconReward.element,
                  { opacity: 1 },
                  { duration: 0.5, delay: 0.25 }
                ).start(),
                this.textReward &&
                  Me.createTween(
                    this.textReward.element,
                    { opacity: 1 },
                    { duration: 0.5, delay: 0.25 }
                  ).start());
          }
          set canOpen(p) {
            this.closeChest.element.useInput = p;
          }
        }
        const yr = Object.freeze({ LevelGroupCount: 4 }),
          Qn = Object.freeze({
            Complete: "MainScreen:Complete",
            OpenSetting: "MainScreen:OpenSetting",
            OpenSelectingSkin: "MainScreen:OpenSelectingSkin",
          });
        class nc extends Ye {
          constructor() {
            super(a.SCREEN_MAIN);
          }
          create() {
            this._createFakeBackground(),
              this._createKeys(),
              this._createCoins(),
              this._createSettingButton(),
              this._createLevelInfo(),
              this._createSelectingSkinButton(),
              this._createTutorial(),
              this._createAnimations();
          }
          _createFakeBackground() {
            (this.fakeBackground = new o.w("fakeBackground")),
              this.fakeBackground.addComponent("element", {
                type: "image",
                anchor: new at.Z(0, 0, 1, 1),
                color: new Ae.Q(0.5, 0.5, 0.5),
                opacity: 0,
              }),
              this.addChild(this.fakeBackground),
              Ge.registerOnTouch(
                this.fakeBackground.element,
                this._onTapBackground,
                this
              );
          }
          _onTapBackground() {
            this.fire(Qn.Complete);
          }
          _createKeys() {
            (this.keyBackground = new o.w("keyBackground")),
              this.keyBackground.addComponent("element", {
                type: "image",
                anchor: new at.Z(0, 1, 0, 1),
                pivot: new Ne.Z(0, 1),
                width: 150,
                height: 50,
                color: new Ae.Q(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.keyBackground.setLocalPosition(10, -20, 0),
              this.addChild(this.keyBackground),
              (this.keyGroup = ze.createGroupElement()),
              this.keyGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(10, 0),
              }),
              this.keyBackground.addChild(this.keyGroup),
              (this.keys = []);
            for (let p = 0; p < a.TOTAL_KEY_TO_COLLECT; p++) {
              let S = ze.createImageElement("spr_icon_key", { scale: 0.8 });
              this.keys.push(S), this.keyGroup.addChild(S);
            }
          }
          updateKeys(p) {
            p > a.TOTAL_KEY_TO_COLLECT && (p = a.TOTAL_KEY_TO_COLLECT);
            for (let S = 0; S < this.keys.length; S++) {
              let U = this.keys[S];
              S < p
                ? (U.element.textureAsset = n.find("spr_icon_key"))
                : (U.element.textureAsset = n.find("spr_icon_key_gray"));
            }
          }
          _createCoins() {
            (this.coinBackground = new o.w("coinBackground")),
              this.coinBackground.addComponent("element", {
                type: "image",
                anchor: new at.Z(1, 1, 1, 1),
                pivot: new Ne.Z(1, 1),
                width: 130,
                height: 50,
                color: new Ae.Q(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.coinBackground.setLocalPosition(-10, -20, 0),
              this.addChild(this.coinBackground),
              (this.coinIcon = ze.createImageElement("spr_icon_coin_reward", {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                pivot: new Ne.Z(1, 0.5),
                x: -10,
                scale: 0.8,
              })),
              this.coinBackground.addChild(this.coinIcon),
              (this.coinText = ze.createTextElement("font_rounded", {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                pivot: new Ne.Z(1, 0.5),
                text: "0",
                fontSize: 46,
                color: Ae.Q.WHITE,
                x: -80,
                y: -5,
              })),
              (this.coinText.element.autoWidth = !0),
              this.coinBackground.addChild(this.coinText);
          }
          updateCoins(p) {
            (this.coinText.element.text = p),
              (this.coinBackground.element.width =
                this.coinText.element.width + 90);
          }
          _createLevelInfo() {
            (this.line = ze.createEmptyImageElement({
              anchor: new at.Z(0.5, 0.8, 0.5, 0.8),
              pivot: new Ne.Z(0.5, 0.5),
              height: 20,
              width: 250,
              color: new Ae.Q(0.5, 0.5, 0.5),
              y: 80,
            })),
              this.addChild(this.line),
              (this.levelGroup = ze.createGroupElement()),
              this.levelGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(50, 0),
              }),
              this.line.addChild(this.levelGroup),
              (this.levelElements = []);
            for (let p = 0; p < yr.LevelGroupCount; p++) {
              let S = new Xe();
              this.levelElements.push(S), this.levelGroup.addChild(S);
            }
            (this.levelText = ze.createTextElement("font_rounded", {
              anchor: new at.Z(0.5, 0.8, 0.5, 0.8),
              pivot: new Ne.Z(0.5, 0.5),
              text: "Level 1",
              y: 150,
              fontSize: 52,
              color: Ae.Q.WHITE,
            })),
              (this.levelText.element.outlineColor = Ae.Q.BLACK),
              (this.levelText.element.outlineThickness = 0.6),
              this.addChild(this.levelText);
          }
          updateLevelInfo(p) {
            let S =
                Math.floor((p - 1) / yr.LevelGroupCount) * yr.LevelGroupCount,
              U = S + yr.LevelGroupCount;
            for (let ee = S; ee < U; ee++) {
              let Se = this.levelElements[ee % yr.LevelGroupCount];
              Se.setText(ee + 1),
                ee < p - 1
                  ? Se.setFrame(us.Passed)
                  : ee === p - 1
                  ? Se.setFrame(us.Current)
                  : Se.setFrame(us.Locked),
                ee === U - 1 && Se.setFrame(us.EndInGroup);
            }
            this.levelText.element.text = `Level ${p}`;
          }
          _createTutorial() {
            (this.tutorialBackground = new o.w("tutorialBackground")),
              this.tutorialBackground.addComponent("element", {
                type: "image",
                anchor: new at.Z(0, 0.25, 1, 0.25),
                pivot: new Ne.Z(0.5, 0.5),
                height: 150,
                textureAsset: n.find("spr_frame_tutorial"),
              }),
              this.addChild(this.tutorialBackground),
              (this.textTutorial = ze.createImageElement("spr_text_tutorial", {
                scale: 1.2,
              })),
              this.tutorialBackground.addChild(this.textTutorial);
          }
          _createSettingButton() {
            (this.settingButton = ze.createButtonElement("spr_icon_setting", {
              anchor: new at.Z(1, 0, 1, 0),
              pivot: new Ne.Z(1, 0),
              x: -10,
              y: 10,
            })),
              this.addChild(this.settingButton),
              this.settingButton.button.on("click", this._onTapSetting, this);
          }
          _onTapSetting() {
            this.fire(Qn.OpenSetting), f.play("sfx_click", 1, !1);
          }
          _createSelectingSkinButton() {
            (this.selectingSkinButton = ze.createButtonElement(
              "spr_icon_ball_select",
              {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                pivot: new Ne.Z(1, 0.5),
                x: -10,
              }
            )),
              this.addChild(this.selectingSkinButton),
              this.selectingSkinButton.button.on(
                "click",
                this._onTapSelectingSkin,
                this
              );
          }
          _onTapSelectingSkin() {
            this.fire(Qn.OpenSelectingSkin), f.play("sfx_click", 1, !1);
          }
          _createAnimations() {
            this._appearAnimations = [];
            let p = { duration: 0.5, easing: Me.Easing.Back.Out };
            this._appearAnimations.push(
              Fe.createTransitionAppearTween(this.line, gt.TopToBottom, p)
            ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.levelGroup,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.levelText,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.coinBackground,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.keyBackground,
                  gt.TopToBottom,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.settingButton,
                  gt.RightToLeft,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.selectingSkinButton,
                  gt.RightToLeft,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.tutorialBackground,
                  gt.BottomToTop,
                  p
                )
              );
          }
          onEnable() {
            var p;
            (p = this._disappearAnimations) == null ||
              p.forEach((S) => S.stop()),
              this._appearAnimations.forEach((S) => S.start());
          }
        }
        const $r = Object.freeze({
          ContinueButtonClicked: "LoseScreen:ContinueButtonClicked",
          RespawnGame: "LoseScreen:RespawnGame",
        });
        class rc extends Ye {
          constructor() {
            super(a.SCREEN_LOSE),
              (this.isRewardAdsReady = !1),
              this._initBackground(),
              this._initLogo(),
              this._initButton(),
              this._createButtonRewardAds(),
              this.resize();
          }
          resize() {
            this.logo.setLocalPosition(0, 400, 0),
              this.logo.setLocalScale(2, 2, 2),
              this.buttonContinue.setLocalPosition(0, -400, 0),
              this.buttonContinue.setLocalScale(2, 2, 2),
              Ht.width >= Ht.height
                ? (this.logo.setLocalScale(1, 1, 1),
                  this.logo.setLocalPosition(0, 200, 0),
                  this.buttonContinue.setLocalPosition(0, -100, 0),
                  this.buttonContinue.setLocalScale(1, 1, 1),
                  this.rewardButton.setLocalScale(0.7, 0.7, 0.7),
                  this.rewardButton.setLocalPosition(0, -300, 0))
                : (this.buttonContinue.setLocalPosition(0, -200, 0),
                  this.buttonContinue.setLocalScale(1.5, 1.5, 1.5),
                  this.rewardButton.setLocalScale(1, 1, 1),
                  this.rewardButton.setLocalPosition(0, -550, 0));
          }
          _initBackground() {
            let p = Ge.createColor(0, 0, 0);
            (this.bg = ze.createColorBackground(p)),
              (this.bg.element.opacity = 0.5),
              this.addChild(this.bg);
          }
          _initLogo() {
            (this.logo = ze.createImageElement("spr_frame_lv_false", {
              pivot: new Ne.Z(0.5, 0.5),
              anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
            })),
              this.addChild(this.logo);
          }
          _initButton() {
            (this.buttonContinue = ze.createButtonElement(
              "spr_frame_continue",
              {
                pivot: new Ne.Z(0.5, 0.5),
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
              }
            )),
              this.addChild(this.buttonContinue),
              Ge.registerOnTouch(
                this.buttonContinue.element,
                this._onContinue,
                this
              );
          }
          _onContinue() {
            this.fire($r.ContinueButtonClicked), f.play("sfx_click");
          }
          _createButtonRewardAds() {
            (this.rewardButton = ze.createButtonElement(
              "spr_button_reward_ads_ball",
              {
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
                pivot: new Ne.Z(0.5, 0.5),
                y: -500,
                x: 0,
                scale: 1,
              }
            )),
              this.rewardButton.button.on(
                "click",
                this._onButtonRewardAdsClick,
                this
              ),
              this.addChild(this.rewardButton);
            let p = ze.createTextElement("font_rounded", {
              anchor: new at.Z(1, 0.5, 1, 0.5),
              pivot: new Ne.Z(1, 0.5),
              text: "+3 balls",
              fontSize: 46,
              color: Ae.Q.WHITE,
              x: -110,
              y: 0,
            });
            this.rewardButton.addChild(p);
          }
          _onButtonRewardAdsClick() {
            this.isShowingRewardAds ||
              (f.play("sfx_click"),
              (this.isShowingRewardAds = !0),
              Ts.showRewardAds((p) => {
                if (((this.isShowingRewardAds = !1), p))
                  console.warn(p), alert(p);
                else {
                  let S = ft.instance.getInt(a.STORAGE_KEY_LIFE);
                  (S = 3),
                    ft.instance.setValue(a.STORAGE_KEY_LIFE, S),
                    this.fire($r.RespawnGame, S),
                    oi.log("reward_show", {
                      case: "increase_life_lose_screen",
                    });
                }
                this.checkIsRewardAdsReady();
              }));
          }
          checkIsRewardAdsReady() {
            (this.rewardButton.enabled = !1),
              (this.checkRewardAdsIntervalID = setInterval(() => {
                Ts.checkIsRewardAdsReady((p) => {
                  console.log("Reward ads ready", p),
                    (this.rewardButton.enabled = p),
                    p && clearInterval(this.checkRewardAdsIntervalID);
                });
              }, 1e3));
          }
          onEnable() {
            this.checkIsRewardAdsReady();
          }
        }
        class ac extends o.w {
          constructor() {
            super("ballSelection"),
              (this.nextSkinPosition = new i.e(5, 0, 0)),
              (this.previousSkinPosition = new i.e(-5, 0, 0)),
              (this.currentSkinPosition = new i.e(0, 0, 0)),
              this._init(),
              (this.enabled = !1);
          }
          _init() {
            (this.skins = []),
              (this.currentSkinName = ft.instance.getString(
                a.STORAGE_KEY_SKIN,
                a.INIT_SKIN
              )),
              (this.currentSkinIndex = -1),
              pe.forEach((p, S) => {
                let U = n.find(p.name).resource.clone();
                (U.data = p),
                  (U.rotateTween = Me.createRotateTween(
                    U,
                    { x: 0, y: 360, z: 0 },
                    { duration: 5, loop: !0 }
                  )),
                  this.skins.push(U),
                  this.addChild(U),
                  (U.enabled = !1),
                  p.name === this.currentSkinName &&
                    ((this.currentSkinIndex = S),
                    (this.currentSkin = U),
                    (U.enabled = !0),
                    U.setLocalPosition(this.currentSkinPosition));
              });
          }
          nexSkin() {
            this.currentSkinTween && this.currentSkinTween.stop(),
              this.nexSkinTween && this.nexSkinTween.stop();
            let p = this.skins[this.currentSkinIndex];
            (this.currentSkinIndex =
              (this.currentSkinIndex + 1) % this.skins.length),
              (this.currentSkinTween = Me.createLocalTranslateTween(
                this.currentSkin,
                this.previousSkinPosition,
                {
                  duration: 0.2,
                  onComplete: () => {
                    (p.enabled = !1), p.rotateTween.stop();
                  },
                  onStop: () => {
                    p.rotateTween.stop(), (p.enabled = !1);
                  },
                }
              ).start()),
              (this.currentSkin = this.skins[this.currentSkinIndex]),
              (this.currentSkin.enabled = !0),
              this.currentSkin.rotateTween.start(),
              (this.nexSkinTween = this.currentSkin.setLocalPosition(
                this.nextSkinPosition
              )),
              Me.createLocalTranslateTween(
                this.currentSkin,
                this.currentSkinPosition,
                { duration: 0.2 }
              ).start();
          }
          previousSkin() {
            this.currentSkinTween && this.currentSkinTween.stop(),
              this.previousSkinTween && this.previousSkinTween.stop(),
              (this.currentSkinIndex =
                (this.currentSkinIndex - 1 + this.skins.length) %
                this.skins.length);
            let p = this.currentSkin;
            (this.currentSkinTween = Me.createLocalTranslateTween(
              p,
              this.nextSkinPosition,
              {
                duration: 0.2,
                onComplete: () => {
                  (p.enabled = !1), p.rotateTween.stop();
                },
                onStop: () => {
                  p.rotateTween.stop(), (p.enabled = !1);
                },
              }
            ).start()),
              (this.currentSkin = this.skins[this.currentSkinIndex]),
              (this.currentSkin.enabled = !0),
              (this.previousSkinTween = this.currentSkin.setLocalPosition(
                this.previousSkinPosition
              )),
              this.currentSkin.rotateTween.start(),
              Me.createLocalTranslateTween(
                this.currentSkin,
                this.currentSkinPosition,
                { duration: 0.2 }
              ).start();
          }
          onBoughtFail() {
            this.shakeTween && this.shakeTween.stop(),
              (this.shakeTween = Me.createShakeTween(
                this.currentSkin,
                new i.e(0.2, 0, 0),
                0.05
              )),
              this.shakeTween.start();
          }
        }
        const xi = Object.freeze({
          Complete: "SkinSelection:Complete",
          NextSkin: "SkinSelection:NextSkin",
          PreviousSkin: "SkinSelection:PreviousSkin",
          SelectSkin: "SkinSelection:SelectSkin",
          BoughtFailed: "SkinSelection:BoughtFailed",
        });
        class oc extends Ye {
          constructor() {
            super(a.SCREEN_SKIN_SELECTION), (this.isRewardAdsReady = !1);
          }
          create() {
            this._createButton(),
              this._createCenterButton(),
              this._createAnimations(),
              this._createCoins(),
              this._createButtonRewardAds();
          }
          _createCoins() {
            (this.coinBackground = new o.w("coinBackground")),
              this.coinBackground.addComponent("element", {
                type: "image",
                anchor: new at.Z(1, 1, 1, 1),
                pivot: new Ne.Z(1, 1),
                width: 130,
                height: 50,
                color: new Ae.Q(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.coinBackground.setLocalPosition(-10, -20, 0),
              this.addChild(this.coinBackground),
              (this.coinIcon = ze.createImageElement("spr_icon_coin_reward", {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                pivot: new Ne.Z(1, 0.5),
                x: -10,
                scale: 0.8,
              })),
              this.coinBackground.addChild(this.coinIcon),
              (this.coinText = ze.createTextElement("font_rounded", {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                pivot: new Ne.Z(1, 0.5),
                text: "0",
                fontSize: 46,
                color: Ae.Q.WHITE,
                x: -80,
                y: -5,
              })),
              (this.coinText.element.autoWidth = !0),
              this.coinBackground.addChild(this.coinText);
          }
          updateCoins(p) {
            (this.coinText.element.text = p),
              (this.coinBackground.element.width =
                this.coinText.element.width + 90);
          }
          _createButtonRewardAds() {
            (this.rewardButton = ze.createButtonElement(
              "spr_button_reward_ads",
              {
                anchor: new at.Z(1, 1, 1, 1),
                pivot: new Ne.Z(1, 0.5),
                y: -200,
                x: 10,
                scale: 1.2,
              }
            )),
              this.rewardButton.button.on(
                "click",
                this._onButtonRewardAdsClick,
                this
              ),
              this.addChild(this.rewardButton);
            let p = ze.createImageElement("spr_icon_coin_reward", {
              anchor: new at.Z(1, 0.5, 1, 0.5),
              pivot: new Ne.Z(1, 0.5),
              x: -20,
              scale: 0.8,
              y: -20,
            });
            this.rewardButton.addChild(p);
            let S = ze.createTextElement("font_rounded", {
              anchor: new at.Z(1, 0.5, 1, 0.5),
              pivot: new Ne.Z(1, 0.5),
              text: "+300",
              fontSize: 46,
              color: Ae.Q.WHITE,
              x: -90,
              y: -25,
            });
            (this.coinText.element.autoWidth = !0),
              this.rewardButton.addChild(S);
          }
          _createButton() {
            (this.leftButton = ze.createButtonElement("spr_icon_arrow", {
              anchor: new at.Z(0, 0.5, 0, 0.5),
              x: 40,
            })),
              this.addChild(this.leftButton),
              this.leftButton.button.on(
                "click",
                this.fire.bind(this, xi.PreviousSkin)
              ),
              (this.rightButton = ze.createButtonElement("spr_icon_arrow", {
                anchor: new at.Z(1, 0.5, 1, 0.5),
                x: -40,
              })),
              this.addChild(this.rightButton),
              this.rightButton.setLocalScale(-1, 1, 1),
              this.rightButton.button.on(
                "click",
                this.fire.bind(this, xi.NextSkin)
              ),
              (this.exitButton = ze.createButtonElement("spr_icon_back", {
                anchor: new at.Z(0, 1, 0, 1),
                x: 40,
                y: -50,
              })),
              this.addChild(this.exitButton),
              this.exitButton.button.on(
                "click",
                this.fire.bind(this, xi.Complete)
              );
          }
          _createCenterButton() {
            (this.centerButton = ze.createButtonElement("spr_frame_green", {
              y: -150,
            })),
              this.addChild(this.centerButton),
              (this.centerGroup = ze.createGroupElement({
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
              })),
              this.centerGroup.addComponent("layoutgroup", {
                orientation: Ve.Yn,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(0, 10),
              }),
              this.centerButton.addChild(this.centerGroup),
              (this.centerButtonText = ze.createTextElement("font_rounded", {
                text: "Selected",
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
                fontSize: 46,
                color: Ae.Q.WHITE,
              })),
              this.centerGroup.addChild(this.centerButtonText),
              (this.centerButtonText.element.autoWidth = !0),
              (this.centerButtonText.element.outlineColor = new Ae.Q(
                13 / 255,
                160 / 255,
                0
              )),
              (this.centerButtonText.element.outlineThickness = 0.6),
              (this.priceGroup = ze.createGroupElement({
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
              })),
              this.priceGroup.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                alignment: new Ne.Z(0.5, 0.5),
                spacing: new Ne.Z(10, 0),
              }),
              this.centerGroup.addChild(this.priceGroup),
              (this.priceText = ze.createTextElement("font_rounded", {
                text: "1000",
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
                fontSize: 46,
                color: Ae.Q.WHITE,
              })),
              this.priceGroup.addChild(this.priceText),
              (this.priceText.element.autoWidth = !0),
              (this.priceText.element.outlineColor = new Ae.Q(
                13 / 255,
                160 / 255,
                0
              )),
              (this.priceText.element.outlineThickness = 0.6),
              (this.priceIcon = ze.createImageElement("spr_icon_coin_reward", {
                anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
                pivot: new Ne.Z(0.5, 0.5),
                scale: 0.8,
              })),
              this.priceGroup.addChild(this.priceIcon),
              (this.priceGroup.enabled = !1);
          }
          changeCenterButtonText(p) {
            (this.centerButtonText.element.text = p),
              (this.priceGroup.enabled = !1);
          }
          changeCenterButtonPrice(p) {
            (this.centerButtonText.element.text = "Unlock"),
              (this.priceText.element.text = p),
              (this.priceGroup.enabled = !0);
          }
          updateSkinInfo(p) {
            let U =
                ft.instance
                  .getString(a.STORAGE_KEY_UNLOCKED_SKIN)
                  .split(",")
                  .indexOf(p.name) !== -1 || p.name === a.INIT_SKIN,
              ee = ft.instance.getString(a.STORAGE_KEY_SKIN, a.INIT_SKIN);
            this.centerButton.button.off("click"),
              p.name === ee
                ? this.changeCenterButtonText("Selected")
                : U
                ? (this.changeCenterButtonText("Select"),
                  this.centerButton.button.on(
                    "click",
                    this._selectSkin.bind(this, p)
                  ),
                  f.play("sfx_click"))
                : (this.changeCenterButtonPrice(p.price),
                  this.centerButton.button.on(
                    "click",
                    this._unlockSkin.bind(this, p)
                  ),
                  f.play("sfx_click"));
          }
          _selectSkin(p) {
            this.changeCenterButtonText("Selected"),
              this.fire(xi.SelectSkin, p);
          }
          _unlockSkin(p) {
            let S = ft.instance.getInt(a.STORAGE_KEY_COIN);
            if (S >= p.price) {
              this.changeCenterButtonText("Selected"),
                this.fire(xi.SelectSkin, p),
                (S -= p.price),
                ft.instance.setValue(a.STORAGE_KEY_COIN, S),
                this.updateCoins(S);
              let U = ft.instance.getString(a.STORAGE_KEY_UNLOCKED_SKIN);
              (U += `,${p.name}`),
                (U = U.replace(/^,/, "")),
                ft.instance.setValue(a.STORAGE_KEY_UNLOCKED_SKIN, U),
                oi.log("shop_item_bought", { ball_skin: p.name });
            } else this.fire(xi.BoughtFailed);
          }
          _createAnimations() {
            this._appearAnimations = [];
            let p = { duration: 0.5, easing: Me.Easing.Back.Out };
            this._appearAnimations.push(
              Fe.createTransitionAppearTween(this.leftButton, gt.LeftToRight, p)
            ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.rightButton,
                  gt.RightToLeft,
                  p
                )
              ),
              this._appearAnimations.push(
                Fe.createTransitionAppearTween(
                  this.exitButton,
                  gt.TopToBottom,
                  p
                )
              );
          }
          onEnable() {
            this._appearAnimations.forEach((p) => {
              p.start();
            }),
              this.checkIsRewardAdsReady();
          }
          checkIsRewardAdsReady() {
            (this.rewardButton.enabled = !1),
              (this.checkRewardAdsIntervalID = setInterval(() => {
                Ts.checkIsRewardAdsReady((p) => {
                  console.log("Reward ads ready", p),
                    (this.rewardButton.enabled = p),
                    p && clearInterval(this.checkRewardAdsIntervalID);
                });
              }, 1e3));
          }
          _onButtonRewardAdsClick() {
            this.isShowingRewardAds ||
              (f.play("sfx_click"),
              (this.isShowingRewardAds = !0),
              Ts.showRewardAds((p) => {
                if (((this.isShowingRewardAds = !1), p))
                  console.warn(p), alert(p);
                else {
                  oi.log("reward_show", { case: "claim_coin_in_shop" });
                  let S = ft.instance.getInt(a.STORAGE_KEY_COIN);
                  (S += 300),
                    ft.instance.setValue(a.STORAGE_KEY_COIN, S),
                    this.updateCoins(S);
                }
                this.checkIsRewardAdsReady();
              }));
          }
        }
        class vr extends o.w {
          static playAt(p) {
            this._spawner || this._createPool();
            let S = this._spawner.spawn();
            return S.setPosition(p), S.play(), S;
          }
          static _createPool() {
            let p = new o.w("spawner_bulletHitEffect");
            (this._spawner = p.addScript(lo, { class: vr, poolSize: 10 })),
              Ht.app.root.addChild(p);
          }
          constructor() {
            super("fx_finish"),
              (this.numParticles = 100),
              (this.particles = []),
              this._initAsset(),
              this._configParticle(),
              this._initParticle(),
              Ht.app.root.addChild(this);
          }
          _initAsset() {
            (this.texture = n.find("tex_particle").resource),
              (this.renderAsset = n.find("model_plane"));
          }
          _configParticle() {
            (this.velocityGraph1 = new Ei.K([
              [0, 3, 0.5, 1.5, 1, 1],
              [0, 12, 0.5, -8, 1, -10],
              [0, -5, -0.5, 0.5, 1, -2],
            ])),
              (this.velocityGraph2 = new Ei.K([
                [0, 5, 0.5, 3, 1, 2],
                [0, 27, 0.5, -4, 1, -6],
                [0, 5, -0.5, 2, 1, 2],
              ])),
              (this.scaleGraph = new Vi.I([0, 0.08])),
              (this.scaleGraph2 = new Vi.I([0, 0.12])),
              (this.rotationSpeedGraph = new Vi.I([0, 500, 0.5, 500, 1, 300])),
              (this.emitterExtents = [6, 3, 5]);
          }
          _createParticle(p) {
            let S = new o.w();
            return (
              this.addChild(S),
              S.addComponent("particlesystem", {
                autoPlay: !1,
                loop: !1,
                lifetime: 3,
                numParticles: this.numParticles,
                rate: 0.001,
                rate2: 0.005,
                colorMap: this.texture,
                blend: Ve.HG,
                mesh: this.renderAsset,
                animNumAnimations: 4,
                animNumFrames: 1,
                randomizeAnimIndex: !0,
                animLoop: !0,
                animSpeed: 1,
                startAngle: 0,
                startAngle2: 0,
                colorGraph: p,
                scaleGraph: this.scaleGraph,
                scaleGraph2: this.scaleGraph2,
                localVelocityGraph: this.velocityGraph1,
                localVelocityGraph2: this.velocityGraph2,
                rotationSpeedGraph: this.rotationSpeedGraph,
                emitterExtents: this.emitterExtents,
              }),
              S
            );
          }
          _initParticle() {
            (this.particleBlue = this._createParticle(
              new Ei.K([
                [0, 108 / 255],
                [0, 211 / 255],
                [0, 1],
              ])
            )),
              (this.particleGreen = this._createParticle(
                new Ei.K([
                  [0, 0],
                  [0, 1],
                  [0, 0],
                ])
              )),
              (this.particleOrange = this._createParticle(
                new Ei.K([
                  [0, 255 / 255],
                  [0, 140 / 255],
                  [0, 0],
                ])
              )),
              (this.particlePink = this._createParticle(
                new Ei.K([
                  [0, 215 / 255],
                  [0, 100 / 255],
                  [0, 199 / 255],
                ])
              )),
              this.particles.push(
                this.particleBlue,
                this.particleGreen,
                this.particleOrange,
                this.particlePink
              );
          }
          play() {
            this.particles.forEach((p) => {
              p.particlesystem.reset(), p.particlesystem.play();
            }),
              Me.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this.fire(_r.Despawn);
                },
              });
          }
        }
        class lc extends Bt.e {
          constructor(p = {}) {
            super(p),
              (this.target = p.target || void 0),
              (this.offset = p.offset || new i.e(0, 5, -10)),
              (this.speed = p.speed || 0.99),
              (this.alwaysBehind = p.alwaysBehind || !1);
          }
          initialize() {
            (this.targetPos = new i.e()),
              (this.matrix = new e.$()),
              (this.quat = new ke.k()),
              (this.vec = new i.e()),
              (this._targetEuler = new i.e()),
              this.target
                ? (this.updateTargetPosition(),
                  (this.currentPos = this.targetPos.clone()))
                : (this.currentPos = this.entity.getPosition().clone());
          }
          updateTargetPosition() {
            this.alwaysBehind &&
              (this._targetEuler.copy(this.target.getEulerAngles()),
              this.quat.setFromEulerAngles(this._targetEuler)),
              this.matrix.setTRS(this.target.getPosition(), this.quat, i.e.ONE),
              this.matrix.transformPoint(this.offset, this.targetPos);
          }
          postUpdate(p) {
            if (this.isTeleporting) {
              this.isTeleporting = !1;
              return;
            }
            this.target &&
              (this.updateTargetPosition(),
              this.currentPos.lerp(
                this.currentPos,
                this.targetPos,
                this.speed * p
              ),
              this.entity.setPosition(this.currentPos),
              this.entity.lookAt(this.target.getPosition()));
          }
          teleportToTarget() {
            this.updateTargetPosition(),
              this.currentPos.copy(this.targetPos),
              this.entity.setPosition(this.currentPos),
              this.entity.lookAt(this.target.getPosition()),
              (this.isTeleporting = !0);
          }
        }
        const el = { ValueChanged: "SwitchElement:ValueChanged" };
        class hc extends o.w {
          constructor(
            p,
            S = "spr_switch_inactive",
            U = "spr_switch_active",
            ee = "spr_circle_white"
          ) {
            super("switchElement"),
              (this.key = p),
              (this.inactiveTextureName = S),
              (this.activeTextureName = U),
              (this.controlTextureName = ee),
              (this._value = !1);
            let Se = n.find(this.inactiveTextureName),
              Re = Se.resource.width * 0.45,
              Be = Se.resource.height * 0.45;
            this.addComponent("element", {
              anchor: new at.Z(0.5, 0.5, 0.5, 0.5),
              pivot: new Ne.Z(0.5, 0.5),
              type: "image",
              textureAsset: Se,
              useInput: !0,
              width: Re,
              height: Be,
            }),
              this.element.on("mousedown", this._onClick, this),
              this.element.on("touchstart", this._onClick, this),
              (this.controlPivot = new Ne.Z(1, 0.5)),
              (this.control = ze.createImageElement(this.controlTextureName, {
                y: 2,
                scale: 0.4,
                pivot: this.controlPivot,
              })),
              this.addChild(this.control),
              (this.toggleOnTween = Me.createTween(
                { x: 1 },
                { x: 0 },
                {
                  duration: 0.2,
                  easing: Me.Easing.Circular.Out,
                  onUpdate: (qe) => {
                    (this.controlPivot.x = qe.x),
                      (this.control.element.pivot = this.controlPivot);
                  },
                  onComplete: () => {
                    this.element.textureAsset = n.find(this.activeTextureName);
                  },
                }
              )),
              (this.toggleOffTween = Me.createTween(
                { x: 0 },
                { x: 1 },
                {
                  duration: 0.2,
                  easing: Me.Easing.Circular.Out,
                  onUpdate: (qe) => {
                    (this.controlPivot.x = qe.x),
                      (this.control.element.pivot = this.controlPivot);
                  },
                  onComplete: () => {
                    this.element.textureAsset = n.find(
                      this.inactiveTextureName
                    );
                  },
                }
              ));
          }
          _onClick() {
            this.toggleOffTween.stop(),
              this.toggleOnTween.stop(),
              this._value
                ? this.toggleOffTween.start()
                : this.toggleOnTween.start(),
              (this._value = !this._value),
              this.fire(el.ValueChanged, this.key, this._value);
          }
          get value() {
            return this._value;
          }
          set value(p) {
            this._value !== p && this._onClick();
          }
        }
        const tl = Object.freeze({ Complete: "SettingScreen:Complete" });
        class cc extends Ye {
          constructor() {
            super(a.SCREEN_SETTING);
          }
          create() {
            this._createBackground(),
              this._createControls(),
              this._createContinueButton(),
              this._createVersion(),
              this._createAnimations();
          }
          _createBackground() {
            (this.background = ze.createImageElement("spr_frame_setting", {
              scale: 0.9,
            })),
              this.addChild(this.background),
              (this.label = ze.createTextElement("font_rounded", {
                anchor: new at.Z(0.5, 1, 0.5, 1),
                pivot: new Ne.Z(0.5, 1),
                fontSize: 65,
                text: "Setting",
                color: Ae.Q.WHITE,
                y: -50,
              })),
              this.background.addChild(this.label);
          }
          _createContinueButton() {
            var p;
            (this.continueButton = ze.createButtonElement(
              "spr_button_continue",
              {
                anchor: new at.Z(0.5, 0, 0.5, 0),
                pivot: new Ne.Z(0.5, 0),
                y: 50,
                scale: 0.8,
              }
            )),
              this.background.addChild(this.continueButton),
              (p = this.continueButton) == null ||
                p.button.once("click", this._onContinue, this);
          }
          _createControls() {
            (this.controlGroup = ze.createGroupElement()),
              this.background.addChild(this.controlGroup),
              this.controlGroup.addComponent("layoutgroup", {
                orientation: Ve.Yn,
                padding: new at.Z(150, 0, 0, 0),
                spacing: new Ne.Z(0, 50),
                alignment: new Ne.Z(0, 0),
              }),
              this._createSwitch("Music", "music"),
              this._createSwitch("Sound", "sound"),
              this._createSwitch("Vibration", "vibration");
          }
          _createVersion() {
            let p = ze.createTextElement("font_rounded", {
              anchor: new at.Z(0.5, 1, 0.5, 1),
              pivot: new Ne.Z(0.5, 1),
              fontSize: 20,
              text: "Version 1.0.0#111222",
              color: Ae.Q.WHITE,
              y: -130,
              opacity: 0.5,
            });
            this.background.addChild(p);
          }
          _createSwitch(p, S) {
            let U = ze.createGroupElement();
            this.controlGroup.addChild(U),
              U.addComponent("layoutgroup", {
                orientation: Ve.Sz,
                spacing: new Ne.Z(40, 0),
                alignment: new Ne.Z(1, 0.5),
              });
            let ee = ze.createTextElement("font_rounded", {
              text: p,
              fontSize: 50,
              color: Ae.Q.WHITE,
            });
            U.addChild(ee);
            let Se = new hc(S);
            U.addChild(Se),
              Se.on(el.ValueChanged, this._onSwitchChanged, this),
              (Se.value = h.get(S));
          }
          _onSwitchChanged(p, S) {
            h.set(p, S);
          }
          onEnable() {
            var p;
            Ht.pause(),
              (Ht.resumeable = !1),
              (p = this.continueButton) == null ||
                p.button.once("click", this._onContinue, this),
              this._appearAnimation.start();
          }
          onDisable() {
            var p;
            (p = this.continueButton) == null ||
              p.button.off("click", this._onContinue, this);
          }
          _onContinue() {
            Ht.resume(), (Ht.resumeable = !0), this.fire(tl.Complete);
          }
          _createAnimations() {
            this._appearAnimation = Me.createTween(
              { x: 0, y: 0, z: 0 },
              { x: 1, y: 1, z: 1 },
              {
                duration: 0.5,
                easing: Me.Easing.Back.Out,
                onUpdate: (p) => {
                  this.background.setLocalScale(p.x, p.y, p.z);
                },
              }
            );
          }
        }
        class dc extends nt {
          constructor() {
            super(a.SCENE_PLAY);
          }
          create() {
            super.create(),
              this._initUI(),
              this._initLight(),
              this._initGameplay(),
              this._initSkinSelection();
          }
          _onStart() {
            Ht.resume(),
              oi.log("level_start", {
                level_index: this.levelManager.currentLevelIndex,
                ball_skin: ft.instance.getString(a.STORAGE_KEY_SKIN),
              }),
              (this.inputHandler.enabled = !0),
              (this.startPosition =
                this.levelManager.currentLevel.map.getPosition()),
              (this.targetPosition =
                this.levelManager.currentLevel.map.finish.getPosition()),
              (this.levelLength = this.startPosition.distance(
                this.targetPosition
              )),
              this.ui.disableAllScreens(),
              this.playScreen.setLevelText(
                this.levelManager.currentLevelIndex + 1
              ),
              this.ui.setScreenActive(a.SCREEN_PLAY);
          }
          pause() {
            var p;
            (p = this.gameManager) == null || p.pause();
          }
          resume() {
            var p;
            (p = this.gameManager) == null || p.resume();
          }
          _onLose() {
            Ht.onLose(),
              (L.state = ge.Lose),
              Me.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this._showWinScreen();
                },
              }).start();
          }
          _onWin() {
            Me.createCountTween({
              duration: 0.8,
              onComplete: () => {
                oi.log("level_completed", {
                  level_index: this.levelManager.currentLevelIndex,
                  ball_skin: ft.instance.getString(a.STORAGE_KEY_SKIN),
                }),
                  this._showWinScreen();
              },
            }).start();
          }
          _showLoseScreen() {
            oi.log("level_failed", {
              level_index: this.levelManager.currentLevelIndex,
              ball_skin: ft.instance.getString(a.STORAGE_KEY_SKIN),
            }),
              this.ui.disableAllScreens(),
              this.ui.setScreenActive(a.SCREEN_LOSE);
          }
          _showWinScreen() {
            let p = `level_${this.levelManager.currentLevelIndex + 1}`,
              S = window.LAGGED_SDK_CONFIG;
            S != null && S.API_AWARDS[p] && Ts.saveAchievement(S.API_AWARDS[p]),
              this.ui.disableAllScreens();
            let U = this.levelManager.currentLevelIndex + 1,
              ee = ft.instance.getInt(a.STORAGE_KEY_COIN),
              Se = ft.instance.getInt(a.STORAGE_KEY_KEY);
            this.winScreen.updateLevelInfo(U),
              this.winScreen.updateCoins(ee),
              this.winScreen.updateKeys(Se);
            let Re = Cs.instance.coinCount;
            this.winScreen.updateRewardCoin(Re),
              this.ui.setScreenActive(a.SCREEN_WIN);
          }
          _onWinScreenCompleted() {
            this._saveLevelReward(), this.levelManager.loadNextLevel();
          }
          _showChestScreen() {
            this.ui.disableAllScreens();
            let p = ft.instance
                .getString(a.STORAGE_KEY_UNLOCKED_SKIN)
                .split(","),
              S = pe
                .map((ee) => ee.name)
                .filter((ee) => p.indexOf(ee) === -1 && ee !== a.INIT_SKIN),
              U = "";
            S.length > 0 && (U = Ge.randomFromList(S)),
              this.chestScreen.updateReward(10, 200, U),
              this.ui.setScreenActive(a.SCREEN_CHEST);
          }
          _showMainScreen() {
            this.ui.disableAllScreens(), this.ui.setScreenActive(a.SCREEN_MAIN);
            let p = this.levelManager.currentLevelIndex + 1,
              S = ft.instance.getInt(a.STORAGE_KEY_COIN),
              U = ft.instance.getInt(a.STORAGE_KEY_KEY);
            this.mainScreen.updateLevelInfo(p),
              this.mainScreen.updateCoins(S),
              this.mainScreen.updateKeys(U);
          }
          _initLight() {
            (this.directionalLight = new o.w("light-directional")),
              this.addChild(this.directionalLight),
              this.directionalLight.addComponent("light", {
                type: Ve.kx,
                color: new Ae.Q(1, 1, 1),
                castShadows: !0,
                shadowDistance: 15,
                shadowResolution: 1024,
                shadowBias: 0.2,
                normalOffsetBias: 0.05,
                intensity: 1,
              }),
              this.directionalLight.setLocalPosition(2, 2, -2),
              this.directionalLight.setLocalEulerAngles(32.33, 27.44, -5.91);
          }
          _initUI() {
            this.ui.addScreens(
              new zt(),
              new xh(),
              new sc(),
              new nc(),
              new rc(),
              new oc(),
              new cc()
            ),
              (this.playScreen = this.ui.getScreen(a.SCREEN_PLAY)),
              (this.winScreen = this.ui.getScreen(a.SCREEN_WIN)),
              (this.chestScreen = this.ui.getScreen(a.SCREEN_CHEST)),
              (this.mainScreen = this.ui.getScreen(a.SCREEN_MAIN)),
              (this.loseScreen = this.ui.getScreen(a.SCREEN_LOSE)),
              (this.skinSelectionScreen = this.ui.getScreen(
                a.SCREEN_SKIN_SELECTION
              )),
              (this.settingScreen = this.ui.getScreen(a.SCREEN_SETTING)),
              this.chestScreen.on(
                qo.Complete,
                this._onChestScreenComplete,
                this
              ),
              this.loseScreen.on(
                $r.ContinueButtonClicked,
                this._onLoseScreenComplete,
                this
              ),
              this.loseScreen.on($r.RespawnGame, this._onRespawn, this),
              this.mainScreen.on(Qn.Complete, this._onStart, this),
              this.mainScreen.on(
                Qn.OpenSelectingSkin,
                this._switchToSkinSelection,
                this
              ),
              this.skinSelectionScreen.on(
                xi.NextSkin,
                this._selectNextSkin,
                this
              ),
              this.skinSelectionScreen.on(
                xi.PreviousSkin,
                this._selectPreviousSkin,
                this
              ),
              this.skinSelectionScreen.on(
                xi.SelectSkin,
                this._selectSkin,
                this
              ),
              this.skinSelectionScreen.on(
                xi.Complete,
                this._onSelectSkinComplete,
                this
              ),
              this.mainScreen.on(Qn.OpenSetting, this._showSettingScreen, this),
              this.playScreen.on(
                Qt.OpenPauseScreen,
                this._showSettingScreen,
                this
              ),
              this.settingScreen.on(
                tl.Complete,
                this._onSettingScreenComplete,
                this
              );
          }
          _initGameplay() {
            this._initInputHandler(),
              this._initBall(),
              this._initCamera(),
              this._initLevelManager(),
              this._cacheShaders();
          }
          _cacheShaders() {
            console.log("Caching shaders...");
            let p = Array.from(n.assets._assets).filter(
                (Et) => Et.type === "model"
              ),
              S = new o.w("cache");
            this.addChild(S);
            let U = new i.e(0, 2, 10);
            S.setLocalPosition(U);
            let ee = -2;
            p.forEach((Et) => {
              let Ct = new o.w(Et.name);
              Ct.addComponent("model", {
                type: "asset",
                asset: Et,
                castShadows: !1,
                receiveShadows: !1,
              }),
                Ct.setLocalScale(0.01, 0.01, 0.01),
                Ct.setLocalPosition(ee, 0, 0),
                (ee += 0.1),
                S.addChild(Ct);
            });
            let Se = vr.playAt(U),
              Re = gr.playAt(U),
              Be = Cn.playAt(U),
              qe = new Xo({
                name: "collectable_ball",
                position: [0, 0, 5],
                eulerAngles: [0, 0, 0],
                scale: [1, 1, 1],
                model: "model_platform_life_bonus_001",
                materials: ["mat_items_001.json"],
              });
            S.addChild(qe),
              setTimeout(() => {
                S.destroy(),
                  Se.destroy(),
                  Re.destroy(),
                  Be.destroy(),
                  console.log("Caching shaders done!"),
                  setTimeout(() => {
                    Ht.onReady();
                  }, 500);
              }, 10);
          }
          _initSkydome() {
            (this.skydome = ze.createModel(
              "model_skydome_001",
              "mat_skydome_001"
            )),
              this.skydome.setLocalScale(10, 10, 10),
              this.skydome.setLocalEulerAngles(170.25, 38.59, 173.75),
              this.addChild(this.skydome);
          }
          _initLevelManager() {
            (this.levelManager = new tc()),
              this.addChild(this.levelManager),
              this.levelManager.on(Jo.LevelLoaded, this._onLevelLoaded, this),
              this.winScreen.on(
                jo.NextLevelButtonClicked,
                this._onWinScreenCompleted,
                this
              );
            let p = ft.instance.getInt(a.STORAGE_KEY_LEVEL);
            this.levelManager.loadLevel(p);
          }
          _onLoseScreenComplete() {
            this.levelManager.loadLevel(this.levelManager.currentLevelIndex),
              (this.ball.life = 1),
              ft.instance.setValue(a.STORAGE_KEY_LIFE, this.ball.life),
              this.playScreen.updateLife(this.ball.life);
          }
          _onSelectSkinComplete() {
            this.levelManager.loadLevel(this.levelManager.currentLevelIndex),
              (this.skinSelection.enabled = !1),
              this.ball.loadSkin(),
              (this.cameraFollowing.enabled = !0),
              this.playScreen.updateLife(this.ball.life),
              (this.disableSkinSelectionTween = Me.createCountTween({
                duration: 1,
                onComplete: () => {
                  (this.ball.skin.enabled = !0),
                    (this.inputHandler.enabled = !0);
                },
              }).start());
          }
          _showSettingScreen() {
            (this.previousScreen = this.ui.getLastActiveScreen()),
              this.ui.disableAllScreens(),
              this.ui.setScreenActive(a.SCREEN_SETTING);
          }
          _onSettingScreenComplete() {
            this.ui.disableAllScreens(),
              this.ui.setScreenActive(this.previousScreen.key);
          }
          _onLevelLoaded(p) {
            this.finishEffectLeft &&
              this.finishEffectRight &&
              (this.finishEffectLeft.destroy(),
              this.finishEffectRight.destroy());
            let S = p.getPosition().clone().add(new i.e(0, 0.4, 0));
            this.ball.checkPoint.position.copy(S),
              this.ball.checkPoint.rotation.copy(p.getRotation()),
              this.ball.respawn(),
              this.cameraFollowing.teleportToTarget(),
              (this.ballController.enabled = !0),
              (this.ball.ballBody.enabled = !0),
              (this.cameraFollowing.enabled = !0),
              ft.instance.setValue(
                a.STORAGE_KEY_LEVEL,
                this.levelManager.currentLevelIndex
              ),
              this._showMainScreen(),
              this.winScreen.checkRewardAdsReady();
          }
          _initInputHandler() {
            let p = new o.w("input");
            (this.inputHandler = p.addScript(ds)),
              (this.inputHandler.enabled = !0),
              this.addChild(p);
          }
          _initGameManager() {
            let p = new o.w("game_manager");
            this.addChild(p),
              (this.gameManager = p.addScript(Ps)),
              this.gameManager.on(
                ls.Start,
                this.inputHandler.enable,
                this.inputHandler
              ),
              this.gameManager.on(ls.Lose, this._onLose, this),
              this.gameManager.on(
                ls.Lose,
                this.inputHandler.disable,
                this.inputHandler
              ),
              this.gameManager.on(ls.Win, this._onWin, this),
              this.gameManager.on(
                ls.Win,
                this.inputHandler.disable,
                this.inputHandler
              );
          }
          _initCamera() {
            if (
              ((this.mainCamera = new o.w()),
              this.mainCamera.addComponent("camera", {
                clearColor: Ge.createColor(0, 0, 0),
                nearClip: 2,
              }),
              this.addChild(this.mainCamera),
              this.mainCamera.setLocalPosition(0, 2, 10),
              (this.cameraFollowing = this.mainCamera.addScript(lc, {
                attributes: {
                  target: this.ball.stableMovingBall,
                  offset: new i.e(0, 3, -7),
                  speed: a.CAMERA_FOLLOW_SPEED,
                  alwaysBehind: !0,
                },
              })),
              a.DEBUG_PHYSICS)
            ) {
              const p = new Ih({
                app: Ht.app,
                limit: { entity: this.mainCamera, distance: 50 },
              });
              (p.enabled = !0), (p.mode = a.DEBUG_PHYSICS_MODE);
            }
          }
          _initBall() {
            let p = new Mh();
            this.addChild(p),
              (this.ball = p),
              this.addChild(p.ballBody),
              this.addChild(p.stableMovingBall),
              this.playScreen.updateLife(this.ball.life),
              (this.swipeMovement = p.addScript(wh, {
                speed: 20,
                screenEntity: this.playScreen,
              })),
              (this.ballController = p.controller);
            let S = new ke.k(),
              U = new i.e(0, 0, 0);
            p.on(Ho.Move, (ee, Se) => {
              let Re = Math.atan2(ee.x, ee.z) * Lt.D.RAD_TO_DEG;
              Re = Math.abs(Re);
              let Be = Math.abs(1 - Re / 90);
              (Be = Math.max(0.4, Be)),
                (Se *= Be),
                U.copy(this.ball.getPosition()),
                U.sub(this.mainCamera.getPosition());
              let qe = Math.atan2(U.x, U.z) * Lt.D.RAD_TO_DEG;
              S.setFromEulerAngles(0, qe, 0),
                (ee = S.transformVector(ee)),
                ee.normalize(),
                this.ballController.applyForce(ee, Se);
            }),
              p.on(Pn.Dead, this._onBallDead, this),
              p.ballBody.on(Pn.Finish, this._onBallFinish, this),
              p.on(Pn.UpdateLife, this.playScreen.updateLife, this.playScreen),
              this.inputHandler.on(
                os.PointerDown,
                this.swipeMovement.onPointerDown,
                this.swipeMovement
              ),
              this.inputHandler.on(
                os.PointerMove,
                this.swipeMovement.onPointerMove,
                this.swipeMovement
              ),
              this.inputHandler.on(
                os.PointerUp,
                this.swipeMovement.onPointerUp,
                this.swipeMovement
              );
          }
          _onBallDead() {
            this.ball.life--,
              this.playScreen.updateLife(this.ball.life),
              this.ball.life > 0
                ? (this.ball.respawn(),
                  this.cameraFollowing.teleportToTarget(),
                  this._showMainScreen())
                : (Ht.pause(), this._showLoseScreen());
          }
          _onRespawn() {
            Ht.resume(),
              (this.ball.life = ft.instance.getInt(a.STORAGE_KEY_LIFE)),
              this.playScreen.updateLife(this.ball.life),
              this.ball.respawn(),
              this.cameraFollowing.teleportToTarget(),
              this._showMainScreen();
          }
          _onBallFinish(p) {
            (this.inputHandler.enabled = !1),
              f.play("sfx_wingame"),
              this._onCollideFinishObject(p),
              Me.createGlobalTranslateTween(
                this.ball,
                {
                  x: p.getPosition().x,
                  y: p.getPosition().y + 1.5,
                  z: p.getPosition().z - 0.55,
                },
                {
                  duration: 0.5,
                  onComplete: () => {
                    (this.ballController.enabled = !1),
                      (this.ball.ballBody.enabled = !1),
                      (this.cameraFollowing.enabled = !1);
                  },
                }
              ).start();
            let S = p.getPosition(),
              U = p.forward.clone(),
              ee = S.clone();
            ee.add(U.mulScalar(-20)),
              (ee.y = S.y + 10),
              Me.createGlobalTranslateTween(this.mainCamera, ee, {
                duration: 0.5,
                onUpdate: () => {
                  this.mainCamera.lookAt(S);
                },
              }).start(),
              Me.createCountTween({
                duration: 0.5,
                onComplete: this._levelComplete.bind(this),
              }).start(),
              this.ball.reset();
          }
          _onCollideFinishObject(p) {
            (this.finishEffectLeft = vr.playAt(p.getPosition())),
              (this.finishEffectRight = vr.playAt(p.getPosition())),
              this.finishEffectLeft.setLocalScale(1, 1, 1),
              this.finishEffectRight.setLocalScale(-1, 1, -1);
          }
          _levelComplete() {
            ft.instance.addInt(a.STORAGE_KEY_KEY, Cs.instance.keyCount) >=
            a.TOTAL_KEY_TO_COLLECT
              ? this._showChestScreen()
              : this._onWin();
          }
          _saveLevelReward() {
            let p = ft.instance;
            p.getInt(a.STORAGE_KEY_KEY) >= a.TOTAL_KEY_TO_COLLECT &&
              p.setValue(a.STORAGE_KEY_KEY, 0),
              p.addInt(a.STORAGE_KEY_COIN, Cs.instance.coinCount),
              p.setValue(a.STORAGE_KEY_LIFE, this.ball.life),
              Cs.instance.reset();
          }
          _onChestScreenComplete(p) {
            if (
              ((Cs.instance.coinCount += p.coin),
              ft.instance.getInt(a.STORAGE_KEY_KEY) >= a.TOTAL_KEY_TO_COLLECT &&
                ft.instance.setValue(a.STORAGE_KEY_KEY, 0),
              p.skin)
            ) {
              let U = ft.instance.getString(a.STORAGE_KEY_UNLOCKED_SKIN);
              (U += `,${p.skin}`),
                (U = U.replace(/^,/, "")),
                ft.instance.setValue(a.STORAGE_KEY_UNLOCKED_SKIN, U);
            }
            Me.createCountTween({
              duration: 1,
              onComplete: this._showWinScreen.bind(this),
            }).start();
          }
          update() {
            if (
              this.startPosition &&
              this.targetPosition &&
              this.levelLength > 0
            ) {
              let p =
                1 -
                this.ball.getPosition().distance(this.targetPosition) /
                  this.levelLength;
              this.playScreen.setProgress(p);
            }
          }
          _initSkinSelection() {
            (this.skinSelection = new ac()),
              this.addChild(this.skinSelection),
              this.skinSelectionScreen.on(
                xi.BoughtFailed,
                this.skinSelection.onBoughtFail,
                this.skinSelection
              ),
              (this.skinSelectionCameraPivot = new o.w(
                "skin_selection_camera_pivot"
              )),
              this.addChild(this.skinSelectionCameraPivot),
              (this.skinSelectionCameraPoint = new o.w(
                "skin_selection_camera_point"
              )),
              this.skinSelectionCameraPivot.addChild(
                this.skinSelectionCameraPoint
              ),
              this.skinSelectionCameraPoint.setLocalPosition(0, 1, -5);
          }
          _selectNextSkin() {
            this.skinSelection.nexSkin(),
              this.skinSelectionScreen.updateSkinInfo(
                this.skinSelection.currentSkin.data
              );
          }
          _selectPreviousSkin() {
            this.skinSelection.previousSkin(),
              this.skinSelectionScreen.updateSkinInfo(
                this.skinSelection.currentSkin.data
              );
          }
          _selectSkin(p) {
            ft.instance.setValue(a.STORAGE_KEY_SKIN, p.name);
          }
          _switchToSkinSelection() {
            var p, S;
            (p = this.enableSkinSelectionTween) == null || p.stop(),
              (S = this.disableSkinSelectionTween) == null || S.stop(),
              this.ui.disableAllScreens(),
              this.ui.setScreenActive(a.SCREEN_SKIN_SELECTION);
            let U = ft.instance.getInt(a.STORAGE_KEY_COIN);
            this.skinSelectionScreen.updateCoins(U),
              (this.skinSelection.enabled = !0);
            let ee = this.ball.getPosition().clone();
            (ee.y += 0.5),
              this.skinSelection.setPosition(ee),
              this.skinSelectionCameraPivot.setPosition(ee);
            let Se = ee.clone();
            (Se.y -= 0.5),
              (this.ball.skin.enabled = !1),
              (this.cameraFollowing.enabled = !1),
              (this.inputHandler.enabled = !1),
              this.skinSelection.currentSkin.rotateTween.start(),
              this.swipeMovement.onPointerUp();
            let Re = new ke.k(),
              Be = new i.e();
            Re.setFromEulerAngles(0, 0, 0);
            let qe = this.mainCamera.getPosition();
            this.enableSkinSelectionTween = Me.createTween(
              Be,
              { y: -170 },
              {
                duration: 0.5,
                easing: Me.Easing.Sinusoidal.Out,
                onUpdate: () => {
                  Re.setFromEulerAngles(0, Be.y, 0),
                    this.skinSelectionCameraPivot.setLocalRotation(Re),
                    (qe = qe.lerp(
                      qe,
                      this.skinSelectionCameraPoint.getPosition(),
                      0.1
                    )),
                    this.mainCamera.setPosition(qe),
                    this.mainCamera.lookAt(Se);
                },
              }
            ).start();
          }
        }
        class Ht {
          static load() {
            A.log("Game", "Load"),
              (this.assetLoaded = !1),
              (this.libraryLoaded = !1),
              (this.canvas = document.getElementById("application-canvas")),
              (this.canvas.id = "application-canvas"),
              (this.canvas.style.zIndex = "0"),
              (this.app = new Ie.l(this.canvas, {
                elementInput: new Le.FW(this.canvas),
                mouse: new tt.K(this.canvas),
                touch: new vt.a(this.canvas),
                keyboard: new it.s(window),
                graphicsDeviceOptions: { antialias: !1 },
              })),
              (this.app.graphicsDevice.maxPixelRatio = window.devicePixelRatio),
              this.app.setCanvasFillMode(At.Ol),
              this.app.setCanvasResolution(At.hD),
              (this.paused = !1),
              (this.resumeable = !0),
              h.loadSetting(),
              (this.timeSession = Date.now()),
              oi.init(),
              bt.init(this.app),
              L.init(ge.Tutorial),
              Ft.init(this.app),
              Me.init(this.app),
              n.init(this.app),
              n.load(this.onAssetLoaded.bind(this)),
              ct.load(this.onLibraryLoaded.bind(this)),
              Ts.init();
            let p = Rt.i.mobile ? "mobile" : "desktop";
            oi.log("game_open", {
              platform: p,
              browser_name: Rt.i.browserName,
            });
          }
          static onAssetLoaded() {
            (this.assetLoaded = !0), this.libraryLoaded && this.create();
          }
          static onLibraryLoaded() {
            (this.libraryLoaded = !0), this.assetLoaded && this.create();
          }
          static create() {
            this.app.start(),
              A.log("Game", "Create"),
              (this.width = window.innerWidth),
              (this.height = window.innerHeight),
              this.app.resizeCanvas(this.width, this.height),
              fe.config(),
              this.app.systems.rigidbody.gravity.set(
                a.GRAVITY_X,
                a.GRAVITY_Y,
                a.GRAVITY_Z
              ),
              (this.app.systems.rigidbody.fixedTimeStep = a.FIXED_TIME_STEP),
              k.init([new dc()]),
              k.loadScene(k.getScene(a.SCREEN_PLAY)),
              this.app.on("update", this.update, this),
              (this.gameCreated = !0),
              (this.timeLoading = Date.now());
          }
          static trackLoadingDuration() {
            (this.timeLoading = Date.now() - this.timeLoading),
              (this.timeLoading = Math.floor(this.timeLoading / 1e3)),
              oi.log("game_loading_duration", {
                time_loading: this.timeLoading,
              });
          }
          static trackingFirstOpen() {
            let p = ft.instance.getBoolean("first_open", !1),
              S = Rt.i.mobile ? "mobile" : "desktop";
            p ||
              (oi.log("first_open", {
                platform: S,
                browser_name: Rt.i.browserName,
              }),
              ft.instance.setValue("first_open", "true"));
          }
          static update() {
            k.update(Ft.dt);
          }
          static onReady() {
            let p = document.getElementById("loading");
            (p.style.display = "none"),
              this.trackLoadingDuration(),
              this.trackingFirstOpen();
          }
          static setPause(p) {
            this.gameCreated &&
              (p ? this.pause() : this.resumeable && this.resume());
          }
          static pause() {
            this.paused ||
              ((this.paused = !0),
              (L.state = ge.Paused),
              (Ft.scale = 0),
              f.muteAll(!0),
              k.pause(),
              (this.app.timeScale = 0),
              window.blur());
          }
          static resume() {
            this.paused &&
              ((this.paused = !1),
              L.prevState !== ge.Paused && (L.state = L.prevState),
              (Ft.scale = 1),
              f.muteAll(!1),
              k.resume(),
              (this.app.timeScale = 1),
              window.focus());
          }
          static resize(p) {
            this.gameCreated
              ? (A.debug("Game", "Resize", p),
                console.assert(
                  p.width && p.height,
                  "Screen size must have width and height greater than 0"
                ),
                (this.width = p.width),
                (this.height = p.height),
                (this.app.graphicsDevice.maxPixelRatio =
                  window.devicePixelRatio),
                this.app.resizeCanvas(this.width, this.height),
                k.resize(),
                this.app.fire("resize"))
              : console.warn("Resize function called before game creation", p);
          }
          static onWin() {}
          static onLose() {}
        }
        let sl = document.getElementById("loading");
        sl &&
          sl.addEventListener("pointerdown", (C) => {
            C.preventDefault(), C.stopPropagation();
          }),
          document.addEventListener("visibilitychange", () => {
            Ht.setPause(document.hidden);
          }),
          window.addEventListener("touchstart", () => Ht.setPause(!1)),
          window.addEventListener("mousedown", () => Ht.setPause(!1)),
          window.addEventListener("focus", () => Ht.setPause(!1)),
          window.addEventListener("blur", () => Ht.setPause(!0)),
          window.addEventListener("resize", () =>
            Ht.resize({ width: window.innerWidth, height: window.innerHeight })
          ),
          window.addEventListener("contextmenu", (C) => C.preventDefault()),
          window.addEventListener("load", () => {
            Ht.load();
          }),
          window.addEventListener("unload", () => {
            (Ht.timeSession = Date.now() - Ht.timeSession),
              (Ht.timeSession = Math.floor(Ht.timeSession / 1e3)),
              oi.log("game_session_duration", { duration: Ht.timeSession });
          }),
          window.focus();
      })();
    })();
  });
  Ac();
})();
